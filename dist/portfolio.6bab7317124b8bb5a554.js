/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@firebase/database/dist/index.esm2017.js":
/*!***************************************************************!*\
  !*** ./node_modules/@firebase/database/dist/index.esm2017.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DataSnapshot": () => (/* binding */ DataSnapshot),
/* harmony export */   "Database": () => (/* binding */ Database),
/* harmony export */   "OnDisconnect": () => (/* binding */ OnDisconnect),
/* harmony export */   "QueryConstraint": () => (/* binding */ QueryConstraint),
/* harmony export */   "TransactionResult": () => (/* binding */ TransactionResult),
/* harmony export */   "_QueryImpl": () => (/* binding */ QueryImpl),
/* harmony export */   "_QueryParams": () => (/* binding */ QueryParams),
/* harmony export */   "_ReferenceImpl": () => (/* binding */ ReferenceImpl),
/* harmony export */   "_TEST_ACCESS_forceRestClient": () => (/* binding */ forceRestClient),
/* harmony export */   "_TEST_ACCESS_hijackHash": () => (/* binding */ hijackHash),
/* harmony export */   "_repoManagerDatabaseFromApp": () => (/* binding */ repoManagerDatabaseFromApp),
/* harmony export */   "_setSDKVersion": () => (/* binding */ setSDKVersion),
/* harmony export */   "_validatePathString": () => (/* binding */ validatePathString),
/* harmony export */   "_validateWritablePath": () => (/* binding */ validateWritablePath),
/* harmony export */   "child": () => (/* binding */ child),
/* harmony export */   "connectDatabaseEmulator": () => (/* binding */ connectDatabaseEmulator),
/* harmony export */   "enableLogging": () => (/* binding */ enableLogging),
/* harmony export */   "endAt": () => (/* binding */ endAt),
/* harmony export */   "endBefore": () => (/* binding */ endBefore),
/* harmony export */   "equalTo": () => (/* binding */ equalTo),
/* harmony export */   "get": () => (/* binding */ get),
/* harmony export */   "getDatabase": () => (/* binding */ getDatabase),
/* harmony export */   "goOffline": () => (/* binding */ goOffline),
/* harmony export */   "goOnline": () => (/* binding */ goOnline),
/* harmony export */   "increment": () => (/* binding */ increment),
/* harmony export */   "limitToFirst": () => (/* binding */ limitToFirst),
/* harmony export */   "limitToLast": () => (/* binding */ limitToLast),
/* harmony export */   "off": () => (/* binding */ off),
/* harmony export */   "onChildAdded": () => (/* binding */ onChildAdded),
/* harmony export */   "onChildChanged": () => (/* binding */ onChildChanged),
/* harmony export */   "onChildMoved": () => (/* binding */ onChildMoved),
/* harmony export */   "onChildRemoved": () => (/* binding */ onChildRemoved),
/* harmony export */   "onDisconnect": () => (/* binding */ onDisconnect),
/* harmony export */   "onValue": () => (/* binding */ onValue),
/* harmony export */   "orderByChild": () => (/* binding */ orderByChild),
/* harmony export */   "orderByKey": () => (/* binding */ orderByKey),
/* harmony export */   "orderByPriority": () => (/* binding */ orderByPriority),
/* harmony export */   "orderByValue": () => (/* binding */ orderByValue),
/* harmony export */   "push": () => (/* binding */ push),
/* harmony export */   "query": () => (/* binding */ query),
/* harmony export */   "ref": () => (/* binding */ ref),
/* harmony export */   "refFromURL": () => (/* binding */ refFromURL),
/* harmony export */   "remove": () => (/* binding */ remove),
/* harmony export */   "runTransaction": () => (/* binding */ runTransaction),
/* harmony export */   "serverTimestamp": () => (/* binding */ serverTimestamp),
/* harmony export */   "set": () => (/* binding */ set),
/* harmony export */   "setPriority": () => (/* binding */ setPriority),
/* harmony export */   "setWithPriority": () => (/* binding */ setWithPriority),
/* harmony export */   "startAfter": () => (/* binding */ startAfter),
/* harmony export */   "startAt": () => (/* binding */ startAt),
/* harmony export */   "update": () => (/* binding */ update)
/* harmony export */ });
/* harmony import */ var _firebase_app__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @firebase/app */ "./node_modules/@firebase/app/dist/esm/index.esm2017.js");
/* harmony import */ var _firebase_component__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @firebase/component */ "./node_modules/@firebase/component/dist/esm/index.esm2017.js");
/* harmony import */ var _firebase_util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @firebase/util */ "./node_modules/@firebase/util/dist/index.esm2017.js");
/* harmony import */ var _firebase_logger__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @firebase/logger */ "./node_modules/@firebase/logger/dist/esm/index.esm2017.js");





const name = "@firebase/database";
const version = "0.12.5";

/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/** The semver (www.semver.org) version of the SDK. */
let SDK_VERSION = '';
/**
 * SDK_VERSION should be set before any database instance is created
 * @internal
 */
function setSDKVersion(version) {
    SDK_VERSION = version;
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Wraps a DOM Storage object and:
 * - automatically encode objects as JSON strings before storing them to allow us to store arbitrary types.
 * - prefixes names with "firebase:" to avoid collisions with app data.
 *
 * We automatically (see storage.js) create two such wrappers, one for sessionStorage,
 * and one for localStorage.
 *
 */
class DOMStorageWrapper {
    /**
     * @param domStorage_ - The underlying storage object (e.g. localStorage or sessionStorage)
     */
    constructor(domStorage_) {
        this.domStorage_ = domStorage_;
        // Use a prefix to avoid collisions with other stuff saved by the app.
        this.prefix_ = 'firebase:';
    }
    /**
     * @param key - The key to save the value under
     * @param value - The value being stored, or null to remove the key.
     */
    set(key, value) {
        if (value == null) {
            this.domStorage_.removeItem(this.prefixedName_(key));
        }
        else {
            this.domStorage_.setItem(this.prefixedName_(key), (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.stringify)(value));
        }
    }
    /**
     * @returns The value that was stored under this key, or null
     */
    get(key) {
        const storedVal = this.domStorage_.getItem(this.prefixedName_(key));
        if (storedVal == null) {
            return null;
        }
        else {
            return (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.jsonEval)(storedVal);
        }
    }
    remove(key) {
        this.domStorage_.removeItem(this.prefixedName_(key));
    }
    prefixedName_(name) {
        return this.prefix_ + name;
    }
    toString() {
        return this.domStorage_.toString();
    }
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * An in-memory storage implementation that matches the API of DOMStorageWrapper
 * (TODO: create interface for both to implement).
 */
class MemoryStorage {
    constructor() {
        this.cache_ = {};
        this.isInMemoryStorage = true;
    }
    set(key, value) {
        if (value == null) {
            delete this.cache_[key];
        }
        else {
            this.cache_[key] = value;
        }
    }
    get(key) {
        if ((0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.contains)(this.cache_, key)) {
            return this.cache_[key];
        }
        return null;
    }
    remove(key) {
        delete this.cache_[key];
    }
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Helper to create a DOMStorageWrapper or else fall back to MemoryStorage.
 * TODO: Once MemoryStorage and DOMStorageWrapper have a shared interface this method annotation should change
 * to reflect this type
 *
 * @param domStorageName - Name of the underlying storage object
 *   (e.g. 'localStorage' or 'sessionStorage').
 * @returns Turning off type information until a common interface is defined.
 */
const createStoragefor = function (domStorageName) {
    try {
        // NOTE: just accessing "localStorage" or "window['localStorage']" may throw a security exception,
        // so it must be inside the try/catch.
        if (typeof window !== 'undefined' &&
            typeof window[domStorageName] !== 'undefined') {
            // Need to test cache. Just because it's here doesn't mean it works
            const domStorage = window[domStorageName];
            domStorage.setItem('firebase:sentinel', 'cache');
            domStorage.removeItem('firebase:sentinel');
            return new DOMStorageWrapper(domStorage);
        }
    }
    catch (e) { }
    // Failed to create wrapper.  Just return in-memory storage.
    // TODO: log?
    return new MemoryStorage();
};
/** A storage object that lasts across sessions */
const PersistentStorage = createStoragefor('localStorage');
/** A storage object that only lasts one session */
const SessionStorage = createStoragefor('sessionStorage');

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const logClient = new _firebase_logger__WEBPACK_IMPORTED_MODULE_3__.Logger('@firebase/database');
/**
 * Returns a locally-unique ID (generated by just incrementing up from 0 each time its called).
 */
const LUIDGenerator = (function () {
    let id = 1;
    return function () {
        return id++;
    };
})();
/**
 * Sha1 hash of the input string
 * @param str - The string to hash
 * @returns {!string} The resulting hash
 */
const sha1 = function (str) {
    const utf8Bytes = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.stringToByteArray)(str);
    const sha1 = new _firebase_util__WEBPACK_IMPORTED_MODULE_2__.Sha1();
    sha1.update(utf8Bytes);
    const sha1Bytes = sha1.digest();
    return _firebase_util__WEBPACK_IMPORTED_MODULE_2__.base64.encodeByteArray(sha1Bytes);
};
const buildLogMessage_ = function (...varArgs) {
    let message = '';
    for (let i = 0; i < varArgs.length; i++) {
        const arg = varArgs[i];
        if (Array.isArray(arg) ||
            (arg &&
                typeof arg === 'object' &&
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                typeof arg.length === 'number')) {
            message += buildLogMessage_.apply(null, arg);
        }
        else if (typeof arg === 'object') {
            message += (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.stringify)(arg);
        }
        else {
            message += arg;
        }
        message += ' ';
    }
    return message;
};
/**
 * Use this for all debug messages in Firebase.
 */
let logger = null;
/**
 * Flag to check for log availability on first log message
 */
let firstLog_ = true;
/**
 * The implementation of Firebase.enableLogging (defined here to break dependencies)
 * @param logger_ - A flag to turn on logging, or a custom logger
 * @param persistent - Whether or not to persist logging settings across refreshes
 */
const enableLogging$1 = function (logger_, persistent) {
    (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(!persistent || logger_ === true || logger_ === false, "Can't turn on custom loggers persistently.");
    if (logger_ === true) {
        logClient.logLevel = _firebase_logger__WEBPACK_IMPORTED_MODULE_3__.LogLevel.VERBOSE;
        logger = logClient.log.bind(logClient);
        if (persistent) {
            SessionStorage.set('logging_enabled', true);
        }
    }
    else if (typeof logger_ === 'function') {
        logger = logger_;
    }
    else {
        logger = null;
        SessionStorage.remove('logging_enabled');
    }
};
const log = function (...varArgs) {
    if (firstLog_ === true) {
        firstLog_ = false;
        if (logger === null && SessionStorage.get('logging_enabled') === true) {
            enableLogging$1(true);
        }
    }
    if (logger) {
        const message = buildLogMessage_.apply(null, varArgs);
        logger(message);
    }
};
const logWrapper = function (prefix) {
    return function (...varArgs) {
        log(prefix, ...varArgs);
    };
};
const error = function (...varArgs) {
    const message = 'FIREBASE INTERNAL ERROR: ' + buildLogMessage_(...varArgs);
    logClient.error(message);
};
const fatal = function (...varArgs) {
    const message = `FIREBASE FATAL ERROR: ${buildLogMessage_(...varArgs)}`;
    logClient.error(message);
    throw new Error(message);
};
const warn = function (...varArgs) {
    const message = 'FIREBASE WARNING: ' + buildLogMessage_(...varArgs);
    logClient.warn(message);
};
/**
 * Logs a warning if the containing page uses https. Called when a call to new Firebase
 * does not use https.
 */
const warnIfPageIsSecure = function () {
    // Be very careful accessing browser globals. Who knows what may or may not exist.
    if (typeof window !== 'undefined' &&
        window.location &&
        window.location.protocol &&
        window.location.protocol.indexOf('https:') !== -1) {
        warn('Insecure Firebase access from a secure page. ' +
            'Please use https in calls to new Firebase().');
    }
};
/**
 * Returns true if data is NaN, or +/- Infinity.
 */
const isInvalidJSONNumber = function (data) {
    return (typeof data === 'number' &&
        (data !== data || // NaN
            data === Number.POSITIVE_INFINITY ||
            data === Number.NEGATIVE_INFINITY));
};
const executeWhenDOMReady = function (fn) {
    if ((0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.isNodeSdk)() || document.readyState === 'complete') {
        fn();
    }
    else {
        // Modeled after jQuery. Try DOMContentLoaded and onreadystatechange (which
        // fire before onload), but fall back to onload.
        let called = false;
        const wrappedFn = function () {
            if (!document.body) {
                setTimeout(wrappedFn, Math.floor(10));
                return;
            }
            if (!called) {
                called = true;
                fn();
            }
        };
        if (document.addEventListener) {
            document.addEventListener('DOMContentLoaded', wrappedFn, false);
            // fallback to onload.
            window.addEventListener('load', wrappedFn, false);
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
        }
        else if (document.attachEvent) {
            // IE.
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            document.attachEvent('onreadystatechange', () => {
                if (document.readyState === 'complete') {
                    wrappedFn();
                }
            });
            // fallback to onload.
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            window.attachEvent('onload', wrappedFn);
            // jQuery has an extra hack for IE that we could employ (based on
            // http://javascript.nwbox.com/IEContentLoaded/) But it looks really old.
            // I'm hoping we don't need it.
        }
    }
};
/**
 * Minimum key name. Invalid for actual data, used as a marker to sort before any valid names
 */
const MIN_NAME = '[MIN_NAME]';
/**
 * Maximum key name. Invalid for actual data, used as a marker to sort above any valid names
 */
const MAX_NAME = '[MAX_NAME]';
/**
 * Compares valid Firebase key names, plus min and max name
 */
const nameCompare = function (a, b) {
    if (a === b) {
        return 0;
    }
    else if (a === MIN_NAME || b === MAX_NAME) {
        return -1;
    }
    else if (b === MIN_NAME || a === MAX_NAME) {
        return 1;
    }
    else {
        const aAsInt = tryParseInt(a), bAsInt = tryParseInt(b);
        if (aAsInt !== null) {
            if (bAsInt !== null) {
                return aAsInt - bAsInt === 0 ? a.length - b.length : aAsInt - bAsInt;
            }
            else {
                return -1;
            }
        }
        else if (bAsInt !== null) {
            return 1;
        }
        else {
            return a < b ? -1 : 1;
        }
    }
};
/**
 * @returns {!number} comparison result.
 */
const stringCompare = function (a, b) {
    if (a === b) {
        return 0;
    }
    else if (a < b) {
        return -1;
    }
    else {
        return 1;
    }
};
const requireKey = function (key, obj) {
    if (obj && key in obj) {
        return obj[key];
    }
    else {
        throw new Error('Missing required key (' + key + ') in object: ' + (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.stringify)(obj));
    }
};
const ObjectToUniqueKey = function (obj) {
    if (typeof obj !== 'object' || obj === null) {
        return (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.stringify)(obj);
    }
    const keys = [];
    // eslint-disable-next-line guard-for-in
    for (const k in obj) {
        keys.push(k);
    }
    // Export as json, but with the keys sorted.
    keys.sort();
    let key = '{';
    for (let i = 0; i < keys.length; i++) {
        if (i !== 0) {
            key += ',';
        }
        key += (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.stringify)(keys[i]);
        key += ':';
        key += ObjectToUniqueKey(obj[keys[i]]);
    }
    key += '}';
    return key;
};
/**
 * Splits a string into a number of smaller segments of maximum size
 * @param str - The string
 * @param segsize - The maximum number of chars in the string.
 * @returns The string, split into appropriately-sized chunks
 */
const splitStringBySize = function (str, segsize) {
    const len = str.length;
    if (len <= segsize) {
        return [str];
    }
    const dataSegs = [];
    for (let c = 0; c < len; c += segsize) {
        if (c + segsize > len) {
            dataSegs.push(str.substring(c, len));
        }
        else {
            dataSegs.push(str.substring(c, c + segsize));
        }
    }
    return dataSegs;
};
/**
 * Apply a function to each (key, value) pair in an object or
 * apply a function to each (index, value) pair in an array
 * @param obj - The object or array to iterate over
 * @param fn - The function to apply
 */
function each(obj, fn) {
    for (const key in obj) {
        if (obj.hasOwnProperty(key)) {
            fn(key, obj[key]);
        }
    }
}
/**
 * Borrowed from http://hg.secondlife.com/llsd/src/tip/js/typedarray.js (MIT License)
 * I made one modification at the end and removed the NaN / Infinity
 * handling (since it seemed broken [caused an overflow] and we don't need it).  See MJL comments.
 * @param v - A double
 *
 */
const doubleToIEEE754String = function (v) {
    (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(!isInvalidJSONNumber(v), 'Invalid JSON number'); // MJL
    const ebits = 11, fbits = 52;
    const bias = (1 << (ebits - 1)) - 1;
    let s, e, f, ln, i;
    // Compute sign, exponent, fraction
    // Skip NaN / Infinity handling --MJL.
    if (v === 0) {
        e = 0;
        f = 0;
        s = 1 / v === -Infinity ? 1 : 0;
    }
    else {
        s = v < 0;
        v = Math.abs(v);
        if (v >= Math.pow(2, 1 - bias)) {
            // Normalized
            ln = Math.min(Math.floor(Math.log(v) / Math.LN2), bias);
            e = ln + bias;
            f = Math.round(v * Math.pow(2, fbits - ln) - Math.pow(2, fbits));
        }
        else {
            // Denormalized
            e = 0;
            f = Math.round(v / Math.pow(2, 1 - bias - fbits));
        }
    }
    // Pack sign, exponent, fraction
    const bits = [];
    for (i = fbits; i; i -= 1) {
        bits.push(f % 2 ? 1 : 0);
        f = Math.floor(f / 2);
    }
    for (i = ebits; i; i -= 1) {
        bits.push(e % 2 ? 1 : 0);
        e = Math.floor(e / 2);
    }
    bits.push(s ? 1 : 0);
    bits.reverse();
    const str = bits.join('');
    // Return the data as a hex string. --MJL
    let hexByteString = '';
    for (i = 0; i < 64; i += 8) {
        let hexByte = parseInt(str.substr(i, 8), 2).toString(16);
        if (hexByte.length === 1) {
            hexByte = '0' + hexByte;
        }
        hexByteString = hexByteString + hexByte;
    }
    return hexByteString.toLowerCase();
};
/**
 * Used to detect if we're in a Chrome content script (which executes in an
 * isolated environment where long-polling doesn't work).
 */
const isChromeExtensionContentScript = function () {
    return !!(typeof window === 'object' &&
        window['chrome'] &&
        window['chrome']['extension'] &&
        !/^chrome/.test(window.location.href));
};
/**
 * Used to detect if we're in a Windows 8 Store app.
 */
const isWindowsStoreApp = function () {
    // Check for the presence of a couple WinRT globals
    return typeof Windows === 'object' && typeof Windows.UI === 'object';
};
/**
 * Converts a server error code to a Javascript Error
 */
function errorForServerCode(code, query) {
    let reason = 'Unknown Error';
    if (code === 'too_big') {
        reason =
            'The data requested exceeds the maximum size ' +
                'that can be accessed with a single request.';
    }
    else if (code === 'permission_denied') {
        reason = "Client doesn't have permission to access the desired data.";
    }
    else if (code === 'unavailable') {
        reason = 'The service is unavailable';
    }
    const error = new Error(code + ' at ' + query._path.toString() + ': ' + reason);
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    error.code = code.toUpperCase();
    return error;
}
/**
 * Used to test for integer-looking strings
 */
const INTEGER_REGEXP_ = new RegExp('^-?(0*)\\d{1,10}$');
/**
 * For use in keys, the minimum possible 32-bit integer.
 */
const INTEGER_32_MIN = -2147483648;
/**
 * For use in kyes, the maximum possible 32-bit integer.
 */
const INTEGER_32_MAX = 2147483647;
/**
 * If the string contains a 32-bit integer, return it.  Else return null.
 */
const tryParseInt = function (str) {
    if (INTEGER_REGEXP_.test(str)) {
        const intVal = Number(str);
        if (intVal >= INTEGER_32_MIN && intVal <= INTEGER_32_MAX) {
            return intVal;
        }
    }
    return null;
};
/**
 * Helper to run some code but catch any exceptions and re-throw them later.
 * Useful for preventing user callbacks from breaking internal code.
 *
 * Re-throwing the exception from a setTimeout is a little evil, but it's very
 * convenient (we don't have to try to figure out when is a safe point to
 * re-throw it), and the behavior seems reasonable:
 *
 * * If you aren't pausing on exceptions, you get an error in the console with
 *   the correct stack trace.
 * * If you're pausing on all exceptions, the debugger will pause on your
 *   exception and then again when we rethrow it.
 * * If you're only pausing on uncaught exceptions, the debugger will only pause
 *   on us re-throwing it.
 *
 * @param fn - The code to guard.
 */
const exceptionGuard = function (fn) {
    try {
        fn();
    }
    catch (e) {
        // Re-throw exception when it's safe.
        setTimeout(() => {
            // It used to be that "throw e" would result in a good console error with
            // relevant context, but as of Chrome 39, you just get the firebase.js
            // file/line number where we re-throw it, which is useless. So we log
            // e.stack explicitly.
            const stack = e.stack || '';
            warn('Exception was thrown by user callback.', stack);
            throw e;
        }, Math.floor(0));
    }
};
/**
 * @returns {boolean} true if we think we're currently being crawled.
 */
const beingCrawled = function () {
    const userAgent = (typeof window === 'object' &&
        window['navigator'] &&
        window['navigator']['userAgent']) ||
        '';
    // For now we whitelist the most popular crawlers.  We should refine this to be the set of crawlers we
    // believe to support JavaScript/AJAX rendering.
    // NOTE: Google Webmaster Tools doesn't really belong, but their "This is how a visitor to your website
    // would have seen the page" is flaky if we don't treat it as a crawler.
    return (userAgent.search(/googlebot|google webmaster tools|bingbot|yahoo! slurp|baiduspider|yandexbot|duckduckbot/i) >= 0);
};
/**
 * Same as setTimeout() except on Node.JS it will /not/ prevent the process from exiting.
 *
 * It is removed with clearTimeout() as normal.
 *
 * @param fn - Function to run.
 * @param time - Milliseconds to wait before running.
 * @returns The setTimeout() return value.
 */
const setTimeoutNonBlocking = function (fn, time) {
    const timeout = setTimeout(fn, time);
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    if (typeof timeout === 'object' && timeout['unref']) {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        timeout['unref']();
    }
    return timeout;
};

/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Abstraction around AppCheck's token fetching capabilities.
 */
class AppCheckTokenProvider {
    constructor(appName_, appCheckProvider) {
        this.appName_ = appName_;
        this.appCheckProvider = appCheckProvider;
        this.appCheck = appCheckProvider === null || appCheckProvider === void 0 ? void 0 : appCheckProvider.getImmediate({ optional: true });
        if (!this.appCheck) {
            appCheckProvider === null || appCheckProvider === void 0 ? void 0 : appCheckProvider.get().then(appCheck => (this.appCheck = appCheck));
        }
    }
    getToken(forceRefresh) {
        if (!this.appCheck) {
            return new Promise((resolve, reject) => {
                // Support delayed initialization of FirebaseAppCheck. This allows our
                // customers to initialize the RTDB SDK before initializing Firebase
                // AppCheck and ensures that all requests are authenticated if a token
                // becomes available before the timoeout below expires.
                setTimeout(() => {
                    if (this.appCheck) {
                        this.getToken(forceRefresh).then(resolve, reject);
                    }
                    else {
                        resolve(null);
                    }
                }, 0);
            });
        }
        return this.appCheck.getToken(forceRefresh);
    }
    addTokenChangeListener(listener) {
        var _a;
        (_a = this.appCheckProvider) === null || _a === void 0 ? void 0 : _a.get().then(appCheck => appCheck.addTokenListener(listener));
    }
    notifyForInvalidToken() {
        warn(`Provided AppCheck credentials for the app named "${this.appName_}" ` +
            'are invalid. This usually indicates your app was not initialized correctly.');
    }
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Abstraction around FirebaseApp's token fetching capabilities.
 */
class FirebaseAuthTokenProvider {
    constructor(appName_, firebaseOptions_, authProvider_) {
        this.appName_ = appName_;
        this.firebaseOptions_ = firebaseOptions_;
        this.authProvider_ = authProvider_;
        this.auth_ = null;
        this.auth_ = authProvider_.getImmediate({ optional: true });
        if (!this.auth_) {
            authProvider_.onInit(auth => (this.auth_ = auth));
        }
    }
    getToken(forceRefresh) {
        if (!this.auth_) {
            return new Promise((resolve, reject) => {
                // Support delayed initialization of FirebaseAuth. This allows our
                // customers to initialize the RTDB SDK before initializing Firebase
                // Auth and ensures that all requests are authenticated if a token
                // becomes available before the timoeout below expires.
                setTimeout(() => {
                    if (this.auth_) {
                        this.getToken(forceRefresh).then(resolve, reject);
                    }
                    else {
                        resolve(null);
                    }
                }, 0);
            });
        }
        return this.auth_.getToken(forceRefresh).catch(error => {
            // TODO: Need to figure out all the cases this is raised and whether
            // this makes sense.
            if (error && error.code === 'auth/token-not-initialized') {
                log('Got auth/token-not-initialized error.  Treating as null token.');
                return null;
            }
            else {
                return Promise.reject(error);
            }
        });
    }
    addTokenChangeListener(listener) {
        // TODO: We might want to wrap the listener and call it with no args to
        // avoid a leaky abstraction, but that makes removing the listener harder.
        if (this.auth_) {
            this.auth_.addAuthTokenListener(listener);
        }
        else {
            this.authProvider_
                .get()
                .then(auth => auth.addAuthTokenListener(listener));
        }
    }
    removeTokenChangeListener(listener) {
        this.authProvider_
            .get()
            .then(auth => auth.removeAuthTokenListener(listener));
    }
    notifyForInvalidToken() {
        let errorMessage = 'Provided authentication credentials for the app named "' +
            this.appName_ +
            '" are invalid. This usually indicates your app was not ' +
            'initialized correctly. ';
        if ('credential' in this.firebaseOptions_) {
            errorMessage +=
                'Make sure the "credential" property provided to initializeApp() ' +
                    'is authorized to access the specified "databaseURL" and is from the correct ' +
                    'project.';
        }
        else if ('serviceAccount' in this.firebaseOptions_) {
            errorMessage +=
                'Make sure the "serviceAccount" property provided to initializeApp() ' +
                    'is authorized to access the specified "databaseURL" and is from the correct ' +
                    'project.';
        }
        else {
            errorMessage +=
                'Make sure the "apiKey" and "databaseURL" properties provided to ' +
                    'initializeApp() match the values provided for your app at ' +
                    'https://console.firebase.google.com/.';
        }
        warn(errorMessage);
    }
}
/* AuthTokenProvider that supplies a constant token. Used by Admin SDK or mockUserToken with emulators. */
class EmulatorTokenProvider {
    constructor(accessToken) {
        this.accessToken = accessToken;
    }
    getToken(forceRefresh) {
        return Promise.resolve({
            accessToken: this.accessToken
        });
    }
    addTokenChangeListener(listener) {
        // Invoke the listener immediately to match the behavior in Firebase Auth
        // (see packages/auth/src/auth.js#L1807)
        listener(this.accessToken);
    }
    removeTokenChangeListener(listener) { }
    notifyForInvalidToken() { }
}
/** A string that is treated as an admin access token by the RTDB emulator. Used by Admin SDK. */
EmulatorTokenProvider.OWNER = 'owner';

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const PROTOCOL_VERSION = '5';
const VERSION_PARAM = 'v';
const TRANSPORT_SESSION_PARAM = 's';
const REFERER_PARAM = 'r';
const FORGE_REF = 'f';
// Matches console.firebase.google.com, firebase-console-*.corp.google.com and
// firebase.corp.google.com
const FORGE_DOMAIN_RE = /(console\.firebase|firebase-console-\w+\.corp|firebase\.corp)\.google\.com/;
const LAST_SESSION_PARAM = 'ls';
const APPLICATION_ID_PARAM = 'p';
const APP_CHECK_TOKEN_PARAM = 'ac';
const WEBSOCKET = 'websocket';
const LONG_POLLING = 'long_polling';

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * A class that holds metadata about a Repo object
 */
class RepoInfo {
    /**
     * @param host - Hostname portion of the url for the repo
     * @param secure - Whether or not this repo is accessed over ssl
     * @param namespace - The namespace represented by the repo
     * @param webSocketOnly - Whether to prefer websockets over all other transports (used by Nest).
     * @param nodeAdmin - Whether this instance uses Admin SDK credentials
     * @param persistenceKey - Override the default session persistence storage key
     */
    constructor(host, secure, namespace, webSocketOnly, nodeAdmin = false, persistenceKey = '', includeNamespaceInQueryParams = false) {
        this.secure = secure;
        this.namespace = namespace;
        this.webSocketOnly = webSocketOnly;
        this.nodeAdmin = nodeAdmin;
        this.persistenceKey = persistenceKey;
        this.includeNamespaceInQueryParams = includeNamespaceInQueryParams;
        this._host = host.toLowerCase();
        this._domain = this._host.substr(this._host.indexOf('.') + 1);
        this.internalHost =
            PersistentStorage.get('host:' + host) || this._host;
    }
    isCacheableHost() {
        return this.internalHost.substr(0, 2) === 's-';
    }
    isCustomHost() {
        return (this._domain !== 'firebaseio.com' &&
            this._domain !== 'firebaseio-demo.com');
    }
    get host() {
        return this._host;
    }
    set host(newHost) {
        if (newHost !== this.internalHost) {
            this.internalHost = newHost;
            if (this.isCacheableHost()) {
                PersistentStorage.set('host:' + this._host, this.internalHost);
            }
        }
    }
    toString() {
        let str = this.toURLString();
        if (this.persistenceKey) {
            str += '<' + this.persistenceKey + '>';
        }
        return str;
    }
    toURLString() {
        const protocol = this.secure ? 'https://' : 'http://';
        const query = this.includeNamespaceInQueryParams
            ? `?ns=${this.namespace}`
            : '';
        return `${protocol}${this.host}/${query}`;
    }
}
function repoInfoNeedsQueryParam(repoInfo) {
    return (repoInfo.host !== repoInfo.internalHost ||
        repoInfo.isCustomHost() ||
        repoInfo.includeNamespaceInQueryParams);
}
/**
 * Returns the websocket URL for this repo
 * @param repoInfo - RepoInfo object
 * @param type - of connection
 * @param params - list
 * @returns The URL for this repo
 */
function repoInfoConnectionURL(repoInfo, type, params) {
    (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(typeof type === 'string', 'typeof type must == string');
    (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(typeof params === 'object', 'typeof params must == object');
    let connURL;
    if (type === WEBSOCKET) {
        connURL =
            (repoInfo.secure ? 'wss://' : 'ws://') + repoInfo.internalHost + '/.ws?';
    }
    else if (type === LONG_POLLING) {
        connURL =
            (repoInfo.secure ? 'https://' : 'http://') +
                repoInfo.internalHost +
                '/.lp?';
    }
    else {
        throw new Error('Unknown connection type: ' + type);
    }
    if (repoInfoNeedsQueryParam(repoInfo)) {
        params['ns'] = repoInfo.namespace;
    }
    const pairs = [];
    each(params, (key, value) => {
        pairs.push(key + '=' + value);
    });
    return connURL + pairs.join('&');
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Tracks a collection of stats.
 */
class StatsCollection {
    constructor() {
        this.counters_ = {};
    }
    incrementCounter(name, amount = 1) {
        if (!(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.contains)(this.counters_, name)) {
            this.counters_[name] = 0;
        }
        this.counters_[name] += amount;
    }
    get() {
        return (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.deepCopy)(this.counters_);
    }
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const collections = {};
const reporters = {};
function statsManagerGetCollection(repoInfo) {
    const hashString = repoInfo.toString();
    if (!collections[hashString]) {
        collections[hashString] = new StatsCollection();
    }
    return collections[hashString];
}
function statsManagerGetOrCreateReporter(repoInfo, creatorFunction) {
    const hashString = repoInfo.toString();
    if (!reporters[hashString]) {
        reporters[hashString] = creatorFunction();
    }
    return reporters[hashString];
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * This class ensures the packets from the server arrive in order
 * This class takes data from the server and ensures it gets passed into the callbacks in order.
 */
class PacketReceiver {
    /**
     * @param onMessage_
     */
    constructor(onMessage_) {
        this.onMessage_ = onMessage_;
        this.pendingResponses = [];
        this.currentResponseNum = 0;
        this.closeAfterResponse = -1;
        this.onClose = null;
    }
    closeAfter(responseNum, callback) {
        this.closeAfterResponse = responseNum;
        this.onClose = callback;
        if (this.closeAfterResponse < this.currentResponseNum) {
            this.onClose();
            this.onClose = null;
        }
    }
    /**
     * Each message from the server comes with a response number, and an array of data. The responseNumber
     * allows us to ensure that we process them in the right order, since we can't be guaranteed that all
     * browsers will respond in the same order as the requests we sent
     */
    handleResponse(requestNum, data) {
        this.pendingResponses[requestNum] = data;
        while (this.pendingResponses[this.currentResponseNum]) {
            const toProcess = this.pendingResponses[this.currentResponseNum];
            delete this.pendingResponses[this.currentResponseNum];
            for (let i = 0; i < toProcess.length; ++i) {
                if (toProcess[i]) {
                    exceptionGuard(() => {
                        this.onMessage_(toProcess[i]);
                    });
                }
            }
            if (this.currentResponseNum === this.closeAfterResponse) {
                if (this.onClose) {
                    this.onClose();
                    this.onClose = null;
                }
                break;
            }
            this.currentResponseNum++;
        }
    }
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// URL query parameters associated with longpolling
const FIREBASE_LONGPOLL_START_PARAM = 'start';
const FIREBASE_LONGPOLL_CLOSE_COMMAND = 'close';
const FIREBASE_LONGPOLL_COMMAND_CB_NAME = 'pLPCommand';
const FIREBASE_LONGPOLL_DATA_CB_NAME = 'pRTLPCB';
const FIREBASE_LONGPOLL_ID_PARAM = 'id';
const FIREBASE_LONGPOLL_PW_PARAM = 'pw';
const FIREBASE_LONGPOLL_SERIAL_PARAM = 'ser';
const FIREBASE_LONGPOLL_CALLBACK_ID_PARAM = 'cb';
const FIREBASE_LONGPOLL_SEGMENT_NUM_PARAM = 'seg';
const FIREBASE_LONGPOLL_SEGMENTS_IN_PACKET = 'ts';
const FIREBASE_LONGPOLL_DATA_PARAM = 'd';
const FIREBASE_LONGPOLL_DISCONN_FRAME_REQUEST_PARAM = 'dframe';
//Data size constants.
//TODO: Perf: the maximum length actually differs from browser to browser.
// We should check what browser we're on and set accordingly.
const MAX_URL_DATA_SIZE = 1870;
const SEG_HEADER_SIZE = 30; //ie: &seg=8299234&ts=982389123&d=
const MAX_PAYLOAD_SIZE = MAX_URL_DATA_SIZE - SEG_HEADER_SIZE;
/**
 * Keepalive period
 * send a fresh request at minimum every 25 seconds. Opera has a maximum request
 * length of 30 seconds that we can't exceed.
 */
const KEEPALIVE_REQUEST_INTERVAL = 25000;
/**
 * How long to wait before aborting a long-polling connection attempt.
 */
const LP_CONNECT_TIMEOUT = 30000;
/**
 * This class manages a single long-polling connection.
 */
class BrowserPollConnection {
    /**
     * @param connId An identifier for this connection, used for logging
     * @param repoInfo The info for the endpoint to send data to.
     * @param applicationId The Firebase App ID for this project.
     * @param appCheckToken The AppCheck token for this client.
     * @param authToken The AuthToken to use for this connection.
     * @param transportSessionId Optional transportSessionid if we are
     * reconnecting for an existing transport session
     * @param lastSessionId Optional lastSessionId if the PersistentConnection has
     * already created a connection previously
     */
    constructor(connId, repoInfo, applicationId, appCheckToken, authToken, transportSessionId, lastSessionId) {
        this.connId = connId;
        this.repoInfo = repoInfo;
        this.applicationId = applicationId;
        this.appCheckToken = appCheckToken;
        this.authToken = authToken;
        this.transportSessionId = transportSessionId;
        this.lastSessionId = lastSessionId;
        this.bytesSent = 0;
        this.bytesReceived = 0;
        this.everConnected_ = false;
        this.log_ = logWrapper(connId);
        this.stats_ = statsManagerGetCollection(repoInfo);
        this.urlFn = (params) => {
            // Always add the token if we have one.
            if (this.appCheckToken) {
                params[APP_CHECK_TOKEN_PARAM] = this.appCheckToken;
            }
            return repoInfoConnectionURL(repoInfo, LONG_POLLING, params);
        };
    }
    /**
     * @param onMessage - Callback when messages arrive
     * @param onDisconnect - Callback with connection lost.
     */
    open(onMessage, onDisconnect) {
        this.curSegmentNum = 0;
        this.onDisconnect_ = onDisconnect;
        this.myPacketOrderer = new PacketReceiver(onMessage);
        this.isClosed_ = false;
        this.connectTimeoutTimer_ = setTimeout(() => {
            this.log_('Timed out trying to connect.');
            // Make sure we clear the host cache
            this.onClosed_();
            this.connectTimeoutTimer_ = null;
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
        }, Math.floor(LP_CONNECT_TIMEOUT));
        // Ensure we delay the creation of the iframe until the DOM is loaded.
        executeWhenDOMReady(() => {
            if (this.isClosed_) {
                return;
            }
            //Set up a callback that gets triggered once a connection is set up.
            this.scriptTagHolder = new FirebaseIFrameScriptHolder((...args) => {
                const [command, arg1, arg2, arg3, arg4] = args;
                this.incrementIncomingBytes_(args);
                if (!this.scriptTagHolder) {
                    return; // we closed the connection.
                }
                if (this.connectTimeoutTimer_) {
                    clearTimeout(this.connectTimeoutTimer_);
                    this.connectTimeoutTimer_ = null;
                }
                this.everConnected_ = true;
                if (command === FIREBASE_LONGPOLL_START_PARAM) {
                    this.id = arg1;
                    this.password = arg2;
                }
                else if (command === FIREBASE_LONGPOLL_CLOSE_COMMAND) {
                    // Don't clear the host cache. We got a response from the server, so we know it's reachable
                    if (arg1) {
                        // We aren't expecting any more data (other than what the server's already in the process of sending us
                        // through our already open polls), so don't send any more.
                        this.scriptTagHolder.sendNewPolls = false;
                        // arg1 in this case is the last response number sent by the server. We should try to receive
                        // all of the responses up to this one before closing
                        this.myPacketOrderer.closeAfter(arg1, () => {
                            this.onClosed_();
                        });
                    }
                    else {
                        this.onClosed_();
                    }
                }
                else {
                    throw new Error('Unrecognized command received: ' + command);
                }
            }, (...args) => {
                const [pN, data] = args;
                this.incrementIncomingBytes_(args);
                this.myPacketOrderer.handleResponse(pN, data);
            }, () => {
                this.onClosed_();
            }, this.urlFn);
            //Send the initial request to connect. The serial number is simply to keep the browser from pulling previous results
            //from cache.
            const urlParams = {};
            urlParams[FIREBASE_LONGPOLL_START_PARAM] = 't';
            urlParams[FIREBASE_LONGPOLL_SERIAL_PARAM] = Math.floor(Math.random() * 100000000);
            if (this.scriptTagHolder.uniqueCallbackIdentifier) {
                urlParams[FIREBASE_LONGPOLL_CALLBACK_ID_PARAM] =
                    this.scriptTagHolder.uniqueCallbackIdentifier;
            }
            urlParams[VERSION_PARAM] = PROTOCOL_VERSION;
            if (this.transportSessionId) {
                urlParams[TRANSPORT_SESSION_PARAM] = this.transportSessionId;
            }
            if (this.lastSessionId) {
                urlParams[LAST_SESSION_PARAM] = this.lastSessionId;
            }
            if (this.applicationId) {
                urlParams[APPLICATION_ID_PARAM] = this.applicationId;
            }
            if (this.appCheckToken) {
                urlParams[APP_CHECK_TOKEN_PARAM] = this.appCheckToken;
            }
            if (typeof location !== 'undefined' &&
                location.hostname &&
                FORGE_DOMAIN_RE.test(location.hostname)) {
                urlParams[REFERER_PARAM] = FORGE_REF;
            }
            const connectURL = this.urlFn(urlParams);
            this.log_('Connecting via long-poll to ' + connectURL);
            this.scriptTagHolder.addTag(connectURL, () => {
                /* do nothing */
            });
        });
    }
    /**
     * Call this when a handshake has completed successfully and we want to consider the connection established
     */
    start() {
        this.scriptTagHolder.startLongPoll(this.id, this.password);
        this.addDisconnectPingFrame(this.id, this.password);
    }
    /**
     * Forces long polling to be considered as a potential transport
     */
    static forceAllow() {
        BrowserPollConnection.forceAllow_ = true;
    }
    /**
     * Forces longpolling to not be considered as a potential transport
     */
    static forceDisallow() {
        BrowserPollConnection.forceDisallow_ = true;
    }
    // Static method, use string literal so it can be accessed in a generic way
    static isAvailable() {
        if ((0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.isNodeSdk)()) {
            return false;
        }
        else if (BrowserPollConnection.forceAllow_) {
            return true;
        }
        else {
            // NOTE: In React-Native there's normally no 'document', but if you debug a React-Native app in
            // the Chrome debugger, 'document' is defined, but document.createElement is null (2015/06/08).
            return (!BrowserPollConnection.forceDisallow_ &&
                typeof document !== 'undefined' &&
                document.createElement != null &&
                !isChromeExtensionContentScript() &&
                !isWindowsStoreApp());
        }
    }
    /**
     * No-op for polling
     */
    markConnectionHealthy() { }
    /**
     * Stops polling and cleans up the iframe
     */
    shutdown_() {
        this.isClosed_ = true;
        if (this.scriptTagHolder) {
            this.scriptTagHolder.close();
            this.scriptTagHolder = null;
        }
        //remove the disconnect frame, which will trigger an XHR call to the server to tell it we're leaving.
        if (this.myDisconnFrame) {
            document.body.removeChild(this.myDisconnFrame);
            this.myDisconnFrame = null;
        }
        if (this.connectTimeoutTimer_) {
            clearTimeout(this.connectTimeoutTimer_);
            this.connectTimeoutTimer_ = null;
        }
    }
    /**
     * Triggered when this transport is closed
     */
    onClosed_() {
        if (!this.isClosed_) {
            this.log_('Longpoll is closing itself');
            this.shutdown_();
            if (this.onDisconnect_) {
                this.onDisconnect_(this.everConnected_);
                this.onDisconnect_ = null;
            }
        }
    }
    /**
     * External-facing close handler. RealTime has requested we shut down. Kill our connection and tell the server
     * that we've left.
     */
    close() {
        if (!this.isClosed_) {
            this.log_('Longpoll is being closed.');
            this.shutdown_();
        }
    }
    /**
     * Send the JSON object down to the server. It will need to be stringified, base64 encoded, and then
     * broken into chunks (since URLs have a small maximum length).
     * @param data - The JSON data to transmit.
     */
    send(data) {
        const dataStr = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.stringify)(data);
        this.bytesSent += dataStr.length;
        this.stats_.incrementCounter('bytes_sent', dataStr.length);
        //first, lets get the base64-encoded data
        const base64data = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.base64Encode)(dataStr);
        //We can only fit a certain amount in each URL, so we need to split this request
        //up into multiple pieces if it doesn't fit in one request.
        const dataSegs = splitStringBySize(base64data, MAX_PAYLOAD_SIZE);
        //Enqueue each segment for transmission. We assign each chunk a sequential ID and a total number
        //of segments so that we can reassemble the packet on the server.
        for (let i = 0; i < dataSegs.length; i++) {
            this.scriptTagHolder.enqueueSegment(this.curSegmentNum, dataSegs.length, dataSegs[i]);
            this.curSegmentNum++;
        }
    }
    /**
     * This is how we notify the server that we're leaving.
     * We aren't able to send requests with DHTML on a window close event, but we can
     * trigger XHR requests in some browsers (everything but Opera basically).
     */
    addDisconnectPingFrame(id, pw) {
        if ((0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.isNodeSdk)()) {
            return;
        }
        this.myDisconnFrame = document.createElement('iframe');
        const urlParams = {};
        urlParams[FIREBASE_LONGPOLL_DISCONN_FRAME_REQUEST_PARAM] = 't';
        urlParams[FIREBASE_LONGPOLL_ID_PARAM] = id;
        urlParams[FIREBASE_LONGPOLL_PW_PARAM] = pw;
        this.myDisconnFrame.src = this.urlFn(urlParams);
        this.myDisconnFrame.style.display = 'none';
        document.body.appendChild(this.myDisconnFrame);
    }
    /**
     * Used to track the bytes received by this client
     */
    incrementIncomingBytes_(args) {
        // TODO: This is an annoying perf hit just to track the number of incoming bytes.  Maybe it should be opt-in.
        const bytesReceived = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.stringify)(args).length;
        this.bytesReceived += bytesReceived;
        this.stats_.incrementCounter('bytes_received', bytesReceived);
    }
}
/*********************************************************************************************
 * A wrapper around an iframe that is used as a long-polling script holder.
 *********************************************************************************************/
class FirebaseIFrameScriptHolder {
    /**
     * @param commandCB - The callback to be called when control commands are recevied from the server.
     * @param onMessageCB - The callback to be triggered when responses arrive from the server.
     * @param onDisconnect - The callback to be triggered when this tag holder is closed
     * @param urlFn - A function that provides the URL of the endpoint to send data to.
     */
    constructor(commandCB, onMessageCB, onDisconnect, urlFn) {
        this.onDisconnect = onDisconnect;
        this.urlFn = urlFn;
        //We maintain a count of all of the outstanding requests, because if we have too many active at once it can cause
        //problems in some browsers.
        this.outstandingRequests = new Set();
        //A queue of the pending segments waiting for transmission to the server.
        this.pendingSegs = [];
        //A serial number. We use this for two things:
        // 1) A way to ensure the browser doesn't cache responses to polls
        // 2) A way to make the server aware when long-polls arrive in a different order than we started them. The
        //    server needs to release both polls in this case or it will cause problems in Opera since Opera can only execute
        //    JSONP code in the order it was added to the iframe.
        this.currentSerial = Math.floor(Math.random() * 100000000);
        // This gets set to false when we're "closing down" the connection (e.g. we're switching transports but there's still
        // incoming data from the server that we're waiting for).
        this.sendNewPolls = true;
        if (!(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.isNodeSdk)()) {
            //Each script holder registers a couple of uniquely named callbacks with the window. These are called from the
            //iframes where we put the long-polling script tags. We have two callbacks:
            //   1) Command Callback - Triggered for control issues, like starting a connection.
            //   2) Message Callback - Triggered when new data arrives.
            this.uniqueCallbackIdentifier = LUIDGenerator();
            window[FIREBASE_LONGPOLL_COMMAND_CB_NAME + this.uniqueCallbackIdentifier] = commandCB;
            window[FIREBASE_LONGPOLL_DATA_CB_NAME + this.uniqueCallbackIdentifier] =
                onMessageCB;
            //Create an iframe for us to add script tags to.
            this.myIFrame = FirebaseIFrameScriptHolder.createIFrame_();
            // Set the iframe's contents.
            let script = '';
            // if we set a javascript url, it's IE and we need to set the document domain. The javascript url is sufficient
            // for ie9, but ie8 needs to do it again in the document itself.
            if (this.myIFrame.src &&
                this.myIFrame.src.substr(0, 'javascript:'.length) === 'javascript:') {
                const currentDomain = document.domain;
                script = '<script>document.domain="' + currentDomain + '";</script>';
            }
            const iframeContents = '<html><body>' + script + '</body></html>';
            try {
                this.myIFrame.doc.open();
                this.myIFrame.doc.write(iframeContents);
                this.myIFrame.doc.close();
            }
            catch (e) {
                log('frame writing exception');
                if (e.stack) {
                    log(e.stack);
                }
                log(e);
            }
        }
        else {
            this.commandCB = commandCB;
            this.onMessageCB = onMessageCB;
        }
    }
    /**
     * Each browser has its own funny way to handle iframes. Here we mush them all together into one object that I can
     * actually use.
     */
    static createIFrame_() {
        const iframe = document.createElement('iframe');
        iframe.style.display = 'none';
        // This is necessary in order to initialize the document inside the iframe
        if (document.body) {
            document.body.appendChild(iframe);
            try {
                // If document.domain has been modified in IE, this will throw an error, and we need to set the
                // domain of the iframe's document manually. We can do this via a javascript: url as the src attribute
                // Also note that we must do this *after* the iframe has been appended to the page. Otherwise it doesn't work.
                const a = iframe.contentWindow.document;
                if (!a) {
                    // Apologies for the log-spam, I need to do something to keep closure from optimizing out the assignment above.
                    log('No IE domain setting required');
                }
            }
            catch (e) {
                const domain = document.domain;
                iframe.src =
                    "javascript:void((function(){document.open();document.domain='" +
                        domain +
                        "';document.close();})())";
            }
        }
        else {
            // LongPollConnection attempts to delay initialization until the document is ready, so hopefully this
            // never gets hit.
            throw 'Document body has not initialized. Wait to initialize Firebase until after the document is ready.';
        }
        // Get the document of the iframe in a browser-specific way.
        if (iframe.contentDocument) {
            iframe.doc = iframe.contentDocument; // Firefox, Opera, Safari
        }
        else if (iframe.contentWindow) {
            iframe.doc = iframe.contentWindow.document; // Internet Explorer
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
        }
        else if (iframe.document) {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            iframe.doc = iframe.document; //others?
        }
        return iframe;
    }
    /**
     * Cancel all outstanding queries and remove the frame.
     */
    close() {
        //Mark this iframe as dead, so no new requests are sent.
        this.alive = false;
        if (this.myIFrame) {
            //We have to actually remove all of the html inside this iframe before removing it from the
            //window, or IE will continue loading and executing the script tags we've already added, which
            //can lead to some errors being thrown. Setting innerHTML seems to be the easiest way to do this.
            this.myIFrame.doc.body.innerHTML = '';
            setTimeout(() => {
                if (this.myIFrame !== null) {
                    document.body.removeChild(this.myIFrame);
                    this.myIFrame = null;
                }
            }, Math.floor(0));
        }
        // Protect from being called recursively.
        const onDisconnect = this.onDisconnect;
        if (onDisconnect) {
            this.onDisconnect = null;
            onDisconnect();
        }
    }
    /**
     * Actually start the long-polling session by adding the first script tag(s) to the iframe.
     * @param id - The ID of this connection
     * @param pw - The password for this connection
     */
    startLongPoll(id, pw) {
        this.myID = id;
        this.myPW = pw;
        this.alive = true;
        //send the initial request. If there are requests queued, make sure that we transmit as many as we are currently able to.
        while (this.newRequest_()) { }
    }
    /**
     * This is called any time someone might want a script tag to be added. It adds a script tag when there aren't
     * too many outstanding requests and we are still alive.
     *
     * If there are outstanding packet segments to send, it sends one. If there aren't, it sends a long-poll anyways if
     * needed.
     */
    newRequest_() {
        // We keep one outstanding request open all the time to receive data, but if we need to send data
        // (pendingSegs.length > 0) then we create a new request to send the data.  The server will automatically
        // close the old request.
        if (this.alive &&
            this.sendNewPolls &&
            this.outstandingRequests.size < (this.pendingSegs.length > 0 ? 2 : 1)) {
            //construct our url
            this.currentSerial++;
            const urlParams = {};
            urlParams[FIREBASE_LONGPOLL_ID_PARAM] = this.myID;
            urlParams[FIREBASE_LONGPOLL_PW_PARAM] = this.myPW;
            urlParams[FIREBASE_LONGPOLL_SERIAL_PARAM] = this.currentSerial;
            let theURL = this.urlFn(urlParams);
            //Now add as much data as we can.
            let curDataString = '';
            let i = 0;
            while (this.pendingSegs.length > 0) {
                //first, lets see if the next segment will fit.
                const nextSeg = this.pendingSegs[0];
                if (nextSeg.d.length +
                    SEG_HEADER_SIZE +
                    curDataString.length <=
                    MAX_URL_DATA_SIZE) {
                    //great, the segment will fit. Lets append it.
                    const theSeg = this.pendingSegs.shift();
                    curDataString =
                        curDataString +
                            '&' +
                            FIREBASE_LONGPOLL_SEGMENT_NUM_PARAM +
                            i +
                            '=' +
                            theSeg.seg +
                            '&' +
                            FIREBASE_LONGPOLL_SEGMENTS_IN_PACKET +
                            i +
                            '=' +
                            theSeg.ts +
                            '&' +
                            FIREBASE_LONGPOLL_DATA_PARAM +
                            i +
                            '=' +
                            theSeg.d;
                    i++;
                }
                else {
                    break;
                }
            }
            theURL = theURL + curDataString;
            this.addLongPollTag_(theURL, this.currentSerial);
            return true;
        }
        else {
            return false;
        }
    }
    /**
     * Queue a packet for transmission to the server.
     * @param segnum - A sequential id for this packet segment used for reassembly
     * @param totalsegs - The total number of segments in this packet
     * @param data - The data for this segment.
     */
    enqueueSegment(segnum, totalsegs, data) {
        //add this to the queue of segments to send.
        this.pendingSegs.push({ seg: segnum, ts: totalsegs, d: data });
        //send the data immediately if there isn't already data being transmitted, unless
        //startLongPoll hasn't been called yet.
        if (this.alive) {
            this.newRequest_();
        }
    }
    /**
     * Add a script tag for a regular long-poll request.
     * @param url - The URL of the script tag.
     * @param serial - The serial number of the request.
     */
    addLongPollTag_(url, serial) {
        //remember that we sent this request.
        this.outstandingRequests.add(serial);
        const doNewRequest = () => {
            this.outstandingRequests.delete(serial);
            this.newRequest_();
        };
        // If this request doesn't return on its own accord (by the server sending us some data), we'll
        // create a new one after the KEEPALIVE interval to make sure we always keep a fresh request open.
        const keepaliveTimeout = setTimeout(doNewRequest, Math.floor(KEEPALIVE_REQUEST_INTERVAL));
        const readyStateCB = () => {
            // Request completed.  Cancel the keepalive.
            clearTimeout(keepaliveTimeout);
            // Trigger a new request so we can continue receiving data.
            doNewRequest();
        };
        this.addTag(url, readyStateCB);
    }
    /**
     * Add an arbitrary script tag to the iframe.
     * @param url - The URL for the script tag source.
     * @param loadCB - A callback to be triggered once the script has loaded.
     */
    addTag(url, loadCB) {
        if ((0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.isNodeSdk)()) {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            this.doNodeLongPoll(url, loadCB);
        }
        else {
            setTimeout(() => {
                try {
                    // if we're already closed, don't add this poll
                    if (!this.sendNewPolls) {
                        return;
                    }
                    const newScript = this.myIFrame.doc.createElement('script');
                    newScript.type = 'text/javascript';
                    newScript.async = true;
                    newScript.src = url;
                    // eslint-disable-next-line @typescript-eslint/no-explicit-any
                    newScript.onload = newScript.onreadystatechange =
                        function () {
                            // eslint-disable-next-line @typescript-eslint/no-explicit-any
                            const rstate = newScript.readyState;
                            if (!rstate || rstate === 'loaded' || rstate === 'complete') {
                                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                                newScript.onload = newScript.onreadystatechange = null;
                                if (newScript.parentNode) {
                                    newScript.parentNode.removeChild(newScript);
                                }
                                loadCB();
                            }
                        };
                    newScript.onerror = () => {
                        log('Long-poll script failed to load: ' + url);
                        this.sendNewPolls = false;
                        this.close();
                    };
                    this.myIFrame.doc.body.appendChild(newScript);
                }
                catch (e) {
                    // TODO: we should make this error visible somehow
                }
            }, Math.floor(1));
        }
    }
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const WEBSOCKET_MAX_FRAME_SIZE = 16384;
const WEBSOCKET_KEEPALIVE_INTERVAL = 45000;
let WebSocketImpl = null;
if (typeof MozWebSocket !== 'undefined') {
    WebSocketImpl = MozWebSocket;
}
else if (typeof WebSocket !== 'undefined') {
    WebSocketImpl = WebSocket;
}
/**
 * Create a new websocket connection with the given callbacks.
 */
class WebSocketConnection {
    /**
     * @param connId identifier for this transport
     * @param repoInfo The info for the websocket endpoint.
     * @param applicationId The Firebase App ID for this project.
     * @param appCheckToken The App Check Token for this client.
     * @param authToken The Auth Token for this client.
     * @param transportSessionId Optional transportSessionId if this is connecting
     * to an existing transport session
     * @param lastSessionId Optional lastSessionId if there was a previous
     * connection
     */
    constructor(connId, repoInfo, applicationId, appCheckToken, authToken, transportSessionId, lastSessionId) {
        this.connId = connId;
        this.applicationId = applicationId;
        this.appCheckToken = appCheckToken;
        this.authToken = authToken;
        this.keepaliveTimer = null;
        this.frames = null;
        this.totalFrames = 0;
        this.bytesSent = 0;
        this.bytesReceived = 0;
        this.log_ = logWrapper(this.connId);
        this.stats_ = statsManagerGetCollection(repoInfo);
        this.connURL = WebSocketConnection.connectionURL_(repoInfo, transportSessionId, lastSessionId, appCheckToken);
        this.nodeAdmin = repoInfo.nodeAdmin;
    }
    /**
     * @param repoInfo - The info for the websocket endpoint.
     * @param transportSessionId - Optional transportSessionId if this is connecting to an existing transport
     *                                         session
     * @param lastSessionId - Optional lastSessionId if there was a previous connection
     * @returns connection url
     */
    static connectionURL_(repoInfo, transportSessionId, lastSessionId, appCheckToken) {
        const urlParams = {};
        urlParams[VERSION_PARAM] = PROTOCOL_VERSION;
        if (!(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.isNodeSdk)() &&
            typeof location !== 'undefined' &&
            location.hostname &&
            FORGE_DOMAIN_RE.test(location.hostname)) {
            urlParams[REFERER_PARAM] = FORGE_REF;
        }
        if (transportSessionId) {
            urlParams[TRANSPORT_SESSION_PARAM] = transportSessionId;
        }
        if (lastSessionId) {
            urlParams[LAST_SESSION_PARAM] = lastSessionId;
        }
        if (appCheckToken) {
            urlParams[APP_CHECK_TOKEN_PARAM] = appCheckToken;
        }
        return repoInfoConnectionURL(repoInfo, WEBSOCKET, urlParams);
    }
    /**
     * @param onMessage - Callback when messages arrive
     * @param onDisconnect - Callback with connection lost.
     */
    open(onMessage, onDisconnect) {
        this.onDisconnect = onDisconnect;
        this.onMessage = onMessage;
        this.log_('Websocket connecting to ' + this.connURL);
        this.everConnected_ = false;
        // Assume failure until proven otherwise.
        PersistentStorage.set('previous_websocket_failure', true);
        try {
            if ((0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.isNodeSdk)()) {
                const device = this.nodeAdmin ? 'AdminNode' : 'Node';
                // UA Format: Firebase/<wire_protocol>/<sdk_version>/<platform>/<device>
                const options = {
                    headers: {
                        'User-Agent': `Firebase/${PROTOCOL_VERSION}/${SDK_VERSION}/${process.platform}/${device}`,
                        'X-Firebase-GMPID': this.applicationId || ''
                    }
                };
                // If using Node with admin creds, AppCheck-related checks are unnecessary.
                // Note that we send the credentials here even if they aren't admin credentials, which is
                // not a problem.
                // Note that this header is just used to bypass appcheck, and the token should still be sent
                // through the websocket connection once it is established.
                if (this.authToken) {
                    options.headers['Authorization'] = `Bearer ${this.authToken}`;
                }
                if (this.appCheckToken) {
                    options.headers['X-Firebase-AppCheck'] = this.appCheckToken;
                }
                // Plumb appropriate http_proxy environment variable into faye-websocket if it exists.
                const env = process['env'];
                const proxy = this.connURL.indexOf('wss://') === 0
                    ? env['HTTPS_PROXY'] || env['https_proxy']
                    : env['HTTP_PROXY'] || env['http_proxy'];
                if (proxy) {
                    options['proxy'] = { origin: proxy };
                }
                this.mySock = new WebSocketImpl(this.connURL, [], options);
            }
            else {
                const options = {
                    headers: {
                        'X-Firebase-GMPID': this.applicationId || '',
                        'X-Firebase-AppCheck': this.appCheckToken || ''
                    }
                };
                this.mySock = new WebSocketImpl(this.connURL, [], options);
            }
        }
        catch (e) {
            this.log_('Error instantiating WebSocket.');
            const error = e.message || e.data;
            if (error) {
                this.log_(error);
            }
            this.onClosed_();
            return;
        }
        this.mySock.onopen = () => {
            this.log_('Websocket connected.');
            this.everConnected_ = true;
        };
        this.mySock.onclose = () => {
            this.log_('Websocket connection was disconnected.');
            this.mySock = null;
            this.onClosed_();
        };
        this.mySock.onmessage = m => {
            this.handleIncomingFrame(m);
        };
        this.mySock.onerror = e => {
            this.log_('WebSocket error.  Closing connection.');
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            const error = e.message || e.data;
            if (error) {
                this.log_(error);
            }
            this.onClosed_();
        };
    }
    /**
     * No-op for websockets, we don't need to do anything once the connection is confirmed as open
     */
    start() { }
    static forceDisallow() {
        WebSocketConnection.forceDisallow_ = true;
    }
    static isAvailable() {
        let isOldAndroid = false;
        if (typeof navigator !== 'undefined' && navigator.userAgent) {
            const oldAndroidRegex = /Android ([0-9]{0,}\.[0-9]{0,})/;
            const oldAndroidMatch = navigator.userAgent.match(oldAndroidRegex);
            if (oldAndroidMatch && oldAndroidMatch.length > 1) {
                if (parseFloat(oldAndroidMatch[1]) < 4.4) {
                    isOldAndroid = true;
                }
            }
        }
        return (!isOldAndroid &&
            WebSocketImpl !== null &&
            !WebSocketConnection.forceDisallow_);
    }
    /**
     * Returns true if we previously failed to connect with this transport.
     */
    static previouslyFailed() {
        // If our persistent storage is actually only in-memory storage,
        // we default to assuming that it previously failed to be safe.
        return (PersistentStorage.isInMemoryStorage ||
            PersistentStorage.get('previous_websocket_failure') === true);
    }
    markConnectionHealthy() {
        PersistentStorage.remove('previous_websocket_failure');
    }
    appendFrame_(data) {
        this.frames.push(data);
        if (this.frames.length === this.totalFrames) {
            const fullMess = this.frames.join('');
            this.frames = null;
            const jsonMess = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.jsonEval)(fullMess);
            //handle the message
            this.onMessage(jsonMess);
        }
    }
    /**
     * @param frameCount - The number of frames we are expecting from the server
     */
    handleNewFrameCount_(frameCount) {
        this.totalFrames = frameCount;
        this.frames = [];
    }
    /**
     * Attempts to parse a frame count out of some text. If it can't, assumes a value of 1
     * @returns Any remaining data to be process, or null if there is none
     */
    extractFrameCount_(data) {
        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(this.frames === null, 'We already have a frame buffer');
        // TODO: The server is only supposed to send up to 9999 frames (i.e. length <= 4), but that isn't being enforced
        // currently.  So allowing larger frame counts (length <= 6).  See https://app.asana.com/0/search/8688598998380/8237608042508
        if (data.length <= 6) {
            const frameCount = Number(data);
            if (!isNaN(frameCount)) {
                this.handleNewFrameCount_(frameCount);
                return null;
            }
        }
        this.handleNewFrameCount_(1);
        return data;
    }
    /**
     * Process a websocket frame that has arrived from the server.
     * @param mess - The frame data
     */
    handleIncomingFrame(mess) {
        if (this.mySock === null) {
            return; // Chrome apparently delivers incoming packets even after we .close() the connection sometimes.
        }
        const data = mess['data'];
        this.bytesReceived += data.length;
        this.stats_.incrementCounter('bytes_received', data.length);
        this.resetKeepAlive();
        if (this.frames !== null) {
            // we're buffering
            this.appendFrame_(data);
        }
        else {
            // try to parse out a frame count, otherwise, assume 1 and process it
            const remainingData = this.extractFrameCount_(data);
            if (remainingData !== null) {
                this.appendFrame_(remainingData);
            }
        }
    }
    /**
     * Send a message to the server
     * @param data - The JSON object to transmit
     */
    send(data) {
        this.resetKeepAlive();
        const dataStr = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.stringify)(data);
        this.bytesSent += dataStr.length;
        this.stats_.incrementCounter('bytes_sent', dataStr.length);
        //We can only fit a certain amount in each websocket frame, so we need to split this request
        //up into multiple pieces if it doesn't fit in one request.
        const dataSegs = splitStringBySize(dataStr, WEBSOCKET_MAX_FRAME_SIZE);
        //Send the length header
        if (dataSegs.length > 1) {
            this.sendString_(String(dataSegs.length));
        }
        //Send the actual data in segments.
        for (let i = 0; i < dataSegs.length; i++) {
            this.sendString_(dataSegs[i]);
        }
    }
    shutdown_() {
        this.isClosed_ = true;
        if (this.keepaliveTimer) {
            clearInterval(this.keepaliveTimer);
            this.keepaliveTimer = null;
        }
        if (this.mySock) {
            this.mySock.close();
            this.mySock = null;
        }
    }
    onClosed_() {
        if (!this.isClosed_) {
            this.log_('WebSocket is closing itself');
            this.shutdown_();
            // since this is an internal close, trigger the close listener
            if (this.onDisconnect) {
                this.onDisconnect(this.everConnected_);
                this.onDisconnect = null;
            }
        }
    }
    /**
     * External-facing close handler.
     * Close the websocket and kill the connection.
     */
    close() {
        if (!this.isClosed_) {
            this.log_('WebSocket is being closed');
            this.shutdown_();
        }
    }
    /**
     * Kill the current keepalive timer and start a new one, to ensure that it always fires N seconds after
     * the last activity.
     */
    resetKeepAlive() {
        clearInterval(this.keepaliveTimer);
        this.keepaliveTimer = setInterval(() => {
            //If there has been no websocket activity for a while, send a no-op
            if (this.mySock) {
                this.sendString_('0');
            }
            this.resetKeepAlive();
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
        }, Math.floor(WEBSOCKET_KEEPALIVE_INTERVAL));
    }
    /**
     * Send a string over the websocket.
     *
     * @param str - String to send.
     */
    sendString_(str) {
        // Firefox seems to sometimes throw exceptions (NS_ERROR_UNEXPECTED) from websocket .send()
        // calls for some unknown reason.  We treat these as an error and disconnect.
        // See https://app.asana.com/0/58926111402292/68021340250410
        try {
            this.mySock.send(str);
        }
        catch (e) {
            this.log_('Exception thrown from WebSocket.send():', e.message || e.data, 'Closing connection.');
            setTimeout(this.onClosed_.bind(this), 0);
        }
    }
}
/**
 * Number of response before we consider the connection "healthy."
 */
WebSocketConnection.responsesRequiredToBeHealthy = 2;
/**
 * Time to wait for the connection te become healthy before giving up.
 */
WebSocketConnection.healthyTimeout = 30000;

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Currently simplistic, this class manages what transport a Connection should use at various stages of its
 * lifecycle.
 *
 * It starts with longpolling in a browser, and httppolling on node. It then upgrades to websockets if
 * they are available.
 */
class TransportManager {
    /**
     * @param repoInfo - Metadata around the namespace we're connecting to
     */
    constructor(repoInfo) {
        this.initTransports_(repoInfo);
    }
    static get ALL_TRANSPORTS() {
        return [BrowserPollConnection, WebSocketConnection];
    }
    initTransports_(repoInfo) {
        const isWebSocketsAvailable = WebSocketConnection && WebSocketConnection['isAvailable']();
        let isSkipPollConnection = isWebSocketsAvailable && !WebSocketConnection.previouslyFailed();
        if (repoInfo.webSocketOnly) {
            if (!isWebSocketsAvailable) {
                warn("wss:// URL used, but browser isn't known to support websockets.  Trying anyway.");
            }
            isSkipPollConnection = true;
        }
        if (isSkipPollConnection) {
            this.transports_ = [WebSocketConnection];
        }
        else {
            const transports = (this.transports_ = []);
            for (const transport of TransportManager.ALL_TRANSPORTS) {
                if (transport && transport['isAvailable']()) {
                    transports.push(transport);
                }
            }
        }
    }
    /**
     * @returns The constructor for the initial transport to use
     */
    initialTransport() {
        if (this.transports_.length > 0) {
            return this.transports_[0];
        }
        else {
            throw new Error('No transports available');
        }
    }
    /**
     * @returns The constructor for the next transport, or null
     */
    upgradeTransport() {
        if (this.transports_.length > 1) {
            return this.transports_[1];
        }
        else {
            return null;
        }
    }
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Abort upgrade attempt if it takes longer than 60s.
const UPGRADE_TIMEOUT = 60000;
// For some transports (WebSockets), we need to "validate" the transport by exchanging a few requests and responses.
// If we haven't sent enough requests within 5s, we'll start sending noop ping requests.
const DELAY_BEFORE_SENDING_EXTRA_REQUESTS = 5000;
// If the initial data sent triggers a lot of bandwidth (i.e. it's a large put or a listen for a large amount of data)
// then we may not be able to exchange our ping/pong requests within the healthy timeout.  So if we reach the timeout
// but we've sent/received enough bytes, we don't cancel the connection.
const BYTES_SENT_HEALTHY_OVERRIDE = 10 * 1024;
const BYTES_RECEIVED_HEALTHY_OVERRIDE = 100 * 1024;
const MESSAGE_TYPE = 't';
const MESSAGE_DATA = 'd';
const CONTROL_SHUTDOWN = 's';
const CONTROL_RESET = 'r';
const CONTROL_ERROR = 'e';
const CONTROL_PONG = 'o';
const SWITCH_ACK = 'a';
const END_TRANSMISSION = 'n';
const PING = 'p';
const SERVER_HELLO = 'h';
/**
 * Creates a new real-time connection to the server using whichever method works
 * best in the current browser.
 */
class Connection {
    /**
     * @param id - an id for this connection
     * @param repoInfo_ - the info for the endpoint to connect to
     * @param applicationId_ - the Firebase App ID for this project
     * @param appCheckToken_ - The App Check Token for this device.
     * @param authToken_ - The auth token for this session.
     * @param onMessage_ - the callback to be triggered when a server-push message arrives
     * @param onReady_ - the callback to be triggered when this connection is ready to send messages.
     * @param onDisconnect_ - the callback to be triggered when a connection was lost
     * @param onKill_ - the callback to be triggered when this connection has permanently shut down.
     * @param lastSessionId - last session id in persistent connection. is used to clean up old session in real-time server
     */
    constructor(id, repoInfo_, applicationId_, appCheckToken_, authToken_, onMessage_, onReady_, onDisconnect_, onKill_, lastSessionId) {
        this.id = id;
        this.repoInfo_ = repoInfo_;
        this.applicationId_ = applicationId_;
        this.appCheckToken_ = appCheckToken_;
        this.authToken_ = authToken_;
        this.onMessage_ = onMessage_;
        this.onReady_ = onReady_;
        this.onDisconnect_ = onDisconnect_;
        this.onKill_ = onKill_;
        this.lastSessionId = lastSessionId;
        this.connectionCount = 0;
        this.pendingDataMessages = [];
        this.state_ = 0 /* CONNECTING */;
        this.log_ = logWrapper('c:' + this.id + ':');
        this.transportManager_ = new TransportManager(repoInfo_);
        this.log_('Connection created');
        this.start_();
    }
    /**
     * Starts a connection attempt
     */
    start_() {
        const conn = this.transportManager_.initialTransport();
        this.conn_ = new conn(this.nextTransportId_(), this.repoInfo_, this.applicationId_, this.appCheckToken_, this.authToken_, null, this.lastSessionId);
        // For certain transports (WebSockets), we need to send and receive several messages back and forth before we
        // can consider the transport healthy.
        this.primaryResponsesRequired_ = conn['responsesRequiredToBeHealthy'] || 0;
        const onMessageReceived = this.connReceiver_(this.conn_);
        const onConnectionLost = this.disconnReceiver_(this.conn_);
        this.tx_ = this.conn_;
        this.rx_ = this.conn_;
        this.secondaryConn_ = null;
        this.isHealthy_ = false;
        /*
         * Firefox doesn't like when code from one iframe tries to create another iframe by way of the parent frame.
         * This can occur in the case of a redirect, i.e. we guessed wrong on what server to connect to and received a reset.
         * Somehow, setTimeout seems to make this ok. That doesn't make sense from a security perspective, since you should
         * still have the context of your originating frame.
         */
        setTimeout(() => {
            // this.conn_ gets set to null in some of the tests. Check to make sure it still exists before using it
            this.conn_ && this.conn_.open(onMessageReceived, onConnectionLost);
        }, Math.floor(0));
        const healthyTimeoutMS = conn['healthyTimeout'] || 0;
        if (healthyTimeoutMS > 0) {
            this.healthyTimeout_ = setTimeoutNonBlocking(() => {
                this.healthyTimeout_ = null;
                if (!this.isHealthy_) {
                    if (this.conn_ &&
                        this.conn_.bytesReceived > BYTES_RECEIVED_HEALTHY_OVERRIDE) {
                        this.log_('Connection exceeded healthy timeout but has received ' +
                            this.conn_.bytesReceived +
                            ' bytes.  Marking connection healthy.');
                        this.isHealthy_ = true;
                        this.conn_.markConnectionHealthy();
                    }
                    else if (this.conn_ &&
                        this.conn_.bytesSent > BYTES_SENT_HEALTHY_OVERRIDE) {
                        this.log_('Connection exceeded healthy timeout but has sent ' +
                            this.conn_.bytesSent +
                            ' bytes.  Leaving connection alive.');
                        // NOTE: We don't want to mark it healthy, since we have no guarantee that the bytes have made it to
                        // the server.
                    }
                    else {
                        this.log_('Closing unhealthy connection after timeout.');
                        this.close();
                    }
                }
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
            }, Math.floor(healthyTimeoutMS));
        }
    }
    nextTransportId_() {
        return 'c:' + this.id + ':' + this.connectionCount++;
    }
    disconnReceiver_(conn) {
        return everConnected => {
            if (conn === this.conn_) {
                this.onConnectionLost_(everConnected);
            }
            else if (conn === this.secondaryConn_) {
                this.log_('Secondary connection lost.');
                this.onSecondaryConnectionLost_();
            }
            else {
                this.log_('closing an old connection');
            }
        };
    }
    connReceiver_(conn) {
        return (message) => {
            if (this.state_ !== 2 /* DISCONNECTED */) {
                if (conn === this.rx_) {
                    this.onPrimaryMessageReceived_(message);
                }
                else if (conn === this.secondaryConn_) {
                    this.onSecondaryMessageReceived_(message);
                }
                else {
                    this.log_('message on old connection');
                }
            }
        };
    }
    /**
     * @param dataMsg - An arbitrary data message to be sent to the server
     */
    sendRequest(dataMsg) {
        // wrap in a data message envelope and send it on
        const msg = { t: 'd', d: dataMsg };
        this.sendData_(msg);
    }
    tryCleanupConnection() {
        if (this.tx_ === this.secondaryConn_ && this.rx_ === this.secondaryConn_) {
            this.log_('cleaning up and promoting a connection: ' + this.secondaryConn_.connId);
            this.conn_ = this.secondaryConn_;
            this.secondaryConn_ = null;
            // the server will shutdown the old connection
        }
    }
    onSecondaryControl_(controlData) {
        if (MESSAGE_TYPE in controlData) {
            const cmd = controlData[MESSAGE_TYPE];
            if (cmd === SWITCH_ACK) {
                this.upgradeIfSecondaryHealthy_();
            }
            else if (cmd === CONTROL_RESET) {
                // Most likely the session wasn't valid. Abandon the switch attempt
                this.log_('Got a reset on secondary, closing it');
                this.secondaryConn_.close();
                // If we were already using this connection for something, than we need to fully close
                if (this.tx_ === this.secondaryConn_ ||
                    this.rx_ === this.secondaryConn_) {
                    this.close();
                }
            }
            else if (cmd === CONTROL_PONG) {
                this.log_('got pong on secondary.');
                this.secondaryResponsesRequired_--;
                this.upgradeIfSecondaryHealthy_();
            }
        }
    }
    onSecondaryMessageReceived_(parsedData) {
        const layer = requireKey('t', parsedData);
        const data = requireKey('d', parsedData);
        if (layer === 'c') {
            this.onSecondaryControl_(data);
        }
        else if (layer === 'd') {
            // got a data message, but we're still second connection. Need to buffer it up
            this.pendingDataMessages.push(data);
        }
        else {
            throw new Error('Unknown protocol layer: ' + layer);
        }
    }
    upgradeIfSecondaryHealthy_() {
        if (this.secondaryResponsesRequired_ <= 0) {
            this.log_('Secondary connection is healthy.');
            this.isHealthy_ = true;
            this.secondaryConn_.markConnectionHealthy();
            this.proceedWithUpgrade_();
        }
        else {
            // Send a ping to make sure the connection is healthy.
            this.log_('sending ping on secondary.');
            this.secondaryConn_.send({ t: 'c', d: { t: PING, d: {} } });
        }
    }
    proceedWithUpgrade_() {
        // tell this connection to consider itself open
        this.secondaryConn_.start();
        // send ack
        this.log_('sending client ack on secondary');
        this.secondaryConn_.send({ t: 'c', d: { t: SWITCH_ACK, d: {} } });
        // send end packet on primary transport, switch to sending on this one
        // can receive on this one, buffer responses until end received on primary transport
        this.log_('Ending transmission on primary');
        this.conn_.send({ t: 'c', d: { t: END_TRANSMISSION, d: {} } });
        this.tx_ = this.secondaryConn_;
        this.tryCleanupConnection();
    }
    onPrimaryMessageReceived_(parsedData) {
        // Must refer to parsedData properties in quotes, so closure doesn't touch them.
        const layer = requireKey('t', parsedData);
        const data = requireKey('d', parsedData);
        if (layer === 'c') {
            this.onControl_(data);
        }
        else if (layer === 'd') {
            this.onDataMessage_(data);
        }
    }
    onDataMessage_(message) {
        this.onPrimaryResponse_();
        // We don't do anything with data messages, just kick them up a level
        this.onMessage_(message);
    }
    onPrimaryResponse_() {
        if (!this.isHealthy_) {
            this.primaryResponsesRequired_--;
            if (this.primaryResponsesRequired_ <= 0) {
                this.log_('Primary connection is healthy.');
                this.isHealthy_ = true;
                this.conn_.markConnectionHealthy();
            }
        }
    }
    onControl_(controlData) {
        const cmd = requireKey(MESSAGE_TYPE, controlData);
        if (MESSAGE_DATA in controlData) {
            const payload = controlData[MESSAGE_DATA];
            if (cmd === SERVER_HELLO) {
                this.onHandshake_(payload);
            }
            else if (cmd === END_TRANSMISSION) {
                this.log_('recvd end transmission on primary');
                this.rx_ = this.secondaryConn_;
                for (let i = 0; i < this.pendingDataMessages.length; ++i) {
                    this.onDataMessage_(this.pendingDataMessages[i]);
                }
                this.pendingDataMessages = [];
                this.tryCleanupConnection();
            }
            else if (cmd === CONTROL_SHUTDOWN) {
                // This was previously the 'onKill' callback passed to the lower-level connection
                // payload in this case is the reason for the shutdown. Generally a human-readable error
                this.onConnectionShutdown_(payload);
            }
            else if (cmd === CONTROL_RESET) {
                // payload in this case is the host we should contact
                this.onReset_(payload);
            }
            else if (cmd === CONTROL_ERROR) {
                error('Server Error: ' + payload);
            }
            else if (cmd === CONTROL_PONG) {
                this.log_('got pong on primary.');
                this.onPrimaryResponse_();
                this.sendPingOnPrimaryIfNecessary_();
            }
            else {
                error('Unknown control packet command: ' + cmd);
            }
        }
    }
    /**
     * @param handshake - The handshake data returned from the server
     */
    onHandshake_(handshake) {
        const timestamp = handshake.ts;
        const version = handshake.v;
        const host = handshake.h;
        this.sessionId = handshake.s;
        this.repoInfo_.host = host;
        // if we've already closed the connection, then don't bother trying to progress further
        if (this.state_ === 0 /* CONNECTING */) {
            this.conn_.start();
            this.onConnectionEstablished_(this.conn_, timestamp);
            if (PROTOCOL_VERSION !== version) {
                warn('Protocol version mismatch detected');
            }
            // TODO: do we want to upgrade? when? maybe a delay?
            this.tryStartUpgrade_();
        }
    }
    tryStartUpgrade_() {
        const conn = this.transportManager_.upgradeTransport();
        if (conn) {
            this.startUpgrade_(conn);
        }
    }
    startUpgrade_(conn) {
        this.secondaryConn_ = new conn(this.nextTransportId_(), this.repoInfo_, this.applicationId_, this.appCheckToken_, this.authToken_, this.sessionId);
        // For certain transports (WebSockets), we need to send and receive several messages back and forth before we
        // can consider the transport healthy.
        this.secondaryResponsesRequired_ =
            conn['responsesRequiredToBeHealthy'] || 0;
        const onMessage = this.connReceiver_(this.secondaryConn_);
        const onDisconnect = this.disconnReceiver_(this.secondaryConn_);
        this.secondaryConn_.open(onMessage, onDisconnect);
        // If we haven't successfully upgraded after UPGRADE_TIMEOUT, give up and kill the secondary.
        setTimeoutNonBlocking(() => {
            if (this.secondaryConn_) {
                this.log_('Timed out trying to upgrade.');
                this.secondaryConn_.close();
            }
        }, Math.floor(UPGRADE_TIMEOUT));
    }
    onReset_(host) {
        this.log_('Reset packet received.  New host: ' + host);
        this.repoInfo_.host = host;
        // TODO: if we're already "connected", we need to trigger a disconnect at the next layer up.
        // We don't currently support resets after the connection has already been established
        if (this.state_ === 1 /* CONNECTED */) {
            this.close();
        }
        else {
            // Close whatever connections we have open and start again.
            this.closeConnections_();
            this.start_();
        }
    }
    onConnectionEstablished_(conn, timestamp) {
        this.log_('Realtime connection established.');
        this.conn_ = conn;
        this.state_ = 1 /* CONNECTED */;
        if (this.onReady_) {
            this.onReady_(timestamp, this.sessionId);
            this.onReady_ = null;
        }
        // If after 5 seconds we haven't sent enough requests to the server to get the connection healthy,
        // send some pings.
        if (this.primaryResponsesRequired_ === 0) {
            this.log_('Primary connection is healthy.');
            this.isHealthy_ = true;
        }
        else {
            setTimeoutNonBlocking(() => {
                this.sendPingOnPrimaryIfNecessary_();
            }, Math.floor(DELAY_BEFORE_SENDING_EXTRA_REQUESTS));
        }
    }
    sendPingOnPrimaryIfNecessary_() {
        // If the connection isn't considered healthy yet, we'll send a noop ping packet request.
        if (!this.isHealthy_ && this.state_ === 1 /* CONNECTED */) {
            this.log_('sending ping on primary.');
            this.sendData_({ t: 'c', d: { t: PING, d: {} } });
        }
    }
    onSecondaryConnectionLost_() {
        const conn = this.secondaryConn_;
        this.secondaryConn_ = null;
        if (this.tx_ === conn || this.rx_ === conn) {
            // we are relying on this connection already in some capacity. Therefore, a failure is real
            this.close();
        }
    }
    /**
     * @param everConnected - Whether or not the connection ever reached a server. Used to determine if
     * we should flush the host cache
     */
    onConnectionLost_(everConnected) {
        this.conn_ = null;
        // NOTE: IF you're seeing a Firefox error for this line, I think it might be because it's getting
        // called on window close and RealtimeState.CONNECTING is no longer defined.  Just a guess.
        if (!everConnected && this.state_ === 0 /* CONNECTING */) {
            this.log_('Realtime connection failed.');
            // Since we failed to connect at all, clear any cached entry for this namespace in case the machine went away
            if (this.repoInfo_.isCacheableHost()) {
                PersistentStorage.remove('host:' + this.repoInfo_.host);
                // reset the internal host to what we would show the user, i.e. <ns>.firebaseio.com
                this.repoInfo_.internalHost = this.repoInfo_.host;
            }
        }
        else if (this.state_ === 1 /* CONNECTED */) {
            this.log_('Realtime connection lost.');
        }
        this.close();
    }
    onConnectionShutdown_(reason) {
        this.log_('Connection shutdown command received. Shutting down...');
        if (this.onKill_) {
            this.onKill_(reason);
            this.onKill_ = null;
        }
        // We intentionally don't want to fire onDisconnect (kill is a different case),
        // so clear the callback.
        this.onDisconnect_ = null;
        this.close();
    }
    sendData_(data) {
        if (this.state_ !== 1 /* CONNECTED */) {
            throw 'Connection is not connected';
        }
        else {
            this.tx_.send(data);
        }
    }
    /**
     * Cleans up this connection, calling the appropriate callbacks
     */
    close() {
        if (this.state_ !== 2 /* DISCONNECTED */) {
            this.log_('Closing realtime connection.');
            this.state_ = 2 /* DISCONNECTED */;
            this.closeConnections_();
            if (this.onDisconnect_) {
                this.onDisconnect_();
                this.onDisconnect_ = null;
            }
        }
    }
    closeConnections_() {
        this.log_('Shutting down all connections');
        if (this.conn_) {
            this.conn_.close();
            this.conn_ = null;
        }
        if (this.secondaryConn_) {
            this.secondaryConn_.close();
            this.secondaryConn_ = null;
        }
        if (this.healthyTimeout_) {
            clearTimeout(this.healthyTimeout_);
            this.healthyTimeout_ = null;
        }
    }
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Interface defining the set of actions that can be performed against the Firebase server
 * (basically corresponds to our wire protocol).
 *
 * @interface
 */
class ServerActions {
    put(pathString, data, onComplete, hash) { }
    merge(pathString, data, onComplete, hash) { }
    /**
     * Refreshes the auth token for the current connection.
     * @param token - The authentication token
     */
    refreshAuthToken(token) { }
    /**
     * Refreshes the app check token for the current connection.
     * @param token The app check token
     */
    refreshAppCheckToken(token) { }
    onDisconnectPut(pathString, data, onComplete) { }
    onDisconnectMerge(pathString, data, onComplete) { }
    onDisconnectCancel(pathString, onComplete) { }
    reportStats(stats) { }
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Base class to be used if you want to emit events. Call the constructor with
 * the set of allowed event names.
 */
class EventEmitter {
    constructor(allowedEvents_) {
        this.allowedEvents_ = allowedEvents_;
        this.listeners_ = {};
        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(Array.isArray(allowedEvents_) && allowedEvents_.length > 0, 'Requires a non-empty array');
    }
    /**
     * To be called by derived classes to trigger events.
     */
    trigger(eventType, ...varArgs) {
        if (Array.isArray(this.listeners_[eventType])) {
            // Clone the list, since callbacks could add/remove listeners.
            const listeners = [...this.listeners_[eventType]];
            for (let i = 0; i < listeners.length; i++) {
                listeners[i].callback.apply(listeners[i].context, varArgs);
            }
        }
    }
    on(eventType, callback, context) {
        this.validateEventType_(eventType);
        this.listeners_[eventType] = this.listeners_[eventType] || [];
        this.listeners_[eventType].push({ callback, context });
        const eventData = this.getInitialEvent(eventType);
        if (eventData) {
            callback.apply(context, eventData);
        }
    }
    off(eventType, callback, context) {
        this.validateEventType_(eventType);
        const listeners = this.listeners_[eventType] || [];
        for (let i = 0; i < listeners.length; i++) {
            if (listeners[i].callback === callback &&
                (!context || context === listeners[i].context)) {
                listeners.splice(i, 1);
                return;
            }
        }
    }
    validateEventType_(eventType) {
        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(this.allowedEvents_.find(et => {
            return et === eventType;
        }), 'Unknown event: ' + eventType);
    }
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Monitors online state (as reported by window.online/offline events).
 *
 * The expectation is that this could have many false positives (thinks we are online
 * when we're not), but no false negatives.  So we can safely use it to determine when
 * we definitely cannot reach the internet.
 */
class OnlineMonitor extends EventEmitter {
    constructor() {
        super(['online']);
        this.online_ = true;
        // We've had repeated complaints that Cordova apps can get stuck "offline", e.g.
        // https://forum.ionicframework.com/t/firebase-connection-is-lost-and-never-come-back/43810
        // It would seem that the 'online' event does not always fire consistently. So we disable it
        // for Cordova.
        if (typeof window !== 'undefined' &&
            typeof window.addEventListener !== 'undefined' &&
            !(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.isMobileCordova)()) {
            window.addEventListener('online', () => {
                if (!this.online_) {
                    this.online_ = true;
                    this.trigger('online', true);
                }
            }, false);
            window.addEventListener('offline', () => {
                if (this.online_) {
                    this.online_ = false;
                    this.trigger('online', false);
                }
            }, false);
        }
    }
    static getInstance() {
        return new OnlineMonitor();
    }
    getInitialEvent(eventType) {
        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(eventType === 'online', 'Unknown event type: ' + eventType);
        return [this.online_];
    }
    currentlyOnline() {
        return this.online_;
    }
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/** Maximum key depth. */
const MAX_PATH_DEPTH = 32;
/** Maximum number of (UTF8) bytes in a Firebase path. */
const MAX_PATH_LENGTH_BYTES = 768;
/**
 * An immutable object representing a parsed path.  It's immutable so that you
 * can pass them around to other functions without worrying about them changing
 * it.
 */
class Path {
    /**
     * @param pathOrString - Path string to parse, or another path, or the raw
     * tokens array
     */
    constructor(pathOrString, pieceNum) {
        if (pieceNum === void 0) {
            this.pieces_ = pathOrString.split('/');
            // Remove empty pieces.
            let copyTo = 0;
            for (let i = 0; i < this.pieces_.length; i++) {
                if (this.pieces_[i].length > 0) {
                    this.pieces_[copyTo] = this.pieces_[i];
                    copyTo++;
                }
            }
            this.pieces_.length = copyTo;
            this.pieceNum_ = 0;
        }
        else {
            this.pieces_ = pathOrString;
            this.pieceNum_ = pieceNum;
        }
    }
    toString() {
        let pathString = '';
        for (let i = this.pieceNum_; i < this.pieces_.length; i++) {
            if (this.pieces_[i] !== '') {
                pathString += '/' + this.pieces_[i];
            }
        }
        return pathString || '/';
    }
}
function newEmptyPath() {
    return new Path('');
}
function pathGetFront(path) {
    if (path.pieceNum_ >= path.pieces_.length) {
        return null;
    }
    return path.pieces_[path.pieceNum_];
}
/**
 * @returns The number of segments in this path
 */
function pathGetLength(path) {
    return path.pieces_.length - path.pieceNum_;
}
function pathPopFront(path) {
    let pieceNum = path.pieceNum_;
    if (pieceNum < path.pieces_.length) {
        pieceNum++;
    }
    return new Path(path.pieces_, pieceNum);
}
function pathGetBack(path) {
    if (path.pieceNum_ < path.pieces_.length) {
        return path.pieces_[path.pieces_.length - 1];
    }
    return null;
}
function pathToUrlEncodedString(path) {
    let pathString = '';
    for (let i = path.pieceNum_; i < path.pieces_.length; i++) {
        if (path.pieces_[i] !== '') {
            pathString += '/' + encodeURIComponent(String(path.pieces_[i]));
        }
    }
    return pathString || '/';
}
/**
 * Shallow copy of the parts of the path.
 *
 */
function pathSlice(path, begin = 0) {
    return path.pieces_.slice(path.pieceNum_ + begin);
}
function pathParent(path) {
    if (path.pieceNum_ >= path.pieces_.length) {
        return null;
    }
    const pieces = [];
    for (let i = path.pieceNum_; i < path.pieces_.length - 1; i++) {
        pieces.push(path.pieces_[i]);
    }
    return new Path(pieces, 0);
}
function pathChild(path, childPathObj) {
    const pieces = [];
    for (let i = path.pieceNum_; i < path.pieces_.length; i++) {
        pieces.push(path.pieces_[i]);
    }
    if (childPathObj instanceof Path) {
        for (let i = childPathObj.pieceNum_; i < childPathObj.pieces_.length; i++) {
            pieces.push(childPathObj.pieces_[i]);
        }
    }
    else {
        const childPieces = childPathObj.split('/');
        for (let i = 0; i < childPieces.length; i++) {
            if (childPieces[i].length > 0) {
                pieces.push(childPieces[i]);
            }
        }
    }
    return new Path(pieces, 0);
}
/**
 * @returns True if there are no segments in this path
 */
function pathIsEmpty(path) {
    return path.pieceNum_ >= path.pieces_.length;
}
/**
 * @returns The path from outerPath to innerPath
 */
function newRelativePath(outerPath, innerPath) {
    const outer = pathGetFront(outerPath), inner = pathGetFront(innerPath);
    if (outer === null) {
        return innerPath;
    }
    else if (outer === inner) {
        return newRelativePath(pathPopFront(outerPath), pathPopFront(innerPath));
    }
    else {
        throw new Error('INTERNAL ERROR: innerPath (' +
            innerPath +
            ') is not within ' +
            'outerPath (' +
            outerPath +
            ')');
    }
}
/**
 * @returns -1, 0, 1 if left is less, equal, or greater than the right.
 */
function pathCompare(left, right) {
    const leftKeys = pathSlice(left, 0);
    const rightKeys = pathSlice(right, 0);
    for (let i = 0; i < leftKeys.length && i < rightKeys.length; i++) {
        const cmp = nameCompare(leftKeys[i], rightKeys[i]);
        if (cmp !== 0) {
            return cmp;
        }
    }
    if (leftKeys.length === rightKeys.length) {
        return 0;
    }
    return leftKeys.length < rightKeys.length ? -1 : 1;
}
/**
 * @returns true if paths are the same.
 */
function pathEquals(path, other) {
    if (pathGetLength(path) !== pathGetLength(other)) {
        return false;
    }
    for (let i = path.pieceNum_, j = other.pieceNum_; i <= path.pieces_.length; i++, j++) {
        if (path.pieces_[i] !== other.pieces_[j]) {
            return false;
        }
    }
    return true;
}
/**
 * @returns True if this path is a parent (or the same as) other
 */
function pathContains(path, other) {
    let i = path.pieceNum_;
    let j = other.pieceNum_;
    if (pathGetLength(path) > pathGetLength(other)) {
        return false;
    }
    while (i < path.pieces_.length) {
        if (path.pieces_[i] !== other.pieces_[j]) {
            return false;
        }
        ++i;
        ++j;
    }
    return true;
}
/**
 * Dynamic (mutable) path used to count path lengths.
 *
 * This class is used to efficiently check paths for valid
 * length (in UTF8 bytes) and depth (used in path validation).
 *
 * Throws Error exception if path is ever invalid.
 *
 * The definition of a path always begins with '/'.
 */
class ValidationPath {
    /**
     * @param path - Initial Path.
     * @param errorPrefix_ - Prefix for any error messages.
     */
    constructor(path, errorPrefix_) {
        this.errorPrefix_ = errorPrefix_;
        this.parts_ = pathSlice(path, 0);
        /** Initialize to number of '/' chars needed in path. */
        this.byteLength_ = Math.max(1, this.parts_.length);
        for (let i = 0; i < this.parts_.length; i++) {
            this.byteLength_ += (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.stringLength)(this.parts_[i]);
        }
        validationPathCheckValid(this);
    }
}
function validationPathPush(validationPath, child) {
    // Count the needed '/'
    if (validationPath.parts_.length > 0) {
        validationPath.byteLength_ += 1;
    }
    validationPath.parts_.push(child);
    validationPath.byteLength_ += (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.stringLength)(child);
    validationPathCheckValid(validationPath);
}
function validationPathPop(validationPath) {
    const last = validationPath.parts_.pop();
    validationPath.byteLength_ -= (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.stringLength)(last);
    // Un-count the previous '/'
    if (validationPath.parts_.length > 0) {
        validationPath.byteLength_ -= 1;
    }
}
function validationPathCheckValid(validationPath) {
    if (validationPath.byteLength_ > MAX_PATH_LENGTH_BYTES) {
        throw new Error(validationPath.errorPrefix_ +
            'has a key path longer than ' +
            MAX_PATH_LENGTH_BYTES +
            ' bytes (' +
            validationPath.byteLength_ +
            ').');
    }
    if (validationPath.parts_.length > MAX_PATH_DEPTH) {
        throw new Error(validationPath.errorPrefix_ +
            'path specified exceeds the maximum depth that can be written (' +
            MAX_PATH_DEPTH +
            ') or object contains a cycle ' +
            validationPathToErrorString(validationPath));
    }
}
/**
 * String for use in error messages - uses '.' notation for path.
 */
function validationPathToErrorString(validationPath) {
    if (validationPath.parts_.length === 0) {
        return '';
    }
    return "in property '" + validationPath.parts_.join('.') + "'";
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class VisibilityMonitor extends EventEmitter {
    constructor() {
        super(['visible']);
        let hidden;
        let visibilityChange;
        if (typeof document !== 'undefined' &&
            typeof document.addEventListener !== 'undefined') {
            if (typeof document['hidden'] !== 'undefined') {
                // Opera 12.10 and Firefox 18 and later support
                visibilityChange = 'visibilitychange';
                hidden = 'hidden';
            }
            else if (typeof document['mozHidden'] !== 'undefined') {
                visibilityChange = 'mozvisibilitychange';
                hidden = 'mozHidden';
            }
            else if (typeof document['msHidden'] !== 'undefined') {
                visibilityChange = 'msvisibilitychange';
                hidden = 'msHidden';
            }
            else if (typeof document['webkitHidden'] !== 'undefined') {
                visibilityChange = 'webkitvisibilitychange';
                hidden = 'webkitHidden';
            }
        }
        // Initially, we always assume we are visible. This ensures that in browsers
        // without page visibility support or in cases where we are never visible
        // (e.g. chrome extension), we act as if we are visible, i.e. don't delay
        // reconnects
        this.visible_ = true;
        if (visibilityChange) {
            document.addEventListener(visibilityChange, () => {
                const visible = !document[hidden];
                if (visible !== this.visible_) {
                    this.visible_ = visible;
                    this.trigger('visible', visible);
                }
            }, false);
        }
    }
    static getInstance() {
        return new VisibilityMonitor();
    }
    getInitialEvent(eventType) {
        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(eventType === 'visible', 'Unknown event type: ' + eventType);
        return [this.visible_];
    }
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const RECONNECT_MIN_DELAY = 1000;
const RECONNECT_MAX_DELAY_DEFAULT = 60 * 5 * 1000; // 5 minutes in milliseconds (Case: 1858)
const GET_CONNECT_TIMEOUT = 3 * 1000;
const RECONNECT_MAX_DELAY_FOR_ADMINS = 30 * 1000; // 30 seconds for admin clients (likely to be a backend server)
const RECONNECT_DELAY_MULTIPLIER = 1.3;
const RECONNECT_DELAY_RESET_TIMEOUT = 30000; // Reset delay back to MIN_DELAY after being connected for 30sec.
const SERVER_KILL_INTERRUPT_REASON = 'server_kill';
// If auth fails repeatedly, we'll assume something is wrong and log a warning / back off.
const INVALID_TOKEN_THRESHOLD = 3;
/**
 * Firebase connection.  Abstracts wire protocol and handles reconnecting.
 *
 * NOTE: All JSON objects sent to the realtime connection must have property names enclosed
 * in quotes to make sure the closure compiler does not minify them.
 */
class PersistentConnection extends ServerActions {
    /**
     * @param repoInfo_ - Data about the namespace we are connecting to
     * @param applicationId_ - The Firebase App ID for this project
     * @param onDataUpdate_ - A callback for new data from the server
     */
    constructor(repoInfo_, applicationId_, onDataUpdate_, onConnectStatus_, onServerInfoUpdate_, authTokenProvider_, appCheckTokenProvider_, authOverride_) {
        super();
        this.repoInfo_ = repoInfo_;
        this.applicationId_ = applicationId_;
        this.onDataUpdate_ = onDataUpdate_;
        this.onConnectStatus_ = onConnectStatus_;
        this.onServerInfoUpdate_ = onServerInfoUpdate_;
        this.authTokenProvider_ = authTokenProvider_;
        this.appCheckTokenProvider_ = appCheckTokenProvider_;
        this.authOverride_ = authOverride_;
        // Used for diagnostic logging.
        this.id = PersistentConnection.nextPersistentConnectionId_++;
        this.log_ = logWrapper('p:' + this.id + ':');
        this.interruptReasons_ = {};
        this.listens = new Map();
        this.outstandingPuts_ = [];
        this.outstandingGets_ = [];
        this.outstandingPutCount_ = 0;
        this.outstandingGetCount_ = 0;
        this.onDisconnectRequestQueue_ = [];
        this.connected_ = false;
        this.reconnectDelay_ = RECONNECT_MIN_DELAY;
        this.maxReconnectDelay_ = RECONNECT_MAX_DELAY_DEFAULT;
        this.securityDebugCallback_ = null;
        this.lastSessionId = null;
        this.establishConnectionTimer_ = null;
        this.visible_ = false;
        // Before we get connected, we keep a queue of pending messages to send.
        this.requestCBHash_ = {};
        this.requestNumber_ = 0;
        this.realtime_ = null;
        this.authToken_ = null;
        this.appCheckToken_ = null;
        this.forceTokenRefresh_ = false;
        this.invalidAuthTokenCount_ = 0;
        this.invalidAppCheckTokenCount_ = 0;
        this.firstConnection_ = true;
        this.lastConnectionAttemptTime_ = null;
        this.lastConnectionEstablishedTime_ = null;
        if (authOverride_ && !(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.isNodeSdk)()) {
            throw new Error('Auth override specified in options, but not supported on non Node.js platforms');
        }
        VisibilityMonitor.getInstance().on('visible', this.onVisible_, this);
        if (repoInfo_.host.indexOf('fblocal') === -1) {
            OnlineMonitor.getInstance().on('online', this.onOnline_, this);
        }
    }
    sendRequest(action, body, onResponse) {
        const curReqNum = ++this.requestNumber_;
        const msg = { r: curReqNum, a: action, b: body };
        this.log_((0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.stringify)(msg));
        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(this.connected_, "sendRequest call when we're not connected not allowed.");
        this.realtime_.sendRequest(msg);
        if (onResponse) {
            this.requestCBHash_[curReqNum] = onResponse;
        }
    }
    get(query) {
        this.initConnection_();
        const deferred = new _firebase_util__WEBPACK_IMPORTED_MODULE_2__.Deferred();
        const request = {
            p: query._path.toString(),
            q: query._queryObject
        };
        const outstandingGet = {
            action: 'g',
            request,
            onComplete: (message) => {
                const payload = message['d'];
                if (message['s'] === 'ok') {
                    this.onDataUpdate_(request['p'], payload, 
                    /*isMerge*/ false, 
                    /*tag*/ null);
                    deferred.resolve(payload);
                }
                else {
                    deferred.reject(payload);
                }
            }
        };
        this.outstandingGets_.push(outstandingGet);
        this.outstandingGetCount_++;
        const index = this.outstandingGets_.length - 1;
        if (!this.connected_) {
            setTimeout(() => {
                const get = this.outstandingGets_[index];
                if (get === undefined || outstandingGet !== get) {
                    return;
                }
                delete this.outstandingGets_[index];
                this.outstandingGetCount_--;
                if (this.outstandingGetCount_ === 0) {
                    this.outstandingGets_ = [];
                }
                this.log_('get ' + index + ' timed out on connection');
                deferred.reject(new Error('Client is offline.'));
            }, GET_CONNECT_TIMEOUT);
        }
        if (this.connected_) {
            this.sendGet_(index);
        }
        return deferred.promise;
    }
    listen(query, currentHashFn, tag, onComplete) {
        this.initConnection_();
        const queryId = query._queryIdentifier;
        const pathString = query._path.toString();
        this.log_('Listen called for ' + pathString + ' ' + queryId);
        if (!this.listens.has(pathString)) {
            this.listens.set(pathString, new Map());
        }
        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(query._queryParams.isDefault() || !query._queryParams.loadsAllData(), 'listen() called for non-default but complete query');
        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(!this.listens.get(pathString).has(queryId), 'listen() called twice for same path/queryId.');
        const listenSpec = {
            onComplete,
            hashFn: currentHashFn,
            query,
            tag
        };
        this.listens.get(pathString).set(queryId, listenSpec);
        if (this.connected_) {
            this.sendListen_(listenSpec);
        }
    }
    sendGet_(index) {
        const get = this.outstandingGets_[index];
        this.sendRequest('g', get.request, (message) => {
            delete this.outstandingGets_[index];
            this.outstandingGetCount_--;
            if (this.outstandingGetCount_ === 0) {
                this.outstandingGets_ = [];
            }
            if (get.onComplete) {
                get.onComplete(message);
            }
        });
    }
    sendListen_(listenSpec) {
        const query = listenSpec.query;
        const pathString = query._path.toString();
        const queryId = query._queryIdentifier;
        this.log_('Listen on ' + pathString + ' for ' + queryId);
        const req = { /*path*/ p: pathString };
        const action = 'q';
        // Only bother to send query if it's non-default.
        if (listenSpec.tag) {
            req['q'] = query._queryObject;
            req['t'] = listenSpec.tag;
        }
        req[ /*hash*/'h'] = listenSpec.hashFn();
        this.sendRequest(action, req, (message) => {
            const payload = message[ /*data*/'d'];
            const status = message[ /*status*/'s'];
            // print warnings in any case...
            PersistentConnection.warnOnListenWarnings_(payload, query);
            const currentListenSpec = this.listens.get(pathString) &&
                this.listens.get(pathString).get(queryId);
            // only trigger actions if the listen hasn't been removed and readded
            if (currentListenSpec === listenSpec) {
                this.log_('listen response', message);
                if (status !== 'ok') {
                    this.removeListen_(pathString, queryId);
                }
                if (listenSpec.onComplete) {
                    listenSpec.onComplete(status, payload);
                }
            }
        });
    }
    static warnOnListenWarnings_(payload, query) {
        if (payload && typeof payload === 'object' && (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.contains)(payload, 'w')) {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            const warnings = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.safeGet)(payload, 'w');
            if (Array.isArray(warnings) && ~warnings.indexOf('no_index')) {
                const indexSpec = '".indexOn": "' + query._queryParams.getIndex().toString() + '"';
                const indexPath = query._path.toString();
                warn(`Using an unspecified index. Your data will be downloaded and ` +
                    `filtered on the client. Consider adding ${indexSpec} at ` +
                    `${indexPath} to your security rules for better performance.`);
            }
        }
    }
    refreshAuthToken(token) {
        this.authToken_ = token;
        this.log_('Auth token refreshed');
        if (this.authToken_) {
            this.tryAuth();
        }
        else {
            //If we're connected we want to let the server know to unauthenticate us. If we're not connected, simply delete
            //the credential so we dont become authenticated next time we connect.
            if (this.connected_) {
                this.sendRequest('unauth', {}, () => { });
            }
        }
        this.reduceReconnectDelayIfAdminCredential_(token);
    }
    reduceReconnectDelayIfAdminCredential_(credential) {
        // NOTE: This isn't intended to be bulletproof (a malicious developer can always just modify the client).
        // Additionally, we don't bother resetting the max delay back to the default if auth fails / expires.
        const isFirebaseSecret = credential && credential.length === 40;
        if (isFirebaseSecret || (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.isAdmin)(credential)) {
            this.log_('Admin auth credential detected.  Reducing max reconnect time.');
            this.maxReconnectDelay_ = RECONNECT_MAX_DELAY_FOR_ADMINS;
        }
    }
    refreshAppCheckToken(token) {
        this.appCheckToken_ = token;
        this.log_('App check token refreshed');
        if (this.appCheckToken_) {
            this.tryAppCheck();
        }
        else {
            //If we're connected we want to let the server know to unauthenticate us.
            //If we're not connected, simply delete the credential so we dont become
            // authenticated next time we connect.
            if (this.connected_) {
                this.sendRequest('unappeck', {}, () => { });
            }
        }
    }
    /**
     * Attempts to authenticate with the given credentials. If the authentication attempt fails, it's triggered like
     * a auth revoked (the connection is closed).
     */
    tryAuth() {
        if (this.connected_ && this.authToken_) {
            const token = this.authToken_;
            const authMethod = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.isValidFormat)(token) ? 'auth' : 'gauth';
            const requestData = { cred: token };
            if (this.authOverride_ === null) {
                requestData['noauth'] = true;
            }
            else if (typeof this.authOverride_ === 'object') {
                requestData['authvar'] = this.authOverride_;
            }
            this.sendRequest(authMethod, requestData, (res) => {
                const status = res[ /*status*/'s'];
                const data = res[ /*data*/'d'] || 'error';
                if (this.authToken_ === token) {
                    if (status === 'ok') {
                        this.invalidAuthTokenCount_ = 0;
                    }
                    else {
                        // Triggers reconnect and force refresh for auth token
                        this.onAuthRevoked_(status, data);
                    }
                }
            });
        }
    }
    /**
     * Attempts to authenticate with the given token. If the authentication
     * attempt fails, it's triggered like the token was revoked (the connection is
     * closed).
     */
    tryAppCheck() {
        if (this.connected_ && this.appCheckToken_) {
            this.sendRequest('appcheck', { 'token': this.appCheckToken_ }, (res) => {
                const status = res[ /*status*/'s'];
                const data = res[ /*data*/'d'] || 'error';
                if (status === 'ok') {
                    this.invalidAppCheckTokenCount_ = 0;
                }
                else {
                    this.onAppCheckRevoked_(status, data);
                }
            });
        }
    }
    /**
     * @inheritDoc
     */
    unlisten(query, tag) {
        const pathString = query._path.toString();
        const queryId = query._queryIdentifier;
        this.log_('Unlisten called for ' + pathString + ' ' + queryId);
        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(query._queryParams.isDefault() || !query._queryParams.loadsAllData(), 'unlisten() called for non-default but complete query');
        const listen = this.removeListen_(pathString, queryId);
        if (listen && this.connected_) {
            this.sendUnlisten_(pathString, queryId, query._queryObject, tag);
        }
    }
    sendUnlisten_(pathString, queryId, queryObj, tag) {
        this.log_('Unlisten on ' + pathString + ' for ' + queryId);
        const req = { /*path*/ p: pathString };
        const action = 'n';
        // Only bother sending queryId if it's non-default.
        if (tag) {
            req['q'] = queryObj;
            req['t'] = tag;
        }
        this.sendRequest(action, req);
    }
    onDisconnectPut(pathString, data, onComplete) {
        this.initConnection_();
        if (this.connected_) {
            this.sendOnDisconnect_('o', pathString, data, onComplete);
        }
        else {
            this.onDisconnectRequestQueue_.push({
                pathString,
                action: 'o',
                data,
                onComplete
            });
        }
    }
    onDisconnectMerge(pathString, data, onComplete) {
        this.initConnection_();
        if (this.connected_) {
            this.sendOnDisconnect_('om', pathString, data, onComplete);
        }
        else {
            this.onDisconnectRequestQueue_.push({
                pathString,
                action: 'om',
                data,
                onComplete
            });
        }
    }
    onDisconnectCancel(pathString, onComplete) {
        this.initConnection_();
        if (this.connected_) {
            this.sendOnDisconnect_('oc', pathString, null, onComplete);
        }
        else {
            this.onDisconnectRequestQueue_.push({
                pathString,
                action: 'oc',
                data: null,
                onComplete
            });
        }
    }
    sendOnDisconnect_(action, pathString, data, onComplete) {
        const request = { /*path*/ p: pathString, /*data*/ d: data };
        this.log_('onDisconnect ' + action, request);
        this.sendRequest(action, request, (response) => {
            if (onComplete) {
                setTimeout(() => {
                    onComplete(response[ /*status*/'s'], response[ /* data */'d']);
                }, Math.floor(0));
            }
        });
    }
    put(pathString, data, onComplete, hash) {
        this.putInternal('p', pathString, data, onComplete, hash);
    }
    merge(pathString, data, onComplete, hash) {
        this.putInternal('m', pathString, data, onComplete, hash);
    }
    putInternal(action, pathString, data, onComplete, hash) {
        this.initConnection_();
        const request = {
            /*path*/ p: pathString,
            /*data*/ d: data
        };
        if (hash !== undefined) {
            request[ /*hash*/'h'] = hash;
        }
        // TODO: Only keep track of the most recent put for a given path?
        this.outstandingPuts_.push({
            action,
            request,
            onComplete
        });
        this.outstandingPutCount_++;
        const index = this.outstandingPuts_.length - 1;
        if (this.connected_) {
            this.sendPut_(index);
        }
        else {
            this.log_('Buffering put: ' + pathString);
        }
    }
    sendPut_(index) {
        const action = this.outstandingPuts_[index].action;
        const request = this.outstandingPuts_[index].request;
        const onComplete = this.outstandingPuts_[index].onComplete;
        this.outstandingPuts_[index].queued = this.connected_;
        this.sendRequest(action, request, (message) => {
            this.log_(action + ' response', message);
            delete this.outstandingPuts_[index];
            this.outstandingPutCount_--;
            // Clean up array occasionally.
            if (this.outstandingPutCount_ === 0) {
                this.outstandingPuts_ = [];
            }
            if (onComplete) {
                onComplete(message[ /*status*/'s'], message[ /* data */'d']);
            }
        });
    }
    reportStats(stats) {
        // If we're not connected, we just drop the stats.
        if (this.connected_) {
            const request = { /*counters*/ c: stats };
            this.log_('reportStats', request);
            this.sendRequest(/*stats*/ 's', request, result => {
                const status = result[ /*status*/'s'];
                if (status !== 'ok') {
                    const errorReason = result[ /* data */'d'];
                    this.log_('reportStats', 'Error sending stats: ' + errorReason);
                }
            });
        }
    }
    onDataMessage_(message) {
        if ('r' in message) {
            // this is a response
            this.log_('from server: ' + (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.stringify)(message));
            const reqNum = message['r'];
            const onResponse = this.requestCBHash_[reqNum];
            if (onResponse) {
                delete this.requestCBHash_[reqNum];
                onResponse(message[ /*body*/'b']);
            }
        }
        else if ('error' in message) {
            throw 'A server-side error has occurred: ' + message['error'];
        }
        else if ('a' in message) {
            // a and b are action and body, respectively
            this.onDataPush_(message['a'], message['b']);
        }
    }
    onDataPush_(action, body) {
        this.log_('handleServerMessage', action, body);
        if (action === 'd') {
            this.onDataUpdate_(body[ /*path*/'p'], body[ /*data*/'d'], 
            /*isMerge*/ false, body['t']);
        }
        else if (action === 'm') {
            this.onDataUpdate_(body[ /*path*/'p'], body[ /*data*/'d'], 
            /*isMerge=*/ true, body['t']);
        }
        else if (action === 'c') {
            this.onListenRevoked_(body[ /*path*/'p'], body[ /*query*/'q']);
        }
        else if (action === 'ac') {
            this.onAuthRevoked_(body[ /*status code*/'s'], body[ /* explanation */'d']);
        }
        else if (action === 'apc') {
            this.onAppCheckRevoked_(body[ /*status code*/'s'], body[ /* explanation */'d']);
        }
        else if (action === 'sd') {
            this.onSecurityDebugPacket_(body);
        }
        else {
            error('Unrecognized action received from server: ' +
                (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.stringify)(action) +
                '\nAre you using the latest client?');
        }
    }
    onReady_(timestamp, sessionId) {
        this.log_('connection ready');
        this.connected_ = true;
        this.lastConnectionEstablishedTime_ = new Date().getTime();
        this.handleTimestamp_(timestamp);
        this.lastSessionId = sessionId;
        if (this.firstConnection_) {
            this.sendConnectStats_();
        }
        this.restoreState_();
        this.firstConnection_ = false;
        this.onConnectStatus_(true);
    }
    scheduleConnect_(timeout) {
        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(!this.realtime_, "Scheduling a connect when we're already connected/ing?");
        if (this.establishConnectionTimer_) {
            clearTimeout(this.establishConnectionTimer_);
        }
        // NOTE: Even when timeout is 0, it's important to do a setTimeout to work around an infuriating "Security Error" in
        // Firefox when trying to write to our long-polling iframe in some scenarios (e.g. Forge or our unit tests).
        this.establishConnectionTimer_ = setTimeout(() => {
            this.establishConnectionTimer_ = null;
            this.establishConnection_();
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
        }, Math.floor(timeout));
    }
    initConnection_() {
        if (!this.realtime_ && this.firstConnection_) {
            this.scheduleConnect_(0);
        }
    }
    onVisible_(visible) {
        // NOTE: Tabbing away and back to a window will defeat our reconnect backoff, but I think that's fine.
        if (visible &&
            !this.visible_ &&
            this.reconnectDelay_ === this.maxReconnectDelay_) {
            this.log_('Window became visible.  Reducing delay.');
            this.reconnectDelay_ = RECONNECT_MIN_DELAY;
            if (!this.realtime_) {
                this.scheduleConnect_(0);
            }
        }
        this.visible_ = visible;
    }
    onOnline_(online) {
        if (online) {
            this.log_('Browser went online.');
            this.reconnectDelay_ = RECONNECT_MIN_DELAY;
            if (!this.realtime_) {
                this.scheduleConnect_(0);
            }
        }
        else {
            this.log_('Browser went offline.  Killing connection.');
            if (this.realtime_) {
                this.realtime_.close();
            }
        }
    }
    onRealtimeDisconnect_() {
        this.log_('data client disconnected');
        this.connected_ = false;
        this.realtime_ = null;
        // Since we don't know if our sent transactions succeeded or not, we need to cancel them.
        this.cancelSentTransactions_();
        // Clear out the pending requests.
        this.requestCBHash_ = {};
        if (this.shouldReconnect_()) {
            if (!this.visible_) {
                this.log_("Window isn't visible.  Delaying reconnect.");
                this.reconnectDelay_ = this.maxReconnectDelay_;
                this.lastConnectionAttemptTime_ = new Date().getTime();
            }
            else if (this.lastConnectionEstablishedTime_) {
                // If we've been connected long enough, reset reconnect delay to minimum.
                const timeSinceLastConnectSucceeded = new Date().getTime() - this.lastConnectionEstablishedTime_;
                if (timeSinceLastConnectSucceeded > RECONNECT_DELAY_RESET_TIMEOUT) {
                    this.reconnectDelay_ = RECONNECT_MIN_DELAY;
                }
                this.lastConnectionEstablishedTime_ = null;
            }
            const timeSinceLastConnectAttempt = new Date().getTime() - this.lastConnectionAttemptTime_;
            let reconnectDelay = Math.max(0, this.reconnectDelay_ - timeSinceLastConnectAttempt);
            reconnectDelay = Math.random() * reconnectDelay;
            this.log_('Trying to reconnect in ' + reconnectDelay + 'ms');
            this.scheduleConnect_(reconnectDelay);
            // Adjust reconnect delay for next time.
            this.reconnectDelay_ = Math.min(this.maxReconnectDelay_, this.reconnectDelay_ * RECONNECT_DELAY_MULTIPLIER);
        }
        this.onConnectStatus_(false);
    }
    async establishConnection_() {
        if (this.shouldReconnect_()) {
            this.log_('Making a connection attempt');
            this.lastConnectionAttemptTime_ = new Date().getTime();
            this.lastConnectionEstablishedTime_ = null;
            const onDataMessage = this.onDataMessage_.bind(this);
            const onReady = this.onReady_.bind(this);
            const onDisconnect = this.onRealtimeDisconnect_.bind(this);
            const connId = this.id + ':' + PersistentConnection.nextConnectionId_++;
            const lastSessionId = this.lastSessionId;
            let canceled = false;
            let connection = null;
            const closeFn = function () {
                if (connection) {
                    connection.close();
                }
                else {
                    canceled = true;
                    onDisconnect();
                }
            };
            const sendRequestFn = function (msg) {
                (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(connection, "sendRequest call when we're not connected not allowed.");
                connection.sendRequest(msg);
            };
            this.realtime_ = {
                close: closeFn,
                sendRequest: sendRequestFn
            };
            const forceRefresh = this.forceTokenRefresh_;
            this.forceTokenRefresh_ = false;
            try {
                // First fetch auth and app check token, and establish connection after
                // fetching the token was successful
                const [authToken, appCheckToken] = await Promise.all([
                    this.authTokenProvider_.getToken(forceRefresh),
                    this.appCheckTokenProvider_.getToken(forceRefresh)
                ]);
                if (!canceled) {
                    log('getToken() completed. Creating connection.');
                    this.authToken_ = authToken && authToken.accessToken;
                    this.appCheckToken_ = appCheckToken && appCheckToken.token;
                    connection = new Connection(connId, this.repoInfo_, this.applicationId_, this.appCheckToken_, this.authToken_, onDataMessage, onReady, onDisconnect, 
                    /* onKill= */ reason => {
                        warn(reason + ' (' + this.repoInfo_.toString() + ')');
                        this.interrupt(SERVER_KILL_INTERRUPT_REASON);
                    }, lastSessionId);
                }
                else {
                    log('getToken() completed but was canceled');
                }
            }
            catch (error) {
                this.log_('Failed to get token: ' + error);
                if (!canceled) {
                    if (this.repoInfo_.nodeAdmin) {
                        // This may be a critical error for the Admin Node.js SDK, so log a warning.
                        // But getToken() may also just have temporarily failed, so we still want to
                        // continue retrying.
                        warn(error);
                    }
                    closeFn();
                }
            }
        }
    }
    interrupt(reason) {
        log('Interrupting connection for reason: ' + reason);
        this.interruptReasons_[reason] = true;
        if (this.realtime_) {
            this.realtime_.close();
        }
        else {
            if (this.establishConnectionTimer_) {
                clearTimeout(this.establishConnectionTimer_);
                this.establishConnectionTimer_ = null;
            }
            if (this.connected_) {
                this.onRealtimeDisconnect_();
            }
        }
    }
    resume(reason) {
        log('Resuming connection for reason: ' + reason);
        delete this.interruptReasons_[reason];
        if ((0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.isEmpty)(this.interruptReasons_)) {
            this.reconnectDelay_ = RECONNECT_MIN_DELAY;
            if (!this.realtime_) {
                this.scheduleConnect_(0);
            }
        }
    }
    handleTimestamp_(timestamp) {
        const delta = timestamp - new Date().getTime();
        this.onServerInfoUpdate_({ serverTimeOffset: delta });
    }
    cancelSentTransactions_() {
        for (let i = 0; i < this.outstandingPuts_.length; i++) {
            const put = this.outstandingPuts_[i];
            if (put && /*hash*/ 'h' in put.request && put.queued) {
                if (put.onComplete) {
                    put.onComplete('disconnect');
                }
                delete this.outstandingPuts_[i];
                this.outstandingPutCount_--;
            }
        }
        // Clean up array occasionally.
        if (this.outstandingPutCount_ === 0) {
            this.outstandingPuts_ = [];
        }
    }
    onListenRevoked_(pathString, query) {
        // Remove the listen and manufacture a "permission_denied" error for the failed listen.
        let queryId;
        if (!query) {
            queryId = 'default';
        }
        else {
            queryId = query.map(q => ObjectToUniqueKey(q)).join('$');
        }
        const listen = this.removeListen_(pathString, queryId);
        if (listen && listen.onComplete) {
            listen.onComplete('permission_denied');
        }
    }
    removeListen_(pathString, queryId) {
        const normalizedPathString = new Path(pathString).toString(); // normalize path.
        let listen;
        if (this.listens.has(normalizedPathString)) {
            const map = this.listens.get(normalizedPathString);
            listen = map.get(queryId);
            map.delete(queryId);
            if (map.size === 0) {
                this.listens.delete(normalizedPathString);
            }
        }
        else {
            // all listens for this path has already been removed
            listen = undefined;
        }
        return listen;
    }
    onAuthRevoked_(statusCode, explanation) {
        log('Auth token revoked: ' + statusCode + '/' + explanation);
        this.authToken_ = null;
        this.forceTokenRefresh_ = true;
        this.realtime_.close();
        if (statusCode === 'invalid_token' || statusCode === 'permission_denied') {
            // We'll wait a couple times before logging the warning / increasing the
            // retry period since oauth tokens will report as "invalid" if they're
            // just expired. Plus there may be transient issues that resolve themselves.
            this.invalidAuthTokenCount_++;
            if (this.invalidAuthTokenCount_ >= INVALID_TOKEN_THRESHOLD) {
                // Set a long reconnect delay because recovery is unlikely
                this.reconnectDelay_ = RECONNECT_MAX_DELAY_FOR_ADMINS;
                // Notify the auth token provider that the token is invalid, which will log
                // a warning
                this.authTokenProvider_.notifyForInvalidToken();
            }
        }
    }
    onAppCheckRevoked_(statusCode, explanation) {
        log('App check token revoked: ' + statusCode + '/' + explanation);
        this.appCheckToken_ = null;
        this.forceTokenRefresh_ = true;
        // Note: We don't close the connection as the developer may not have
        // enforcement enabled. The backend closes connections with enforcements.
        if (statusCode === 'invalid_token' || statusCode === 'permission_denied') {
            // We'll wait a couple times before logging the warning / increasing the
            // retry period since oauth tokens will report as "invalid" if they're
            // just expired. Plus there may be transient issues that resolve themselves.
            this.invalidAppCheckTokenCount_++;
            if (this.invalidAppCheckTokenCount_ >= INVALID_TOKEN_THRESHOLD) {
                this.appCheckTokenProvider_.notifyForInvalidToken();
            }
        }
    }
    onSecurityDebugPacket_(body) {
        if (this.securityDebugCallback_) {
            this.securityDebugCallback_(body);
        }
        else {
            if ('msg' in body) {
                console.log('FIREBASE: ' + body['msg'].replace('\n', '\nFIREBASE: '));
            }
        }
    }
    restoreState_() {
        //Re-authenticate ourselves if we have a credential stored.
        this.tryAuth();
        this.tryAppCheck();
        // Puts depend on having received the corresponding data update from the server before they complete, so we must
        // make sure to send listens before puts.
        for (const queries of this.listens.values()) {
            for (const listenSpec of queries.values()) {
                this.sendListen_(listenSpec);
            }
        }
        for (let i = 0; i < this.outstandingPuts_.length; i++) {
            if (this.outstandingPuts_[i]) {
                this.sendPut_(i);
            }
        }
        while (this.onDisconnectRequestQueue_.length) {
            const request = this.onDisconnectRequestQueue_.shift();
            this.sendOnDisconnect_(request.action, request.pathString, request.data, request.onComplete);
        }
        for (let i = 0; i < this.outstandingGets_.length; i++) {
            if (this.outstandingGets_[i]) {
                this.sendGet_(i);
            }
        }
    }
    /**
     * Sends client stats for first connection
     */
    sendConnectStats_() {
        const stats = {};
        let clientName = 'js';
        if ((0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.isNodeSdk)()) {
            if (this.repoInfo_.nodeAdmin) {
                clientName = 'admin_node';
            }
            else {
                clientName = 'node';
            }
        }
        stats['sdk.' + clientName + '.' + SDK_VERSION.replace(/\./g, '-')] = 1;
        if ((0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.isMobileCordova)()) {
            stats['framework.cordova'] = 1;
        }
        else if ((0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.isReactNative)()) {
            stats['framework.reactnative'] = 1;
        }
        this.reportStats(stats);
    }
    shouldReconnect_() {
        const online = OnlineMonitor.getInstance().currentlyOnline();
        return (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.isEmpty)(this.interruptReasons_) && online;
    }
}
PersistentConnection.nextPersistentConnectionId_ = 0;
/**
 * Counter for number of connections created. Mainly used for tagging in the logs
 */
PersistentConnection.nextConnectionId_ = 0;

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class NamedNode {
    constructor(name, node) {
        this.name = name;
        this.node = node;
    }
    static Wrap(name, node) {
        return new NamedNode(name, node);
    }
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Index {
    /**
     * @returns A standalone comparison function for
     * this index
     */
    getCompare() {
        return this.compare.bind(this);
    }
    /**
     * Given a before and after value for a node, determine if the indexed value has changed. Even if they are different,
     * it's possible that the changes are isolated to parts of the snapshot that are not indexed.
     *
     *
     * @returns True if the portion of the snapshot being indexed changed between oldNode and newNode
     */
    indexedValueChanged(oldNode, newNode) {
        const oldWrapped = new NamedNode(MIN_NAME, oldNode);
        const newWrapped = new NamedNode(MIN_NAME, newNode);
        return this.compare(oldWrapped, newWrapped) !== 0;
    }
    /**
     * @returns a node wrapper that will sort equal to or less than
     * any other node wrapper, using this index
     */
    minPost() {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        return NamedNode.MIN;
    }
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
let __EMPTY_NODE;
class KeyIndex extends Index {
    static get __EMPTY_NODE() {
        return __EMPTY_NODE;
    }
    static set __EMPTY_NODE(val) {
        __EMPTY_NODE = val;
    }
    compare(a, b) {
        return nameCompare(a.name, b.name);
    }
    isDefinedOn(node) {
        // We could probably return true here (since every node has a key), but it's never called
        // so just leaving unimplemented for now.
        throw (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assertionError)('KeyIndex.isDefinedOn not expected to be called.');
    }
    indexedValueChanged(oldNode, newNode) {
        return false; // The key for a node never changes.
    }
    minPost() {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        return NamedNode.MIN;
    }
    maxPost() {
        // TODO: This should really be created once and cached in a static property, but
        // NamedNode isn't defined yet, so I can't use it in a static.  Bleh.
        return new NamedNode(MAX_NAME, __EMPTY_NODE);
    }
    makePost(indexValue, name) {
        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(typeof indexValue === 'string', 'KeyIndex indexValue must always be a string.');
        // We just use empty node, but it'll never be compared, since our comparator only looks at name.
        return new NamedNode(indexValue, __EMPTY_NODE);
    }
    /**
     * @returns String representation for inclusion in a query spec
     */
    toString() {
        return '.key';
    }
}
const KEY_INDEX = new KeyIndex();

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * An iterator over an LLRBNode.
 */
class SortedMapIterator {
    /**
     * @param node - Node to iterate.
     * @param isReverse_ - Whether or not to iterate in reverse
     */
    constructor(node, startKey, comparator, isReverse_, resultGenerator_ = null) {
        this.isReverse_ = isReverse_;
        this.resultGenerator_ = resultGenerator_;
        this.nodeStack_ = [];
        let cmp = 1;
        while (!node.isEmpty()) {
            node = node;
            cmp = startKey ? comparator(node.key, startKey) : 1;
            // flip the comparison if we're going in reverse
            if (isReverse_) {
                cmp *= -1;
            }
            if (cmp < 0) {
                // This node is less than our start key. ignore it
                if (this.isReverse_) {
                    node = node.left;
                }
                else {
                    node = node.right;
                }
            }
            else if (cmp === 0) {
                // This node is exactly equal to our start key. Push it on the stack, but stop iterating;
                this.nodeStack_.push(node);
                break;
            }
            else {
                // This node is greater than our start key, add it to the stack and move to the next one
                this.nodeStack_.push(node);
                if (this.isReverse_) {
                    node = node.right;
                }
                else {
                    node = node.left;
                }
            }
        }
    }
    getNext() {
        if (this.nodeStack_.length === 0) {
            return null;
        }
        let node = this.nodeStack_.pop();
        let result;
        if (this.resultGenerator_) {
            result = this.resultGenerator_(node.key, node.value);
        }
        else {
            result = { key: node.key, value: node.value };
        }
        if (this.isReverse_) {
            node = node.left;
            while (!node.isEmpty()) {
                this.nodeStack_.push(node);
                node = node.right;
            }
        }
        else {
            node = node.right;
            while (!node.isEmpty()) {
                this.nodeStack_.push(node);
                node = node.left;
            }
        }
        return result;
    }
    hasNext() {
        return this.nodeStack_.length > 0;
    }
    peek() {
        if (this.nodeStack_.length === 0) {
            return null;
        }
        const node = this.nodeStack_[this.nodeStack_.length - 1];
        if (this.resultGenerator_) {
            return this.resultGenerator_(node.key, node.value);
        }
        else {
            return { key: node.key, value: node.value };
        }
    }
}
/**
 * Represents a node in a Left-leaning Red-Black tree.
 */
class LLRBNode {
    /**
     * @param key - Key associated with this node.
     * @param value - Value associated with this node.
     * @param color - Whether this node is red.
     * @param left - Left child.
     * @param right - Right child.
     */
    constructor(key, value, color, left, right) {
        this.key = key;
        this.value = value;
        this.color = color != null ? color : LLRBNode.RED;
        this.left =
            left != null ? left : SortedMap.EMPTY_NODE;
        this.right =
            right != null ? right : SortedMap.EMPTY_NODE;
    }
    /**
     * Returns a copy of the current node, optionally replacing pieces of it.
     *
     * @param key - New key for the node, or null.
     * @param value - New value for the node, or null.
     * @param color - New color for the node, or null.
     * @param left - New left child for the node, or null.
     * @param right - New right child for the node, or null.
     * @returns The node copy.
     */
    copy(key, value, color, left, right) {
        return new LLRBNode(key != null ? key : this.key, value != null ? value : this.value, color != null ? color : this.color, left != null ? left : this.left, right != null ? right : this.right);
    }
    /**
     * @returns The total number of nodes in the tree.
     */
    count() {
        return this.left.count() + 1 + this.right.count();
    }
    /**
     * @returns True if the tree is empty.
     */
    isEmpty() {
        return false;
    }
    /**
     * Traverses the tree in key order and calls the specified action function
     * for each node.
     *
     * @param action - Callback function to be called for each
     *   node.  If it returns true, traversal is aborted.
     * @returns The first truthy value returned by action, or the last falsey
     *   value returned by action
     */
    inorderTraversal(action) {
        return (this.left.inorderTraversal(action) ||
            !!action(this.key, this.value) ||
            this.right.inorderTraversal(action));
    }
    /**
     * Traverses the tree in reverse key order and calls the specified action function
     * for each node.
     *
     * @param action - Callback function to be called for each
     * node.  If it returns true, traversal is aborted.
     * @returns True if traversal was aborted.
     */
    reverseTraversal(action) {
        return (this.right.reverseTraversal(action) ||
            action(this.key, this.value) ||
            this.left.reverseTraversal(action));
    }
    /**
     * @returns The minimum node in the tree.
     */
    min_() {
        if (this.left.isEmpty()) {
            return this;
        }
        else {
            return this.left.min_();
        }
    }
    /**
     * @returns The maximum key in the tree.
     */
    minKey() {
        return this.min_().key;
    }
    /**
     * @returns The maximum key in the tree.
     */
    maxKey() {
        if (this.right.isEmpty()) {
            return this.key;
        }
        else {
            return this.right.maxKey();
        }
    }
    /**
     * @param key - Key to insert.
     * @param value - Value to insert.
     * @param comparator - Comparator.
     * @returns New tree, with the key/value added.
     */
    insert(key, value, comparator) {
        let n = this;
        const cmp = comparator(key, n.key);
        if (cmp < 0) {
            n = n.copy(null, null, null, n.left.insert(key, value, comparator), null);
        }
        else if (cmp === 0) {
            n = n.copy(null, value, null, null, null);
        }
        else {
            n = n.copy(null, null, null, null, n.right.insert(key, value, comparator));
        }
        return n.fixUp_();
    }
    /**
     * @returns New tree, with the minimum key removed.
     */
    removeMin_() {
        if (this.left.isEmpty()) {
            return SortedMap.EMPTY_NODE;
        }
        let n = this;
        if (!n.left.isRed_() && !n.left.left.isRed_()) {
            n = n.moveRedLeft_();
        }
        n = n.copy(null, null, null, n.left.removeMin_(), null);
        return n.fixUp_();
    }
    /**
     * @param key - The key of the item to remove.
     * @param comparator - Comparator.
     * @returns New tree, with the specified item removed.
     */
    remove(key, comparator) {
        let n, smallest;
        n = this;
        if (comparator(key, n.key) < 0) {
            if (!n.left.isEmpty() && !n.left.isRed_() && !n.left.left.isRed_()) {
                n = n.moveRedLeft_();
            }
            n = n.copy(null, null, null, n.left.remove(key, comparator), null);
        }
        else {
            if (n.left.isRed_()) {
                n = n.rotateRight_();
            }
            if (!n.right.isEmpty() && !n.right.isRed_() && !n.right.left.isRed_()) {
                n = n.moveRedRight_();
            }
            if (comparator(key, n.key) === 0) {
                if (n.right.isEmpty()) {
                    return SortedMap.EMPTY_NODE;
                }
                else {
                    smallest = n.right.min_();
                    n = n.copy(smallest.key, smallest.value, null, null, n.right.removeMin_());
                }
            }
            n = n.copy(null, null, null, null, n.right.remove(key, comparator));
        }
        return n.fixUp_();
    }
    /**
     * @returns Whether this is a RED node.
     */
    isRed_() {
        return this.color;
    }
    /**
     * @returns New tree after performing any needed rotations.
     */
    fixUp_() {
        let n = this;
        if (n.right.isRed_() && !n.left.isRed_()) {
            n = n.rotateLeft_();
        }
        if (n.left.isRed_() && n.left.left.isRed_()) {
            n = n.rotateRight_();
        }
        if (n.left.isRed_() && n.right.isRed_()) {
            n = n.colorFlip_();
        }
        return n;
    }
    /**
     * @returns New tree, after moveRedLeft.
     */
    moveRedLeft_() {
        let n = this.colorFlip_();
        if (n.right.left.isRed_()) {
            n = n.copy(null, null, null, null, n.right.rotateRight_());
            n = n.rotateLeft_();
            n = n.colorFlip_();
        }
        return n;
    }
    /**
     * @returns New tree, after moveRedRight.
     */
    moveRedRight_() {
        let n = this.colorFlip_();
        if (n.left.left.isRed_()) {
            n = n.rotateRight_();
            n = n.colorFlip_();
        }
        return n;
    }
    /**
     * @returns New tree, after rotateLeft.
     */
    rotateLeft_() {
        const nl = this.copy(null, null, LLRBNode.RED, null, this.right.left);
        return this.right.copy(null, null, this.color, nl, null);
    }
    /**
     * @returns New tree, after rotateRight.
     */
    rotateRight_() {
        const nr = this.copy(null, null, LLRBNode.RED, this.left.right, null);
        return this.left.copy(null, null, this.color, null, nr);
    }
    /**
     * @returns Newt ree, after colorFlip.
     */
    colorFlip_() {
        const left = this.left.copy(null, null, !this.left.color, null, null);
        const right = this.right.copy(null, null, !this.right.color, null, null);
        return this.copy(null, null, !this.color, left, right);
    }
    /**
     * For testing.
     *
     * @returns True if all is well.
     */
    checkMaxDepth_() {
        const blackDepth = this.check_();
        return Math.pow(2.0, blackDepth) <= this.count() + 1;
    }
    check_() {
        if (this.isRed_() && this.left.isRed_()) {
            throw new Error('Red node has red child(' + this.key + ',' + this.value + ')');
        }
        if (this.right.isRed_()) {
            throw new Error('Right child of (' + this.key + ',' + this.value + ') is red');
        }
        const blackDepth = this.left.check_();
        if (blackDepth !== this.right.check_()) {
            throw new Error('Black depths differ');
        }
        else {
            return blackDepth + (this.isRed_() ? 0 : 1);
        }
    }
}
LLRBNode.RED = true;
LLRBNode.BLACK = false;
/**
 * Represents an empty node (a leaf node in the Red-Black Tree).
 */
class LLRBEmptyNode {
    /**
     * Returns a copy of the current node.
     *
     * @returns The node copy.
     */
    copy(key, value, color, left, right) {
        return this;
    }
    /**
     * Returns a copy of the tree, with the specified key/value added.
     *
     * @param key - Key to be added.
     * @param value - Value to be added.
     * @param comparator - Comparator.
     * @returns New tree, with item added.
     */
    insert(key, value, comparator) {
        return new LLRBNode(key, value, null);
    }
    /**
     * Returns a copy of the tree, with the specified key removed.
     *
     * @param key - The key to remove.
     * @param comparator - Comparator.
     * @returns New tree, with item removed.
     */
    remove(key, comparator) {
        return this;
    }
    /**
     * @returns The total number of nodes in the tree.
     */
    count() {
        return 0;
    }
    /**
     * @returns True if the tree is empty.
     */
    isEmpty() {
        return true;
    }
    /**
     * Traverses the tree in key order and calls the specified action function
     * for each node.
     *
     * @param action - Callback function to be called for each
     * node.  If it returns true, traversal is aborted.
     * @returns True if traversal was aborted.
     */
    inorderTraversal(action) {
        return false;
    }
    /**
     * Traverses the tree in reverse key order and calls the specified action function
     * for each node.
     *
     * @param action - Callback function to be called for each
     * node.  If it returns true, traversal is aborted.
     * @returns True if traversal was aborted.
     */
    reverseTraversal(action) {
        return false;
    }
    minKey() {
        return null;
    }
    maxKey() {
        return null;
    }
    check_() {
        return 0;
    }
    /**
     * @returns Whether this node is red.
     */
    isRed_() {
        return false;
    }
}
/**
 * An immutable sorted map implementation, based on a Left-leaning Red-Black
 * tree.
 */
class SortedMap {
    /**
     * @param comparator_ - Key comparator.
     * @param root_ - Optional root node for the map.
     */
    constructor(comparator_, root_ = SortedMap.EMPTY_NODE) {
        this.comparator_ = comparator_;
        this.root_ = root_;
    }
    /**
     * Returns a copy of the map, with the specified key/value added or replaced.
     * (TODO: We should perhaps rename this method to 'put')
     *
     * @param key - Key to be added.
     * @param value - Value to be added.
     * @returns New map, with item added.
     */
    insert(key, value) {
        return new SortedMap(this.comparator_, this.root_
            .insert(key, value, this.comparator_)
            .copy(null, null, LLRBNode.BLACK, null, null));
    }
    /**
     * Returns a copy of the map, with the specified key removed.
     *
     * @param key - The key to remove.
     * @returns New map, with item removed.
     */
    remove(key) {
        return new SortedMap(this.comparator_, this.root_
            .remove(key, this.comparator_)
            .copy(null, null, LLRBNode.BLACK, null, null));
    }
    /**
     * Returns the value of the node with the given key, or null.
     *
     * @param key - The key to look up.
     * @returns The value of the node with the given key, or null if the
     * key doesn't exist.
     */
    get(key) {
        let cmp;
        let node = this.root_;
        while (!node.isEmpty()) {
            cmp = this.comparator_(key, node.key);
            if (cmp === 0) {
                return node.value;
            }
            else if (cmp < 0) {
                node = node.left;
            }
            else if (cmp > 0) {
                node = node.right;
            }
        }
        return null;
    }
    /**
     * Returns the key of the item *before* the specified key, or null if key is the first item.
     * @param key - The key to find the predecessor of
     * @returns The predecessor key.
     */
    getPredecessorKey(key) {
        let cmp, node = this.root_, rightParent = null;
        while (!node.isEmpty()) {
            cmp = this.comparator_(key, node.key);
            if (cmp === 0) {
                if (!node.left.isEmpty()) {
                    node = node.left;
                    while (!node.right.isEmpty()) {
                        node = node.right;
                    }
                    return node.key;
                }
                else if (rightParent) {
                    return rightParent.key;
                }
                else {
                    return null; // first item.
                }
            }
            else if (cmp < 0) {
                node = node.left;
            }
            else if (cmp > 0) {
                rightParent = node;
                node = node.right;
            }
        }
        throw new Error('Attempted to find predecessor key for a nonexistent key.  What gives?');
    }
    /**
     * @returns True if the map is empty.
     */
    isEmpty() {
        return this.root_.isEmpty();
    }
    /**
     * @returns The total number of nodes in the map.
     */
    count() {
        return this.root_.count();
    }
    /**
     * @returns The minimum key in the map.
     */
    minKey() {
        return this.root_.minKey();
    }
    /**
     * @returns The maximum key in the map.
     */
    maxKey() {
        return this.root_.maxKey();
    }
    /**
     * Traverses the map in key order and calls the specified action function
     * for each key/value pair.
     *
     * @param action - Callback function to be called
     * for each key/value pair.  If action returns true, traversal is aborted.
     * @returns The first truthy value returned by action, or the last falsey
     *   value returned by action
     */
    inorderTraversal(action) {
        return this.root_.inorderTraversal(action);
    }
    /**
     * Traverses the map in reverse key order and calls the specified action function
     * for each key/value pair.
     *
     * @param action - Callback function to be called
     * for each key/value pair.  If action returns true, traversal is aborted.
     * @returns True if the traversal was aborted.
     */
    reverseTraversal(action) {
        return this.root_.reverseTraversal(action);
    }
    /**
     * Returns an iterator over the SortedMap.
     * @returns The iterator.
     */
    getIterator(resultGenerator) {
        return new SortedMapIterator(this.root_, null, this.comparator_, false, resultGenerator);
    }
    getIteratorFrom(key, resultGenerator) {
        return new SortedMapIterator(this.root_, key, this.comparator_, false, resultGenerator);
    }
    getReverseIteratorFrom(key, resultGenerator) {
        return new SortedMapIterator(this.root_, key, this.comparator_, true, resultGenerator);
    }
    getReverseIterator(resultGenerator) {
        return new SortedMapIterator(this.root_, null, this.comparator_, true, resultGenerator);
    }
}
/**
 * Always use the same empty node, to reduce memory.
 */
SortedMap.EMPTY_NODE = new LLRBEmptyNode();

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function NAME_ONLY_COMPARATOR(left, right) {
    return nameCompare(left.name, right.name);
}
function NAME_COMPARATOR(left, right) {
    return nameCompare(left, right);
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
let MAX_NODE$2;
function setMaxNode$1(val) {
    MAX_NODE$2 = val;
}
const priorityHashText = function (priority) {
    if (typeof priority === 'number') {
        return 'number:' + doubleToIEEE754String(priority);
    }
    else {
        return 'string:' + priority;
    }
};
/**
 * Validates that a priority snapshot Node is valid.
 */
const validatePriorityNode = function (priorityNode) {
    if (priorityNode.isLeafNode()) {
        const val = priorityNode.val();
        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(typeof val === 'string' ||
            typeof val === 'number' ||
            (typeof val === 'object' && (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.contains)(val, '.sv')), 'Priority must be a string or number.');
    }
    else {
        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(priorityNode === MAX_NODE$2 || priorityNode.isEmpty(), 'priority of unexpected type.');
    }
    // Don't call getPriority() on MAX_NODE to avoid hitting assertion.
    (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(priorityNode === MAX_NODE$2 || priorityNode.getPriority().isEmpty(), "Priority nodes can't have a priority of their own.");
};

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
let __childrenNodeConstructor;
/**
 * LeafNode is a class for storing leaf nodes in a DataSnapshot.  It
 * implements Node and stores the value of the node (a string,
 * number, or boolean) accessible via getValue().
 */
class LeafNode {
    /**
     * @param value_ - The value to store in this leaf node. The object type is
     * possible in the event of a deferred value
     * @param priorityNode_ - The priority of this node.
     */
    constructor(value_, priorityNode_ = LeafNode.__childrenNodeConstructor.EMPTY_NODE) {
        this.value_ = value_;
        this.priorityNode_ = priorityNode_;
        this.lazyHash_ = null;
        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(this.value_ !== undefined && this.value_ !== null, "LeafNode shouldn't be created with null/undefined value.");
        validatePriorityNode(this.priorityNode_);
    }
    static set __childrenNodeConstructor(val) {
        __childrenNodeConstructor = val;
    }
    static get __childrenNodeConstructor() {
        return __childrenNodeConstructor;
    }
    /** @inheritDoc */
    isLeafNode() {
        return true;
    }
    /** @inheritDoc */
    getPriority() {
        return this.priorityNode_;
    }
    /** @inheritDoc */
    updatePriority(newPriorityNode) {
        return new LeafNode(this.value_, newPriorityNode);
    }
    /** @inheritDoc */
    getImmediateChild(childName) {
        // Hack to treat priority as a regular child
        if (childName === '.priority') {
            return this.priorityNode_;
        }
        else {
            return LeafNode.__childrenNodeConstructor.EMPTY_NODE;
        }
    }
    /** @inheritDoc */
    getChild(path) {
        if (pathIsEmpty(path)) {
            return this;
        }
        else if (pathGetFront(path) === '.priority') {
            return this.priorityNode_;
        }
        else {
            return LeafNode.__childrenNodeConstructor.EMPTY_NODE;
        }
    }
    hasChild() {
        return false;
    }
    /** @inheritDoc */
    getPredecessorChildName(childName, childNode) {
        return null;
    }
    /** @inheritDoc */
    updateImmediateChild(childName, newChildNode) {
        if (childName === '.priority') {
            return this.updatePriority(newChildNode);
        }
        else if (newChildNode.isEmpty() && childName !== '.priority') {
            return this;
        }
        else {
            return LeafNode.__childrenNodeConstructor.EMPTY_NODE.updateImmediateChild(childName, newChildNode).updatePriority(this.priorityNode_);
        }
    }
    /** @inheritDoc */
    updateChild(path, newChildNode) {
        const front = pathGetFront(path);
        if (front === null) {
            return newChildNode;
        }
        else if (newChildNode.isEmpty() && front !== '.priority') {
            return this;
        }
        else {
            (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(front !== '.priority' || pathGetLength(path) === 1, '.priority must be the last token in a path');
            return this.updateImmediateChild(front, LeafNode.__childrenNodeConstructor.EMPTY_NODE.updateChild(pathPopFront(path), newChildNode));
        }
    }
    /** @inheritDoc */
    isEmpty() {
        return false;
    }
    /** @inheritDoc */
    numChildren() {
        return 0;
    }
    /** @inheritDoc */
    forEachChild(index, action) {
        return false;
    }
    val(exportFormat) {
        if (exportFormat && !this.getPriority().isEmpty()) {
            return {
                '.value': this.getValue(),
                '.priority': this.getPriority().val()
            };
        }
        else {
            return this.getValue();
        }
    }
    /** @inheritDoc */
    hash() {
        if (this.lazyHash_ === null) {
            let toHash = '';
            if (!this.priorityNode_.isEmpty()) {
                toHash +=
                    'priority:' +
                        priorityHashText(this.priorityNode_.val()) +
                        ':';
            }
            const type = typeof this.value_;
            toHash += type + ':';
            if (type === 'number') {
                toHash += doubleToIEEE754String(this.value_);
            }
            else {
                toHash += this.value_;
            }
            this.lazyHash_ = sha1(toHash);
        }
        return this.lazyHash_;
    }
    /**
     * Returns the value of the leaf node.
     * @returns The value of the node.
     */
    getValue() {
        return this.value_;
    }
    compareTo(other) {
        if (other === LeafNode.__childrenNodeConstructor.EMPTY_NODE) {
            return 1;
        }
        else if (other instanceof LeafNode.__childrenNodeConstructor) {
            return -1;
        }
        else {
            (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(other.isLeafNode(), 'Unknown node type');
            return this.compareToLeafNode_(other);
        }
    }
    /**
     * Comparison specifically for two leaf nodes
     */
    compareToLeafNode_(otherLeaf) {
        const otherLeafType = typeof otherLeaf.value_;
        const thisLeafType = typeof this.value_;
        const otherIndex = LeafNode.VALUE_TYPE_ORDER.indexOf(otherLeafType);
        const thisIndex = LeafNode.VALUE_TYPE_ORDER.indexOf(thisLeafType);
        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(otherIndex >= 0, 'Unknown leaf type: ' + otherLeafType);
        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(thisIndex >= 0, 'Unknown leaf type: ' + thisLeafType);
        if (otherIndex === thisIndex) {
            // Same type, compare values
            if (thisLeafType === 'object') {
                // Deferred value nodes are all equal, but we should also never get to this point...
                return 0;
            }
            else {
                // Note that this works because true > false, all others are number or string comparisons
                if (this.value_ < otherLeaf.value_) {
                    return -1;
                }
                else if (this.value_ === otherLeaf.value_) {
                    return 0;
                }
                else {
                    return 1;
                }
            }
        }
        else {
            return thisIndex - otherIndex;
        }
    }
    withIndex() {
        return this;
    }
    isIndexed() {
        return true;
    }
    equals(other) {
        if (other === this) {
            return true;
        }
        else if (other.isLeafNode()) {
            const otherLeaf = other;
            return (this.value_ === otherLeaf.value_ &&
                this.priorityNode_.equals(otherLeaf.priorityNode_));
        }
        else {
            return false;
        }
    }
}
/**
 * The sort order for comparing leaf nodes of different types. If two leaf nodes have
 * the same type, the comparison falls back to their value
 */
LeafNode.VALUE_TYPE_ORDER = ['object', 'boolean', 'number', 'string'];

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
let nodeFromJSON$1;
let MAX_NODE$1;
function setNodeFromJSON(val) {
    nodeFromJSON$1 = val;
}
function setMaxNode(val) {
    MAX_NODE$1 = val;
}
class PriorityIndex extends Index {
    compare(a, b) {
        const aPriority = a.node.getPriority();
        const bPriority = b.node.getPriority();
        const indexCmp = aPriority.compareTo(bPriority);
        if (indexCmp === 0) {
            return nameCompare(a.name, b.name);
        }
        else {
            return indexCmp;
        }
    }
    isDefinedOn(node) {
        return !node.getPriority().isEmpty();
    }
    indexedValueChanged(oldNode, newNode) {
        return !oldNode.getPriority().equals(newNode.getPriority());
    }
    minPost() {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        return NamedNode.MIN;
    }
    maxPost() {
        return new NamedNode(MAX_NAME, new LeafNode('[PRIORITY-POST]', MAX_NODE$1));
    }
    makePost(indexValue, name) {
        const priorityNode = nodeFromJSON$1(indexValue);
        return new NamedNode(name, new LeafNode('[PRIORITY-POST]', priorityNode));
    }
    /**
     * @returns String representation for inclusion in a query spec
     */
    toString() {
        return '.priority';
    }
}
const PRIORITY_INDEX = new PriorityIndex();

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const LOG_2 = Math.log(2);
class Base12Num {
    constructor(length) {
        const logBase2 = (num) => 
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        parseInt((Math.log(num) / LOG_2), 10);
        const bitMask = (bits) => parseInt(Array(bits + 1).join('1'), 2);
        this.count = logBase2(length + 1);
        this.current_ = this.count - 1;
        const mask = bitMask(this.count);
        this.bits_ = (length + 1) & mask;
    }
    nextBitIsOne() {
        //noinspection JSBitwiseOperatorUsage
        const result = !(this.bits_ & (0x1 << this.current_));
        this.current_--;
        return result;
    }
}
/**
 * Takes a list of child nodes and constructs a SortedSet using the given comparison
 * function
 *
 * Uses the algorithm described in the paper linked here:
 * http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.46.1458
 *
 * @param childList - Unsorted list of children
 * @param cmp - The comparison method to be used
 * @param keyFn - An optional function to extract K from a node wrapper, if K's
 * type is not NamedNode
 * @param mapSortFn - An optional override for comparator used by the generated sorted map
 */
const buildChildSet = function (childList, cmp, keyFn, mapSortFn) {
    childList.sort(cmp);
    const buildBalancedTree = function (low, high) {
        const length = high - low;
        let namedNode;
        let key;
        if (length === 0) {
            return null;
        }
        else if (length === 1) {
            namedNode = childList[low];
            key = keyFn ? keyFn(namedNode) : namedNode;
            return new LLRBNode(key, namedNode.node, LLRBNode.BLACK, null, null);
        }
        else {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            const middle = parseInt((length / 2), 10) + low;
            const left = buildBalancedTree(low, middle);
            const right = buildBalancedTree(middle + 1, high);
            namedNode = childList[middle];
            key = keyFn ? keyFn(namedNode) : namedNode;
            return new LLRBNode(key, namedNode.node, LLRBNode.BLACK, left, right);
        }
    };
    const buildFrom12Array = function (base12) {
        let node = null;
        let root = null;
        let index = childList.length;
        const buildPennant = function (chunkSize, color) {
            const low = index - chunkSize;
            const high = index;
            index -= chunkSize;
            const childTree = buildBalancedTree(low + 1, high);
            const namedNode = childList[low];
            const key = keyFn ? keyFn(namedNode) : namedNode;
            attachPennant(new LLRBNode(key, namedNode.node, color, null, childTree));
        };
        const attachPennant = function (pennant) {
            if (node) {
                node.left = pennant;
                node = pennant;
            }
            else {
                root = pennant;
                node = pennant;
            }
        };
        for (let i = 0; i < base12.count; ++i) {
            const isOne = base12.nextBitIsOne();
            // The number of nodes taken in each slice is 2^(arr.length - (i + 1))
            const chunkSize = Math.pow(2, base12.count - (i + 1));
            if (isOne) {
                buildPennant(chunkSize, LLRBNode.BLACK);
            }
            else {
                // current == 2
                buildPennant(chunkSize, LLRBNode.BLACK);
                buildPennant(chunkSize, LLRBNode.RED);
            }
        }
        return root;
    };
    const base12 = new Base12Num(childList.length);
    const root = buildFrom12Array(base12);
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    return new SortedMap(mapSortFn || cmp, root);
};

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
let _defaultIndexMap;
const fallbackObject = {};
class IndexMap {
    constructor(indexes_, indexSet_) {
        this.indexes_ = indexes_;
        this.indexSet_ = indexSet_;
    }
    /**
     * The default IndexMap for nodes without a priority
     */
    static get Default() {
        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(fallbackObject && PRIORITY_INDEX, 'ChildrenNode.ts has not been loaded');
        _defaultIndexMap =
            _defaultIndexMap ||
                new IndexMap({ '.priority': fallbackObject }, { '.priority': PRIORITY_INDEX });
        return _defaultIndexMap;
    }
    get(indexKey) {
        const sortedMap = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.safeGet)(this.indexes_, indexKey);
        if (!sortedMap) {
            throw new Error('No index defined for ' + indexKey);
        }
        if (sortedMap instanceof SortedMap) {
            return sortedMap;
        }
        else {
            // The index exists, but it falls back to just name comparison. Return null so that the calling code uses the
            // regular child map
            return null;
        }
    }
    hasIndex(indexDefinition) {
        return (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.contains)(this.indexSet_, indexDefinition.toString());
    }
    addIndex(indexDefinition, existingChildren) {
        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(indexDefinition !== KEY_INDEX, "KeyIndex always exists and isn't meant to be added to the IndexMap.");
        const childList = [];
        let sawIndexedValue = false;
        const iter = existingChildren.getIterator(NamedNode.Wrap);
        let next = iter.getNext();
        while (next) {
            sawIndexedValue =
                sawIndexedValue || indexDefinition.isDefinedOn(next.node);
            childList.push(next);
            next = iter.getNext();
        }
        let newIndex;
        if (sawIndexedValue) {
            newIndex = buildChildSet(childList, indexDefinition.getCompare());
        }
        else {
            newIndex = fallbackObject;
        }
        const indexName = indexDefinition.toString();
        const newIndexSet = Object.assign({}, this.indexSet_);
        newIndexSet[indexName] = indexDefinition;
        const newIndexes = Object.assign({}, this.indexes_);
        newIndexes[indexName] = newIndex;
        return new IndexMap(newIndexes, newIndexSet);
    }
    /**
     * Ensure that this node is properly tracked in any indexes that we're maintaining
     */
    addToIndexes(namedNode, existingChildren) {
        const newIndexes = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.map)(this.indexes_, (indexedChildren, indexName) => {
            const index = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.safeGet)(this.indexSet_, indexName);
            (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(index, 'Missing index implementation for ' + indexName);
            if (indexedChildren === fallbackObject) {
                // Check to see if we need to index everything
                if (index.isDefinedOn(namedNode.node)) {
                    // We need to build this index
                    const childList = [];
                    const iter = existingChildren.getIterator(NamedNode.Wrap);
                    let next = iter.getNext();
                    while (next) {
                        if (next.name !== namedNode.name) {
                            childList.push(next);
                        }
                        next = iter.getNext();
                    }
                    childList.push(namedNode);
                    return buildChildSet(childList, index.getCompare());
                }
                else {
                    // No change, this remains a fallback
                    return fallbackObject;
                }
            }
            else {
                const existingSnap = existingChildren.get(namedNode.name);
                let newChildren = indexedChildren;
                if (existingSnap) {
                    newChildren = newChildren.remove(new NamedNode(namedNode.name, existingSnap));
                }
                return newChildren.insert(namedNode, namedNode.node);
            }
        });
        return new IndexMap(newIndexes, this.indexSet_);
    }
    /**
     * Create a new IndexMap instance with the given value removed
     */
    removeFromIndexes(namedNode, existingChildren) {
        const newIndexes = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.map)(this.indexes_, (indexedChildren) => {
            if (indexedChildren === fallbackObject) {
                // This is the fallback. Just return it, nothing to do in this case
                return indexedChildren;
            }
            else {
                const existingSnap = existingChildren.get(namedNode.name);
                if (existingSnap) {
                    return indexedChildren.remove(new NamedNode(namedNode.name, existingSnap));
                }
                else {
                    // No record of this child
                    return indexedChildren;
                }
            }
        });
        return new IndexMap(newIndexes, this.indexSet_);
    }
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// TODO: For memory savings, don't store priorityNode_ if it's empty.
let EMPTY_NODE;
/**
 * ChildrenNode is a class for storing internal nodes in a DataSnapshot
 * (i.e. nodes with children).  It implements Node and stores the
 * list of children in the children property, sorted by child name.
 */
class ChildrenNode {
    /**
     * @param children_ - List of children of this node..
     * @param priorityNode_ - The priority of this node (as a snapshot node).
     */
    constructor(children_, priorityNode_, indexMap_) {
        this.children_ = children_;
        this.priorityNode_ = priorityNode_;
        this.indexMap_ = indexMap_;
        this.lazyHash_ = null;
        /**
         * Note: The only reason we allow null priority is for EMPTY_NODE, since we can't use
         * EMPTY_NODE as the priority of EMPTY_NODE.  We might want to consider making EMPTY_NODE its own
         * class instead of an empty ChildrenNode.
         */
        if (this.priorityNode_) {
            validatePriorityNode(this.priorityNode_);
        }
        if (this.children_.isEmpty()) {
            (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(!this.priorityNode_ || this.priorityNode_.isEmpty(), 'An empty node cannot have a priority');
        }
    }
    static get EMPTY_NODE() {
        return (EMPTY_NODE ||
            (EMPTY_NODE = new ChildrenNode(new SortedMap(NAME_COMPARATOR), null, IndexMap.Default)));
    }
    /** @inheritDoc */
    isLeafNode() {
        return false;
    }
    /** @inheritDoc */
    getPriority() {
        return this.priorityNode_ || EMPTY_NODE;
    }
    /** @inheritDoc */
    updatePriority(newPriorityNode) {
        if (this.children_.isEmpty()) {
            // Don't allow priorities on empty nodes
            return this;
        }
        else {
            return new ChildrenNode(this.children_, newPriorityNode, this.indexMap_);
        }
    }
    /** @inheritDoc */
    getImmediateChild(childName) {
        // Hack to treat priority as a regular child
        if (childName === '.priority') {
            return this.getPriority();
        }
        else {
            const child = this.children_.get(childName);
            return child === null ? EMPTY_NODE : child;
        }
    }
    /** @inheritDoc */
    getChild(path) {
        const front = pathGetFront(path);
        if (front === null) {
            return this;
        }
        return this.getImmediateChild(front).getChild(pathPopFront(path));
    }
    /** @inheritDoc */
    hasChild(childName) {
        return this.children_.get(childName) !== null;
    }
    /** @inheritDoc */
    updateImmediateChild(childName, newChildNode) {
        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(newChildNode, 'We should always be passing snapshot nodes');
        if (childName === '.priority') {
            return this.updatePriority(newChildNode);
        }
        else {
            const namedNode = new NamedNode(childName, newChildNode);
            let newChildren, newIndexMap;
            if (newChildNode.isEmpty()) {
                newChildren = this.children_.remove(childName);
                newIndexMap = this.indexMap_.removeFromIndexes(namedNode, this.children_);
            }
            else {
                newChildren = this.children_.insert(childName, newChildNode);
                newIndexMap = this.indexMap_.addToIndexes(namedNode, this.children_);
            }
            const newPriority = newChildren.isEmpty()
                ? EMPTY_NODE
                : this.priorityNode_;
            return new ChildrenNode(newChildren, newPriority, newIndexMap);
        }
    }
    /** @inheritDoc */
    updateChild(path, newChildNode) {
        const front = pathGetFront(path);
        if (front === null) {
            return newChildNode;
        }
        else {
            (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(pathGetFront(path) !== '.priority' || pathGetLength(path) === 1, '.priority must be the last token in a path');
            const newImmediateChild = this.getImmediateChild(front).updateChild(pathPopFront(path), newChildNode);
            return this.updateImmediateChild(front, newImmediateChild);
        }
    }
    /** @inheritDoc */
    isEmpty() {
        return this.children_.isEmpty();
    }
    /** @inheritDoc */
    numChildren() {
        return this.children_.count();
    }
    /** @inheritDoc */
    val(exportFormat) {
        if (this.isEmpty()) {
            return null;
        }
        const obj = {};
        let numKeys = 0, maxKey = 0, allIntegerKeys = true;
        this.forEachChild(PRIORITY_INDEX, (key, childNode) => {
            obj[key] = childNode.val(exportFormat);
            numKeys++;
            if (allIntegerKeys && ChildrenNode.INTEGER_REGEXP_.test(key)) {
                maxKey = Math.max(maxKey, Number(key));
            }
            else {
                allIntegerKeys = false;
            }
        });
        if (!exportFormat && allIntegerKeys && maxKey < 2 * numKeys) {
            // convert to array.
            const array = [];
            // eslint-disable-next-line guard-for-in
            for (const key in obj) {
                array[key] = obj[key];
            }
            return array;
        }
        else {
            if (exportFormat && !this.getPriority().isEmpty()) {
                obj['.priority'] = this.getPriority().val();
            }
            return obj;
        }
    }
    /** @inheritDoc */
    hash() {
        if (this.lazyHash_ === null) {
            let toHash = '';
            if (!this.getPriority().isEmpty()) {
                toHash +=
                    'priority:' +
                        priorityHashText(this.getPriority().val()) +
                        ':';
            }
            this.forEachChild(PRIORITY_INDEX, (key, childNode) => {
                const childHash = childNode.hash();
                if (childHash !== '') {
                    toHash += ':' + key + ':' + childHash;
                }
            });
            this.lazyHash_ = toHash === '' ? '' : sha1(toHash);
        }
        return this.lazyHash_;
    }
    /** @inheritDoc */
    getPredecessorChildName(childName, childNode, index) {
        const idx = this.resolveIndex_(index);
        if (idx) {
            const predecessor = idx.getPredecessorKey(new NamedNode(childName, childNode));
            return predecessor ? predecessor.name : null;
        }
        else {
            return this.children_.getPredecessorKey(childName);
        }
    }
    getFirstChildName(indexDefinition) {
        const idx = this.resolveIndex_(indexDefinition);
        if (idx) {
            const minKey = idx.minKey();
            return minKey && minKey.name;
        }
        else {
            return this.children_.minKey();
        }
    }
    getFirstChild(indexDefinition) {
        const minKey = this.getFirstChildName(indexDefinition);
        if (minKey) {
            return new NamedNode(minKey, this.children_.get(minKey));
        }
        else {
            return null;
        }
    }
    /**
     * Given an index, return the key name of the largest value we have, according to that index
     */
    getLastChildName(indexDefinition) {
        const idx = this.resolveIndex_(indexDefinition);
        if (idx) {
            const maxKey = idx.maxKey();
            return maxKey && maxKey.name;
        }
        else {
            return this.children_.maxKey();
        }
    }
    getLastChild(indexDefinition) {
        const maxKey = this.getLastChildName(indexDefinition);
        if (maxKey) {
            return new NamedNode(maxKey, this.children_.get(maxKey));
        }
        else {
            return null;
        }
    }
    forEachChild(index, action) {
        const idx = this.resolveIndex_(index);
        if (idx) {
            return idx.inorderTraversal(wrappedNode => {
                return action(wrappedNode.name, wrappedNode.node);
            });
        }
        else {
            return this.children_.inorderTraversal(action);
        }
    }
    getIterator(indexDefinition) {
        return this.getIteratorFrom(indexDefinition.minPost(), indexDefinition);
    }
    getIteratorFrom(startPost, indexDefinition) {
        const idx = this.resolveIndex_(indexDefinition);
        if (idx) {
            return idx.getIteratorFrom(startPost, key => key);
        }
        else {
            const iterator = this.children_.getIteratorFrom(startPost.name, NamedNode.Wrap);
            let next = iterator.peek();
            while (next != null && indexDefinition.compare(next, startPost) < 0) {
                iterator.getNext();
                next = iterator.peek();
            }
            return iterator;
        }
    }
    getReverseIterator(indexDefinition) {
        return this.getReverseIteratorFrom(indexDefinition.maxPost(), indexDefinition);
    }
    getReverseIteratorFrom(endPost, indexDefinition) {
        const idx = this.resolveIndex_(indexDefinition);
        if (idx) {
            return idx.getReverseIteratorFrom(endPost, key => {
                return key;
            });
        }
        else {
            const iterator = this.children_.getReverseIteratorFrom(endPost.name, NamedNode.Wrap);
            let next = iterator.peek();
            while (next != null && indexDefinition.compare(next, endPost) > 0) {
                iterator.getNext();
                next = iterator.peek();
            }
            return iterator;
        }
    }
    compareTo(other) {
        if (this.isEmpty()) {
            if (other.isEmpty()) {
                return 0;
            }
            else {
                return -1;
            }
        }
        else if (other.isLeafNode() || other.isEmpty()) {
            return 1;
        }
        else if (other === MAX_NODE) {
            return -1;
        }
        else {
            // Must be another node with children.
            return 0;
        }
    }
    withIndex(indexDefinition) {
        if (indexDefinition === KEY_INDEX ||
            this.indexMap_.hasIndex(indexDefinition)) {
            return this;
        }
        else {
            const newIndexMap = this.indexMap_.addIndex(indexDefinition, this.children_);
            return new ChildrenNode(this.children_, this.priorityNode_, newIndexMap);
        }
    }
    isIndexed(index) {
        return index === KEY_INDEX || this.indexMap_.hasIndex(index);
    }
    equals(other) {
        if (other === this) {
            return true;
        }
        else if (other.isLeafNode()) {
            return false;
        }
        else {
            const otherChildrenNode = other;
            if (!this.getPriority().equals(otherChildrenNode.getPriority())) {
                return false;
            }
            else if (this.children_.count() === otherChildrenNode.children_.count()) {
                const thisIter = this.getIterator(PRIORITY_INDEX);
                const otherIter = otherChildrenNode.getIterator(PRIORITY_INDEX);
                let thisCurrent = thisIter.getNext();
                let otherCurrent = otherIter.getNext();
                while (thisCurrent && otherCurrent) {
                    if (thisCurrent.name !== otherCurrent.name ||
                        !thisCurrent.node.equals(otherCurrent.node)) {
                        return false;
                    }
                    thisCurrent = thisIter.getNext();
                    otherCurrent = otherIter.getNext();
                }
                return thisCurrent === null && otherCurrent === null;
            }
            else {
                return false;
            }
        }
    }
    /**
     * Returns a SortedMap ordered by index, or null if the default (by-key) ordering can be used
     * instead.
     *
     */
    resolveIndex_(indexDefinition) {
        if (indexDefinition === KEY_INDEX) {
            return null;
        }
        else {
            return this.indexMap_.get(indexDefinition.toString());
        }
    }
}
ChildrenNode.INTEGER_REGEXP_ = /^(0|[1-9]\d*)$/;
class MaxNode extends ChildrenNode {
    constructor() {
        super(new SortedMap(NAME_COMPARATOR), ChildrenNode.EMPTY_NODE, IndexMap.Default);
    }
    compareTo(other) {
        if (other === this) {
            return 0;
        }
        else {
            return 1;
        }
    }
    equals(other) {
        // Not that we every compare it, but MAX_NODE is only ever equal to itself
        return other === this;
    }
    getPriority() {
        return this;
    }
    getImmediateChild(childName) {
        return ChildrenNode.EMPTY_NODE;
    }
    isEmpty() {
        return false;
    }
}
/**
 * Marker that will sort higher than any other snapshot.
 */
const MAX_NODE = new MaxNode();
Object.defineProperties(NamedNode, {
    MIN: {
        value: new NamedNode(MIN_NAME, ChildrenNode.EMPTY_NODE)
    },
    MAX: {
        value: new NamedNode(MAX_NAME, MAX_NODE)
    }
});
/**
 * Reference Extensions
 */
KeyIndex.__EMPTY_NODE = ChildrenNode.EMPTY_NODE;
LeafNode.__childrenNodeConstructor = ChildrenNode;
setMaxNode$1(MAX_NODE);
setMaxNode(MAX_NODE);

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const USE_HINZE = true;
/**
 * Constructs a snapshot node representing the passed JSON and returns it.
 * @param json - JSON to create a node for.
 * @param priority - Optional priority to use.  This will be ignored if the
 * passed JSON contains a .priority property.
 */
function nodeFromJSON(json, priority = null) {
    if (json === null) {
        return ChildrenNode.EMPTY_NODE;
    }
    if (typeof json === 'object' && '.priority' in json) {
        priority = json['.priority'];
    }
    (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(priority === null ||
        typeof priority === 'string' ||
        typeof priority === 'number' ||
        (typeof priority === 'object' && '.sv' in priority), 'Invalid priority type found: ' + typeof priority);
    if (typeof json === 'object' && '.value' in json && json['.value'] !== null) {
        json = json['.value'];
    }
    // Valid leaf nodes include non-objects or server-value wrapper objects
    if (typeof json !== 'object' || '.sv' in json) {
        const jsonLeaf = json;
        return new LeafNode(jsonLeaf, nodeFromJSON(priority));
    }
    if (!(json instanceof Array) && USE_HINZE) {
        const children = [];
        let childrenHavePriority = false;
        const hinzeJsonObj = json;
        each(hinzeJsonObj, (key, child) => {
            if (key.substring(0, 1) !== '.') {
                // Ignore metadata nodes
                const childNode = nodeFromJSON(child);
                if (!childNode.isEmpty()) {
                    childrenHavePriority =
                        childrenHavePriority || !childNode.getPriority().isEmpty();
                    children.push(new NamedNode(key, childNode));
                }
            }
        });
        if (children.length === 0) {
            return ChildrenNode.EMPTY_NODE;
        }
        const childSet = buildChildSet(children, NAME_ONLY_COMPARATOR, namedNode => namedNode.name, NAME_COMPARATOR);
        if (childrenHavePriority) {
            const sortedChildSet = buildChildSet(children, PRIORITY_INDEX.getCompare());
            return new ChildrenNode(childSet, nodeFromJSON(priority), new IndexMap({ '.priority': sortedChildSet }, { '.priority': PRIORITY_INDEX }));
        }
        else {
            return new ChildrenNode(childSet, nodeFromJSON(priority), IndexMap.Default);
        }
    }
    else {
        let node = ChildrenNode.EMPTY_NODE;
        each(json, (key, childData) => {
            if ((0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.contains)(json, key)) {
                if (key.substring(0, 1) !== '.') {
                    // ignore metadata nodes.
                    const childNode = nodeFromJSON(childData);
                    if (childNode.isLeafNode() || !childNode.isEmpty()) {
                        node = node.updateImmediateChild(key, childNode);
                    }
                }
            }
        });
        return node.updatePriority(nodeFromJSON(priority));
    }
}
setNodeFromJSON(nodeFromJSON);

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class PathIndex extends Index {
    constructor(indexPath_) {
        super();
        this.indexPath_ = indexPath_;
        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(!pathIsEmpty(indexPath_) && pathGetFront(indexPath_) !== '.priority', "Can't create PathIndex with empty path or .priority key");
    }
    extractChild(snap) {
        return snap.getChild(this.indexPath_);
    }
    isDefinedOn(node) {
        return !node.getChild(this.indexPath_).isEmpty();
    }
    compare(a, b) {
        const aChild = this.extractChild(a.node);
        const bChild = this.extractChild(b.node);
        const indexCmp = aChild.compareTo(bChild);
        if (indexCmp === 0) {
            return nameCompare(a.name, b.name);
        }
        else {
            return indexCmp;
        }
    }
    makePost(indexValue, name) {
        const valueNode = nodeFromJSON(indexValue);
        const node = ChildrenNode.EMPTY_NODE.updateChild(this.indexPath_, valueNode);
        return new NamedNode(name, node);
    }
    maxPost() {
        const node = ChildrenNode.EMPTY_NODE.updateChild(this.indexPath_, MAX_NODE);
        return new NamedNode(MAX_NAME, node);
    }
    toString() {
        return pathSlice(this.indexPath_, 0).join('/');
    }
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ValueIndex extends Index {
    compare(a, b) {
        const indexCmp = a.node.compareTo(b.node);
        if (indexCmp === 0) {
            return nameCompare(a.name, b.name);
        }
        else {
            return indexCmp;
        }
    }
    isDefinedOn(node) {
        return true;
    }
    indexedValueChanged(oldNode, newNode) {
        return !oldNode.equals(newNode);
    }
    minPost() {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        return NamedNode.MIN;
    }
    maxPost() {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        return NamedNode.MAX;
    }
    makePost(indexValue, name) {
        const valueNode = nodeFromJSON(indexValue);
        return new NamedNode(name, valueNode);
    }
    /**
     * @returns String representation for inclusion in a query spec
     */
    toString() {
        return '.value';
    }
}
const VALUE_INDEX = new ValueIndex();

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Modeled after base64 web-safe chars, but ordered by ASCII.
const PUSH_CHARS = '-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz';
const MIN_PUSH_CHAR = '-';
const MAX_PUSH_CHAR = 'z';
const MAX_KEY_LEN = 786;
/**
 * Fancy ID generator that creates 20-character string identifiers with the
 * following properties:
 *
 * 1. They're based on timestamp so that they sort *after* any existing ids.
 * 2. They contain 72-bits of random data after the timestamp so that IDs won't
 *    collide with other clients' IDs.
 * 3. They sort *lexicographically* (so the timestamp is converted to characters
 *    that will sort properly).
 * 4. They're monotonically increasing. Even if you generate more than one in
 *    the same timestamp, the latter ones will sort after the former ones. We do
 *    this by using the previous random bits but "incrementing" them by 1 (only
 *    in the case of a timestamp collision).
 */
const nextPushId = (function () {
    // Timestamp of last push, used to prevent local collisions if you push twice
    // in one ms.
    let lastPushTime = 0;
    // We generate 72-bits of randomness which get turned into 12 characters and
    // appended to the timestamp to prevent collisions with other clients. We
    // store the last characters we generated because in the event of a collision,
    // we'll use those same characters except "incremented" by one.
    const lastRandChars = [];
    return function (now) {
        const duplicateTime = now === lastPushTime;
        lastPushTime = now;
        let i;
        const timeStampChars = new Array(8);
        for (i = 7; i >= 0; i--) {
            timeStampChars[i] = PUSH_CHARS.charAt(now % 64);
            // NOTE: Can't use << here because javascript will convert to int and lose
            // the upper bits.
            now = Math.floor(now / 64);
        }
        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(now === 0, 'Cannot push at time == 0');
        let id = timeStampChars.join('');
        if (!duplicateTime) {
            for (i = 0; i < 12; i++) {
                lastRandChars[i] = Math.floor(Math.random() * 64);
            }
        }
        else {
            // If the timestamp hasn't changed since last push, use the same random
            // number, except incremented by 1.
            for (i = 11; i >= 0 && lastRandChars[i] === 63; i--) {
                lastRandChars[i] = 0;
            }
            lastRandChars[i]++;
        }
        for (i = 0; i < 12; i++) {
            id += PUSH_CHARS.charAt(lastRandChars[i]);
        }
        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(id.length === 20, 'nextPushId: Length should be 20.');
        return id;
    };
})();
const successor = function (key) {
    if (key === '' + INTEGER_32_MAX) {
        // See https://firebase.google.com/docs/database/web/lists-of-data#data-order
        return MIN_PUSH_CHAR;
    }
    const keyAsInt = tryParseInt(key);
    if (keyAsInt != null) {
        return '' + (keyAsInt + 1);
    }
    const next = new Array(key.length);
    for (let i = 0; i < next.length; i++) {
        next[i] = key.charAt(i);
    }
    if (next.length < MAX_KEY_LEN) {
        next.push(MIN_PUSH_CHAR);
        return next.join('');
    }
    let i = next.length - 1;
    while (i >= 0 && next[i] === MAX_PUSH_CHAR) {
        i--;
    }
    // `successor` was called on the largest possible key, so return the
    // MAX_NAME, which sorts larger than all keys.
    if (i === -1) {
        return MAX_NAME;
    }
    const source = next[i];
    const sourcePlusOne = PUSH_CHARS.charAt(PUSH_CHARS.indexOf(source) + 1);
    next[i] = sourcePlusOne;
    return next.slice(0, i + 1).join('');
};
// `key` is assumed to be non-empty.
const predecessor = function (key) {
    if (key === '' + INTEGER_32_MIN) {
        return MIN_NAME;
    }
    const keyAsInt = tryParseInt(key);
    if (keyAsInt != null) {
        return '' + (keyAsInt - 1);
    }
    const next = new Array(key.length);
    for (let i = 0; i < next.length; i++) {
        next[i] = key.charAt(i);
    }
    // If `key` ends in `MIN_PUSH_CHAR`, the largest key lexicographically
    // smaller than `key`, is `key[0:key.length - 1]`. The next key smaller
    // than that, `predecessor(predecessor(key))`, is
    //
    // `key[0:key.length - 2] + (key[key.length - 1] - 1) + \
    //   { MAX_PUSH_CHAR repeated MAX_KEY_LEN - (key.length - 1) times }
    //
    // analogous to increment/decrement for base-10 integers.
    //
    // This works because lexigographic comparison works character-by-character,
    // using length as a tie-breaker if one key is a prefix of the other.
    if (next[next.length - 1] === MIN_PUSH_CHAR) {
        if (next.length === 1) {
            // See https://firebase.google.com/docs/database/web/lists-of-data#orderbykey
            return '' + INTEGER_32_MAX;
        }
        delete next[next.length - 1];
        return next.join('');
    }
    // Replace the last character with it's immediate predecessor, and
    // fill the suffix of the key with MAX_PUSH_CHAR. This is the
    // lexicographically largest possible key smaller than `key`.
    next[next.length - 1] = PUSH_CHARS.charAt(PUSH_CHARS.indexOf(next[next.length - 1]) - 1);
    return next.join('') + MAX_PUSH_CHAR.repeat(MAX_KEY_LEN - next.length);
};

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function changeValue(snapshotNode) {
    return { type: "value" /* VALUE */, snapshotNode };
}
function changeChildAdded(childName, snapshotNode) {
    return { type: "child_added" /* CHILD_ADDED */, snapshotNode, childName };
}
function changeChildRemoved(childName, snapshotNode) {
    return { type: "child_removed" /* CHILD_REMOVED */, snapshotNode, childName };
}
function changeChildChanged(childName, snapshotNode, oldSnap) {
    return {
        type: "child_changed" /* CHILD_CHANGED */,
        snapshotNode,
        childName,
        oldSnap
    };
}
function changeChildMoved(childName, snapshotNode) {
    return { type: "child_moved" /* CHILD_MOVED */, snapshotNode, childName };
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Doesn't really filter nodes but applies an index to the node and keeps track of any changes
 */
class IndexedFilter {
    constructor(index_) {
        this.index_ = index_;
    }
    updateChild(snap, key, newChild, affectedPath, source, optChangeAccumulator) {
        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(snap.isIndexed(this.index_), 'A node must be indexed if only a child is updated');
        const oldChild = snap.getImmediateChild(key);
        // Check if anything actually changed.
        if (oldChild.getChild(affectedPath).equals(newChild.getChild(affectedPath))) {
            // There's an edge case where a child can enter or leave the view because affectedPath was set to null.
            // In this case, affectedPath will appear null in both the old and new snapshots.  So we need
            // to avoid treating these cases as "nothing changed."
            if (oldChild.isEmpty() === newChild.isEmpty()) {
                // Nothing changed.
                // This assert should be valid, but it's expensive (can dominate perf testing) so don't actually do it.
                //assert(oldChild.equals(newChild), 'Old and new snapshots should be equal.');
                return snap;
            }
        }
        if (optChangeAccumulator != null) {
            if (newChild.isEmpty()) {
                if (snap.hasChild(key)) {
                    optChangeAccumulator.trackChildChange(changeChildRemoved(key, oldChild));
                }
                else {
                    (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(snap.isLeafNode(), 'A child remove without an old child only makes sense on a leaf node');
                }
            }
            else if (oldChild.isEmpty()) {
                optChangeAccumulator.trackChildChange(changeChildAdded(key, newChild));
            }
            else {
                optChangeAccumulator.trackChildChange(changeChildChanged(key, newChild, oldChild));
            }
        }
        if (snap.isLeafNode() && newChild.isEmpty()) {
            return snap;
        }
        else {
            // Make sure the node is indexed
            return snap.updateImmediateChild(key, newChild).withIndex(this.index_);
        }
    }
    updateFullNode(oldSnap, newSnap, optChangeAccumulator) {
        if (optChangeAccumulator != null) {
            if (!oldSnap.isLeafNode()) {
                oldSnap.forEachChild(PRIORITY_INDEX, (key, childNode) => {
                    if (!newSnap.hasChild(key)) {
                        optChangeAccumulator.trackChildChange(changeChildRemoved(key, childNode));
                    }
                });
            }
            if (!newSnap.isLeafNode()) {
                newSnap.forEachChild(PRIORITY_INDEX, (key, childNode) => {
                    if (oldSnap.hasChild(key)) {
                        const oldChild = oldSnap.getImmediateChild(key);
                        if (!oldChild.equals(childNode)) {
                            optChangeAccumulator.trackChildChange(changeChildChanged(key, childNode, oldChild));
                        }
                    }
                    else {
                        optChangeAccumulator.trackChildChange(changeChildAdded(key, childNode));
                    }
                });
            }
        }
        return newSnap.withIndex(this.index_);
    }
    updatePriority(oldSnap, newPriority) {
        if (oldSnap.isEmpty()) {
            return ChildrenNode.EMPTY_NODE;
        }
        else {
            return oldSnap.updatePriority(newPriority);
        }
    }
    filtersNodes() {
        return false;
    }
    getIndexedFilter() {
        return this;
    }
    getIndex() {
        return this.index_;
    }
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Filters nodes by range and uses an IndexFilter to track any changes after filtering the node
 */
class RangedFilter {
    constructor(params) {
        this.indexedFilter_ = new IndexedFilter(params.getIndex());
        this.index_ = params.getIndex();
        this.startPost_ = RangedFilter.getStartPost_(params);
        this.endPost_ = RangedFilter.getEndPost_(params);
    }
    getStartPost() {
        return this.startPost_;
    }
    getEndPost() {
        return this.endPost_;
    }
    matches(node) {
        return (this.index_.compare(this.getStartPost(), node) <= 0 &&
            this.index_.compare(node, this.getEndPost()) <= 0);
    }
    updateChild(snap, key, newChild, affectedPath, source, optChangeAccumulator) {
        if (!this.matches(new NamedNode(key, newChild))) {
            newChild = ChildrenNode.EMPTY_NODE;
        }
        return this.indexedFilter_.updateChild(snap, key, newChild, affectedPath, source, optChangeAccumulator);
    }
    updateFullNode(oldSnap, newSnap, optChangeAccumulator) {
        if (newSnap.isLeafNode()) {
            // Make sure we have a children node with the correct index, not a leaf node;
            newSnap = ChildrenNode.EMPTY_NODE;
        }
        let filtered = newSnap.withIndex(this.index_);
        // Don't support priorities on queries
        filtered = filtered.updatePriority(ChildrenNode.EMPTY_NODE);
        const self = this;
        newSnap.forEachChild(PRIORITY_INDEX, (key, childNode) => {
            if (!self.matches(new NamedNode(key, childNode))) {
                filtered = filtered.updateImmediateChild(key, ChildrenNode.EMPTY_NODE);
            }
        });
        return this.indexedFilter_.updateFullNode(oldSnap, filtered, optChangeAccumulator);
    }
    updatePriority(oldSnap, newPriority) {
        // Don't support priorities on queries
        return oldSnap;
    }
    filtersNodes() {
        return true;
    }
    getIndexedFilter() {
        return this.indexedFilter_;
    }
    getIndex() {
        return this.index_;
    }
    static getStartPost_(params) {
        if (params.hasStart()) {
            const startName = params.getIndexStartName();
            return params.getIndex().makePost(params.getIndexStartValue(), startName);
        }
        else {
            return params.getIndex().minPost();
        }
    }
    static getEndPost_(params) {
        if (params.hasEnd()) {
            const endName = params.getIndexEndName();
            return params.getIndex().makePost(params.getIndexEndValue(), endName);
        }
        else {
            return params.getIndex().maxPost();
        }
    }
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Applies a limit and a range to a node and uses RangedFilter to do the heavy lifting where possible
 */
class LimitedFilter {
    constructor(params) {
        this.rangedFilter_ = new RangedFilter(params);
        this.index_ = params.getIndex();
        this.limit_ = params.getLimit();
        this.reverse_ = !params.isViewFromLeft();
    }
    updateChild(snap, key, newChild, affectedPath, source, optChangeAccumulator) {
        if (!this.rangedFilter_.matches(new NamedNode(key, newChild))) {
            newChild = ChildrenNode.EMPTY_NODE;
        }
        if (snap.getImmediateChild(key).equals(newChild)) {
            // No change
            return snap;
        }
        else if (snap.numChildren() < this.limit_) {
            return this.rangedFilter_
                .getIndexedFilter()
                .updateChild(snap, key, newChild, affectedPath, source, optChangeAccumulator);
        }
        else {
            return this.fullLimitUpdateChild_(snap, key, newChild, source, optChangeAccumulator);
        }
    }
    updateFullNode(oldSnap, newSnap, optChangeAccumulator) {
        let filtered;
        if (newSnap.isLeafNode() || newSnap.isEmpty()) {
            // Make sure we have a children node with the correct index, not a leaf node;
            filtered = ChildrenNode.EMPTY_NODE.withIndex(this.index_);
        }
        else {
            if (this.limit_ * 2 < newSnap.numChildren() &&
                newSnap.isIndexed(this.index_)) {
                // Easier to build up a snapshot, since what we're given has more than twice the elements we want
                filtered = ChildrenNode.EMPTY_NODE.withIndex(this.index_);
                // anchor to the startPost, endPost, or last element as appropriate
                let iterator;
                if (this.reverse_) {
                    iterator = newSnap.getReverseIteratorFrom(this.rangedFilter_.getEndPost(), this.index_);
                }
                else {
                    iterator = newSnap.getIteratorFrom(this.rangedFilter_.getStartPost(), this.index_);
                }
                let count = 0;
                while (iterator.hasNext() && count < this.limit_) {
                    const next = iterator.getNext();
                    let inRange;
                    if (this.reverse_) {
                        inRange =
                            this.index_.compare(this.rangedFilter_.getStartPost(), next) <= 0;
                    }
                    else {
                        inRange =
                            this.index_.compare(next, this.rangedFilter_.getEndPost()) <= 0;
                    }
                    if (inRange) {
                        filtered = filtered.updateImmediateChild(next.name, next.node);
                        count++;
                    }
                    else {
                        // if we have reached the end post, we cannot keep adding elemments
                        break;
                    }
                }
            }
            else {
                // The snap contains less than twice the limit. Faster to delete from the snap than build up a new one
                filtered = newSnap.withIndex(this.index_);
                // Don't support priorities on queries
                filtered = filtered.updatePriority(ChildrenNode.EMPTY_NODE);
                let startPost;
                let endPost;
                let cmp;
                let iterator;
                if (this.reverse_) {
                    iterator = filtered.getReverseIterator(this.index_);
                    startPost = this.rangedFilter_.getEndPost();
                    endPost = this.rangedFilter_.getStartPost();
                    const indexCompare = this.index_.getCompare();
                    cmp = (a, b) => indexCompare(b, a);
                }
                else {
                    iterator = filtered.getIterator(this.index_);
                    startPost = this.rangedFilter_.getStartPost();
                    endPost = this.rangedFilter_.getEndPost();
                    cmp = this.index_.getCompare();
                }
                let count = 0;
                let foundStartPost = false;
                while (iterator.hasNext()) {
                    const next = iterator.getNext();
                    if (!foundStartPost && cmp(startPost, next) <= 0) {
                        // start adding
                        foundStartPost = true;
                    }
                    const inRange = foundStartPost && count < this.limit_ && cmp(next, endPost) <= 0;
                    if (inRange) {
                        count++;
                    }
                    else {
                        filtered = filtered.updateImmediateChild(next.name, ChildrenNode.EMPTY_NODE);
                    }
                }
            }
        }
        return this.rangedFilter_
            .getIndexedFilter()
            .updateFullNode(oldSnap, filtered, optChangeAccumulator);
    }
    updatePriority(oldSnap, newPriority) {
        // Don't support priorities on queries
        return oldSnap;
    }
    filtersNodes() {
        return true;
    }
    getIndexedFilter() {
        return this.rangedFilter_.getIndexedFilter();
    }
    getIndex() {
        return this.index_;
    }
    fullLimitUpdateChild_(snap, childKey, childSnap, source, changeAccumulator) {
        // TODO: rename all cache stuff etc to general snap terminology
        let cmp;
        if (this.reverse_) {
            const indexCmp = this.index_.getCompare();
            cmp = (a, b) => indexCmp(b, a);
        }
        else {
            cmp = this.index_.getCompare();
        }
        const oldEventCache = snap;
        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(oldEventCache.numChildren() === this.limit_, '');
        const newChildNamedNode = new NamedNode(childKey, childSnap);
        const windowBoundary = this.reverse_
            ? oldEventCache.getFirstChild(this.index_)
            : oldEventCache.getLastChild(this.index_);
        const inRange = this.rangedFilter_.matches(newChildNamedNode);
        if (oldEventCache.hasChild(childKey)) {
            const oldChildSnap = oldEventCache.getImmediateChild(childKey);
            let nextChild = source.getChildAfterChild(this.index_, windowBoundary, this.reverse_);
            while (nextChild != null &&
                (nextChild.name === childKey || oldEventCache.hasChild(nextChild.name))) {
                // There is a weird edge case where a node is updated as part of a merge in the write tree, but hasn't
                // been applied to the limited filter yet. Ignore this next child which will be updated later in
                // the limited filter...
                nextChild = source.getChildAfterChild(this.index_, nextChild, this.reverse_);
            }
            const compareNext = nextChild == null ? 1 : cmp(nextChild, newChildNamedNode);
            const remainsInWindow = inRange && !childSnap.isEmpty() && compareNext >= 0;
            if (remainsInWindow) {
                if (changeAccumulator != null) {
                    changeAccumulator.trackChildChange(changeChildChanged(childKey, childSnap, oldChildSnap));
                }
                return oldEventCache.updateImmediateChild(childKey, childSnap);
            }
            else {
                if (changeAccumulator != null) {
                    changeAccumulator.trackChildChange(changeChildRemoved(childKey, oldChildSnap));
                }
                const newEventCache = oldEventCache.updateImmediateChild(childKey, ChildrenNode.EMPTY_NODE);
                const nextChildInRange = nextChild != null && this.rangedFilter_.matches(nextChild);
                if (nextChildInRange) {
                    if (changeAccumulator != null) {
                        changeAccumulator.trackChildChange(changeChildAdded(nextChild.name, nextChild.node));
                    }
                    return newEventCache.updateImmediateChild(nextChild.name, nextChild.node);
                }
                else {
                    return newEventCache;
                }
            }
        }
        else if (childSnap.isEmpty()) {
            // we're deleting a node, but it was not in the window, so ignore it
            return snap;
        }
        else if (inRange) {
            if (cmp(windowBoundary, newChildNamedNode) >= 0) {
                if (changeAccumulator != null) {
                    changeAccumulator.trackChildChange(changeChildRemoved(windowBoundary.name, windowBoundary.node));
                    changeAccumulator.trackChildChange(changeChildAdded(childKey, childSnap));
                }
                return oldEventCache
                    .updateImmediateChild(childKey, childSnap)
                    .updateImmediateChild(windowBoundary.name, ChildrenNode.EMPTY_NODE);
            }
            else {
                return snap;
            }
        }
        else {
            return snap;
        }
    }
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * This class is an immutable-from-the-public-api struct containing a set of query parameters defining a
 * range to be returned for a particular location. It is assumed that validation of parameters is done at the
 * user-facing API level, so it is not done here.
 *
 * @internal
 */
class QueryParams {
    constructor() {
        this.limitSet_ = false;
        this.startSet_ = false;
        this.startNameSet_ = false;
        this.startAfterSet_ = false;
        this.endSet_ = false;
        this.endNameSet_ = false;
        this.endBeforeSet_ = false;
        this.limit_ = 0;
        this.viewFrom_ = '';
        this.indexStartValue_ = null;
        this.indexStartName_ = '';
        this.indexEndValue_ = null;
        this.indexEndName_ = '';
        this.index_ = PRIORITY_INDEX;
    }
    hasStart() {
        return this.startSet_;
    }
    hasStartAfter() {
        return this.startAfterSet_;
    }
    hasEndBefore() {
        return this.endBeforeSet_;
    }
    /**
     * @returns True if it would return from left.
     */
    isViewFromLeft() {
        if (this.viewFrom_ === '') {
            // limit(), rather than limitToFirst or limitToLast was called.
            // This means that only one of startSet_ and endSet_ is true. Use them
            // to calculate which side of the view to anchor to. If neither is set,
            // anchor to the end.
            return this.startSet_;
        }
        else {
            return this.viewFrom_ === "l" /* VIEW_FROM_LEFT */;
        }
    }
    /**
     * Only valid to call if hasStart() returns true
     */
    getIndexStartValue() {
        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(this.startSet_, 'Only valid if start has been set');
        return this.indexStartValue_;
    }
    /**
     * Only valid to call if hasStart() returns true.
     * Returns the starting key name for the range defined by these query parameters
     */
    getIndexStartName() {
        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(this.startSet_, 'Only valid if start has been set');
        if (this.startNameSet_) {
            return this.indexStartName_;
        }
        else {
            return MIN_NAME;
        }
    }
    hasEnd() {
        return this.endSet_;
    }
    /**
     * Only valid to call if hasEnd() returns true.
     */
    getIndexEndValue() {
        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(this.endSet_, 'Only valid if end has been set');
        return this.indexEndValue_;
    }
    /**
     * Only valid to call if hasEnd() returns true.
     * Returns the end key name for the range defined by these query parameters
     */
    getIndexEndName() {
        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(this.endSet_, 'Only valid if end has been set');
        if (this.endNameSet_) {
            return this.indexEndName_;
        }
        else {
            return MAX_NAME;
        }
    }
    hasLimit() {
        return this.limitSet_;
    }
    /**
     * @returns True if a limit has been set and it has been explicitly anchored
     */
    hasAnchoredLimit() {
        return this.limitSet_ && this.viewFrom_ !== '';
    }
    /**
     * Only valid to call if hasLimit() returns true
     */
    getLimit() {
        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(this.limitSet_, 'Only valid if limit has been set');
        return this.limit_;
    }
    getIndex() {
        return this.index_;
    }
    loadsAllData() {
        return !(this.startSet_ || this.endSet_ || this.limitSet_);
    }
    isDefault() {
        return this.loadsAllData() && this.index_ === PRIORITY_INDEX;
    }
    copy() {
        const copy = new QueryParams();
        copy.limitSet_ = this.limitSet_;
        copy.limit_ = this.limit_;
        copy.startSet_ = this.startSet_;
        copy.indexStartValue_ = this.indexStartValue_;
        copy.startNameSet_ = this.startNameSet_;
        copy.indexStartName_ = this.indexStartName_;
        copy.endSet_ = this.endSet_;
        copy.indexEndValue_ = this.indexEndValue_;
        copy.endNameSet_ = this.endNameSet_;
        copy.indexEndName_ = this.indexEndName_;
        copy.index_ = this.index_;
        copy.viewFrom_ = this.viewFrom_;
        return copy;
    }
}
function queryParamsGetNodeFilter(queryParams) {
    if (queryParams.loadsAllData()) {
        return new IndexedFilter(queryParams.getIndex());
    }
    else if (queryParams.hasLimit()) {
        return new LimitedFilter(queryParams);
    }
    else {
        return new RangedFilter(queryParams);
    }
}
function queryParamsLimitToFirst(queryParams, newLimit) {
    const newParams = queryParams.copy();
    newParams.limitSet_ = true;
    newParams.limit_ = newLimit;
    newParams.viewFrom_ = "l" /* VIEW_FROM_LEFT */;
    return newParams;
}
function queryParamsLimitToLast(queryParams, newLimit) {
    const newParams = queryParams.copy();
    newParams.limitSet_ = true;
    newParams.limit_ = newLimit;
    newParams.viewFrom_ = "r" /* VIEW_FROM_RIGHT */;
    return newParams;
}
function queryParamsStartAt(queryParams, indexValue, key) {
    const newParams = queryParams.copy();
    newParams.startSet_ = true;
    if (indexValue === undefined) {
        indexValue = null;
    }
    newParams.indexStartValue_ = indexValue;
    if (key != null) {
        newParams.startNameSet_ = true;
        newParams.indexStartName_ = key;
    }
    else {
        newParams.startNameSet_ = false;
        newParams.indexStartName_ = '';
    }
    return newParams;
}
function queryParamsStartAfter(queryParams, indexValue, key) {
    let params;
    if (queryParams.index_ === KEY_INDEX) {
        if (typeof indexValue === 'string') {
            indexValue = successor(indexValue);
        }
        params = queryParamsStartAt(queryParams, indexValue, key);
    }
    else {
        let childKey;
        if (key == null) {
            childKey = MAX_NAME;
        }
        else {
            childKey = successor(key);
        }
        params = queryParamsStartAt(queryParams, indexValue, childKey);
    }
    params.startAfterSet_ = true;
    return params;
}
function queryParamsEndAt(queryParams, indexValue, key) {
    const newParams = queryParams.copy();
    newParams.endSet_ = true;
    if (indexValue === undefined) {
        indexValue = null;
    }
    newParams.indexEndValue_ = indexValue;
    if (key !== undefined) {
        newParams.endNameSet_ = true;
        newParams.indexEndName_ = key;
    }
    else {
        newParams.endNameSet_ = false;
        newParams.indexEndName_ = '';
    }
    return newParams;
}
function queryParamsEndBefore(queryParams, indexValue, key) {
    let childKey;
    let params;
    if (queryParams.index_ === KEY_INDEX) {
        if (typeof indexValue === 'string') {
            indexValue = predecessor(indexValue);
        }
        params = queryParamsEndAt(queryParams, indexValue, key);
    }
    else {
        if (key == null) {
            childKey = MIN_NAME;
        }
        else {
            childKey = predecessor(key);
        }
        params = queryParamsEndAt(queryParams, indexValue, childKey);
    }
    params.endBeforeSet_ = true;
    return params;
}
function queryParamsOrderBy(queryParams, index) {
    const newParams = queryParams.copy();
    newParams.index_ = index;
    return newParams;
}
/**
 * Returns a set of REST query string parameters representing this query.
 *
 * @returns query string parameters
 */
function queryParamsToRestQueryStringParameters(queryParams) {
    const qs = {};
    if (queryParams.isDefault()) {
        return qs;
    }
    let orderBy;
    if (queryParams.index_ === PRIORITY_INDEX) {
        orderBy = "$priority" /* PRIORITY_INDEX */;
    }
    else if (queryParams.index_ === VALUE_INDEX) {
        orderBy = "$value" /* VALUE_INDEX */;
    }
    else if (queryParams.index_ === KEY_INDEX) {
        orderBy = "$key" /* KEY_INDEX */;
    }
    else {
        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(queryParams.index_ instanceof PathIndex, 'Unrecognized index type!');
        orderBy = queryParams.index_.toString();
    }
    qs["orderBy" /* ORDER_BY */] = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.stringify)(orderBy);
    if (queryParams.startSet_) {
        qs["startAt" /* START_AT */] = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.stringify)(queryParams.indexStartValue_);
        if (queryParams.startNameSet_) {
            qs["startAt" /* START_AT */] +=
                ',' + (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.stringify)(queryParams.indexStartName_);
        }
    }
    if (queryParams.endSet_) {
        qs["endAt" /* END_AT */] = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.stringify)(queryParams.indexEndValue_);
        if (queryParams.endNameSet_) {
            qs["endAt" /* END_AT */] +=
                ',' + (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.stringify)(queryParams.indexEndName_);
        }
    }
    if (queryParams.limitSet_) {
        if (queryParams.isViewFromLeft()) {
            qs["limitToFirst" /* LIMIT_TO_FIRST */] = queryParams.limit_;
        }
        else {
            qs["limitToLast" /* LIMIT_TO_LAST */] = queryParams.limit_;
        }
    }
    return qs;
}
function queryParamsGetQueryObject(queryParams) {
    const obj = {};
    if (queryParams.startSet_) {
        obj["sp" /* INDEX_START_VALUE */] =
            queryParams.indexStartValue_;
        if (queryParams.startNameSet_) {
            obj["sn" /* INDEX_START_NAME */] =
                queryParams.indexStartName_;
        }
    }
    if (queryParams.endSet_) {
        obj["ep" /* INDEX_END_VALUE */] = queryParams.indexEndValue_;
        if (queryParams.endNameSet_) {
            obj["en" /* INDEX_END_NAME */] = queryParams.indexEndName_;
        }
    }
    if (queryParams.limitSet_) {
        obj["l" /* LIMIT */] = queryParams.limit_;
        let viewFrom = queryParams.viewFrom_;
        if (viewFrom === '') {
            if (queryParams.isViewFromLeft()) {
                viewFrom = "l" /* VIEW_FROM_LEFT */;
            }
            else {
                viewFrom = "r" /* VIEW_FROM_RIGHT */;
            }
        }
        obj["vf" /* VIEW_FROM */] = viewFrom;
    }
    // For now, priority index is the default, so we only specify if it's some other index
    if (queryParams.index_ !== PRIORITY_INDEX) {
        obj["i" /* INDEX */] = queryParams.index_.toString();
    }
    return obj;
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * An implementation of ServerActions that communicates with the server via REST requests.
 * This is mostly useful for compatibility with crawlers, where we don't want to spin up a full
 * persistent connection (using WebSockets or long-polling)
 */
class ReadonlyRestClient extends ServerActions {
    /**
     * @param repoInfo_ - Data about the namespace we are connecting to
     * @param onDataUpdate_ - A callback for new data from the server
     */
    constructor(repoInfo_, onDataUpdate_, authTokenProvider_, appCheckTokenProvider_) {
        super();
        this.repoInfo_ = repoInfo_;
        this.onDataUpdate_ = onDataUpdate_;
        this.authTokenProvider_ = authTokenProvider_;
        this.appCheckTokenProvider_ = appCheckTokenProvider_;
        /** @private {function(...[*])} */
        this.log_ = logWrapper('p:rest:');
        /**
         * We don't actually need to track listens, except to prevent us calling an onComplete for a listen
         * that's been removed. :-/
         */
        this.listens_ = {};
    }
    reportStats(stats) {
        throw new Error('Method not implemented.');
    }
    static getListenId_(query, tag) {
        if (tag !== undefined) {
            return 'tag$' + tag;
        }
        else {
            (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(query._queryParams.isDefault(), "should have a tag if it's not a default query.");
            return query._path.toString();
        }
    }
    /** @inheritDoc */
    listen(query, currentHashFn, tag, onComplete) {
        const pathString = query._path.toString();
        this.log_('Listen called for ' + pathString + ' ' + query._queryIdentifier);
        // Mark this listener so we can tell if it's removed.
        const listenId = ReadonlyRestClient.getListenId_(query, tag);
        const thisListen = {};
        this.listens_[listenId] = thisListen;
        const queryStringParameters = queryParamsToRestQueryStringParameters(query._queryParams);
        this.restRequest_(pathString + '.json', queryStringParameters, (error, result) => {
            let data = result;
            if (error === 404) {
                data = null;
                error = null;
            }
            if (error === null) {
                this.onDataUpdate_(pathString, data, /*isMerge=*/ false, tag);
            }
            if ((0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.safeGet)(this.listens_, listenId) === thisListen) {
                let status;
                if (!error) {
                    status = 'ok';
                }
                else if (error === 401) {
                    status = 'permission_denied';
                }
                else {
                    status = 'rest_error:' + error;
                }
                onComplete(status, null);
            }
        });
    }
    /** @inheritDoc */
    unlisten(query, tag) {
        const listenId = ReadonlyRestClient.getListenId_(query, tag);
        delete this.listens_[listenId];
    }
    get(query) {
        const queryStringParameters = queryParamsToRestQueryStringParameters(query._queryParams);
        const pathString = query._path.toString();
        const deferred = new _firebase_util__WEBPACK_IMPORTED_MODULE_2__.Deferred();
        this.restRequest_(pathString + '.json', queryStringParameters, (error, result) => {
            let data = result;
            if (error === 404) {
                data = null;
                error = null;
            }
            if (error === null) {
                this.onDataUpdate_(pathString, data, 
                /*isMerge=*/ false, 
                /*tag=*/ null);
                deferred.resolve(data);
            }
            else {
                deferred.reject(new Error(data));
            }
        });
        return deferred.promise;
    }
    /** @inheritDoc */
    refreshAuthToken(token) {
        // no-op since we just always call getToken.
    }
    /**
     * Performs a REST request to the given path, with the provided query string parameters,
     * and any auth credentials we have.
     */
    restRequest_(pathString, queryStringParameters = {}, callback) {
        queryStringParameters['format'] = 'export';
        return Promise.all([
            this.authTokenProvider_.getToken(/*forceRefresh=*/ false),
            this.appCheckTokenProvider_.getToken(/*forceRefresh=*/ false)
        ]).then(([authToken, appCheckToken]) => {
            if (authToken && authToken.accessToken) {
                queryStringParameters['auth'] = authToken.accessToken;
            }
            if (appCheckToken && appCheckToken.token) {
                queryStringParameters['ac'] = appCheckToken.token;
            }
            const url = (this.repoInfo_.secure ? 'https://' : 'http://') +
                this.repoInfo_.host +
                pathString +
                '?' +
                'ns=' +
                this.repoInfo_.namespace +
                (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.querystring)(queryStringParameters);
            this.log_('Sending REST request for ' + url);
            const xhr = new XMLHttpRequest();
            xhr.onreadystatechange = () => {
                if (callback && xhr.readyState === 4) {
                    this.log_('REST Response for ' + url + ' received. status:', xhr.status, 'response:', xhr.responseText);
                    let res = null;
                    if (xhr.status >= 200 && xhr.status < 300) {
                        try {
                            res = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.jsonEval)(xhr.responseText);
                        }
                        catch (e) {
                            warn('Failed to parse JSON response for ' +
                                url +
                                ': ' +
                                xhr.responseText);
                        }
                        callback(null, res);
                    }
                    else {
                        // 401 and 404 are expected.
                        if (xhr.status !== 401 && xhr.status !== 404) {
                            warn('Got unsuccessful REST response for ' +
                                url +
                                ' Status: ' +
                                xhr.status);
                        }
                        callback(xhr.status);
                    }
                    callback = null;
                }
            };
            xhr.open('GET', url, /*asynchronous=*/ true);
            xhr.send();
        });
    }
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Mutable object which basically just stores a reference to the "latest" immutable snapshot.
 */
class SnapshotHolder {
    constructor() {
        this.rootNode_ = ChildrenNode.EMPTY_NODE;
    }
    getNode(path) {
        return this.rootNode_.getChild(path);
    }
    updateSnapshot(path, newSnapshotNode) {
        this.rootNode_ = this.rootNode_.updateChild(path, newSnapshotNode);
    }
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function newSparseSnapshotTree() {
    return {
        value: null,
        children: new Map()
    };
}
/**
 * Stores the given node at the specified path. If there is already a node
 * at a shallower path, it merges the new data into that snapshot node.
 *
 * @param path - Path to look up snapshot for.
 * @param data - The new data, or null.
 */
function sparseSnapshotTreeRemember(sparseSnapshotTree, path, data) {
    if (pathIsEmpty(path)) {
        sparseSnapshotTree.value = data;
        sparseSnapshotTree.children.clear();
    }
    else if (sparseSnapshotTree.value !== null) {
        sparseSnapshotTree.value = sparseSnapshotTree.value.updateChild(path, data);
    }
    else {
        const childKey = pathGetFront(path);
        if (!sparseSnapshotTree.children.has(childKey)) {
            sparseSnapshotTree.children.set(childKey, newSparseSnapshotTree());
        }
        const child = sparseSnapshotTree.children.get(childKey);
        path = pathPopFront(path);
        sparseSnapshotTreeRemember(child, path, data);
    }
}
/**
 * Purge the data at path from the cache.
 *
 * @param path - Path to look up snapshot for.
 * @returns True if this node should now be removed.
 */
function sparseSnapshotTreeForget(sparseSnapshotTree, path) {
    if (pathIsEmpty(path)) {
        sparseSnapshotTree.value = null;
        sparseSnapshotTree.children.clear();
        return true;
    }
    else {
        if (sparseSnapshotTree.value !== null) {
            if (sparseSnapshotTree.value.isLeafNode()) {
                // We're trying to forget a node that doesn't exist
                return false;
            }
            else {
                const value = sparseSnapshotTree.value;
                sparseSnapshotTree.value = null;
                value.forEachChild(PRIORITY_INDEX, (key, tree) => {
                    sparseSnapshotTreeRemember(sparseSnapshotTree, new Path(key), tree);
                });
                return sparseSnapshotTreeForget(sparseSnapshotTree, path);
            }
        }
        else if (sparseSnapshotTree.children.size > 0) {
            const childKey = pathGetFront(path);
            path = pathPopFront(path);
            if (sparseSnapshotTree.children.has(childKey)) {
                const safeToRemove = sparseSnapshotTreeForget(sparseSnapshotTree.children.get(childKey), path);
                if (safeToRemove) {
                    sparseSnapshotTree.children.delete(childKey);
                }
            }
            return sparseSnapshotTree.children.size === 0;
        }
        else {
            return true;
        }
    }
}
/**
 * Recursively iterates through all of the stored tree and calls the
 * callback on each one.
 *
 * @param prefixPath - Path to look up node for.
 * @param func - The function to invoke for each tree.
 */
function sparseSnapshotTreeForEachTree(sparseSnapshotTree, prefixPath, func) {
    if (sparseSnapshotTree.value !== null) {
        func(prefixPath, sparseSnapshotTree.value);
    }
    else {
        sparseSnapshotTreeForEachChild(sparseSnapshotTree, (key, tree) => {
            const path = new Path(prefixPath.toString() + '/' + key);
            sparseSnapshotTreeForEachTree(tree, path, func);
        });
    }
}
/**
 * Iterates through each immediate child and triggers the callback.
 * Only seems to be used in tests.
 *
 * @param func - The function to invoke for each child.
 */
function sparseSnapshotTreeForEachChild(sparseSnapshotTree, func) {
    sparseSnapshotTree.children.forEach((tree, key) => {
        func(key, tree);
    });
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Returns the delta from the previous call to get stats.
 *
 * @param collection_ - The collection to "listen" to.
 */
class StatsListener {
    constructor(collection_) {
        this.collection_ = collection_;
        this.last_ = null;
    }
    get() {
        const newStats = this.collection_.get();
        const delta = Object.assign({}, newStats);
        if (this.last_) {
            each(this.last_, (stat, value) => {
                delta[stat] = delta[stat] - value;
            });
        }
        this.last_ = newStats;
        return delta;
    }
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Assuming some apps may have a short amount of time on page, and a bulk of firebase operations probably
// happen on page load, we try to report our first set of stats pretty quickly, but we wait at least 10
// seconds to try to ensure the Firebase connection is established / settled.
const FIRST_STATS_MIN_TIME = 10 * 1000;
const FIRST_STATS_MAX_TIME = 30 * 1000;
// We'll continue to report stats on average every 5 minutes.
const REPORT_STATS_INTERVAL = 5 * 60 * 1000;
class StatsReporter {
    constructor(collection, server_) {
        this.server_ = server_;
        this.statsToReport_ = {};
        this.statsListener_ = new StatsListener(collection);
        const timeout = FIRST_STATS_MIN_TIME +
            (FIRST_STATS_MAX_TIME - FIRST_STATS_MIN_TIME) * Math.random();
        setTimeoutNonBlocking(this.reportStats_.bind(this), Math.floor(timeout));
    }
    reportStats_() {
        const stats = this.statsListener_.get();
        const reportedStats = {};
        let haveStatsToReport = false;
        each(stats, (stat, value) => {
            if (value > 0 && (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.contains)(this.statsToReport_, stat)) {
                reportedStats[stat] = value;
                haveStatsToReport = true;
            }
        });
        if (haveStatsToReport) {
            this.server_.reportStats(reportedStats);
        }
        // queue our next run.
        setTimeoutNonBlocking(this.reportStats_.bind(this), Math.floor(Math.random() * 2 * REPORT_STATS_INTERVAL));
    }
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 *
 * @enum
 */
var OperationType;
(function (OperationType) {
    OperationType[OperationType["OVERWRITE"] = 0] = "OVERWRITE";
    OperationType[OperationType["MERGE"] = 1] = "MERGE";
    OperationType[OperationType["ACK_USER_WRITE"] = 2] = "ACK_USER_WRITE";
    OperationType[OperationType["LISTEN_COMPLETE"] = 3] = "LISTEN_COMPLETE";
})(OperationType || (OperationType = {}));
function newOperationSourceUser() {
    return {
        fromUser: true,
        fromServer: false,
        queryId: null,
        tagged: false
    };
}
function newOperationSourceServer() {
    return {
        fromUser: false,
        fromServer: true,
        queryId: null,
        tagged: false
    };
}
function newOperationSourceServerTaggedQuery(queryId) {
    return {
        fromUser: false,
        fromServer: true,
        queryId,
        tagged: true
    };
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class AckUserWrite {
    /**
     * @param affectedTree - A tree containing true for each affected path. Affected paths can't overlap.
     */
    constructor(
    /** @inheritDoc */ path, 
    /** @inheritDoc */ affectedTree, 
    /** @inheritDoc */ revert) {
        this.path = path;
        this.affectedTree = affectedTree;
        this.revert = revert;
        /** @inheritDoc */
        this.type = OperationType.ACK_USER_WRITE;
        /** @inheritDoc */
        this.source = newOperationSourceUser();
    }
    operationForChild(childName) {
        if (!pathIsEmpty(this.path)) {
            (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(pathGetFront(this.path) === childName, 'operationForChild called for unrelated child.');
            return new AckUserWrite(pathPopFront(this.path), this.affectedTree, this.revert);
        }
        else if (this.affectedTree.value != null) {
            (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(this.affectedTree.children.isEmpty(), 'affectedTree should not have overlapping affected paths.');
            // All child locations are affected as well; just return same operation.
            return this;
        }
        else {
            const childTree = this.affectedTree.subtree(new Path(childName));
            return new AckUserWrite(newEmptyPath(), childTree, this.revert);
        }
    }
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ListenComplete {
    constructor(source, path) {
        this.source = source;
        this.path = path;
        /** @inheritDoc */
        this.type = OperationType.LISTEN_COMPLETE;
    }
    operationForChild(childName) {
        if (pathIsEmpty(this.path)) {
            return new ListenComplete(this.source, newEmptyPath());
        }
        else {
            return new ListenComplete(this.source, pathPopFront(this.path));
        }
    }
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Overwrite {
    constructor(source, path, snap) {
        this.source = source;
        this.path = path;
        this.snap = snap;
        /** @inheritDoc */
        this.type = OperationType.OVERWRITE;
    }
    operationForChild(childName) {
        if (pathIsEmpty(this.path)) {
            return new Overwrite(this.source, newEmptyPath(), this.snap.getImmediateChild(childName));
        }
        else {
            return new Overwrite(this.source, pathPopFront(this.path), this.snap);
        }
    }
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Merge {
    constructor(
    /** @inheritDoc */ source, 
    /** @inheritDoc */ path, 
    /** @inheritDoc */ children) {
        this.source = source;
        this.path = path;
        this.children = children;
        /** @inheritDoc */
        this.type = OperationType.MERGE;
    }
    operationForChild(childName) {
        if (pathIsEmpty(this.path)) {
            const childTree = this.children.subtree(new Path(childName));
            if (childTree.isEmpty()) {
                // This child is unaffected
                return null;
            }
            else if (childTree.value) {
                // We have a snapshot for the child in question.  This becomes an overwrite of the child.
                return new Overwrite(this.source, newEmptyPath(), childTree.value);
            }
            else {
                // This is a merge at a deeper level
                return new Merge(this.source, newEmptyPath(), childTree);
            }
        }
        else {
            (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(pathGetFront(this.path) === childName, "Can't get a merge for a child not on the path of the operation");
            return new Merge(this.source, pathPopFront(this.path), this.children);
        }
    }
    toString() {
        return ('Operation(' +
            this.path +
            ': ' +
            this.source.toString() +
            ' merge: ' +
            this.children.toString() +
            ')');
    }
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * A cache node only stores complete children. Additionally it holds a flag whether the node can be considered fully
 * initialized in the sense that we know at one point in time this represented a valid state of the world, e.g.
 * initialized with data from the server, or a complete overwrite by the client. The filtered flag also tracks
 * whether a node potentially had children removed due to a filter.
 */
class CacheNode {
    constructor(node_, fullyInitialized_, filtered_) {
        this.node_ = node_;
        this.fullyInitialized_ = fullyInitialized_;
        this.filtered_ = filtered_;
    }
    /**
     * Returns whether this node was fully initialized with either server data or a complete overwrite by the client
     */
    isFullyInitialized() {
        return this.fullyInitialized_;
    }
    /**
     * Returns whether this node is potentially missing children due to a filter applied to the node
     */
    isFiltered() {
        return this.filtered_;
    }
    isCompleteForPath(path) {
        if (pathIsEmpty(path)) {
            return this.isFullyInitialized() && !this.filtered_;
        }
        const childKey = pathGetFront(path);
        return this.isCompleteForChild(childKey);
    }
    isCompleteForChild(key) {
        return ((this.isFullyInitialized() && !this.filtered_) || this.node_.hasChild(key));
    }
    getNode() {
        return this.node_;
    }
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * An EventGenerator is used to convert "raw" changes (Change) as computed by the
 * CacheDiffer into actual events (Event) that can be raised.  See generateEventsForChanges()
 * for details.
 *
 */
class EventGenerator {
    constructor(query_) {
        this.query_ = query_;
        this.index_ = this.query_._queryParams.getIndex();
    }
}
/**
 * Given a set of raw changes (no moved events and prevName not specified yet), and a set of
 * EventRegistrations that should be notified of these changes, generate the actual events to be raised.
 *
 * Notes:
 *  - child_moved events will be synthesized at this time for any child_changed events that affect
 *    our index.
 *  - prevName will be calculated based on the index ordering.
 */
function eventGeneratorGenerateEventsForChanges(eventGenerator, changes, eventCache, eventRegistrations) {
    const events = [];
    const moves = [];
    changes.forEach(change => {
        if (change.type === "child_changed" /* CHILD_CHANGED */ &&
            eventGenerator.index_.indexedValueChanged(change.oldSnap, change.snapshotNode)) {
            moves.push(changeChildMoved(change.childName, change.snapshotNode));
        }
    });
    eventGeneratorGenerateEventsForType(eventGenerator, events, "child_removed" /* CHILD_REMOVED */, changes, eventRegistrations, eventCache);
    eventGeneratorGenerateEventsForType(eventGenerator, events, "child_added" /* CHILD_ADDED */, changes, eventRegistrations, eventCache);
    eventGeneratorGenerateEventsForType(eventGenerator, events, "child_moved" /* CHILD_MOVED */, moves, eventRegistrations, eventCache);
    eventGeneratorGenerateEventsForType(eventGenerator, events, "child_changed" /* CHILD_CHANGED */, changes, eventRegistrations, eventCache);
    eventGeneratorGenerateEventsForType(eventGenerator, events, "value" /* VALUE */, changes, eventRegistrations, eventCache);
    return events;
}
/**
 * Given changes of a single change type, generate the corresponding events.
 */
function eventGeneratorGenerateEventsForType(eventGenerator, events, eventType, changes, registrations, eventCache) {
    const filteredChanges = changes.filter(change => change.type === eventType);
    filteredChanges.sort((a, b) => eventGeneratorCompareChanges(eventGenerator, a, b));
    filteredChanges.forEach(change => {
        const materializedChange = eventGeneratorMaterializeSingleChange(eventGenerator, change, eventCache);
        registrations.forEach(registration => {
            if (registration.respondsTo(change.type)) {
                events.push(registration.createEvent(materializedChange, eventGenerator.query_));
            }
        });
    });
}
function eventGeneratorMaterializeSingleChange(eventGenerator, change, eventCache) {
    if (change.type === 'value' || change.type === 'child_removed') {
        return change;
    }
    else {
        change.prevName = eventCache.getPredecessorChildName(change.childName, change.snapshotNode, eventGenerator.index_);
        return change;
    }
}
function eventGeneratorCompareChanges(eventGenerator, a, b) {
    if (a.childName == null || b.childName == null) {
        throw (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assertionError)('Should only compare child_ events.');
    }
    const aWrapped = new NamedNode(a.childName, a.snapshotNode);
    const bWrapped = new NamedNode(b.childName, b.snapshotNode);
    return eventGenerator.index_.compare(aWrapped, bWrapped);
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function newViewCache(eventCache, serverCache) {
    return { eventCache, serverCache };
}
function viewCacheUpdateEventSnap(viewCache, eventSnap, complete, filtered) {
    return newViewCache(new CacheNode(eventSnap, complete, filtered), viewCache.serverCache);
}
function viewCacheUpdateServerSnap(viewCache, serverSnap, complete, filtered) {
    return newViewCache(viewCache.eventCache, new CacheNode(serverSnap, complete, filtered));
}
function viewCacheGetCompleteEventSnap(viewCache) {
    return viewCache.eventCache.isFullyInitialized()
        ? viewCache.eventCache.getNode()
        : null;
}
function viewCacheGetCompleteServerSnap(viewCache) {
    return viewCache.serverCache.isFullyInitialized()
        ? viewCache.serverCache.getNode()
        : null;
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
let emptyChildrenSingleton;
/**
 * Singleton empty children collection.
 *
 */
const EmptyChildren = () => {
    if (!emptyChildrenSingleton) {
        emptyChildrenSingleton = new SortedMap(stringCompare);
    }
    return emptyChildrenSingleton;
};
/**
 * A tree with immutable elements.
 */
class ImmutableTree {
    constructor(value, children = EmptyChildren()) {
        this.value = value;
        this.children = children;
    }
    static fromObject(obj) {
        let tree = new ImmutableTree(null);
        each(obj, (childPath, childSnap) => {
            tree = tree.set(new Path(childPath), childSnap);
        });
        return tree;
    }
    /**
     * True if the value is empty and there are no children
     */
    isEmpty() {
        return this.value === null && this.children.isEmpty();
    }
    /**
     * Given a path and predicate, return the first node and the path to that node
     * where the predicate returns true.
     *
     * TODO Do a perf test -- If we're creating a bunch of `{path: value:}`
     * objects on the way back out, it may be better to pass down a pathSoFar obj.
     *
     * @param relativePath - The remainder of the path
     * @param predicate - The predicate to satisfy to return a node
     */
    findRootMostMatchingPathAndValue(relativePath, predicate) {
        if (this.value != null && predicate(this.value)) {
            return { path: newEmptyPath(), value: this.value };
        }
        else {
            if (pathIsEmpty(relativePath)) {
                return null;
            }
            else {
                const front = pathGetFront(relativePath);
                const child = this.children.get(front);
                if (child !== null) {
                    const childExistingPathAndValue = child.findRootMostMatchingPathAndValue(pathPopFront(relativePath), predicate);
                    if (childExistingPathAndValue != null) {
                        const fullPath = pathChild(new Path(front), childExistingPathAndValue.path);
                        return { path: fullPath, value: childExistingPathAndValue.value };
                    }
                    else {
                        return null;
                    }
                }
                else {
                    return null;
                }
            }
        }
    }
    /**
     * Find, if it exists, the shortest subpath of the given path that points a defined
     * value in the tree
     */
    findRootMostValueAndPath(relativePath) {
        return this.findRootMostMatchingPathAndValue(relativePath, () => true);
    }
    /**
     * @returns The subtree at the given path
     */
    subtree(relativePath) {
        if (pathIsEmpty(relativePath)) {
            return this;
        }
        else {
            const front = pathGetFront(relativePath);
            const childTree = this.children.get(front);
            if (childTree !== null) {
                return childTree.subtree(pathPopFront(relativePath));
            }
            else {
                return new ImmutableTree(null);
            }
        }
    }
    /**
     * Sets a value at the specified path.
     *
     * @param relativePath - Path to set value at.
     * @param toSet - Value to set.
     * @returns Resulting tree.
     */
    set(relativePath, toSet) {
        if (pathIsEmpty(relativePath)) {
            return new ImmutableTree(toSet, this.children);
        }
        else {
            const front = pathGetFront(relativePath);
            const child = this.children.get(front) || new ImmutableTree(null);
            const newChild = child.set(pathPopFront(relativePath), toSet);
            const newChildren = this.children.insert(front, newChild);
            return new ImmutableTree(this.value, newChildren);
        }
    }
    /**
     * Removes the value at the specified path.
     *
     * @param relativePath - Path to value to remove.
     * @returns Resulting tree.
     */
    remove(relativePath) {
        if (pathIsEmpty(relativePath)) {
            if (this.children.isEmpty()) {
                return new ImmutableTree(null);
            }
            else {
                return new ImmutableTree(null, this.children);
            }
        }
        else {
            const front = pathGetFront(relativePath);
            const child = this.children.get(front);
            if (child) {
                const newChild = child.remove(pathPopFront(relativePath));
                let newChildren;
                if (newChild.isEmpty()) {
                    newChildren = this.children.remove(front);
                }
                else {
                    newChildren = this.children.insert(front, newChild);
                }
                if (this.value === null && newChildren.isEmpty()) {
                    return new ImmutableTree(null);
                }
                else {
                    return new ImmutableTree(this.value, newChildren);
                }
            }
            else {
                return this;
            }
        }
    }
    /**
     * Gets a value from the tree.
     *
     * @param relativePath - Path to get value for.
     * @returns Value at path, or null.
     */
    get(relativePath) {
        if (pathIsEmpty(relativePath)) {
            return this.value;
        }
        else {
            const front = pathGetFront(relativePath);
            const child = this.children.get(front);
            if (child) {
                return child.get(pathPopFront(relativePath));
            }
            else {
                return null;
            }
        }
    }
    /**
     * Replace the subtree at the specified path with the given new tree.
     *
     * @param relativePath - Path to replace subtree for.
     * @param newTree - New tree.
     * @returns Resulting tree.
     */
    setTree(relativePath, newTree) {
        if (pathIsEmpty(relativePath)) {
            return newTree;
        }
        else {
            const front = pathGetFront(relativePath);
            const child = this.children.get(front) || new ImmutableTree(null);
            const newChild = child.setTree(pathPopFront(relativePath), newTree);
            let newChildren;
            if (newChild.isEmpty()) {
                newChildren = this.children.remove(front);
            }
            else {
                newChildren = this.children.insert(front, newChild);
            }
            return new ImmutableTree(this.value, newChildren);
        }
    }
    /**
     * Performs a depth first fold on this tree. Transforms a tree into a single
     * value, given a function that operates on the path to a node, an optional
     * current value, and a map of child names to folded subtrees
     */
    fold(fn) {
        return this.fold_(newEmptyPath(), fn);
    }
    /**
     * Recursive helper for public-facing fold() method
     */
    fold_(pathSoFar, fn) {
        const accum = {};
        this.children.inorderTraversal((childKey, childTree) => {
            accum[childKey] = childTree.fold_(pathChild(pathSoFar, childKey), fn);
        });
        return fn(pathSoFar, this.value, accum);
    }
    /**
     * Find the first matching value on the given path. Return the result of applying f to it.
     */
    findOnPath(path, f) {
        return this.findOnPath_(path, newEmptyPath(), f);
    }
    findOnPath_(pathToFollow, pathSoFar, f) {
        const result = this.value ? f(pathSoFar, this.value) : false;
        if (result) {
            return result;
        }
        else {
            if (pathIsEmpty(pathToFollow)) {
                return null;
            }
            else {
                const front = pathGetFront(pathToFollow);
                const nextChild = this.children.get(front);
                if (nextChild) {
                    return nextChild.findOnPath_(pathPopFront(pathToFollow), pathChild(pathSoFar, front), f);
                }
                else {
                    return null;
                }
            }
        }
    }
    foreachOnPath(path, f) {
        return this.foreachOnPath_(path, newEmptyPath(), f);
    }
    foreachOnPath_(pathToFollow, currentRelativePath, f) {
        if (pathIsEmpty(pathToFollow)) {
            return this;
        }
        else {
            if (this.value) {
                f(currentRelativePath, this.value);
            }
            const front = pathGetFront(pathToFollow);
            const nextChild = this.children.get(front);
            if (nextChild) {
                return nextChild.foreachOnPath_(pathPopFront(pathToFollow), pathChild(currentRelativePath, front), f);
            }
            else {
                return new ImmutableTree(null);
            }
        }
    }
    /**
     * Calls the given function for each node in the tree that has a value.
     *
     * @param f - A function to be called with the path from the root of the tree to
     * a node, and the value at that node. Called in depth-first order.
     */
    foreach(f) {
        this.foreach_(newEmptyPath(), f);
    }
    foreach_(currentRelativePath, f) {
        this.children.inorderTraversal((childName, childTree) => {
            childTree.foreach_(pathChild(currentRelativePath, childName), f);
        });
        if (this.value) {
            f(currentRelativePath, this.value);
        }
    }
    foreachChild(f) {
        this.children.inorderTraversal((childName, childTree) => {
            if (childTree.value) {
                f(childName, childTree.value);
            }
        });
    }
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * This class holds a collection of writes that can be applied to nodes in unison. It abstracts away the logic with
 * dealing with priority writes and multiple nested writes. At any given path there is only allowed to be one write
 * modifying that path. Any write to an existing path or shadowing an existing path will modify that existing write
 * to reflect the write added.
 */
class CompoundWrite {
    constructor(writeTree_) {
        this.writeTree_ = writeTree_;
    }
    static empty() {
        return new CompoundWrite(new ImmutableTree(null));
    }
}
function compoundWriteAddWrite(compoundWrite, path, node) {
    if (pathIsEmpty(path)) {
        return new CompoundWrite(new ImmutableTree(node));
    }
    else {
        const rootmost = compoundWrite.writeTree_.findRootMostValueAndPath(path);
        if (rootmost != null) {
            const rootMostPath = rootmost.path;
            let value = rootmost.value;
            const relativePath = newRelativePath(rootMostPath, path);
            value = value.updateChild(relativePath, node);
            return new CompoundWrite(compoundWrite.writeTree_.set(rootMostPath, value));
        }
        else {
            const subtree = new ImmutableTree(node);
            const newWriteTree = compoundWrite.writeTree_.setTree(path, subtree);
            return new CompoundWrite(newWriteTree);
        }
    }
}
function compoundWriteAddWrites(compoundWrite, path, updates) {
    let newWrite = compoundWrite;
    each(updates, (childKey, node) => {
        newWrite = compoundWriteAddWrite(newWrite, pathChild(path, childKey), node);
    });
    return newWrite;
}
/**
 * Will remove a write at the given path and deeper paths. This will <em>not</em> modify a write at a higher
 * location, which must be removed by calling this method with that path.
 *
 * @param compoundWrite - The CompoundWrite to remove.
 * @param path - The path at which a write and all deeper writes should be removed
 * @returns The new CompoundWrite with the removed path
 */
function compoundWriteRemoveWrite(compoundWrite, path) {
    if (pathIsEmpty(path)) {
        return CompoundWrite.empty();
    }
    else {
        const newWriteTree = compoundWrite.writeTree_.setTree(path, new ImmutableTree(null));
        return new CompoundWrite(newWriteTree);
    }
}
/**
 * Returns whether this CompoundWrite will fully overwrite a node at a given location and can therefore be
 * considered "complete".
 *
 * @param compoundWrite - The CompoundWrite to check.
 * @param path - The path to check for
 * @returns Whether there is a complete write at that path
 */
function compoundWriteHasCompleteWrite(compoundWrite, path) {
    return compoundWriteGetCompleteNode(compoundWrite, path) != null;
}
/**
 * Returns a node for a path if and only if the node is a "complete" overwrite at that path. This will not aggregate
 * writes from deeper paths, but will return child nodes from a more shallow path.
 *
 * @param compoundWrite - The CompoundWrite to get the node from.
 * @param path - The path to get a complete write
 * @returns The node if complete at that path, or null otherwise.
 */
function compoundWriteGetCompleteNode(compoundWrite, path) {
    const rootmost = compoundWrite.writeTree_.findRootMostValueAndPath(path);
    if (rootmost != null) {
        return compoundWrite.writeTree_
            .get(rootmost.path)
            .getChild(newRelativePath(rootmost.path, path));
    }
    else {
        return null;
    }
}
/**
 * Returns all children that are guaranteed to be a complete overwrite.
 *
 * @param compoundWrite - The CompoundWrite to get children from.
 * @returns A list of all complete children.
 */
function compoundWriteGetCompleteChildren(compoundWrite) {
    const children = [];
    const node = compoundWrite.writeTree_.value;
    if (node != null) {
        // If it's a leaf node, it has no children; so nothing to do.
        if (!node.isLeafNode()) {
            node.forEachChild(PRIORITY_INDEX, (childName, childNode) => {
                children.push(new NamedNode(childName, childNode));
            });
        }
    }
    else {
        compoundWrite.writeTree_.children.inorderTraversal((childName, childTree) => {
            if (childTree.value != null) {
                children.push(new NamedNode(childName, childTree.value));
            }
        });
    }
    return children;
}
function compoundWriteChildCompoundWrite(compoundWrite, path) {
    if (pathIsEmpty(path)) {
        return compoundWrite;
    }
    else {
        const shadowingNode = compoundWriteGetCompleteNode(compoundWrite, path);
        if (shadowingNode != null) {
            return new CompoundWrite(new ImmutableTree(shadowingNode));
        }
        else {
            return new CompoundWrite(compoundWrite.writeTree_.subtree(path));
        }
    }
}
/**
 * Returns true if this CompoundWrite is empty and therefore does not modify any nodes.
 * @returns Whether this CompoundWrite is empty
 */
function compoundWriteIsEmpty(compoundWrite) {
    return compoundWrite.writeTree_.isEmpty();
}
/**
 * Applies this CompoundWrite to a node. The node is returned with all writes from this CompoundWrite applied to the
 * node
 * @param node - The node to apply this CompoundWrite to
 * @returns The node with all writes applied
 */
function compoundWriteApply(compoundWrite, node) {
    return applySubtreeWrite(newEmptyPath(), compoundWrite.writeTree_, node);
}
function applySubtreeWrite(relativePath, writeTree, node) {
    if (writeTree.value != null) {
        // Since there a write is always a leaf, we're done here
        return node.updateChild(relativePath, writeTree.value);
    }
    else {
        let priorityWrite = null;
        writeTree.children.inorderTraversal((childKey, childTree) => {
            if (childKey === '.priority') {
                // Apply priorities at the end so we don't update priorities for either empty nodes or forget
                // to apply priorities to empty nodes that are later filled
                (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(childTree.value !== null, 'Priority writes must always be leaf nodes');
                priorityWrite = childTree.value;
            }
            else {
                node = applySubtreeWrite(pathChild(relativePath, childKey), childTree, node);
            }
        });
        // If there was a priority write, we only apply it if the node is not empty
        if (!node.getChild(relativePath).isEmpty() && priorityWrite !== null) {
            node = node.updateChild(pathChild(relativePath, '.priority'), priorityWrite);
        }
        return node;
    }
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Create a new WriteTreeRef for the given path. For use with a new sync point at the given path.
 *
 */
function writeTreeChildWrites(writeTree, path) {
    return newWriteTreeRef(path, writeTree);
}
/**
 * Record a new overwrite from user code.
 *
 * @param visible - This is set to false by some transactions. It should be excluded from event caches
 */
function writeTreeAddOverwrite(writeTree, path, snap, writeId, visible) {
    (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(writeId > writeTree.lastWriteId, 'Stacking an older write on top of newer ones');
    if (visible === undefined) {
        visible = true;
    }
    writeTree.allWrites.push({
        path,
        snap,
        writeId,
        visible
    });
    if (visible) {
        writeTree.visibleWrites = compoundWriteAddWrite(writeTree.visibleWrites, path, snap);
    }
    writeTree.lastWriteId = writeId;
}
/**
 * Record a new merge from user code.
 */
function writeTreeAddMerge(writeTree, path, changedChildren, writeId) {
    (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(writeId > writeTree.lastWriteId, 'Stacking an older merge on top of newer ones');
    writeTree.allWrites.push({
        path,
        children: changedChildren,
        writeId,
        visible: true
    });
    writeTree.visibleWrites = compoundWriteAddWrites(writeTree.visibleWrites, path, changedChildren);
    writeTree.lastWriteId = writeId;
}
function writeTreeGetWrite(writeTree, writeId) {
    for (let i = 0; i < writeTree.allWrites.length; i++) {
        const record = writeTree.allWrites[i];
        if (record.writeId === writeId) {
            return record;
        }
    }
    return null;
}
/**
 * Remove a write (either an overwrite or merge) that has been successfully acknowledge by the server. Recalculates
 * the tree if necessary.  We return true if it may have been visible, meaning views need to reevaluate.
 *
 * @returns true if the write may have been visible (meaning we'll need to reevaluate / raise
 * events as a result).
 */
function writeTreeRemoveWrite(writeTree, writeId) {
    // Note: disabling this check. It could be a transaction that preempted another transaction, and thus was applied
    // out of order.
    //const validClear = revert || this.allWrites_.length === 0 || writeId <= this.allWrites_[0].writeId;
    //assert(validClear, "Either we don't have this write, or it's the first one in the queue");
    const idx = writeTree.allWrites.findIndex(s => {
        return s.writeId === writeId;
    });
    (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(idx >= 0, 'removeWrite called with nonexistent writeId.');
    const writeToRemove = writeTree.allWrites[idx];
    writeTree.allWrites.splice(idx, 1);
    let removedWriteWasVisible = writeToRemove.visible;
    let removedWriteOverlapsWithOtherWrites = false;
    let i = writeTree.allWrites.length - 1;
    while (removedWriteWasVisible && i >= 0) {
        const currentWrite = writeTree.allWrites[i];
        if (currentWrite.visible) {
            if (i >= idx &&
                writeTreeRecordContainsPath_(currentWrite, writeToRemove.path)) {
                // The removed write was completely shadowed by a subsequent write.
                removedWriteWasVisible = false;
            }
            else if (pathContains(writeToRemove.path, currentWrite.path)) {
                // Either we're covering some writes or they're covering part of us (depending on which came first).
                removedWriteOverlapsWithOtherWrites = true;
            }
        }
        i--;
    }
    if (!removedWriteWasVisible) {
        return false;
    }
    else if (removedWriteOverlapsWithOtherWrites) {
        // There's some shadowing going on. Just rebuild the visible writes from scratch.
        writeTreeResetTree_(writeTree);
        return true;
    }
    else {
        // There's no shadowing.  We can safely just remove the write(s) from visibleWrites.
        if (writeToRemove.snap) {
            writeTree.visibleWrites = compoundWriteRemoveWrite(writeTree.visibleWrites, writeToRemove.path);
        }
        else {
            const children = writeToRemove.children;
            each(children, (childName) => {
                writeTree.visibleWrites = compoundWriteRemoveWrite(writeTree.visibleWrites, pathChild(writeToRemove.path, childName));
            });
        }
        return true;
    }
}
function writeTreeRecordContainsPath_(writeRecord, path) {
    if (writeRecord.snap) {
        return pathContains(writeRecord.path, path);
    }
    else {
        for (const childName in writeRecord.children) {
            if (writeRecord.children.hasOwnProperty(childName) &&
                pathContains(pathChild(writeRecord.path, childName), path)) {
                return true;
            }
        }
        return false;
    }
}
/**
 * Re-layer the writes and merges into a tree so we can efficiently calculate event snapshots
 */
function writeTreeResetTree_(writeTree) {
    writeTree.visibleWrites = writeTreeLayerTree_(writeTree.allWrites, writeTreeDefaultFilter_, newEmptyPath());
    if (writeTree.allWrites.length > 0) {
        writeTree.lastWriteId =
            writeTree.allWrites[writeTree.allWrites.length - 1].writeId;
    }
    else {
        writeTree.lastWriteId = -1;
    }
}
/**
 * The default filter used when constructing the tree. Keep everything that's visible.
 */
function writeTreeDefaultFilter_(write) {
    return write.visible;
}
/**
 * Static method. Given an array of WriteRecords, a filter for which ones to include, and a path, construct the tree of
 * event data at that path.
 */
function writeTreeLayerTree_(writes, filter, treeRoot) {
    let compoundWrite = CompoundWrite.empty();
    for (let i = 0; i < writes.length; ++i) {
        const write = writes[i];
        // Theory, a later set will either:
        // a) abort a relevant transaction, so no need to worry about excluding it from calculating that transaction
        // b) not be relevant to a transaction (separate branch), so again will not affect the data for that transaction
        if (filter(write)) {
            const writePath = write.path;
            let relativePath;
            if (write.snap) {
                if (pathContains(treeRoot, writePath)) {
                    relativePath = newRelativePath(treeRoot, writePath);
                    compoundWrite = compoundWriteAddWrite(compoundWrite, relativePath, write.snap);
                }
                else if (pathContains(writePath, treeRoot)) {
                    relativePath = newRelativePath(writePath, treeRoot);
                    compoundWrite = compoundWriteAddWrite(compoundWrite, newEmptyPath(), write.snap.getChild(relativePath));
                }
                else ;
            }
            else if (write.children) {
                if (pathContains(treeRoot, writePath)) {
                    relativePath = newRelativePath(treeRoot, writePath);
                    compoundWrite = compoundWriteAddWrites(compoundWrite, relativePath, write.children);
                }
                else if (pathContains(writePath, treeRoot)) {
                    relativePath = newRelativePath(writePath, treeRoot);
                    if (pathIsEmpty(relativePath)) {
                        compoundWrite = compoundWriteAddWrites(compoundWrite, newEmptyPath(), write.children);
                    }
                    else {
                        const child = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.safeGet)(write.children, pathGetFront(relativePath));
                        if (child) {
                            // There exists a child in this node that matches the root path
                            const deepNode = child.getChild(pathPopFront(relativePath));
                            compoundWrite = compoundWriteAddWrite(compoundWrite, newEmptyPath(), deepNode);
                        }
                    }
                }
                else ;
            }
            else {
                throw (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assertionError)('WriteRecord should have .snap or .children');
            }
        }
    }
    return compoundWrite;
}
/**
 * Given optional, underlying server data, and an optional set of constraints (exclude some sets, include hidden
 * writes), attempt to calculate a complete snapshot for the given path
 *
 * @param writeIdsToExclude - An optional set to be excluded
 * @param includeHiddenWrites - Defaults to false, whether or not to layer on writes with visible set to false
 */
function writeTreeCalcCompleteEventCache(writeTree, treePath, completeServerCache, writeIdsToExclude, includeHiddenWrites) {
    if (!writeIdsToExclude && !includeHiddenWrites) {
        const shadowingNode = compoundWriteGetCompleteNode(writeTree.visibleWrites, treePath);
        if (shadowingNode != null) {
            return shadowingNode;
        }
        else {
            const subMerge = compoundWriteChildCompoundWrite(writeTree.visibleWrites, treePath);
            if (compoundWriteIsEmpty(subMerge)) {
                return completeServerCache;
            }
            else if (completeServerCache == null &&
                !compoundWriteHasCompleteWrite(subMerge, newEmptyPath())) {
                // We wouldn't have a complete snapshot, since there's no underlying data and no complete shadow
                return null;
            }
            else {
                const layeredCache = completeServerCache || ChildrenNode.EMPTY_NODE;
                return compoundWriteApply(subMerge, layeredCache);
            }
        }
    }
    else {
        const merge = compoundWriteChildCompoundWrite(writeTree.visibleWrites, treePath);
        if (!includeHiddenWrites && compoundWriteIsEmpty(merge)) {
            return completeServerCache;
        }
        else {
            // If the server cache is null, and we don't have a complete cache, we need to return null
            if (!includeHiddenWrites &&
                completeServerCache == null &&
                !compoundWriteHasCompleteWrite(merge, newEmptyPath())) {
                return null;
            }
            else {
                const filter = function (write) {
                    return ((write.visible || includeHiddenWrites) &&
                        (!writeIdsToExclude ||
                            !~writeIdsToExclude.indexOf(write.writeId)) &&
                        (pathContains(write.path, treePath) ||
                            pathContains(treePath, write.path)));
                };
                const mergeAtPath = writeTreeLayerTree_(writeTree.allWrites, filter, treePath);
                const layeredCache = completeServerCache || ChildrenNode.EMPTY_NODE;
                return compoundWriteApply(mergeAtPath, layeredCache);
            }
        }
    }
}
/**
 * With optional, underlying server data, attempt to return a children node of children that we have complete data for.
 * Used when creating new views, to pre-fill their complete event children snapshot.
 */
function writeTreeCalcCompleteEventChildren(writeTree, treePath, completeServerChildren) {
    let completeChildren = ChildrenNode.EMPTY_NODE;
    const topLevelSet = compoundWriteGetCompleteNode(writeTree.visibleWrites, treePath);
    if (topLevelSet) {
        if (!topLevelSet.isLeafNode()) {
            // we're shadowing everything. Return the children.
            topLevelSet.forEachChild(PRIORITY_INDEX, (childName, childSnap) => {
                completeChildren = completeChildren.updateImmediateChild(childName, childSnap);
            });
        }
        return completeChildren;
    }
    else if (completeServerChildren) {
        // Layer any children we have on top of this
        // We know we don't have a top-level set, so just enumerate existing children
        const merge = compoundWriteChildCompoundWrite(writeTree.visibleWrites, treePath);
        completeServerChildren.forEachChild(PRIORITY_INDEX, (childName, childNode) => {
            const node = compoundWriteApply(compoundWriteChildCompoundWrite(merge, new Path(childName)), childNode);
            completeChildren = completeChildren.updateImmediateChild(childName, node);
        });
        // Add any complete children we have from the set
        compoundWriteGetCompleteChildren(merge).forEach(namedNode => {
            completeChildren = completeChildren.updateImmediateChild(namedNode.name, namedNode.node);
        });
        return completeChildren;
    }
    else {
        // We don't have anything to layer on top of. Layer on any children we have
        // Note that we can return an empty snap if we have a defined delete
        const merge = compoundWriteChildCompoundWrite(writeTree.visibleWrites, treePath);
        compoundWriteGetCompleteChildren(merge).forEach(namedNode => {
            completeChildren = completeChildren.updateImmediateChild(namedNode.name, namedNode.node);
        });
        return completeChildren;
    }
}
/**
 * Given that the underlying server data has updated, determine what, if anything, needs to be
 * applied to the event cache.
 *
 * Possibilities:
 *
 * 1. No writes are shadowing. Events should be raised, the snap to be applied comes from the server data
 *
 * 2. Some write is completely shadowing. No events to be raised
 *
 * 3. Is partially shadowed. Events
 *
 * Either existingEventSnap or existingServerSnap must exist
 */
function writeTreeCalcEventCacheAfterServerOverwrite(writeTree, treePath, childPath, existingEventSnap, existingServerSnap) {
    (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(existingEventSnap || existingServerSnap, 'Either existingEventSnap or existingServerSnap must exist');
    const path = pathChild(treePath, childPath);
    if (compoundWriteHasCompleteWrite(writeTree.visibleWrites, path)) {
        // At this point we can probably guarantee that we're in case 2, meaning no events
        // May need to check visibility while doing the findRootMostValueAndPath call
        return null;
    }
    else {
        // No complete shadowing. We're either partially shadowing or not shadowing at all.
        const childMerge = compoundWriteChildCompoundWrite(writeTree.visibleWrites, path);
        if (compoundWriteIsEmpty(childMerge)) {
            // We're not shadowing at all. Case 1
            return existingServerSnap.getChild(childPath);
        }
        else {
            // This could be more efficient if the serverNode + updates doesn't change the eventSnap
            // However this is tricky to find out, since user updates don't necessary change the server
            // snap, e.g. priority updates on empty nodes, or deep deletes. Another special case is if the server
            // adds nodes, but doesn't change any existing writes. It is therefore not enough to
            // only check if the updates change the serverNode.
            // Maybe check if the merge tree contains these special cases and only do a full overwrite in that case?
            return compoundWriteApply(childMerge, existingServerSnap.getChild(childPath));
        }
    }
}
/**
 * Returns a complete child for a given server snap after applying all user writes or null if there is no
 * complete child for this ChildKey.
 */
function writeTreeCalcCompleteChild(writeTree, treePath, childKey, existingServerSnap) {
    const path = pathChild(treePath, childKey);
    const shadowingNode = compoundWriteGetCompleteNode(writeTree.visibleWrites, path);
    if (shadowingNode != null) {
        return shadowingNode;
    }
    else {
        if (existingServerSnap.isCompleteForChild(childKey)) {
            const childMerge = compoundWriteChildCompoundWrite(writeTree.visibleWrites, path);
            return compoundWriteApply(childMerge, existingServerSnap.getNode().getImmediateChild(childKey));
        }
        else {
            return null;
        }
    }
}
/**
 * Returns a node if there is a complete overwrite for this path. More specifically, if there is a write at
 * a higher path, this will return the child of that write relative to the write and this path.
 * Returns null if there is no write at this path.
 */
function writeTreeShadowingWrite(writeTree, path) {
    return compoundWriteGetCompleteNode(writeTree.visibleWrites, path);
}
/**
 * This method is used when processing child remove events on a query. If we can, we pull in children that were outside
 * the window, but may now be in the window.
 */
function writeTreeCalcIndexedSlice(writeTree, treePath, completeServerData, startPost, count, reverse, index) {
    let toIterate;
    const merge = compoundWriteChildCompoundWrite(writeTree.visibleWrites, treePath);
    const shadowingNode = compoundWriteGetCompleteNode(merge, newEmptyPath());
    if (shadowingNode != null) {
        toIterate = shadowingNode;
    }
    else if (completeServerData != null) {
        toIterate = compoundWriteApply(merge, completeServerData);
    }
    else {
        // no children to iterate on
        return [];
    }
    toIterate = toIterate.withIndex(index);
    if (!toIterate.isEmpty() && !toIterate.isLeafNode()) {
        const nodes = [];
        const cmp = index.getCompare();
        const iter = reverse
            ? toIterate.getReverseIteratorFrom(startPost, index)
            : toIterate.getIteratorFrom(startPost, index);
        let next = iter.getNext();
        while (next && nodes.length < count) {
            if (cmp(next, startPost) !== 0) {
                nodes.push(next);
            }
            next = iter.getNext();
        }
        return nodes;
    }
    else {
        return [];
    }
}
function newWriteTree() {
    return {
        visibleWrites: CompoundWrite.empty(),
        allWrites: [],
        lastWriteId: -1
    };
}
/**
 * If possible, returns a complete event cache, using the underlying server data if possible. In addition, can be used
 * to get a cache that includes hidden writes, and excludes arbitrary writes. Note that customizing the returned node
 * can lead to a more expensive calculation.
 *
 * @param writeIdsToExclude - Optional writes to exclude.
 * @param includeHiddenWrites - Defaults to false, whether or not to layer on writes with visible set to false
 */
function writeTreeRefCalcCompleteEventCache(writeTreeRef, completeServerCache, writeIdsToExclude, includeHiddenWrites) {
    return writeTreeCalcCompleteEventCache(writeTreeRef.writeTree, writeTreeRef.treePath, completeServerCache, writeIdsToExclude, includeHiddenWrites);
}
/**
 * If possible, returns a children node containing all of the complete children we have data for. The returned data is a
 * mix of the given server data and write data.
 *
 */
function writeTreeRefCalcCompleteEventChildren(writeTreeRef, completeServerChildren) {
    return writeTreeCalcCompleteEventChildren(writeTreeRef.writeTree, writeTreeRef.treePath, completeServerChildren);
}
/**
 * Given that either the underlying server data has updated or the outstanding writes have updated, determine what,
 * if anything, needs to be applied to the event cache.
 *
 * Possibilities:
 *
 * 1. No writes are shadowing. Events should be raised, the snap to be applied comes from the server data
 *
 * 2. Some write is completely shadowing. No events to be raised
 *
 * 3. Is partially shadowed. Events should be raised
 *
 * Either existingEventSnap or existingServerSnap must exist, this is validated via an assert
 *
 *
 */
function writeTreeRefCalcEventCacheAfterServerOverwrite(writeTreeRef, path, existingEventSnap, existingServerSnap) {
    return writeTreeCalcEventCacheAfterServerOverwrite(writeTreeRef.writeTree, writeTreeRef.treePath, path, existingEventSnap, existingServerSnap);
}
/**
 * Returns a node if there is a complete overwrite for this path. More specifically, if there is a write at
 * a higher path, this will return the child of that write relative to the write and this path.
 * Returns null if there is no write at this path.
 *
 */
function writeTreeRefShadowingWrite(writeTreeRef, path) {
    return writeTreeShadowingWrite(writeTreeRef.writeTree, pathChild(writeTreeRef.treePath, path));
}
/**
 * This method is used when processing child remove events on a query. If we can, we pull in children that were outside
 * the window, but may now be in the window
 */
function writeTreeRefCalcIndexedSlice(writeTreeRef, completeServerData, startPost, count, reverse, index) {
    return writeTreeCalcIndexedSlice(writeTreeRef.writeTree, writeTreeRef.treePath, completeServerData, startPost, count, reverse, index);
}
/**
 * Returns a complete child for a given server snap after applying all user writes or null if there is no
 * complete child for this ChildKey.
 */
function writeTreeRefCalcCompleteChild(writeTreeRef, childKey, existingServerCache) {
    return writeTreeCalcCompleteChild(writeTreeRef.writeTree, writeTreeRef.treePath, childKey, existingServerCache);
}
/**
 * Return a WriteTreeRef for a child.
 */
function writeTreeRefChild(writeTreeRef, childName) {
    return newWriteTreeRef(pathChild(writeTreeRef.treePath, childName), writeTreeRef.writeTree);
}
function newWriteTreeRef(path, writeTree) {
    return {
        treePath: path,
        writeTree
    };
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ChildChangeAccumulator {
    constructor() {
        this.changeMap = new Map();
    }
    trackChildChange(change) {
        const type = change.type;
        const childKey = change.childName;
        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(type === "child_added" /* CHILD_ADDED */ ||
            type === "child_changed" /* CHILD_CHANGED */ ||
            type === "child_removed" /* CHILD_REMOVED */, 'Only child changes supported for tracking');
        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(childKey !== '.priority', 'Only non-priority child changes can be tracked.');
        const oldChange = this.changeMap.get(childKey);
        if (oldChange) {
            const oldType = oldChange.type;
            if (type === "child_added" /* CHILD_ADDED */ &&
                oldType === "child_removed" /* CHILD_REMOVED */) {
                this.changeMap.set(childKey, changeChildChanged(childKey, change.snapshotNode, oldChange.snapshotNode));
            }
            else if (type === "child_removed" /* CHILD_REMOVED */ &&
                oldType === "child_added" /* CHILD_ADDED */) {
                this.changeMap.delete(childKey);
            }
            else if (type === "child_removed" /* CHILD_REMOVED */ &&
                oldType === "child_changed" /* CHILD_CHANGED */) {
                this.changeMap.set(childKey, changeChildRemoved(childKey, oldChange.oldSnap));
            }
            else if (type === "child_changed" /* CHILD_CHANGED */ &&
                oldType === "child_added" /* CHILD_ADDED */) {
                this.changeMap.set(childKey, changeChildAdded(childKey, change.snapshotNode));
            }
            else if (type === "child_changed" /* CHILD_CHANGED */ &&
                oldType === "child_changed" /* CHILD_CHANGED */) {
                this.changeMap.set(childKey, changeChildChanged(childKey, change.snapshotNode, oldChange.oldSnap));
            }
            else {
                throw (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assertionError)('Illegal combination of changes: ' +
                    change +
                    ' occurred after ' +
                    oldChange);
            }
        }
        else {
            this.changeMap.set(childKey, change);
        }
    }
    getChanges() {
        return Array.from(this.changeMap.values());
    }
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * An implementation of CompleteChildSource that never returns any additional children
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
class NoCompleteChildSource_ {
    getCompleteChild(childKey) {
        return null;
    }
    getChildAfterChild(index, child, reverse) {
        return null;
    }
}
/**
 * Singleton instance.
 */
const NO_COMPLETE_CHILD_SOURCE = new NoCompleteChildSource_();
/**
 * An implementation of CompleteChildSource that uses a WriteTree in addition to any other server data or
 * old event caches available to calculate complete children.
 */
class WriteTreeCompleteChildSource {
    constructor(writes_, viewCache_, optCompleteServerCache_ = null) {
        this.writes_ = writes_;
        this.viewCache_ = viewCache_;
        this.optCompleteServerCache_ = optCompleteServerCache_;
    }
    getCompleteChild(childKey) {
        const node = this.viewCache_.eventCache;
        if (node.isCompleteForChild(childKey)) {
            return node.getNode().getImmediateChild(childKey);
        }
        else {
            const serverNode = this.optCompleteServerCache_ != null
                ? new CacheNode(this.optCompleteServerCache_, true, false)
                : this.viewCache_.serverCache;
            return writeTreeRefCalcCompleteChild(this.writes_, childKey, serverNode);
        }
    }
    getChildAfterChild(index, child, reverse) {
        const completeServerData = this.optCompleteServerCache_ != null
            ? this.optCompleteServerCache_
            : viewCacheGetCompleteServerSnap(this.viewCache_);
        const nodes = writeTreeRefCalcIndexedSlice(this.writes_, completeServerData, child, 1, reverse, index);
        if (nodes.length === 0) {
            return null;
        }
        else {
            return nodes[0];
        }
    }
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function newViewProcessor(filter) {
    return { filter };
}
function viewProcessorAssertIndexed(viewProcessor, viewCache) {
    (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(viewCache.eventCache.getNode().isIndexed(viewProcessor.filter.getIndex()), 'Event snap not indexed');
    (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(viewCache.serverCache.getNode().isIndexed(viewProcessor.filter.getIndex()), 'Server snap not indexed');
}
function viewProcessorApplyOperation(viewProcessor, oldViewCache, operation, writesCache, completeCache) {
    const accumulator = new ChildChangeAccumulator();
    let newViewCache, filterServerNode;
    if (operation.type === OperationType.OVERWRITE) {
        const overwrite = operation;
        if (overwrite.source.fromUser) {
            newViewCache = viewProcessorApplyUserOverwrite(viewProcessor, oldViewCache, overwrite.path, overwrite.snap, writesCache, completeCache, accumulator);
        }
        else {
            (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(overwrite.source.fromServer, 'Unknown source.');
            // We filter the node if it's a tagged update or the node has been previously filtered  and the
            // update is not at the root in which case it is ok (and necessary) to mark the node unfiltered
            // again
            filterServerNode =
                overwrite.source.tagged ||
                    (oldViewCache.serverCache.isFiltered() && !pathIsEmpty(overwrite.path));
            newViewCache = viewProcessorApplyServerOverwrite(viewProcessor, oldViewCache, overwrite.path, overwrite.snap, writesCache, completeCache, filterServerNode, accumulator);
        }
    }
    else if (operation.type === OperationType.MERGE) {
        const merge = operation;
        if (merge.source.fromUser) {
            newViewCache = viewProcessorApplyUserMerge(viewProcessor, oldViewCache, merge.path, merge.children, writesCache, completeCache, accumulator);
        }
        else {
            (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(merge.source.fromServer, 'Unknown source.');
            // We filter the node if it's a tagged update or the node has been previously filtered
            filterServerNode =
                merge.source.tagged || oldViewCache.serverCache.isFiltered();
            newViewCache = viewProcessorApplyServerMerge(viewProcessor, oldViewCache, merge.path, merge.children, writesCache, completeCache, filterServerNode, accumulator);
        }
    }
    else if (operation.type === OperationType.ACK_USER_WRITE) {
        const ackUserWrite = operation;
        if (!ackUserWrite.revert) {
            newViewCache = viewProcessorAckUserWrite(viewProcessor, oldViewCache, ackUserWrite.path, ackUserWrite.affectedTree, writesCache, completeCache, accumulator);
        }
        else {
            newViewCache = viewProcessorRevertUserWrite(viewProcessor, oldViewCache, ackUserWrite.path, writesCache, completeCache, accumulator);
        }
    }
    else if (operation.type === OperationType.LISTEN_COMPLETE) {
        newViewCache = viewProcessorListenComplete(viewProcessor, oldViewCache, operation.path, writesCache, accumulator);
    }
    else {
        throw (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assertionError)('Unknown operation type: ' + operation.type);
    }
    const changes = accumulator.getChanges();
    viewProcessorMaybeAddValueEvent(oldViewCache, newViewCache, changes);
    return { viewCache: newViewCache, changes };
}
function viewProcessorMaybeAddValueEvent(oldViewCache, newViewCache, accumulator) {
    const eventSnap = newViewCache.eventCache;
    if (eventSnap.isFullyInitialized()) {
        const isLeafOrEmpty = eventSnap.getNode().isLeafNode() || eventSnap.getNode().isEmpty();
        const oldCompleteSnap = viewCacheGetCompleteEventSnap(oldViewCache);
        if (accumulator.length > 0 ||
            !oldViewCache.eventCache.isFullyInitialized() ||
            (isLeafOrEmpty && !eventSnap.getNode().equals(oldCompleteSnap)) ||
            !eventSnap.getNode().getPriority().equals(oldCompleteSnap.getPriority())) {
            accumulator.push(changeValue(viewCacheGetCompleteEventSnap(newViewCache)));
        }
    }
}
function viewProcessorGenerateEventCacheAfterServerEvent(viewProcessor, viewCache, changePath, writesCache, source, accumulator) {
    const oldEventSnap = viewCache.eventCache;
    if (writeTreeRefShadowingWrite(writesCache, changePath) != null) {
        // we have a shadowing write, ignore changes
        return viewCache;
    }
    else {
        let newEventCache, serverNode;
        if (pathIsEmpty(changePath)) {
            // TODO: figure out how this plays with "sliding ack windows"
            (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(viewCache.serverCache.isFullyInitialized(), 'If change path is empty, we must have complete server data');
            if (viewCache.serverCache.isFiltered()) {
                // We need to special case this, because we need to only apply writes to complete children, or
                // we might end up raising events for incomplete children. If the server data is filtered deep
                // writes cannot be guaranteed to be complete
                const serverCache = viewCacheGetCompleteServerSnap(viewCache);
                const completeChildren = serverCache instanceof ChildrenNode
                    ? serverCache
                    : ChildrenNode.EMPTY_NODE;
                const completeEventChildren = writeTreeRefCalcCompleteEventChildren(writesCache, completeChildren);
                newEventCache = viewProcessor.filter.updateFullNode(viewCache.eventCache.getNode(), completeEventChildren, accumulator);
            }
            else {
                const completeNode = writeTreeRefCalcCompleteEventCache(writesCache, viewCacheGetCompleteServerSnap(viewCache));
                newEventCache = viewProcessor.filter.updateFullNode(viewCache.eventCache.getNode(), completeNode, accumulator);
            }
        }
        else {
            const childKey = pathGetFront(changePath);
            if (childKey === '.priority') {
                (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(pathGetLength(changePath) === 1, "Can't have a priority with additional path components");
                const oldEventNode = oldEventSnap.getNode();
                serverNode = viewCache.serverCache.getNode();
                // we might have overwrites for this priority
                const updatedPriority = writeTreeRefCalcEventCacheAfterServerOverwrite(writesCache, changePath, oldEventNode, serverNode);
                if (updatedPriority != null) {
                    newEventCache = viewProcessor.filter.updatePriority(oldEventNode, updatedPriority);
                }
                else {
                    // priority didn't change, keep old node
                    newEventCache = oldEventSnap.getNode();
                }
            }
            else {
                const childChangePath = pathPopFront(changePath);
                // update child
                let newEventChild;
                if (oldEventSnap.isCompleteForChild(childKey)) {
                    serverNode = viewCache.serverCache.getNode();
                    const eventChildUpdate = writeTreeRefCalcEventCacheAfterServerOverwrite(writesCache, changePath, oldEventSnap.getNode(), serverNode);
                    if (eventChildUpdate != null) {
                        newEventChild = oldEventSnap
                            .getNode()
                            .getImmediateChild(childKey)
                            .updateChild(childChangePath, eventChildUpdate);
                    }
                    else {
                        // Nothing changed, just keep the old child
                        newEventChild = oldEventSnap.getNode().getImmediateChild(childKey);
                    }
                }
                else {
                    newEventChild = writeTreeRefCalcCompleteChild(writesCache, childKey, viewCache.serverCache);
                }
                if (newEventChild != null) {
                    newEventCache = viewProcessor.filter.updateChild(oldEventSnap.getNode(), childKey, newEventChild, childChangePath, source, accumulator);
                }
                else {
                    // no complete child available or no change
                    newEventCache = oldEventSnap.getNode();
                }
            }
        }
        return viewCacheUpdateEventSnap(viewCache, newEventCache, oldEventSnap.isFullyInitialized() || pathIsEmpty(changePath), viewProcessor.filter.filtersNodes());
    }
}
function viewProcessorApplyServerOverwrite(viewProcessor, oldViewCache, changePath, changedSnap, writesCache, completeCache, filterServerNode, accumulator) {
    const oldServerSnap = oldViewCache.serverCache;
    let newServerCache;
    const serverFilter = filterServerNode
        ? viewProcessor.filter
        : viewProcessor.filter.getIndexedFilter();
    if (pathIsEmpty(changePath)) {
        newServerCache = serverFilter.updateFullNode(oldServerSnap.getNode(), changedSnap, null);
    }
    else if (serverFilter.filtersNodes() && !oldServerSnap.isFiltered()) {
        // we want to filter the server node, but we didn't filter the server node yet, so simulate a full update
        const newServerNode = oldServerSnap
            .getNode()
            .updateChild(changePath, changedSnap);
        newServerCache = serverFilter.updateFullNode(oldServerSnap.getNode(), newServerNode, null);
    }
    else {
        const childKey = pathGetFront(changePath);
        if (!oldServerSnap.isCompleteForPath(changePath) &&
            pathGetLength(changePath) > 1) {
            // We don't update incomplete nodes with updates intended for other listeners
            return oldViewCache;
        }
        const childChangePath = pathPopFront(changePath);
        const childNode = oldServerSnap.getNode().getImmediateChild(childKey);
        const newChildNode = childNode.updateChild(childChangePath, changedSnap);
        if (childKey === '.priority') {
            newServerCache = serverFilter.updatePriority(oldServerSnap.getNode(), newChildNode);
        }
        else {
            newServerCache = serverFilter.updateChild(oldServerSnap.getNode(), childKey, newChildNode, childChangePath, NO_COMPLETE_CHILD_SOURCE, null);
        }
    }
    const newViewCache = viewCacheUpdateServerSnap(oldViewCache, newServerCache, oldServerSnap.isFullyInitialized() || pathIsEmpty(changePath), serverFilter.filtersNodes());
    const source = new WriteTreeCompleteChildSource(writesCache, newViewCache, completeCache);
    return viewProcessorGenerateEventCacheAfterServerEvent(viewProcessor, newViewCache, changePath, writesCache, source, accumulator);
}
function viewProcessorApplyUserOverwrite(viewProcessor, oldViewCache, changePath, changedSnap, writesCache, completeCache, accumulator) {
    const oldEventSnap = oldViewCache.eventCache;
    let newViewCache, newEventCache;
    const source = new WriteTreeCompleteChildSource(writesCache, oldViewCache, completeCache);
    if (pathIsEmpty(changePath)) {
        newEventCache = viewProcessor.filter.updateFullNode(oldViewCache.eventCache.getNode(), changedSnap, accumulator);
        newViewCache = viewCacheUpdateEventSnap(oldViewCache, newEventCache, true, viewProcessor.filter.filtersNodes());
    }
    else {
        const childKey = pathGetFront(changePath);
        if (childKey === '.priority') {
            newEventCache = viewProcessor.filter.updatePriority(oldViewCache.eventCache.getNode(), changedSnap);
            newViewCache = viewCacheUpdateEventSnap(oldViewCache, newEventCache, oldEventSnap.isFullyInitialized(), oldEventSnap.isFiltered());
        }
        else {
            const childChangePath = pathPopFront(changePath);
            const oldChild = oldEventSnap.getNode().getImmediateChild(childKey);
            let newChild;
            if (pathIsEmpty(childChangePath)) {
                // Child overwrite, we can replace the child
                newChild = changedSnap;
            }
            else {
                const childNode = source.getCompleteChild(childKey);
                if (childNode != null) {
                    if (pathGetBack(childChangePath) === '.priority' &&
                        childNode.getChild(pathParent(childChangePath)).isEmpty()) {
                        // This is a priority update on an empty node. If this node exists on the server, the
                        // server will send down the priority in the update, so ignore for now
                        newChild = childNode;
                    }
                    else {
                        newChild = childNode.updateChild(childChangePath, changedSnap);
                    }
                }
                else {
                    // There is no complete child node available
                    newChild = ChildrenNode.EMPTY_NODE;
                }
            }
            if (!oldChild.equals(newChild)) {
                const newEventSnap = viewProcessor.filter.updateChild(oldEventSnap.getNode(), childKey, newChild, childChangePath, source, accumulator);
                newViewCache = viewCacheUpdateEventSnap(oldViewCache, newEventSnap, oldEventSnap.isFullyInitialized(), viewProcessor.filter.filtersNodes());
            }
            else {
                newViewCache = oldViewCache;
            }
        }
    }
    return newViewCache;
}
function viewProcessorCacheHasChild(viewCache, childKey) {
    return viewCache.eventCache.isCompleteForChild(childKey);
}
function viewProcessorApplyUserMerge(viewProcessor, viewCache, path, changedChildren, writesCache, serverCache, accumulator) {
    // HACK: In the case of a limit query, there may be some changes that bump things out of the
    // window leaving room for new items.  It's important we process these changes first, so we
    // iterate the changes twice, first processing any that affect items currently in view.
    // TODO: I consider an item "in view" if cacheHasChild is true, which checks both the server
    // and event snap.  I'm not sure if this will result in edge cases when a child is in one but
    // not the other.
    let curViewCache = viewCache;
    changedChildren.foreach((relativePath, childNode) => {
        const writePath = pathChild(path, relativePath);
        if (viewProcessorCacheHasChild(viewCache, pathGetFront(writePath))) {
            curViewCache = viewProcessorApplyUserOverwrite(viewProcessor, curViewCache, writePath, childNode, writesCache, serverCache, accumulator);
        }
    });
    changedChildren.foreach((relativePath, childNode) => {
        const writePath = pathChild(path, relativePath);
        if (!viewProcessorCacheHasChild(viewCache, pathGetFront(writePath))) {
            curViewCache = viewProcessorApplyUserOverwrite(viewProcessor, curViewCache, writePath, childNode, writesCache, serverCache, accumulator);
        }
    });
    return curViewCache;
}
function viewProcessorApplyMerge(viewProcessor, node, merge) {
    merge.foreach((relativePath, childNode) => {
        node = node.updateChild(relativePath, childNode);
    });
    return node;
}
function viewProcessorApplyServerMerge(viewProcessor, viewCache, path, changedChildren, writesCache, serverCache, filterServerNode, accumulator) {
    // If we don't have a cache yet, this merge was intended for a previously listen in the same location. Ignore it and
    // wait for the complete data update coming soon.
    if (viewCache.serverCache.getNode().isEmpty() &&
        !viewCache.serverCache.isFullyInitialized()) {
        return viewCache;
    }
    // HACK: In the case of a limit query, there may be some changes that bump things out of the
    // window leaving room for new items.  It's important we process these changes first, so we
    // iterate the changes twice, first processing any that affect items currently in view.
    // TODO: I consider an item "in view" if cacheHasChild is true, which checks both the server
    // and event snap.  I'm not sure if this will result in edge cases when a child is in one but
    // not the other.
    let curViewCache = viewCache;
    let viewMergeTree;
    if (pathIsEmpty(path)) {
        viewMergeTree = changedChildren;
    }
    else {
        viewMergeTree = new ImmutableTree(null).setTree(path, changedChildren);
    }
    const serverNode = viewCache.serverCache.getNode();
    viewMergeTree.children.inorderTraversal((childKey, childTree) => {
        if (serverNode.hasChild(childKey)) {
            const serverChild = viewCache.serverCache
                .getNode()
                .getImmediateChild(childKey);
            const newChild = viewProcessorApplyMerge(viewProcessor, serverChild, childTree);
            curViewCache = viewProcessorApplyServerOverwrite(viewProcessor, curViewCache, new Path(childKey), newChild, writesCache, serverCache, filterServerNode, accumulator);
        }
    });
    viewMergeTree.children.inorderTraversal((childKey, childMergeTree) => {
        const isUnknownDeepMerge = !viewCache.serverCache.isCompleteForChild(childKey) &&
            childMergeTree.value === undefined;
        if (!serverNode.hasChild(childKey) && !isUnknownDeepMerge) {
            const serverChild = viewCache.serverCache
                .getNode()
                .getImmediateChild(childKey);
            const newChild = viewProcessorApplyMerge(viewProcessor, serverChild, childMergeTree);
            curViewCache = viewProcessorApplyServerOverwrite(viewProcessor, curViewCache, new Path(childKey), newChild, writesCache, serverCache, filterServerNode, accumulator);
        }
    });
    return curViewCache;
}
function viewProcessorAckUserWrite(viewProcessor, viewCache, ackPath, affectedTree, writesCache, completeCache, accumulator) {
    if (writeTreeRefShadowingWrite(writesCache, ackPath) != null) {
        return viewCache;
    }
    // Only filter server node if it is currently filtered
    const filterServerNode = viewCache.serverCache.isFiltered();
    // Essentially we'll just get our existing server cache for the affected paths and re-apply it as a server update
    // now that it won't be shadowed.
    const serverCache = viewCache.serverCache;
    if (affectedTree.value != null) {
        // This is an overwrite.
        if ((pathIsEmpty(ackPath) && serverCache.isFullyInitialized()) ||
            serverCache.isCompleteForPath(ackPath)) {
            return viewProcessorApplyServerOverwrite(viewProcessor, viewCache, ackPath, serverCache.getNode().getChild(ackPath), writesCache, completeCache, filterServerNode, accumulator);
        }
        else if (pathIsEmpty(ackPath)) {
            // This is a goofy edge case where we are acking data at this location but don't have full data.  We
            // should just re-apply whatever we have in our cache as a merge.
            let changedChildren = new ImmutableTree(null);
            serverCache.getNode().forEachChild(KEY_INDEX, (name, node) => {
                changedChildren = changedChildren.set(new Path(name), node);
            });
            return viewProcessorApplyServerMerge(viewProcessor, viewCache, ackPath, changedChildren, writesCache, completeCache, filterServerNode, accumulator);
        }
        else {
            return viewCache;
        }
    }
    else {
        // This is a merge.
        let changedChildren = new ImmutableTree(null);
        affectedTree.foreach((mergePath, value) => {
            const serverCachePath = pathChild(ackPath, mergePath);
            if (serverCache.isCompleteForPath(serverCachePath)) {
                changedChildren = changedChildren.set(mergePath, serverCache.getNode().getChild(serverCachePath));
            }
        });
        return viewProcessorApplyServerMerge(viewProcessor, viewCache, ackPath, changedChildren, writesCache, completeCache, filterServerNode, accumulator);
    }
}
function viewProcessorListenComplete(viewProcessor, viewCache, path, writesCache, accumulator) {
    const oldServerNode = viewCache.serverCache;
    const newViewCache = viewCacheUpdateServerSnap(viewCache, oldServerNode.getNode(), oldServerNode.isFullyInitialized() || pathIsEmpty(path), oldServerNode.isFiltered());
    return viewProcessorGenerateEventCacheAfterServerEvent(viewProcessor, newViewCache, path, writesCache, NO_COMPLETE_CHILD_SOURCE, accumulator);
}
function viewProcessorRevertUserWrite(viewProcessor, viewCache, path, writesCache, completeServerCache, accumulator) {
    let complete;
    if (writeTreeRefShadowingWrite(writesCache, path) != null) {
        return viewCache;
    }
    else {
        const source = new WriteTreeCompleteChildSource(writesCache, viewCache, completeServerCache);
        const oldEventCache = viewCache.eventCache.getNode();
        let newEventCache;
        if (pathIsEmpty(path) || pathGetFront(path) === '.priority') {
            let newNode;
            if (viewCache.serverCache.isFullyInitialized()) {
                newNode = writeTreeRefCalcCompleteEventCache(writesCache, viewCacheGetCompleteServerSnap(viewCache));
            }
            else {
                const serverChildren = viewCache.serverCache.getNode();
                (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(serverChildren instanceof ChildrenNode, 'serverChildren would be complete if leaf node');
                newNode = writeTreeRefCalcCompleteEventChildren(writesCache, serverChildren);
            }
            newNode = newNode;
            newEventCache = viewProcessor.filter.updateFullNode(oldEventCache, newNode, accumulator);
        }
        else {
            const childKey = pathGetFront(path);
            let newChild = writeTreeRefCalcCompleteChild(writesCache, childKey, viewCache.serverCache);
            if (newChild == null &&
                viewCache.serverCache.isCompleteForChild(childKey)) {
                newChild = oldEventCache.getImmediateChild(childKey);
            }
            if (newChild != null) {
                newEventCache = viewProcessor.filter.updateChild(oldEventCache, childKey, newChild, pathPopFront(path), source, accumulator);
            }
            else if (viewCache.eventCache.getNode().hasChild(childKey)) {
                // No complete child available, delete the existing one, if any
                newEventCache = viewProcessor.filter.updateChild(oldEventCache, childKey, ChildrenNode.EMPTY_NODE, pathPopFront(path), source, accumulator);
            }
            else {
                newEventCache = oldEventCache;
            }
            if (newEventCache.isEmpty() &&
                viewCache.serverCache.isFullyInitialized()) {
                // We might have reverted all child writes. Maybe the old event was a leaf node
                complete = writeTreeRefCalcCompleteEventCache(writesCache, viewCacheGetCompleteServerSnap(viewCache));
                if (complete.isLeafNode()) {
                    newEventCache = viewProcessor.filter.updateFullNode(newEventCache, complete, accumulator);
                }
            }
        }
        complete =
            viewCache.serverCache.isFullyInitialized() ||
                writeTreeRefShadowingWrite(writesCache, newEmptyPath()) != null;
        return viewCacheUpdateEventSnap(viewCache, newEventCache, complete, viewProcessor.filter.filtersNodes());
    }
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * A view represents a specific location and query that has 1 or more event registrations.
 *
 * It does several things:
 *  - Maintains the list of event registrations for this location/query.
 *  - Maintains a cache of the data visible for this location/query.
 *  - Applies new operations (via applyOperation), updates the cache, and based on the event
 *    registrations returns the set of events to be raised.
 */
class View {
    constructor(query_, initialViewCache) {
        this.query_ = query_;
        this.eventRegistrations_ = [];
        const params = this.query_._queryParams;
        const indexFilter = new IndexedFilter(params.getIndex());
        const filter = queryParamsGetNodeFilter(params);
        this.processor_ = newViewProcessor(filter);
        const initialServerCache = initialViewCache.serverCache;
        const initialEventCache = initialViewCache.eventCache;
        // Don't filter server node with other filter than index, wait for tagged listen
        const serverSnap = indexFilter.updateFullNode(ChildrenNode.EMPTY_NODE, initialServerCache.getNode(), null);
        const eventSnap = filter.updateFullNode(ChildrenNode.EMPTY_NODE, initialEventCache.getNode(), null);
        const newServerCache = new CacheNode(serverSnap, initialServerCache.isFullyInitialized(), indexFilter.filtersNodes());
        const newEventCache = new CacheNode(eventSnap, initialEventCache.isFullyInitialized(), filter.filtersNodes());
        this.viewCache_ = newViewCache(newEventCache, newServerCache);
        this.eventGenerator_ = new EventGenerator(this.query_);
    }
    get query() {
        return this.query_;
    }
}
function viewGetServerCache(view) {
    return view.viewCache_.serverCache.getNode();
}
function viewGetCompleteNode(view) {
    return viewCacheGetCompleteEventSnap(view.viewCache_);
}
function viewGetCompleteServerCache(view, path) {
    const cache = viewCacheGetCompleteServerSnap(view.viewCache_);
    if (cache) {
        // If this isn't a "loadsAllData" view, then cache isn't actually a complete cache and
        // we need to see if it contains the child we're interested in.
        if (view.query._queryParams.loadsAllData() ||
            (!pathIsEmpty(path) &&
                !cache.getImmediateChild(pathGetFront(path)).isEmpty())) {
            return cache.getChild(path);
        }
    }
    return null;
}
function viewIsEmpty(view) {
    return view.eventRegistrations_.length === 0;
}
function viewAddEventRegistration(view, eventRegistration) {
    view.eventRegistrations_.push(eventRegistration);
}
/**
 * @param eventRegistration - If null, remove all callbacks.
 * @param cancelError - If a cancelError is provided, appropriate cancel events will be returned.
 * @returns Cancel events, if cancelError was provided.
 */
function viewRemoveEventRegistration(view, eventRegistration, cancelError) {
    const cancelEvents = [];
    if (cancelError) {
        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(eventRegistration == null, 'A cancel should cancel all event registrations.');
        const path = view.query._path;
        view.eventRegistrations_.forEach(registration => {
            const maybeEvent = registration.createCancelEvent(cancelError, path);
            if (maybeEvent) {
                cancelEvents.push(maybeEvent);
            }
        });
    }
    if (eventRegistration) {
        let remaining = [];
        for (let i = 0; i < view.eventRegistrations_.length; ++i) {
            const existing = view.eventRegistrations_[i];
            if (!existing.matches(eventRegistration)) {
                remaining.push(existing);
            }
            else if (eventRegistration.hasAnyCallback()) {
                // We're removing just this one
                remaining = remaining.concat(view.eventRegistrations_.slice(i + 1));
                break;
            }
        }
        view.eventRegistrations_ = remaining;
    }
    else {
        view.eventRegistrations_ = [];
    }
    return cancelEvents;
}
/**
 * Applies the given Operation, updates our cache, and returns the appropriate events.
 */
function viewApplyOperation(view, operation, writesCache, completeServerCache) {
    if (operation.type === OperationType.MERGE &&
        operation.source.queryId !== null) {
        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(viewCacheGetCompleteServerSnap(view.viewCache_), 'We should always have a full cache before handling merges');
        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(viewCacheGetCompleteEventSnap(view.viewCache_), 'Missing event cache, even though we have a server cache');
    }
    const oldViewCache = view.viewCache_;
    const result = viewProcessorApplyOperation(view.processor_, oldViewCache, operation, writesCache, completeServerCache);
    viewProcessorAssertIndexed(view.processor_, result.viewCache);
    (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(result.viewCache.serverCache.isFullyInitialized() ||
        !oldViewCache.serverCache.isFullyInitialized(), 'Once a server snap is complete, it should never go back');
    view.viewCache_ = result.viewCache;
    return viewGenerateEventsForChanges_(view, result.changes, result.viewCache.eventCache.getNode(), null);
}
function viewGetInitialEvents(view, registration) {
    const eventSnap = view.viewCache_.eventCache;
    const initialChanges = [];
    if (!eventSnap.getNode().isLeafNode()) {
        const eventNode = eventSnap.getNode();
        eventNode.forEachChild(PRIORITY_INDEX, (key, childNode) => {
            initialChanges.push(changeChildAdded(key, childNode));
        });
    }
    if (eventSnap.isFullyInitialized()) {
        initialChanges.push(changeValue(eventSnap.getNode()));
    }
    return viewGenerateEventsForChanges_(view, initialChanges, eventSnap.getNode(), registration);
}
function viewGenerateEventsForChanges_(view, changes, eventCache, eventRegistration) {
    const registrations = eventRegistration
        ? [eventRegistration]
        : view.eventRegistrations_;
    return eventGeneratorGenerateEventsForChanges(view.eventGenerator_, changes, eventCache, registrations);
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
let referenceConstructor$1;
/**
 * SyncPoint represents a single location in a SyncTree with 1 or more event registrations, meaning we need to
 * maintain 1 or more Views at this location to cache server data and raise appropriate events for server changes
 * and user writes (set, transaction, update).
 *
 * It's responsible for:
 *  - Maintaining the set of 1 or more views necessary at this location (a SyncPoint with 0 views should be removed).
 *  - Proxying user / server operations to the views as appropriate (i.e. applyServerOverwrite,
 *    applyUserOverwrite, etc.)
 */
class SyncPoint {
    constructor() {
        /**
         * The Views being tracked at this location in the tree, stored as a map where the key is a
         * queryId and the value is the View for that query.
         *
         * NOTE: This list will be quite small (usually 1, but perhaps 2 or 3; any more is an odd use case).
         */
        this.views = new Map();
    }
}
function syncPointSetReferenceConstructor(val) {
    (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(!referenceConstructor$1, '__referenceConstructor has already been defined');
    referenceConstructor$1 = val;
}
function syncPointGetReferenceConstructor() {
    (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(referenceConstructor$1, 'Reference.ts has not been loaded');
    return referenceConstructor$1;
}
function syncPointIsEmpty(syncPoint) {
    return syncPoint.views.size === 0;
}
function syncPointApplyOperation(syncPoint, operation, writesCache, optCompleteServerCache) {
    const queryId = operation.source.queryId;
    if (queryId !== null) {
        const view = syncPoint.views.get(queryId);
        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(view != null, 'SyncTree gave us an op for an invalid query.');
        return viewApplyOperation(view, operation, writesCache, optCompleteServerCache);
    }
    else {
        let events = [];
        for (const view of syncPoint.views.values()) {
            events = events.concat(viewApplyOperation(view, operation, writesCache, optCompleteServerCache));
        }
        return events;
    }
}
/**
 * Get a view for the specified query.
 *
 * @param query - The query to return a view for
 * @param writesCache
 * @param serverCache
 * @param serverCacheComplete
 * @returns Events to raise.
 */
function syncPointGetView(syncPoint, query, writesCache, serverCache, serverCacheComplete) {
    const queryId = query._queryIdentifier;
    const view = syncPoint.views.get(queryId);
    if (!view) {
        // TODO: make writesCache take flag for complete server node
        let eventCache = writeTreeRefCalcCompleteEventCache(writesCache, serverCacheComplete ? serverCache : null);
        let eventCacheComplete = false;
        if (eventCache) {
            eventCacheComplete = true;
        }
        else if (serverCache instanceof ChildrenNode) {
            eventCache = writeTreeRefCalcCompleteEventChildren(writesCache, serverCache);
            eventCacheComplete = false;
        }
        else {
            eventCache = ChildrenNode.EMPTY_NODE;
            eventCacheComplete = false;
        }
        const viewCache = newViewCache(new CacheNode(eventCache, eventCacheComplete, false), new CacheNode(serverCache, serverCacheComplete, false));
        return new View(query, viewCache);
    }
    return view;
}
/**
 * Add an event callback for the specified query.
 *
 * @param query
 * @param eventRegistration
 * @param writesCache
 * @param serverCache - Complete server cache, if we have it.
 * @param serverCacheComplete
 * @returns Events to raise.
 */
function syncPointAddEventRegistration(syncPoint, query, eventRegistration, writesCache, serverCache, serverCacheComplete) {
    const view = syncPointGetView(syncPoint, query, writesCache, serverCache, serverCacheComplete);
    if (!syncPoint.views.has(query._queryIdentifier)) {
        syncPoint.views.set(query._queryIdentifier, view);
    }
    // This is guaranteed to exist now, we just created anything that was missing
    viewAddEventRegistration(view, eventRegistration);
    return viewGetInitialEvents(view, eventRegistration);
}
/**
 * Remove event callback(s).  Return cancelEvents if a cancelError is specified.
 *
 * If query is the default query, we'll check all views for the specified eventRegistration.
 * If eventRegistration is null, we'll remove all callbacks for the specified view(s).
 *
 * @param eventRegistration - If null, remove all callbacks.
 * @param cancelError - If a cancelError is provided, appropriate cancel events will be returned.
 * @returns removed queries and any cancel events
 */
function syncPointRemoveEventRegistration(syncPoint, query, eventRegistration, cancelError) {
    const queryId = query._queryIdentifier;
    const removed = [];
    let cancelEvents = [];
    const hadCompleteView = syncPointHasCompleteView(syncPoint);
    if (queryId === 'default') {
        // When you do ref.off(...), we search all views for the registration to remove.
        for (const [viewQueryId, view] of syncPoint.views.entries()) {
            cancelEvents = cancelEvents.concat(viewRemoveEventRegistration(view, eventRegistration, cancelError));
            if (viewIsEmpty(view)) {
                syncPoint.views.delete(viewQueryId);
                // We'll deal with complete views later.
                if (!view.query._queryParams.loadsAllData()) {
                    removed.push(view.query);
                }
            }
        }
    }
    else {
        // remove the callback from the specific view.
        const view = syncPoint.views.get(queryId);
        if (view) {
            cancelEvents = cancelEvents.concat(viewRemoveEventRegistration(view, eventRegistration, cancelError));
            if (viewIsEmpty(view)) {
                syncPoint.views.delete(queryId);
                // We'll deal with complete views later.
                if (!view.query._queryParams.loadsAllData()) {
                    removed.push(view.query);
                }
            }
        }
    }
    if (hadCompleteView && !syncPointHasCompleteView(syncPoint)) {
        // We removed our last complete view.
        removed.push(new (syncPointGetReferenceConstructor())(query._repo, query._path));
    }
    return { removed, events: cancelEvents };
}
function syncPointGetQueryViews(syncPoint) {
    const result = [];
    for (const view of syncPoint.views.values()) {
        if (!view.query._queryParams.loadsAllData()) {
            result.push(view);
        }
    }
    return result;
}
/**
 * @param path - The path to the desired complete snapshot
 * @returns A complete cache, if it exists
 */
function syncPointGetCompleteServerCache(syncPoint, path) {
    let serverCache = null;
    for (const view of syncPoint.views.values()) {
        serverCache = serverCache || viewGetCompleteServerCache(view, path);
    }
    return serverCache;
}
function syncPointViewForQuery(syncPoint, query) {
    const params = query._queryParams;
    if (params.loadsAllData()) {
        return syncPointGetCompleteView(syncPoint);
    }
    else {
        const queryId = query._queryIdentifier;
        return syncPoint.views.get(queryId);
    }
}
function syncPointViewExistsForQuery(syncPoint, query) {
    return syncPointViewForQuery(syncPoint, query) != null;
}
function syncPointHasCompleteView(syncPoint) {
    return syncPointGetCompleteView(syncPoint) != null;
}
function syncPointGetCompleteView(syncPoint) {
    for (const view of syncPoint.views.values()) {
        if (view.query._queryParams.loadsAllData()) {
            return view;
        }
    }
    return null;
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
let referenceConstructor;
function syncTreeSetReferenceConstructor(val) {
    (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(!referenceConstructor, '__referenceConstructor has already been defined');
    referenceConstructor = val;
}
function syncTreeGetReferenceConstructor() {
    (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(referenceConstructor, 'Reference.ts has not been loaded');
    return referenceConstructor;
}
/**
 * Static tracker for next query tag.
 */
let syncTreeNextQueryTag_ = 1;
/**
 * SyncTree is the central class for managing event callback registration, data caching, views
 * (query processing), and event generation.  There are typically two SyncTree instances for
 * each Repo, one for the normal Firebase data, and one for the .info data.
 *
 * It has a number of responsibilities, including:
 *  - Tracking all user event callbacks (registered via addEventRegistration() and removeEventRegistration()).
 *  - Applying and caching data changes for user set(), transaction(), and update() calls
 *    (applyUserOverwrite(), applyUserMerge()).
 *  - Applying and caching data changes for server data changes (applyServerOverwrite(),
 *    applyServerMerge()).
 *  - Generating user-facing events for server and user changes (all of the apply* methods
 *    return the set of events that need to be raised as a result).
 *  - Maintaining the appropriate set of server listens to ensure we are always subscribed
 *    to the correct set of paths and queries to satisfy the current set of user event
 *    callbacks (listens are started/stopped using the provided listenProvider).
 *
 * NOTE: Although SyncTree tracks event callbacks and calculates events to raise, the actual
 * events are returned to the caller rather than raised synchronously.
 *
 */
class SyncTree {
    /**
     * @param listenProvider_ - Used by SyncTree to start / stop listening
     *   to server data.
     */
    constructor(listenProvider_) {
        this.listenProvider_ = listenProvider_;
        /**
         * Tree of SyncPoints.  There's a SyncPoint at any location that has 1 or more views.
         */
        this.syncPointTree_ = new ImmutableTree(null);
        /**
         * A tree of all pending user writes (user-initiated set()'s, transaction()'s, update()'s, etc.).
         */
        this.pendingWriteTree_ = newWriteTree();
        this.tagToQueryMap = new Map();
        this.queryToTagMap = new Map();
    }
}
/**
 * Apply the data changes for a user-generated set() or transaction() call.
 *
 * @returns Events to raise.
 */
function syncTreeApplyUserOverwrite(syncTree, path, newData, writeId, visible) {
    // Record pending write.
    writeTreeAddOverwrite(syncTree.pendingWriteTree_, path, newData, writeId, visible);
    if (!visible) {
        return [];
    }
    else {
        return syncTreeApplyOperationToSyncPoints_(syncTree, new Overwrite(newOperationSourceUser(), path, newData));
    }
}
/**
 * Apply the data from a user-generated update() call
 *
 * @returns Events to raise.
 */
function syncTreeApplyUserMerge(syncTree, path, changedChildren, writeId) {
    // Record pending merge.
    writeTreeAddMerge(syncTree.pendingWriteTree_, path, changedChildren, writeId);
    const changeTree = ImmutableTree.fromObject(changedChildren);
    return syncTreeApplyOperationToSyncPoints_(syncTree, new Merge(newOperationSourceUser(), path, changeTree));
}
/**
 * Acknowledge a pending user write that was previously registered with applyUserOverwrite() or applyUserMerge().
 *
 * @param revert - True if the given write failed and needs to be reverted
 * @returns Events to raise.
 */
function syncTreeAckUserWrite(syncTree, writeId, revert = false) {
    const write = writeTreeGetWrite(syncTree.pendingWriteTree_, writeId);
    const needToReevaluate = writeTreeRemoveWrite(syncTree.pendingWriteTree_, writeId);
    if (!needToReevaluate) {
        return [];
    }
    else {
        let affectedTree = new ImmutableTree(null);
        if (write.snap != null) {
            // overwrite
            affectedTree = affectedTree.set(newEmptyPath(), true);
        }
        else {
            each(write.children, (pathString) => {
                affectedTree = affectedTree.set(new Path(pathString), true);
            });
        }
        return syncTreeApplyOperationToSyncPoints_(syncTree, new AckUserWrite(write.path, affectedTree, revert));
    }
}
/**
 * Apply new server data for the specified path..
 *
 * @returns Events to raise.
 */
function syncTreeApplyServerOverwrite(syncTree, path, newData) {
    return syncTreeApplyOperationToSyncPoints_(syncTree, new Overwrite(newOperationSourceServer(), path, newData));
}
/**
 * Apply new server data to be merged in at the specified path.
 *
 * @returns Events to raise.
 */
function syncTreeApplyServerMerge(syncTree, path, changedChildren) {
    const changeTree = ImmutableTree.fromObject(changedChildren);
    return syncTreeApplyOperationToSyncPoints_(syncTree, new Merge(newOperationSourceServer(), path, changeTree));
}
/**
 * Apply a listen complete for a query
 *
 * @returns Events to raise.
 */
function syncTreeApplyListenComplete(syncTree, path) {
    return syncTreeApplyOperationToSyncPoints_(syncTree, new ListenComplete(newOperationSourceServer(), path));
}
/**
 * Apply a listen complete for a tagged query
 *
 * @returns Events to raise.
 */
function syncTreeApplyTaggedListenComplete(syncTree, path, tag) {
    const queryKey = syncTreeQueryKeyForTag_(syncTree, tag);
    if (queryKey) {
        const r = syncTreeParseQueryKey_(queryKey);
        const queryPath = r.path, queryId = r.queryId;
        const relativePath = newRelativePath(queryPath, path);
        const op = new ListenComplete(newOperationSourceServerTaggedQuery(queryId), relativePath);
        return syncTreeApplyTaggedOperation_(syncTree, queryPath, op);
    }
    else {
        // We've already removed the query. No big deal, ignore the update
        return [];
    }
}
/**
 * Remove event callback(s).
 *
 * If query is the default query, we'll check all queries for the specified eventRegistration.
 * If eventRegistration is null, we'll remove all callbacks for the specified query/queries.
 *
 * @param eventRegistration - If null, all callbacks are removed.
 * @param cancelError - If a cancelError is provided, appropriate cancel events will be returned.
 * @returns Cancel events, if cancelError was provided.
 */
function syncTreeRemoveEventRegistration(syncTree, query, eventRegistration, cancelError) {
    // Find the syncPoint first. Then deal with whether or not it has matching listeners
    const path = query._path;
    const maybeSyncPoint = syncTree.syncPointTree_.get(path);
    let cancelEvents = [];
    // A removal on a default query affects all queries at that location. A removal on an indexed query, even one without
    // other query constraints, does *not* affect all queries at that location. So this check must be for 'default', and
    // not loadsAllData().
    if (maybeSyncPoint &&
        (query._queryIdentifier === 'default' ||
            syncPointViewExistsForQuery(maybeSyncPoint, query))) {
        const removedAndEvents = syncPointRemoveEventRegistration(maybeSyncPoint, query, eventRegistration, cancelError);
        if (syncPointIsEmpty(maybeSyncPoint)) {
            syncTree.syncPointTree_ = syncTree.syncPointTree_.remove(path);
        }
        const removed = removedAndEvents.removed;
        cancelEvents = removedAndEvents.events;
        // We may have just removed one of many listeners and can short-circuit this whole process
        // We may also not have removed a default listener, in which case all of the descendant listeners should already be
        // properly set up.
        //
        // Since indexed queries can shadow if they don't have other query constraints, check for loadsAllData(), instead of
        // queryId === 'default'
        const removingDefault = -1 !==
            removed.findIndex(query => {
                return query._queryParams.loadsAllData();
            });
        const covered = syncTree.syncPointTree_.findOnPath(path, (relativePath, parentSyncPoint) => syncPointHasCompleteView(parentSyncPoint));
        if (removingDefault && !covered) {
            const subtree = syncTree.syncPointTree_.subtree(path);
            // There are potentially child listeners. Determine what if any listens we need to send before executing the
            // removal
            if (!subtree.isEmpty()) {
                // We need to fold over our subtree and collect the listeners to send
                const newViews = syncTreeCollectDistinctViewsForSubTree_(subtree);
                // Ok, we've collected all the listens we need. Set them up.
                for (let i = 0; i < newViews.length; ++i) {
                    const view = newViews[i], newQuery = view.query;
                    const listener = syncTreeCreateListenerForView_(syncTree, view);
                    syncTree.listenProvider_.startListening(syncTreeQueryForListening_(newQuery), syncTreeTagForQuery_(syncTree, newQuery), listener.hashFn, listener.onComplete);
                }
            }
        }
        // If we removed anything and we're not covered by a higher up listen, we need to stop listening on this query
        // The above block has us covered in terms of making sure we're set up on listens lower in the tree.
        // Also, note that if we have a cancelError, it's already been removed at the provider level.
        if (!covered && removed.length > 0 && !cancelError) {
            // If we removed a default, then we weren't listening on any of the other queries here. Just cancel the one
            // default. Otherwise, we need to iterate through and cancel each individual query
            if (removingDefault) {
                // We don't tag default listeners
                const defaultTag = null;
                syncTree.listenProvider_.stopListening(syncTreeQueryForListening_(query), defaultTag);
            }
            else {
                removed.forEach((queryToRemove) => {
                    const tagToRemove = syncTree.queryToTagMap.get(syncTreeMakeQueryKey_(queryToRemove));
                    syncTree.listenProvider_.stopListening(syncTreeQueryForListening_(queryToRemove), tagToRemove);
                });
            }
        }
        // Now, clear all of the tags we're tracking for the removed listens
        syncTreeRemoveTags_(syncTree, removed);
    }
    return cancelEvents;
}
/**
 * Apply new server data for the specified tagged query.
 *
 * @returns Events to raise.
 */
function syncTreeApplyTaggedQueryOverwrite(syncTree, path, snap, tag) {
    const queryKey = syncTreeQueryKeyForTag_(syncTree, tag);
    if (queryKey != null) {
        const r = syncTreeParseQueryKey_(queryKey);
        const queryPath = r.path, queryId = r.queryId;
        const relativePath = newRelativePath(queryPath, path);
        const op = new Overwrite(newOperationSourceServerTaggedQuery(queryId), relativePath, snap);
        return syncTreeApplyTaggedOperation_(syncTree, queryPath, op);
    }
    else {
        // Query must have been removed already
        return [];
    }
}
/**
 * Apply server data to be merged in for the specified tagged query.
 *
 * @returns Events to raise.
 */
function syncTreeApplyTaggedQueryMerge(syncTree, path, changedChildren, tag) {
    const queryKey = syncTreeQueryKeyForTag_(syncTree, tag);
    if (queryKey) {
        const r = syncTreeParseQueryKey_(queryKey);
        const queryPath = r.path, queryId = r.queryId;
        const relativePath = newRelativePath(queryPath, path);
        const changeTree = ImmutableTree.fromObject(changedChildren);
        const op = new Merge(newOperationSourceServerTaggedQuery(queryId), relativePath, changeTree);
        return syncTreeApplyTaggedOperation_(syncTree, queryPath, op);
    }
    else {
        // We've already removed the query. No big deal, ignore the update
        return [];
    }
}
/**
 * Add an event callback for the specified query.
 *
 * @returns Events to raise.
 */
function syncTreeAddEventRegistration(syncTree, query, eventRegistration) {
    const path = query._path;
    let serverCache = null;
    let foundAncestorDefaultView = false;
    // Any covering writes will necessarily be at the root, so really all we need to find is the server cache.
    // Consider optimizing this once there's a better understanding of what actual behavior will be.
    syncTree.syncPointTree_.foreachOnPath(path, (pathToSyncPoint, sp) => {
        const relativePath = newRelativePath(pathToSyncPoint, path);
        serverCache =
            serverCache || syncPointGetCompleteServerCache(sp, relativePath);
        foundAncestorDefaultView =
            foundAncestorDefaultView || syncPointHasCompleteView(sp);
    });
    let syncPoint = syncTree.syncPointTree_.get(path);
    if (!syncPoint) {
        syncPoint = new SyncPoint();
        syncTree.syncPointTree_ = syncTree.syncPointTree_.set(path, syncPoint);
    }
    else {
        foundAncestorDefaultView =
            foundAncestorDefaultView || syncPointHasCompleteView(syncPoint);
        serverCache =
            serverCache || syncPointGetCompleteServerCache(syncPoint, newEmptyPath());
    }
    let serverCacheComplete;
    if (serverCache != null) {
        serverCacheComplete = true;
    }
    else {
        serverCacheComplete = false;
        serverCache = ChildrenNode.EMPTY_NODE;
        const subtree = syncTree.syncPointTree_.subtree(path);
        subtree.foreachChild((childName, childSyncPoint) => {
            const completeCache = syncPointGetCompleteServerCache(childSyncPoint, newEmptyPath());
            if (completeCache) {
                serverCache = serverCache.updateImmediateChild(childName, completeCache);
            }
        });
    }
    const viewAlreadyExists = syncPointViewExistsForQuery(syncPoint, query);
    if (!viewAlreadyExists && !query._queryParams.loadsAllData()) {
        // We need to track a tag for this query
        const queryKey = syncTreeMakeQueryKey_(query);
        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(!syncTree.queryToTagMap.has(queryKey), 'View does not exist, but we have a tag');
        const tag = syncTreeGetNextQueryTag_();
        syncTree.queryToTagMap.set(queryKey, tag);
        syncTree.tagToQueryMap.set(tag, queryKey);
    }
    const writesCache = writeTreeChildWrites(syncTree.pendingWriteTree_, path);
    let events = syncPointAddEventRegistration(syncPoint, query, eventRegistration, writesCache, serverCache, serverCacheComplete);
    if (!viewAlreadyExists && !foundAncestorDefaultView) {
        const view = syncPointViewForQuery(syncPoint, query);
        events = events.concat(syncTreeSetupListener_(syncTree, query, view));
    }
    return events;
}
/**
 * Returns a complete cache, if we have one, of the data at a particular path. If the location does not have a
 * listener above it, we will get a false "null". This shouldn't be a problem because transactions will always
 * have a listener above, and atomic operations would correctly show a jitter of <increment value> ->
 *     <incremented total> as the write is applied locally and then acknowledged at the server.
 *
 * Note: this method will *include* hidden writes from transaction with applyLocally set to false.
 *
 * @param path - The path to the data we want
 * @param writeIdsToExclude - A specific set to be excluded
 */
function syncTreeCalcCompleteEventCache(syncTree, path, writeIdsToExclude) {
    const includeHiddenSets = true;
    const writeTree = syncTree.pendingWriteTree_;
    const serverCache = syncTree.syncPointTree_.findOnPath(path, (pathSoFar, syncPoint) => {
        const relativePath = newRelativePath(pathSoFar, path);
        const serverCache = syncPointGetCompleteServerCache(syncPoint, relativePath);
        if (serverCache) {
            return serverCache;
        }
    });
    return writeTreeCalcCompleteEventCache(writeTree, path, serverCache, writeIdsToExclude, includeHiddenSets);
}
function syncTreeGetServerValue(syncTree, query) {
    const path = query._path;
    let serverCache = null;
    // Any covering writes will necessarily be at the root, so really all we need to find is the server cache.
    // Consider optimizing this once there's a better understanding of what actual behavior will be.
    syncTree.syncPointTree_.foreachOnPath(path, (pathToSyncPoint, sp) => {
        const relativePath = newRelativePath(pathToSyncPoint, path);
        serverCache =
            serverCache || syncPointGetCompleteServerCache(sp, relativePath);
    });
    let syncPoint = syncTree.syncPointTree_.get(path);
    if (!syncPoint) {
        syncPoint = new SyncPoint();
        syncTree.syncPointTree_ = syncTree.syncPointTree_.set(path, syncPoint);
    }
    else {
        serverCache =
            serverCache || syncPointGetCompleteServerCache(syncPoint, newEmptyPath());
    }
    const serverCacheComplete = serverCache != null;
    const serverCacheNode = serverCacheComplete
        ? new CacheNode(serverCache, true, false)
        : null;
    const writesCache = writeTreeChildWrites(syncTree.pendingWriteTree_, query._path);
    const view = syncPointGetView(syncPoint, query, writesCache, serverCacheComplete ? serverCacheNode.getNode() : ChildrenNode.EMPTY_NODE, serverCacheComplete);
    return viewGetCompleteNode(view);
}
/**
 * A helper method that visits all descendant and ancestor SyncPoints, applying the operation.
 *
 * NOTES:
 * - Descendant SyncPoints will be visited first (since we raise events depth-first).
 *
 * - We call applyOperation() on each SyncPoint passing three things:
 *   1. A version of the Operation that has been made relative to the SyncPoint location.
 *   2. A WriteTreeRef of any writes we have cached at the SyncPoint location.
 *   3. A snapshot Node with cached server data, if we have it.
 *
 * - We concatenate all of the events returned by each SyncPoint and return the result.
 */
function syncTreeApplyOperationToSyncPoints_(syncTree, operation) {
    return syncTreeApplyOperationHelper_(operation, syncTree.syncPointTree_, 
    /*serverCache=*/ null, writeTreeChildWrites(syncTree.pendingWriteTree_, newEmptyPath()));
}
/**
 * Recursive helper for applyOperationToSyncPoints_
 */
function syncTreeApplyOperationHelper_(operation, syncPointTree, serverCache, writesCache) {
    if (pathIsEmpty(operation.path)) {
        return syncTreeApplyOperationDescendantsHelper_(operation, syncPointTree, serverCache, writesCache);
    }
    else {
        const syncPoint = syncPointTree.get(newEmptyPath());
        // If we don't have cached server data, see if we can get it from this SyncPoint.
        if (serverCache == null && syncPoint != null) {
            serverCache = syncPointGetCompleteServerCache(syncPoint, newEmptyPath());
        }
        let events = [];
        const childName = pathGetFront(operation.path);
        const childOperation = operation.operationForChild(childName);
        const childTree = syncPointTree.children.get(childName);
        if (childTree && childOperation) {
            const childServerCache = serverCache
                ? serverCache.getImmediateChild(childName)
                : null;
            const childWritesCache = writeTreeRefChild(writesCache, childName);
            events = events.concat(syncTreeApplyOperationHelper_(childOperation, childTree, childServerCache, childWritesCache));
        }
        if (syncPoint) {
            events = events.concat(syncPointApplyOperation(syncPoint, operation, writesCache, serverCache));
        }
        return events;
    }
}
/**
 * Recursive helper for applyOperationToSyncPoints_
 */
function syncTreeApplyOperationDescendantsHelper_(operation, syncPointTree, serverCache, writesCache) {
    const syncPoint = syncPointTree.get(newEmptyPath());
    // If we don't have cached server data, see if we can get it from this SyncPoint.
    if (serverCache == null && syncPoint != null) {
        serverCache = syncPointGetCompleteServerCache(syncPoint, newEmptyPath());
    }
    let events = [];
    syncPointTree.children.inorderTraversal((childName, childTree) => {
        const childServerCache = serverCache
            ? serverCache.getImmediateChild(childName)
            : null;
        const childWritesCache = writeTreeRefChild(writesCache, childName);
        const childOperation = operation.operationForChild(childName);
        if (childOperation) {
            events = events.concat(syncTreeApplyOperationDescendantsHelper_(childOperation, childTree, childServerCache, childWritesCache));
        }
    });
    if (syncPoint) {
        events = events.concat(syncPointApplyOperation(syncPoint, operation, writesCache, serverCache));
    }
    return events;
}
function syncTreeCreateListenerForView_(syncTree, view) {
    const query = view.query;
    const tag = syncTreeTagForQuery_(syncTree, query);
    return {
        hashFn: () => {
            const cache = viewGetServerCache(view) || ChildrenNode.EMPTY_NODE;
            return cache.hash();
        },
        onComplete: (status) => {
            if (status === 'ok') {
                if (tag) {
                    return syncTreeApplyTaggedListenComplete(syncTree, query._path, tag);
                }
                else {
                    return syncTreeApplyListenComplete(syncTree, query._path);
                }
            }
            else {
                // If a listen failed, kill all of the listeners here, not just the one that triggered the error.
                // Note that this may need to be scoped to just this listener if we change permissions on filtered children
                const error = errorForServerCode(status, query);
                return syncTreeRemoveEventRegistration(syncTree, query, 
                /*eventRegistration*/ null, error);
            }
        }
    };
}
/**
 * Return the tag associated with the given query.
 */
function syncTreeTagForQuery_(syncTree, query) {
    const queryKey = syncTreeMakeQueryKey_(query);
    return syncTree.queryToTagMap.get(queryKey);
}
/**
 * Given a query, computes a "queryKey" suitable for use in our queryToTagMap_.
 */
function syncTreeMakeQueryKey_(query) {
    return query._path.toString() + '$' + query._queryIdentifier;
}
/**
 * Return the query associated with the given tag, if we have one
 */
function syncTreeQueryKeyForTag_(syncTree, tag) {
    return syncTree.tagToQueryMap.get(tag);
}
/**
 * Given a queryKey (created by makeQueryKey), parse it back into a path and queryId.
 */
function syncTreeParseQueryKey_(queryKey) {
    const splitIndex = queryKey.indexOf('$');
    (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(splitIndex !== -1 && splitIndex < queryKey.length - 1, 'Bad queryKey.');
    return {
        queryId: queryKey.substr(splitIndex + 1),
        path: new Path(queryKey.substr(0, splitIndex))
    };
}
/**
 * A helper method to apply tagged operations
 */
function syncTreeApplyTaggedOperation_(syncTree, queryPath, operation) {
    const syncPoint = syncTree.syncPointTree_.get(queryPath);
    (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(syncPoint, "Missing sync point for query tag that we're tracking");
    const writesCache = writeTreeChildWrites(syncTree.pendingWriteTree_, queryPath);
    return syncPointApplyOperation(syncPoint, operation, writesCache, null);
}
/**
 * This collapses multiple unfiltered views into a single view, since we only need a single
 * listener for them.
 */
function syncTreeCollectDistinctViewsForSubTree_(subtree) {
    return subtree.fold((relativePath, maybeChildSyncPoint, childMap) => {
        if (maybeChildSyncPoint && syncPointHasCompleteView(maybeChildSyncPoint)) {
            const completeView = syncPointGetCompleteView(maybeChildSyncPoint);
            return [completeView];
        }
        else {
            // No complete view here, flatten any deeper listens into an array
            let views = [];
            if (maybeChildSyncPoint) {
                views = syncPointGetQueryViews(maybeChildSyncPoint);
            }
            each(childMap, (_key, childViews) => {
                views = views.concat(childViews);
            });
            return views;
        }
    });
}
/**
 * Normalizes a query to a query we send the server for listening
 *
 * @returns The normalized query
 */
function syncTreeQueryForListening_(query) {
    if (query._queryParams.loadsAllData() && !query._queryParams.isDefault()) {
        // We treat queries that load all data as default queries
        // Cast is necessary because ref() technically returns Firebase which is actually fb.api.Firebase which inherits
        // from Query
        return new (syncTreeGetReferenceConstructor())(query._repo, query._path);
    }
    else {
        return query;
    }
}
function syncTreeRemoveTags_(syncTree, queries) {
    for (let j = 0; j < queries.length; ++j) {
        const removedQuery = queries[j];
        if (!removedQuery._queryParams.loadsAllData()) {
            // We should have a tag for this
            const removedQueryKey = syncTreeMakeQueryKey_(removedQuery);
            const removedQueryTag = syncTree.queryToTagMap.get(removedQueryKey);
            syncTree.queryToTagMap.delete(removedQueryKey);
            syncTree.tagToQueryMap.delete(removedQueryTag);
        }
    }
}
/**
 * Static accessor for query tags.
 */
function syncTreeGetNextQueryTag_() {
    return syncTreeNextQueryTag_++;
}
/**
 * For a given new listen, manage the de-duplication of outstanding subscriptions.
 *
 * @returns This method can return events to support synchronous data sources
 */
function syncTreeSetupListener_(syncTree, query, view) {
    const path = query._path;
    const tag = syncTreeTagForQuery_(syncTree, query);
    const listener = syncTreeCreateListenerForView_(syncTree, view);
    const events = syncTree.listenProvider_.startListening(syncTreeQueryForListening_(query), tag, listener.hashFn, listener.onComplete);
    const subtree = syncTree.syncPointTree_.subtree(path);
    // The root of this subtree has our query. We're here because we definitely need to send a listen for that, but we
    // may need to shadow other listens as well.
    if (tag) {
        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(!syncPointHasCompleteView(subtree.value), "If we're adding a query, it shouldn't be shadowed");
    }
    else {
        // Shadow everything at or below this location, this is a default listener.
        const queriesToStop = subtree.fold((relativePath, maybeChildSyncPoint, childMap) => {
            if (!pathIsEmpty(relativePath) &&
                maybeChildSyncPoint &&
                syncPointHasCompleteView(maybeChildSyncPoint)) {
                return [syncPointGetCompleteView(maybeChildSyncPoint).query];
            }
            else {
                // No default listener here, flatten any deeper queries into an array
                let queries = [];
                if (maybeChildSyncPoint) {
                    queries = queries.concat(syncPointGetQueryViews(maybeChildSyncPoint).map(view => view.query));
                }
                each(childMap, (_key, childQueries) => {
                    queries = queries.concat(childQueries);
                });
                return queries;
            }
        });
        for (let i = 0; i < queriesToStop.length; ++i) {
            const queryToStop = queriesToStop[i];
            syncTree.listenProvider_.stopListening(syncTreeQueryForListening_(queryToStop), syncTreeTagForQuery_(syncTree, queryToStop));
        }
    }
    return events;
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ExistingValueProvider {
    constructor(node_) {
        this.node_ = node_;
    }
    getImmediateChild(childName) {
        const child = this.node_.getImmediateChild(childName);
        return new ExistingValueProvider(child);
    }
    node() {
        return this.node_;
    }
}
class DeferredValueProvider {
    constructor(syncTree, path) {
        this.syncTree_ = syncTree;
        this.path_ = path;
    }
    getImmediateChild(childName) {
        const childPath = pathChild(this.path_, childName);
        return new DeferredValueProvider(this.syncTree_, childPath);
    }
    node() {
        return syncTreeCalcCompleteEventCache(this.syncTree_, this.path_);
    }
}
/**
 * Generate placeholders for deferred values.
 */
const generateWithValues = function (values) {
    values = values || {};
    values['timestamp'] = values['timestamp'] || new Date().getTime();
    return values;
};
/**
 * Value to use when firing local events. When writing server values, fire
 * local events with an approximate value, otherwise return value as-is.
 */
const resolveDeferredLeafValue = function (value, existingVal, serverValues) {
    if (!value || typeof value !== 'object') {
        return value;
    }
    (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)('.sv' in value, 'Unexpected leaf node or priority contents');
    if (typeof value['.sv'] === 'string') {
        return resolveScalarDeferredValue(value['.sv'], existingVal, serverValues);
    }
    else if (typeof value['.sv'] === 'object') {
        return resolveComplexDeferredValue(value['.sv'], existingVal);
    }
    else {
        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(false, 'Unexpected server value: ' + JSON.stringify(value, null, 2));
    }
};
const resolveScalarDeferredValue = function (op, existing, serverValues) {
    switch (op) {
        case 'timestamp':
            return serverValues['timestamp'];
        default:
            (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(false, 'Unexpected server value: ' + op);
    }
};
const resolveComplexDeferredValue = function (op, existing, unused) {
    if (!op.hasOwnProperty('increment')) {
        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(false, 'Unexpected server value: ' + JSON.stringify(op, null, 2));
    }
    const delta = op['increment'];
    if (typeof delta !== 'number') {
        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(false, 'Unexpected increment value: ' + delta);
    }
    const existingNode = existing.node();
    (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(existingNode !== null && typeof existingNode !== 'undefined', 'Expected ChildrenNode.EMPTY_NODE for nulls');
    // Incrementing a non-number sets the value to the incremented amount
    if (!existingNode.isLeafNode()) {
        return delta;
    }
    const leaf = existingNode;
    const existingVal = leaf.getValue();
    if (typeof existingVal !== 'number') {
        return delta;
    }
    // No need to do over/underflow arithmetic here because JS only handles floats under the covers
    return existingVal + delta;
};
/**
 * Recursively replace all deferred values and priorities in the tree with the
 * specified generated replacement values.
 * @param path - path to which write is relative
 * @param node - new data written at path
 * @param syncTree - current data
 */
const resolveDeferredValueTree = function (path, node, syncTree, serverValues) {
    return resolveDeferredValue(node, new DeferredValueProvider(syncTree, path), serverValues);
};
/**
 * Recursively replace all deferred values and priorities in the node with the
 * specified generated replacement values.  If there are no server values in the node,
 * it'll be returned as-is.
 */
const resolveDeferredValueSnapshot = function (node, existing, serverValues) {
    return resolveDeferredValue(node, new ExistingValueProvider(existing), serverValues);
};
function resolveDeferredValue(node, existingVal, serverValues) {
    const rawPri = node.getPriority().val();
    const priority = resolveDeferredLeafValue(rawPri, existingVal.getImmediateChild('.priority'), serverValues);
    let newNode;
    if (node.isLeafNode()) {
        const leafNode = node;
        const value = resolveDeferredLeafValue(leafNode.getValue(), existingVal, serverValues);
        if (value !== leafNode.getValue() ||
            priority !== leafNode.getPriority().val()) {
            return new LeafNode(value, nodeFromJSON(priority));
        }
        else {
            return node;
        }
    }
    else {
        const childrenNode = node;
        newNode = childrenNode;
        if (priority !== childrenNode.getPriority().val()) {
            newNode = newNode.updatePriority(new LeafNode(priority));
        }
        childrenNode.forEachChild(PRIORITY_INDEX, (childName, childNode) => {
            const newChildNode = resolveDeferredValue(childNode, existingVal.getImmediateChild(childName), serverValues);
            if (newChildNode !== childNode) {
                newNode = newNode.updateImmediateChild(childName, newChildNode);
            }
        });
        return newNode;
    }
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * A light-weight tree, traversable by path.  Nodes can have both values and children.
 * Nodes are not enumerated (by forEachChild) unless they have a value or non-empty
 * children.
 */
class Tree {
    /**
     * @param name - Optional name of the node.
     * @param parent - Optional parent node.
     * @param node - Optional node to wrap.
     */
    constructor(name = '', parent = null, node = { children: {}, childCount: 0 }) {
        this.name = name;
        this.parent = parent;
        this.node = node;
    }
}
/**
 * Returns a sub-Tree for the given path.
 *
 * @param pathObj - Path to look up.
 * @returns Tree for path.
 */
function treeSubTree(tree, pathObj) {
    // TODO: Require pathObj to be Path?
    let path = pathObj instanceof Path ? pathObj : new Path(pathObj);
    let child = tree, next = pathGetFront(path);
    while (next !== null) {
        const childNode = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.safeGet)(child.node.children, next) || {
            children: {},
            childCount: 0
        };
        child = new Tree(next, child, childNode);
        path = pathPopFront(path);
        next = pathGetFront(path);
    }
    return child;
}
/**
 * Returns the data associated with this tree node.
 *
 * @returns The data or null if no data exists.
 */
function treeGetValue(tree) {
    return tree.node.value;
}
/**
 * Sets data to this tree node.
 *
 * @param value - Value to set.
 */
function treeSetValue(tree, value) {
    tree.node.value = value;
    treeUpdateParents(tree);
}
/**
 * @returns Whether the tree has any children.
 */
function treeHasChildren(tree) {
    return tree.node.childCount > 0;
}
/**
 * @returns Whethe rthe tree is empty (no value or children).
 */
function treeIsEmpty(tree) {
    return treeGetValue(tree) === undefined && !treeHasChildren(tree);
}
/**
 * Calls action for each child of this tree node.
 *
 * @param action - Action to be called for each child.
 */
function treeForEachChild(tree, action) {
    each(tree.node.children, (child, childTree) => {
        action(new Tree(child, tree, childTree));
    });
}
/**
 * Does a depth-first traversal of this node's descendants, calling action for each one.
 *
 * @param action - Action to be called for each child.
 * @param includeSelf - Whether to call action on this node as well. Defaults to
 *   false.
 * @param childrenFirst - Whether to call action on children before calling it on
 *   parent.
 */
function treeForEachDescendant(tree, action, includeSelf, childrenFirst) {
    if (includeSelf && !childrenFirst) {
        action(tree);
    }
    treeForEachChild(tree, child => {
        treeForEachDescendant(child, action, true, childrenFirst);
    });
    if (includeSelf && childrenFirst) {
        action(tree);
    }
}
/**
 * Calls action on each ancestor node.
 *
 * @param action - Action to be called on each parent; return
 *   true to abort.
 * @param includeSelf - Whether to call action on this node as well.
 * @returns true if the action callback returned true.
 */
function treeForEachAncestor(tree, action, includeSelf) {
    let node = includeSelf ? tree : tree.parent;
    while (node !== null) {
        if (action(node)) {
            return true;
        }
        node = node.parent;
    }
    return false;
}
/**
 * @returns The path of this tree node, as a Path.
 */
function treeGetPath(tree) {
    return new Path(tree.parent === null
        ? tree.name
        : treeGetPath(tree.parent) + '/' + tree.name);
}
/**
 * Adds or removes this child from its parent based on whether it's empty or not.
 */
function treeUpdateParents(tree) {
    if (tree.parent !== null) {
        treeUpdateChild(tree.parent, tree.name, tree);
    }
}
/**
 * Adds or removes the passed child to this tree node, depending on whether it's empty.
 *
 * @param childName - The name of the child to update.
 * @param child - The child to update.
 */
function treeUpdateChild(tree, childName, child) {
    const childEmpty = treeIsEmpty(child);
    const childExists = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.contains)(tree.node.children, childName);
    if (childEmpty && childExists) {
        delete tree.node.children[childName];
        tree.node.childCount--;
        treeUpdateParents(tree);
    }
    else if (!childEmpty && !childExists) {
        tree.node.children[childName] = child.node;
        tree.node.childCount++;
        treeUpdateParents(tree);
    }
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * True for invalid Firebase keys
 */
const INVALID_KEY_REGEX_ = /[\[\].#$\/\u0000-\u001F\u007F]/;
/**
 * True for invalid Firebase paths.
 * Allows '/' in paths.
 */
const INVALID_PATH_REGEX_ = /[\[\].#$\u0000-\u001F\u007F]/;
/**
 * Maximum number of characters to allow in leaf value
 */
const MAX_LEAF_SIZE_ = 10 * 1024 * 1024;
const isValidKey = function (key) {
    return (typeof key === 'string' && key.length !== 0 && !INVALID_KEY_REGEX_.test(key));
};
const isValidPathString = function (pathString) {
    return (typeof pathString === 'string' &&
        pathString.length !== 0 &&
        !INVALID_PATH_REGEX_.test(pathString));
};
const isValidRootPathString = function (pathString) {
    if (pathString) {
        // Allow '/.info/' at the beginning.
        pathString = pathString.replace(/^\/*\.info(\/|$)/, '/');
    }
    return isValidPathString(pathString);
};
const isValidPriority = function (priority) {
    return (priority === null ||
        typeof priority === 'string' ||
        (typeof priority === 'number' && !isInvalidJSONNumber(priority)) ||
        (priority &&
            typeof priority === 'object' &&
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.contains)(priority, '.sv')));
};
/**
 * Pre-validate a datum passed as an argument to Firebase function.
 */
const validateFirebaseDataArg = function (fnName, value, path, optional) {
    if (optional && value === undefined) {
        return;
    }
    validateFirebaseData((0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.errorPrefix)(fnName, 'value'), value, path);
};
/**
 * Validate a data object client-side before sending to server.
 */
const validateFirebaseData = function (errorPrefix, data, path_) {
    const path = path_ instanceof Path ? new ValidationPath(path_, errorPrefix) : path_;
    if (data === undefined) {
        throw new Error(errorPrefix + 'contains undefined ' + validationPathToErrorString(path));
    }
    if (typeof data === 'function') {
        throw new Error(errorPrefix +
            'contains a function ' +
            validationPathToErrorString(path) +
            ' with contents = ' +
            data.toString());
    }
    if (isInvalidJSONNumber(data)) {
        throw new Error(errorPrefix +
            'contains ' +
            data.toString() +
            ' ' +
            validationPathToErrorString(path));
    }
    // Check max leaf size, but try to avoid the utf8 conversion if we can.
    if (typeof data === 'string' &&
        data.length > MAX_LEAF_SIZE_ / 3 &&
        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.stringLength)(data) > MAX_LEAF_SIZE_) {
        throw new Error(errorPrefix +
            'contains a string greater than ' +
            MAX_LEAF_SIZE_ +
            ' utf8 bytes ' +
            validationPathToErrorString(path) +
            " ('" +
            data.substring(0, 50) +
            "...')");
    }
    // TODO = Perf = Consider combining the recursive validation of keys into NodeFromJSON
    // to save extra walking of large objects.
    if (data && typeof data === 'object') {
        let hasDotValue = false;
        let hasActualChild = false;
        each(data, (key, value) => {
            if (key === '.value') {
                hasDotValue = true;
            }
            else if (key !== '.priority' && key !== '.sv') {
                hasActualChild = true;
                if (!isValidKey(key)) {
                    throw new Error(errorPrefix +
                        ' contains an invalid key (' +
                        key +
                        ') ' +
                        validationPathToErrorString(path) +
                        '.  Keys must be non-empty strings ' +
                        'and can\'t contain ".", "#", "$", "/", "[", or "]"');
                }
            }
            validationPathPush(path, key);
            validateFirebaseData(errorPrefix, value, path);
            validationPathPop(path);
        });
        if (hasDotValue && hasActualChild) {
            throw new Error(errorPrefix +
                ' contains ".value" child ' +
                validationPathToErrorString(path) +
                ' in addition to actual children.');
        }
    }
};
/**
 * Pre-validate paths passed in the firebase function.
 */
const validateFirebaseMergePaths = function (errorPrefix, mergePaths) {
    let i, curPath;
    for (i = 0; i < mergePaths.length; i++) {
        curPath = mergePaths[i];
        const keys = pathSlice(curPath);
        for (let j = 0; j < keys.length; j++) {
            if (keys[j] === '.priority' && j === keys.length - 1) ;
            else if (!isValidKey(keys[j])) {
                throw new Error(errorPrefix +
                    'contains an invalid key (' +
                    keys[j] +
                    ') in path ' +
                    curPath.toString() +
                    '. Keys must be non-empty strings ' +
                    'and can\'t contain ".", "#", "$", "/", "[", or "]"');
            }
        }
    }
    // Check that update keys are not descendants of each other.
    // We rely on the property that sorting guarantees that ancestors come
    // right before descendants.
    mergePaths.sort(pathCompare);
    let prevPath = null;
    for (i = 0; i < mergePaths.length; i++) {
        curPath = mergePaths[i];
        if (prevPath !== null && pathContains(prevPath, curPath)) {
            throw new Error(errorPrefix +
                'contains a path ' +
                prevPath.toString() +
                ' that is ancestor of another path ' +
                curPath.toString());
        }
        prevPath = curPath;
    }
};
/**
 * pre-validate an object passed as an argument to firebase function (
 * must be an object - e.g. for firebase.update()).
 */
const validateFirebaseMergeDataArg = function (fnName, data, path, optional) {
    if (optional && data === undefined) {
        return;
    }
    const errorPrefix$1 = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.errorPrefix)(fnName, 'values');
    if (!(data && typeof data === 'object') || Array.isArray(data)) {
        throw new Error(errorPrefix$1 + ' must be an object containing the children to replace.');
    }
    const mergePaths = [];
    each(data, (key, value) => {
        const curPath = new Path(key);
        validateFirebaseData(errorPrefix$1, value, pathChild(path, curPath));
        if (pathGetBack(curPath) === '.priority') {
            if (!isValidPriority(value)) {
                throw new Error(errorPrefix$1 +
                    "contains an invalid value for '" +
                    curPath.toString() +
                    "', which must be a valid " +
                    'Firebase priority (a string, finite number, server value, or null).');
            }
        }
        mergePaths.push(curPath);
    });
    validateFirebaseMergePaths(errorPrefix$1, mergePaths);
};
const validatePriority = function (fnName, priority, optional) {
    if (optional && priority === undefined) {
        return;
    }
    if (isInvalidJSONNumber(priority)) {
        throw new Error((0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.errorPrefix)(fnName, 'priority') +
            'is ' +
            priority.toString() +
            ', but must be a valid Firebase priority (a string, finite number, ' +
            'server value, or null).');
    }
    // Special case to allow importing data with a .sv.
    if (!isValidPriority(priority)) {
        throw new Error((0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.errorPrefix)(fnName, 'priority') +
            'must be a valid Firebase priority ' +
            '(a string, finite number, server value, or null).');
    }
};
const validateKey = function (fnName, argumentName, key, optional) {
    if (optional && key === undefined) {
        return;
    }
    if (!isValidKey(key)) {
        throw new Error((0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.errorPrefix)(fnName, argumentName) +
            'was an invalid key = "' +
            key +
            '".  Firebase keys must be non-empty strings and ' +
            'can\'t contain ".", "#", "$", "/", "[", or "]").');
    }
};
/**
 * @internal
 */
const validatePathString = function (fnName, argumentName, pathString, optional) {
    if (optional && pathString === undefined) {
        return;
    }
    if (!isValidPathString(pathString)) {
        throw new Error((0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.errorPrefix)(fnName, argumentName) +
            'was an invalid path = "' +
            pathString +
            '". Paths must be non-empty strings and ' +
            'can\'t contain ".", "#", "$", "[", or "]"');
    }
};
const validateRootPathString = function (fnName, argumentName, pathString, optional) {
    if (pathString) {
        // Allow '/.info/' at the beginning.
        pathString = pathString.replace(/^\/*\.info(\/|$)/, '/');
    }
    validatePathString(fnName, argumentName, pathString, optional);
};
/**
 * @internal
 */
const validateWritablePath = function (fnName, path) {
    if (pathGetFront(path) === '.info') {
        throw new Error(fnName + " failed = Can't modify data under /.info/");
    }
};
const validateUrl = function (fnName, parsedUrl) {
    // TODO = Validate server better.
    const pathString = parsedUrl.path.toString();
    if (!(typeof parsedUrl.repoInfo.host === 'string') ||
        parsedUrl.repoInfo.host.length === 0 ||
        (!isValidKey(parsedUrl.repoInfo.namespace) &&
            parsedUrl.repoInfo.host.split(':')[0] !== 'localhost') ||
        (pathString.length !== 0 && !isValidRootPathString(pathString))) {
        throw new Error((0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.errorPrefix)(fnName, 'url') +
            'must be a valid firebase URL and ' +
            'the path can\'t contain ".", "#", "$", "[", or "]".');
    }
};

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * The event queue serves a few purposes:
 * 1. It ensures we maintain event order in the face of event callbacks doing operations that result in more
 *    events being queued.
 * 2. raiseQueuedEvents() handles being called reentrantly nicely.  That is, if in the course of raising events,
 *    raiseQueuedEvents() is called again, the "inner" call will pick up raising events where the "outer" call
 *    left off, ensuring that the events are still raised synchronously and in order.
 * 3. You can use raiseEventsAtPath and raiseEventsForChangedPath to ensure only relevant previously-queued
 *    events are raised synchronously.
 *
 * NOTE: This can all go away if/when we move to async events.
 *
 */
class EventQueue {
    constructor() {
        this.eventLists_ = [];
        /**
         * Tracks recursion depth of raiseQueuedEvents_, for debugging purposes.
         */
        this.recursionDepth_ = 0;
    }
}
/**
 * @param eventDataList - The new events to queue.
 */
function eventQueueQueueEvents(eventQueue, eventDataList) {
    // We group events by path, storing them in a single EventList, to make it easier to skip over them quickly.
    let currList = null;
    for (let i = 0; i < eventDataList.length; i++) {
        const data = eventDataList[i];
        const path = data.getPath();
        if (currList !== null && !pathEquals(path, currList.path)) {
            eventQueue.eventLists_.push(currList);
            currList = null;
        }
        if (currList === null) {
            currList = { events: [], path };
        }
        currList.events.push(data);
    }
    if (currList) {
        eventQueue.eventLists_.push(currList);
    }
}
/**
 * Queues the specified events and synchronously raises all events (including previously queued ones)
 * for the specified path.
 *
 * It is assumed that the new events are all for the specified path.
 *
 * @param path - The path to raise events for.
 * @param eventDataList - The new events to raise.
 */
function eventQueueRaiseEventsAtPath(eventQueue, path, eventDataList) {
    eventQueueQueueEvents(eventQueue, eventDataList);
    eventQueueRaiseQueuedEventsMatchingPredicate(eventQueue, eventPath => pathEquals(eventPath, path));
}
/**
 * Queues the specified events and synchronously raises all events (including previously queued ones) for
 * locations related to the specified change path (i.e. all ancestors and descendants).
 *
 * It is assumed that the new events are all related (ancestor or descendant) to the specified path.
 *
 * @param changedPath - The path to raise events for.
 * @param eventDataList - The events to raise
 */
function eventQueueRaiseEventsForChangedPath(eventQueue, changedPath, eventDataList) {
    eventQueueQueueEvents(eventQueue, eventDataList);
    eventQueueRaiseQueuedEventsMatchingPredicate(eventQueue, eventPath => pathContains(eventPath, changedPath) ||
        pathContains(changedPath, eventPath));
}
function eventQueueRaiseQueuedEventsMatchingPredicate(eventQueue, predicate) {
    eventQueue.recursionDepth_++;
    let sentAll = true;
    for (let i = 0; i < eventQueue.eventLists_.length; i++) {
        const eventList = eventQueue.eventLists_[i];
        if (eventList) {
            const eventPath = eventList.path;
            if (predicate(eventPath)) {
                eventListRaise(eventQueue.eventLists_[i]);
                eventQueue.eventLists_[i] = null;
            }
            else {
                sentAll = false;
            }
        }
    }
    if (sentAll) {
        eventQueue.eventLists_ = [];
    }
    eventQueue.recursionDepth_--;
}
/**
 * Iterates through the list and raises each event
 */
function eventListRaise(eventList) {
    for (let i = 0; i < eventList.events.length; i++) {
        const eventData = eventList.events[i];
        if (eventData !== null) {
            eventList.events[i] = null;
            const eventFn = eventData.getEventRunner();
            if (logger) {
                log('event: ' + eventData.toString());
            }
            exceptionGuard(eventFn);
        }
    }
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const INTERRUPT_REASON = 'repo_interrupt';
/**
 * If a transaction does not succeed after 25 retries, we abort it. Among other
 * things this ensure that if there's ever a bug causing a mismatch between
 * client / server hashes for some data, we won't retry indefinitely.
 */
const MAX_TRANSACTION_RETRIES = 25;
/**
 * A connection to a single data repository.
 */
class Repo {
    constructor(repoInfo_, forceRestClient_, authTokenProvider_, appCheckProvider_) {
        this.repoInfo_ = repoInfo_;
        this.forceRestClient_ = forceRestClient_;
        this.authTokenProvider_ = authTokenProvider_;
        this.appCheckProvider_ = appCheckProvider_;
        this.dataUpdateCount = 0;
        this.statsListener_ = null;
        this.eventQueue_ = new EventQueue();
        this.nextWriteId_ = 1;
        this.interceptServerDataCallback_ = null;
        /** A list of data pieces and paths to be set when this client disconnects. */
        this.onDisconnect_ = newSparseSnapshotTree();
        /** Stores queues of outstanding transactions for Firebase locations. */
        this.transactionQueueTree_ = new Tree();
        // TODO: This should be @private but it's used by test_access.js and internal.js
        this.persistentConnection_ = null;
        // This key is intentionally not updated if RepoInfo is later changed or replaced
        this.key = this.repoInfo_.toURLString();
    }
    /**
     * @returns The URL corresponding to the root of this Firebase.
     */
    toString() {
        return ((this.repoInfo_.secure ? 'https://' : 'http://') + this.repoInfo_.host);
    }
}
function repoStart(repo, appId, authOverride) {
    repo.stats_ = statsManagerGetCollection(repo.repoInfo_);
    if (repo.forceRestClient_ || beingCrawled()) {
        repo.server_ = new ReadonlyRestClient(repo.repoInfo_, (pathString, data, isMerge, tag) => {
            repoOnDataUpdate(repo, pathString, data, isMerge, tag);
        }, repo.authTokenProvider_, repo.appCheckProvider_);
        // Minor hack: Fire onConnect immediately, since there's no actual connection.
        setTimeout(() => repoOnConnectStatus(repo, /* connectStatus= */ true), 0);
    }
    else {
        // Validate authOverride
        if (typeof authOverride !== 'undefined' && authOverride !== null) {
            if (typeof authOverride !== 'object') {
                throw new Error('Only objects are supported for option databaseAuthVariableOverride');
            }
            try {
                (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.stringify)(authOverride);
            }
            catch (e) {
                throw new Error('Invalid authOverride provided: ' + e);
            }
        }
        repo.persistentConnection_ = new PersistentConnection(repo.repoInfo_, appId, (pathString, data, isMerge, tag) => {
            repoOnDataUpdate(repo, pathString, data, isMerge, tag);
        }, (connectStatus) => {
            repoOnConnectStatus(repo, connectStatus);
        }, (updates) => {
            repoOnServerInfoUpdate(repo, updates);
        }, repo.authTokenProvider_, repo.appCheckProvider_, authOverride);
        repo.server_ = repo.persistentConnection_;
    }
    repo.authTokenProvider_.addTokenChangeListener(token => {
        repo.server_.refreshAuthToken(token);
    });
    repo.appCheckProvider_.addTokenChangeListener(result => {
        repo.server_.refreshAppCheckToken(result.token);
    });
    // In the case of multiple Repos for the same repoInfo (i.e. there are multiple Firebase.Contexts being used),
    // we only want to create one StatsReporter.  As such, we'll report stats over the first Repo created.
    repo.statsReporter_ = statsManagerGetOrCreateReporter(repo.repoInfo_, () => new StatsReporter(repo.stats_, repo.server_));
    // Used for .info.
    repo.infoData_ = new SnapshotHolder();
    repo.infoSyncTree_ = new SyncTree({
        startListening: (query, tag, currentHashFn, onComplete) => {
            let infoEvents = [];
            const node = repo.infoData_.getNode(query._path);
            // This is possibly a hack, but we have different semantics for .info endpoints. We don't raise null events
            // on initial data...
            if (!node.isEmpty()) {
                infoEvents = syncTreeApplyServerOverwrite(repo.infoSyncTree_, query._path, node);
                setTimeout(() => {
                    onComplete('ok');
                }, 0);
            }
            return infoEvents;
        },
        stopListening: () => { }
    });
    repoUpdateInfo(repo, 'connected', false);
    repo.serverSyncTree_ = new SyncTree({
        startListening: (query, tag, currentHashFn, onComplete) => {
            repo.server_.listen(query, currentHashFn, tag, (status, data) => {
                const events = onComplete(status, data);
                eventQueueRaiseEventsForChangedPath(repo.eventQueue_, query._path, events);
            });
            // No synchronous events for network-backed sync trees
            return [];
        },
        stopListening: (query, tag) => {
            repo.server_.unlisten(query, tag);
        }
    });
}
/**
 * @returns The time in milliseconds, taking the server offset into account if we have one.
 */
function repoServerTime(repo) {
    const offsetNode = repo.infoData_.getNode(new Path('.info/serverTimeOffset'));
    const offset = offsetNode.val() || 0;
    return new Date().getTime() + offset;
}
/**
 * Generate ServerValues using some variables from the repo object.
 */
function repoGenerateServerValues(repo) {
    return generateWithValues({
        timestamp: repoServerTime(repo)
    });
}
/**
 * Called by realtime when we get new messages from the server.
 */
function repoOnDataUpdate(repo, pathString, data, isMerge, tag) {
    // For testing.
    repo.dataUpdateCount++;
    const path = new Path(pathString);
    data = repo.interceptServerDataCallback_
        ? repo.interceptServerDataCallback_(pathString, data)
        : data;
    let events = [];
    if (tag) {
        if (isMerge) {
            const taggedChildren = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.map)(data, (raw) => nodeFromJSON(raw));
            events = syncTreeApplyTaggedQueryMerge(repo.serverSyncTree_, path, taggedChildren, tag);
        }
        else {
            const taggedSnap = nodeFromJSON(data);
            events = syncTreeApplyTaggedQueryOverwrite(repo.serverSyncTree_, path, taggedSnap, tag);
        }
    }
    else if (isMerge) {
        const changedChildren = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.map)(data, (raw) => nodeFromJSON(raw));
        events = syncTreeApplyServerMerge(repo.serverSyncTree_, path, changedChildren);
    }
    else {
        const snap = nodeFromJSON(data);
        events = syncTreeApplyServerOverwrite(repo.serverSyncTree_, path, snap);
    }
    let affectedPath = path;
    if (events.length > 0) {
        // Since we have a listener outstanding for each transaction, receiving any events
        // is a proxy for some change having occurred.
        affectedPath = repoRerunTransactions(repo, path);
    }
    eventQueueRaiseEventsForChangedPath(repo.eventQueue_, affectedPath, events);
}
function repoOnConnectStatus(repo, connectStatus) {
    repoUpdateInfo(repo, 'connected', connectStatus);
    if (connectStatus === false) {
        repoRunOnDisconnectEvents(repo);
    }
}
function repoOnServerInfoUpdate(repo, updates) {
    each(updates, (key, value) => {
        repoUpdateInfo(repo, key, value);
    });
}
function repoUpdateInfo(repo, pathString, value) {
    const path = new Path('/.info/' + pathString);
    const newNode = nodeFromJSON(value);
    repo.infoData_.updateSnapshot(path, newNode);
    const events = syncTreeApplyServerOverwrite(repo.infoSyncTree_, path, newNode);
    eventQueueRaiseEventsForChangedPath(repo.eventQueue_, path, events);
}
function repoGetNextWriteId(repo) {
    return repo.nextWriteId_++;
}
/**
 * The purpose of `getValue` is to return the latest known value
 * satisfying `query`.
 *
 * This method will first check for in-memory cached values
 * belonging to active listeners. If they are found, such values
 * are considered to be the most up-to-date.
 *
 * If the client is not connected, this method will try to
 * establish a connection and request the value for `query`. If
 * the client is not able to retrieve the query result, it reports
 * an error.
 *
 * @param query - The query to surface a value for.
 */
function repoGetValue(repo, query) {
    // Only active queries are cached. There is no persisted cache.
    const cached = syncTreeGetServerValue(repo.serverSyncTree_, query);
    if (cached != null) {
        return Promise.resolve(cached);
    }
    return repo.server_.get(query).then(payload => {
        const node = nodeFromJSON(payload).withIndex(query._queryParams.getIndex());
        const events = syncTreeApplyServerOverwrite(repo.serverSyncTree_, query._path, node);
        eventQueueRaiseEventsAtPath(repo.eventQueue_, query._path, events);
        return Promise.resolve(node);
    }, err => {
        repoLog(repo, 'get for query ' + (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.stringify)(query) + ' failed: ' + err);
        return Promise.reject(new Error(err));
    });
}
function repoSetWithPriority(repo, path, newVal, newPriority, onComplete) {
    repoLog(repo, 'set', {
        path: path.toString(),
        value: newVal,
        priority: newPriority
    });
    // TODO: Optimize this behavior to either (a) store flag to skip resolving where possible and / or
    // (b) store unresolved paths on JSON parse
    const serverValues = repoGenerateServerValues(repo);
    const newNodeUnresolved = nodeFromJSON(newVal, newPriority);
    const existing = syncTreeCalcCompleteEventCache(repo.serverSyncTree_, path);
    const newNode = resolveDeferredValueSnapshot(newNodeUnresolved, existing, serverValues);
    const writeId = repoGetNextWriteId(repo);
    const events = syncTreeApplyUserOverwrite(repo.serverSyncTree_, path, newNode, writeId, true);
    eventQueueQueueEvents(repo.eventQueue_, events);
    repo.server_.put(path.toString(), newNodeUnresolved.val(/*export=*/ true), (status, errorReason) => {
        const success = status === 'ok';
        if (!success) {
            warn('set at ' + path + ' failed: ' + status);
        }
        const clearEvents = syncTreeAckUserWrite(repo.serverSyncTree_, writeId, !success);
        eventQueueRaiseEventsForChangedPath(repo.eventQueue_, path, clearEvents);
        repoCallOnCompleteCallback(repo, onComplete, status, errorReason);
    });
    const affectedPath = repoAbortTransactions(repo, path);
    repoRerunTransactions(repo, affectedPath);
    // We queued the events above, so just flush the queue here
    eventQueueRaiseEventsForChangedPath(repo.eventQueue_, affectedPath, []);
}
function repoUpdate(repo, path, childrenToMerge, onComplete) {
    repoLog(repo, 'update', { path: path.toString(), value: childrenToMerge });
    // Start with our existing data and merge each child into it.
    let empty = true;
    const serverValues = repoGenerateServerValues(repo);
    const changedChildren = {};
    each(childrenToMerge, (changedKey, changedValue) => {
        empty = false;
        changedChildren[changedKey] = resolveDeferredValueTree(pathChild(path, changedKey), nodeFromJSON(changedValue), repo.serverSyncTree_, serverValues);
    });
    if (!empty) {
        const writeId = repoGetNextWriteId(repo);
        const events = syncTreeApplyUserMerge(repo.serverSyncTree_, path, changedChildren, writeId);
        eventQueueQueueEvents(repo.eventQueue_, events);
        repo.server_.merge(path.toString(), childrenToMerge, (status, errorReason) => {
            const success = status === 'ok';
            if (!success) {
                warn('update at ' + path + ' failed: ' + status);
            }
            const clearEvents = syncTreeAckUserWrite(repo.serverSyncTree_, writeId, !success);
            const affectedPath = clearEvents.length > 0 ? repoRerunTransactions(repo, path) : path;
            eventQueueRaiseEventsForChangedPath(repo.eventQueue_, affectedPath, clearEvents);
            repoCallOnCompleteCallback(repo, onComplete, status, errorReason);
        });
        each(childrenToMerge, (changedPath) => {
            const affectedPath = repoAbortTransactions(repo, pathChild(path, changedPath));
            repoRerunTransactions(repo, affectedPath);
        });
        // We queued the events above, so just flush the queue here
        eventQueueRaiseEventsForChangedPath(repo.eventQueue_, path, []);
    }
    else {
        log("update() called with empty data.  Don't do anything.");
        repoCallOnCompleteCallback(repo, onComplete, 'ok', undefined);
    }
}
/**
 * Applies all of the changes stored up in the onDisconnect_ tree.
 */
function repoRunOnDisconnectEvents(repo) {
    repoLog(repo, 'onDisconnectEvents');
    const serverValues = repoGenerateServerValues(repo);
    const resolvedOnDisconnectTree = newSparseSnapshotTree();
    sparseSnapshotTreeForEachTree(repo.onDisconnect_, newEmptyPath(), (path, node) => {
        const resolved = resolveDeferredValueTree(path, node, repo.serverSyncTree_, serverValues);
        sparseSnapshotTreeRemember(resolvedOnDisconnectTree, path, resolved);
    });
    let events = [];
    sparseSnapshotTreeForEachTree(resolvedOnDisconnectTree, newEmptyPath(), (path, snap) => {
        events = events.concat(syncTreeApplyServerOverwrite(repo.serverSyncTree_, path, snap));
        const affectedPath = repoAbortTransactions(repo, path);
        repoRerunTransactions(repo, affectedPath);
    });
    repo.onDisconnect_ = newSparseSnapshotTree();
    eventQueueRaiseEventsForChangedPath(repo.eventQueue_, newEmptyPath(), events);
}
function repoOnDisconnectCancel(repo, path, onComplete) {
    repo.server_.onDisconnectCancel(path.toString(), (status, errorReason) => {
        if (status === 'ok') {
            sparseSnapshotTreeForget(repo.onDisconnect_, path);
        }
        repoCallOnCompleteCallback(repo, onComplete, status, errorReason);
    });
}
function repoOnDisconnectSet(repo, path, value, onComplete) {
    const newNode = nodeFromJSON(value);
    repo.server_.onDisconnectPut(path.toString(), newNode.val(/*export=*/ true), (status, errorReason) => {
        if (status === 'ok') {
            sparseSnapshotTreeRemember(repo.onDisconnect_, path, newNode);
        }
        repoCallOnCompleteCallback(repo, onComplete, status, errorReason);
    });
}
function repoOnDisconnectSetWithPriority(repo, path, value, priority, onComplete) {
    const newNode = nodeFromJSON(value, priority);
    repo.server_.onDisconnectPut(path.toString(), newNode.val(/*export=*/ true), (status, errorReason) => {
        if (status === 'ok') {
            sparseSnapshotTreeRemember(repo.onDisconnect_, path, newNode);
        }
        repoCallOnCompleteCallback(repo, onComplete, status, errorReason);
    });
}
function repoOnDisconnectUpdate(repo, path, childrenToMerge, onComplete) {
    if ((0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.isEmpty)(childrenToMerge)) {
        log("onDisconnect().update() called with empty data.  Don't do anything.");
        repoCallOnCompleteCallback(repo, onComplete, 'ok', undefined);
        return;
    }
    repo.server_.onDisconnectMerge(path.toString(), childrenToMerge, (status, errorReason) => {
        if (status === 'ok') {
            each(childrenToMerge, (childName, childNode) => {
                const newChildNode = nodeFromJSON(childNode);
                sparseSnapshotTreeRemember(repo.onDisconnect_, pathChild(path, childName), newChildNode);
            });
        }
        repoCallOnCompleteCallback(repo, onComplete, status, errorReason);
    });
}
function repoAddEventCallbackForQuery(repo, query, eventRegistration) {
    let events;
    if (pathGetFront(query._path) === '.info') {
        events = syncTreeAddEventRegistration(repo.infoSyncTree_, query, eventRegistration);
    }
    else {
        events = syncTreeAddEventRegistration(repo.serverSyncTree_, query, eventRegistration);
    }
    eventQueueRaiseEventsAtPath(repo.eventQueue_, query._path, events);
}
function repoRemoveEventCallbackForQuery(repo, query, eventRegistration) {
    // These are guaranteed not to raise events, since we're not passing in a cancelError. However, we can future-proof
    // a little bit by handling the return values anyways.
    let events;
    if (pathGetFront(query._path) === '.info') {
        events = syncTreeRemoveEventRegistration(repo.infoSyncTree_, query, eventRegistration);
    }
    else {
        events = syncTreeRemoveEventRegistration(repo.serverSyncTree_, query, eventRegistration);
    }
    eventQueueRaiseEventsAtPath(repo.eventQueue_, query._path, events);
}
function repoInterrupt(repo) {
    if (repo.persistentConnection_) {
        repo.persistentConnection_.interrupt(INTERRUPT_REASON);
    }
}
function repoResume(repo) {
    if (repo.persistentConnection_) {
        repo.persistentConnection_.resume(INTERRUPT_REASON);
    }
}
function repoLog(repo, ...varArgs) {
    let prefix = '';
    if (repo.persistentConnection_) {
        prefix = repo.persistentConnection_.id + ':';
    }
    log(prefix, ...varArgs);
}
function repoCallOnCompleteCallback(repo, callback, status, errorReason) {
    if (callback) {
        exceptionGuard(() => {
            if (status === 'ok') {
                callback(null);
            }
            else {
                const code = (status || 'error').toUpperCase();
                let message = code;
                if (errorReason) {
                    message += ': ' + errorReason;
                }
                const error = new Error(message);
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                error.code = code;
                callback(error);
            }
        });
    }
}
/**
 * Creates a new transaction, adds it to the transactions we're tracking, and
 * sends it to the server if possible.
 *
 * @param path - Path at which to do transaction.
 * @param transactionUpdate - Update callback.
 * @param onComplete - Completion callback.
 * @param unwatcher - Function that will be called when the transaction no longer
 * need data updates for `path`.
 * @param applyLocally - Whether or not to make intermediate results visible
 */
function repoStartTransaction(repo, path, transactionUpdate, onComplete, unwatcher, applyLocally) {
    repoLog(repo, 'transaction on ' + path);
    // Initialize transaction.
    const transaction = {
        path,
        update: transactionUpdate,
        onComplete,
        // One of TransactionStatus enums.
        status: null,
        // Used when combining transactions at different locations to figure out
        // which one goes first.
        order: LUIDGenerator(),
        // Whether to raise local events for this transaction.
        applyLocally,
        // Count of how many times we've retried the transaction.
        retryCount: 0,
        // Function to call to clean up our .on() listener.
        unwatcher,
        // Stores why a transaction was aborted.
        abortReason: null,
        currentWriteId: null,
        currentInputSnapshot: null,
        currentOutputSnapshotRaw: null,
        currentOutputSnapshotResolved: null
    };
    // Run transaction initially.
    const currentState = repoGetLatestState(repo, path, undefined);
    transaction.currentInputSnapshot = currentState;
    const newVal = transaction.update(currentState.val());
    if (newVal === undefined) {
        // Abort transaction.
        transaction.unwatcher();
        transaction.currentOutputSnapshotRaw = null;
        transaction.currentOutputSnapshotResolved = null;
        if (transaction.onComplete) {
            transaction.onComplete(null, false, transaction.currentInputSnapshot);
        }
    }
    else {
        validateFirebaseData('transaction failed: Data returned ', newVal, transaction.path);
        // Mark as run and add to our queue.
        transaction.status = 0 /* RUN */;
        const queueNode = treeSubTree(repo.transactionQueueTree_, path);
        const nodeQueue = treeGetValue(queueNode) || [];
        nodeQueue.push(transaction);
        treeSetValue(queueNode, nodeQueue);
        // Update visibleData and raise events
        // Note: We intentionally raise events after updating all of our
        // transaction state, since the user could start new transactions from the
        // event callbacks.
        let priorityForNode;
        if (typeof newVal === 'object' &&
            newVal !== null &&
            (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.contains)(newVal, '.priority')) {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            priorityForNode = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.safeGet)(newVal, '.priority');
            (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(isValidPriority(priorityForNode), 'Invalid priority returned by transaction. ' +
                'Priority must be a valid string, finite number, server value, or null.');
        }
        else {
            const currentNode = syncTreeCalcCompleteEventCache(repo.serverSyncTree_, path) ||
                ChildrenNode.EMPTY_NODE;
            priorityForNode = currentNode.getPriority().val();
        }
        const serverValues = repoGenerateServerValues(repo);
        const newNodeUnresolved = nodeFromJSON(newVal, priorityForNode);
        const newNode = resolveDeferredValueSnapshot(newNodeUnresolved, currentState, serverValues);
        transaction.currentOutputSnapshotRaw = newNodeUnresolved;
        transaction.currentOutputSnapshotResolved = newNode;
        transaction.currentWriteId = repoGetNextWriteId(repo);
        const events = syncTreeApplyUserOverwrite(repo.serverSyncTree_, path, newNode, transaction.currentWriteId, transaction.applyLocally);
        eventQueueRaiseEventsForChangedPath(repo.eventQueue_, path, events);
        repoSendReadyTransactions(repo, repo.transactionQueueTree_);
    }
}
/**
 * @param excludeSets - A specific set to exclude
 */
function repoGetLatestState(repo, path, excludeSets) {
    return (syncTreeCalcCompleteEventCache(repo.serverSyncTree_, path, excludeSets) ||
        ChildrenNode.EMPTY_NODE);
}
/**
 * Sends any already-run transactions that aren't waiting for outstanding
 * transactions to complete.
 *
 * Externally it's called with no arguments, but it calls itself recursively
 * with a particular transactionQueueTree node to recurse through the tree.
 *
 * @param node - transactionQueueTree node to start at.
 */
function repoSendReadyTransactions(repo, node = repo.transactionQueueTree_) {
    // Before recursing, make sure any completed transactions are removed.
    if (!node) {
        repoPruneCompletedTransactionsBelowNode(repo, node);
    }
    if (treeGetValue(node)) {
        const queue = repoBuildTransactionQueue(repo, node);
        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(queue.length > 0, 'Sending zero length transaction queue');
        const allRun = queue.every((transaction) => transaction.status === 0 /* RUN */);
        // If they're all run (and not sent), we can send them.  Else, we must wait.
        if (allRun) {
            repoSendTransactionQueue(repo, treeGetPath(node), queue);
        }
    }
    else if (treeHasChildren(node)) {
        treeForEachChild(node, childNode => {
            repoSendReadyTransactions(repo, childNode);
        });
    }
}
/**
 * Given a list of run transactions, send them to the server and then handle
 * the result (success or failure).
 *
 * @param path - The location of the queue.
 * @param queue - Queue of transactions under the specified location.
 */
function repoSendTransactionQueue(repo, path, queue) {
    // Mark transactions as sent and increment retry count!
    const setsToIgnore = queue.map(txn => {
        return txn.currentWriteId;
    });
    const latestState = repoGetLatestState(repo, path, setsToIgnore);
    let snapToSend = latestState;
    const latestHash = latestState.hash();
    for (let i = 0; i < queue.length; i++) {
        const txn = queue[i];
        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(txn.status === 0 /* RUN */, 'tryToSendTransactionQueue_: items in queue should all be run.');
        txn.status = 1 /* SENT */;
        txn.retryCount++;
        const relativePath = newRelativePath(path, txn.path);
        // If we've gotten to this point, the output snapshot must be defined.
        snapToSend = snapToSend.updateChild(relativePath /** @type {!Node} */, txn.currentOutputSnapshotRaw);
    }
    const dataToSend = snapToSend.val(true);
    const pathToSend = path;
    // Send the put.
    repo.server_.put(pathToSend.toString(), dataToSend, (status) => {
        repoLog(repo, 'transaction put response', {
            path: pathToSend.toString(),
            status
        });
        let events = [];
        if (status === 'ok') {
            // Queue up the callbacks and fire them after cleaning up all of our
            // transaction state, since the callback could trigger more
            // transactions or sets.
            const callbacks = [];
            for (let i = 0; i < queue.length; i++) {
                queue[i].status = 2 /* COMPLETED */;
                events = events.concat(syncTreeAckUserWrite(repo.serverSyncTree_, queue[i].currentWriteId));
                if (queue[i].onComplete) {
                    // We never unset the output snapshot, and given that this
                    // transaction is complete, it should be set
                    callbacks.push(() => queue[i].onComplete(null, true, queue[i].currentOutputSnapshotResolved));
                }
                queue[i].unwatcher();
            }
            // Now remove the completed transactions.
            repoPruneCompletedTransactionsBelowNode(repo, treeSubTree(repo.transactionQueueTree_, path));
            // There may be pending transactions that we can now send.
            repoSendReadyTransactions(repo, repo.transactionQueueTree_);
            eventQueueRaiseEventsForChangedPath(repo.eventQueue_, path, events);
            // Finally, trigger onComplete callbacks.
            for (let i = 0; i < callbacks.length; i++) {
                exceptionGuard(callbacks[i]);
            }
        }
        else {
            // transactions are no longer sent.  Update their status appropriately.
            if (status === 'datastale') {
                for (let i = 0; i < queue.length; i++) {
                    if (queue[i].status === 3 /* SENT_NEEDS_ABORT */) {
                        queue[i].status = 4 /* NEEDS_ABORT */;
                    }
                    else {
                        queue[i].status = 0 /* RUN */;
                    }
                }
            }
            else {
                warn('transaction at ' + pathToSend.toString() + ' failed: ' + status);
                for (let i = 0; i < queue.length; i++) {
                    queue[i].status = 4 /* NEEDS_ABORT */;
                    queue[i].abortReason = status;
                }
            }
            repoRerunTransactions(repo, path);
        }
    }, latestHash);
}
/**
 * Finds all transactions dependent on the data at changedPath and reruns them.
 *
 * Should be called any time cached data changes.
 *
 * Return the highest path that was affected by rerunning transactions. This
 * is the path at which events need to be raised for.
 *
 * @param changedPath - The path in mergedData that changed.
 * @returns The rootmost path that was affected by rerunning transactions.
 */
function repoRerunTransactions(repo, changedPath) {
    const rootMostTransactionNode = repoGetAncestorTransactionNode(repo, changedPath);
    const path = treeGetPath(rootMostTransactionNode);
    const queue = repoBuildTransactionQueue(repo, rootMostTransactionNode);
    repoRerunTransactionQueue(repo, queue, path);
    return path;
}
/**
 * Does all the work of rerunning transactions (as well as cleans up aborted
 * transactions and whatnot).
 *
 * @param queue - The queue of transactions to run.
 * @param path - The path the queue is for.
 */
function repoRerunTransactionQueue(repo, queue, path) {
    if (queue.length === 0) {
        return; // Nothing to do!
    }
    // Queue up the callbacks and fire them after cleaning up all of our
    // transaction state, since the callback could trigger more transactions or
    // sets.
    const callbacks = [];
    let events = [];
    // Ignore all of the sets we're going to re-run.
    const txnsToRerun = queue.filter(q => {
        return q.status === 0 /* RUN */;
    });
    const setsToIgnore = txnsToRerun.map(q => {
        return q.currentWriteId;
    });
    for (let i = 0; i < queue.length; i++) {
        const transaction = queue[i];
        const relativePath = newRelativePath(path, transaction.path);
        let abortTransaction = false, abortReason;
        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(relativePath !== null, 'rerunTransactionsUnderNode_: relativePath should not be null.');
        if (transaction.status === 4 /* NEEDS_ABORT */) {
            abortTransaction = true;
            abortReason = transaction.abortReason;
            events = events.concat(syncTreeAckUserWrite(repo.serverSyncTree_, transaction.currentWriteId, true));
        }
        else if (transaction.status === 0 /* RUN */) {
            if (transaction.retryCount >= MAX_TRANSACTION_RETRIES) {
                abortTransaction = true;
                abortReason = 'maxretry';
                events = events.concat(syncTreeAckUserWrite(repo.serverSyncTree_, transaction.currentWriteId, true));
            }
            else {
                // This code reruns a transaction
                const currentNode = repoGetLatestState(repo, transaction.path, setsToIgnore);
                transaction.currentInputSnapshot = currentNode;
                const newData = queue[i].update(currentNode.val());
                if (newData !== undefined) {
                    validateFirebaseData('transaction failed: Data returned ', newData, transaction.path);
                    let newDataNode = nodeFromJSON(newData);
                    const hasExplicitPriority = typeof newData === 'object' &&
                        newData != null &&
                        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.contains)(newData, '.priority');
                    if (!hasExplicitPriority) {
                        // Keep the old priority if there wasn't a priority explicitly specified.
                        newDataNode = newDataNode.updatePriority(currentNode.getPriority());
                    }
                    const oldWriteId = transaction.currentWriteId;
                    const serverValues = repoGenerateServerValues(repo);
                    const newNodeResolved = resolveDeferredValueSnapshot(newDataNode, currentNode, serverValues);
                    transaction.currentOutputSnapshotRaw = newDataNode;
                    transaction.currentOutputSnapshotResolved = newNodeResolved;
                    transaction.currentWriteId = repoGetNextWriteId(repo);
                    // Mutates setsToIgnore in place
                    setsToIgnore.splice(setsToIgnore.indexOf(oldWriteId), 1);
                    events = events.concat(syncTreeApplyUserOverwrite(repo.serverSyncTree_, transaction.path, newNodeResolved, transaction.currentWriteId, transaction.applyLocally));
                    events = events.concat(syncTreeAckUserWrite(repo.serverSyncTree_, oldWriteId, true));
                }
                else {
                    abortTransaction = true;
                    abortReason = 'nodata';
                    events = events.concat(syncTreeAckUserWrite(repo.serverSyncTree_, transaction.currentWriteId, true));
                }
            }
        }
        eventQueueRaiseEventsForChangedPath(repo.eventQueue_, path, events);
        events = [];
        if (abortTransaction) {
            // Abort.
            queue[i].status = 2 /* COMPLETED */;
            // Removing a listener can trigger pruning which can muck with
            // mergedData/visibleData (as it prunes data). So defer the unwatcher
            // until we're done.
            (function (unwatcher) {
                setTimeout(unwatcher, Math.floor(0));
            })(queue[i].unwatcher);
            if (queue[i].onComplete) {
                if (abortReason === 'nodata') {
                    callbacks.push(() => queue[i].onComplete(null, false, queue[i].currentInputSnapshot));
                }
                else {
                    callbacks.push(() => queue[i].onComplete(new Error(abortReason), false, null));
                }
            }
        }
    }
    // Clean up completed transactions.
    repoPruneCompletedTransactionsBelowNode(repo, repo.transactionQueueTree_);
    // Now fire callbacks, now that we're in a good, known state.
    for (let i = 0; i < callbacks.length; i++) {
        exceptionGuard(callbacks[i]);
    }
    // Try to send the transaction result to the server.
    repoSendReadyTransactions(repo, repo.transactionQueueTree_);
}
/**
 * Returns the rootmost ancestor node of the specified path that has a pending
 * transaction on it, or just returns the node for the given path if there are
 * no pending transactions on any ancestor.
 *
 * @param path - The location to start at.
 * @returns The rootmost node with a transaction.
 */
function repoGetAncestorTransactionNode(repo, path) {
    let front;
    // Start at the root and walk deeper into the tree towards path until we
    // find a node with pending transactions.
    let transactionNode = repo.transactionQueueTree_;
    front = pathGetFront(path);
    while (front !== null && treeGetValue(transactionNode) === undefined) {
        transactionNode = treeSubTree(transactionNode, front);
        path = pathPopFront(path);
        front = pathGetFront(path);
    }
    return transactionNode;
}
/**
 * Builds the queue of all transactions at or below the specified
 * transactionNode.
 *
 * @param transactionNode
 * @returns The generated queue.
 */
function repoBuildTransactionQueue(repo, transactionNode) {
    // Walk any child transaction queues and aggregate them into a single queue.
    const transactionQueue = [];
    repoAggregateTransactionQueuesForNode(repo, transactionNode, transactionQueue);
    // Sort them by the order the transactions were created.
    transactionQueue.sort((a, b) => a.order - b.order);
    return transactionQueue;
}
function repoAggregateTransactionQueuesForNode(repo, node, queue) {
    const nodeQueue = treeGetValue(node);
    if (nodeQueue) {
        for (let i = 0; i < nodeQueue.length; i++) {
            queue.push(nodeQueue[i]);
        }
    }
    treeForEachChild(node, child => {
        repoAggregateTransactionQueuesForNode(repo, child, queue);
    });
}
/**
 * Remove COMPLETED transactions at or below this node in the transactionQueueTree_.
 */
function repoPruneCompletedTransactionsBelowNode(repo, node) {
    const queue = treeGetValue(node);
    if (queue) {
        let to = 0;
        for (let from = 0; from < queue.length; from++) {
            if (queue[from].status !== 2 /* COMPLETED */) {
                queue[to] = queue[from];
                to++;
            }
        }
        queue.length = to;
        treeSetValue(node, queue.length > 0 ? queue : undefined);
    }
    treeForEachChild(node, childNode => {
        repoPruneCompletedTransactionsBelowNode(repo, childNode);
    });
}
/**
 * Aborts all transactions on ancestors or descendants of the specified path.
 * Called when doing a set() or update() since we consider them incompatible
 * with transactions.
 *
 * @param path - Path for which we want to abort related transactions.
 */
function repoAbortTransactions(repo, path) {
    const affectedPath = treeGetPath(repoGetAncestorTransactionNode(repo, path));
    const transactionNode = treeSubTree(repo.transactionQueueTree_, path);
    treeForEachAncestor(transactionNode, (node) => {
        repoAbortTransactionsOnNode(repo, node);
    });
    repoAbortTransactionsOnNode(repo, transactionNode);
    treeForEachDescendant(transactionNode, (node) => {
        repoAbortTransactionsOnNode(repo, node);
    });
    return affectedPath;
}
/**
 * Abort transactions stored in this transaction queue node.
 *
 * @param node - Node to abort transactions for.
 */
function repoAbortTransactionsOnNode(repo, node) {
    const queue = treeGetValue(node);
    if (queue) {
        // Queue up the callbacks and fire them after cleaning up all of our
        // transaction state, since the callback could trigger more transactions
        // or sets.
        const callbacks = [];
        // Go through queue.  Any already-sent transactions must be marked for
        // abort, while the unsent ones can be immediately aborted and removed.
        let events = [];
        let lastSent = -1;
        for (let i = 0; i < queue.length; i++) {
            if (queue[i].status === 3 /* SENT_NEEDS_ABORT */) ;
            else if (queue[i].status === 1 /* SENT */) {
                (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(lastSent === i - 1, 'All SENT items should be at beginning of queue.');
                lastSent = i;
                // Mark transaction for abort when it comes back.
                queue[i].status = 3 /* SENT_NEEDS_ABORT */;
                queue[i].abortReason = 'set';
            }
            else {
                (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(queue[i].status === 0 /* RUN */, 'Unexpected transaction status in abort');
                // We can abort it immediately.
                queue[i].unwatcher();
                events = events.concat(syncTreeAckUserWrite(repo.serverSyncTree_, queue[i].currentWriteId, true));
                if (queue[i].onComplete) {
                    callbacks.push(queue[i].onComplete.bind(null, new Error('set'), false, null));
                }
            }
        }
        if (lastSent === -1) {
            // We're not waiting for any sent transactions.  We can clear the queue.
            treeSetValue(node, undefined);
        }
        else {
            // Remove the transactions we aborted.
            queue.length = lastSent + 1;
        }
        // Now fire the callbacks.
        eventQueueRaiseEventsForChangedPath(repo.eventQueue_, treeGetPath(node), events);
        for (let i = 0; i < callbacks.length; i++) {
            exceptionGuard(callbacks[i]);
        }
    }
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function decodePath(pathString) {
    let pathStringDecoded = '';
    const pieces = pathString.split('/');
    for (let i = 0; i < pieces.length; i++) {
        if (pieces[i].length > 0) {
            let piece = pieces[i];
            try {
                piece = decodeURIComponent(piece.replace(/\+/g, ' '));
            }
            catch (e) { }
            pathStringDecoded += '/' + piece;
        }
    }
    return pathStringDecoded;
}
/**
 * @returns key value hash
 */
function decodeQuery(queryString) {
    const results = {};
    if (queryString.charAt(0) === '?') {
        queryString = queryString.substring(1);
    }
    for (const segment of queryString.split('&')) {
        if (segment.length === 0) {
            continue;
        }
        const kv = segment.split('=');
        if (kv.length === 2) {
            results[decodeURIComponent(kv[0])] = decodeURIComponent(kv[1]);
        }
        else {
            warn(`Invalid query segment '${segment}' in query '${queryString}'`);
        }
    }
    return results;
}
const parseRepoInfo = function (dataURL, nodeAdmin) {
    const parsedUrl = parseDatabaseURL(dataURL), namespace = parsedUrl.namespace;
    if (parsedUrl.domain === 'firebase.com') {
        fatal(parsedUrl.host +
            ' is no longer supported. ' +
            'Please use <YOUR FIREBASE>.firebaseio.com instead');
    }
    // Catch common error of uninitialized namespace value.
    if ((!namespace || namespace === 'undefined') &&
        parsedUrl.domain !== 'localhost') {
        fatal('Cannot parse Firebase url. Please use https://<YOUR FIREBASE>.firebaseio.com');
    }
    if (!parsedUrl.secure) {
        warnIfPageIsSecure();
    }
    const webSocketOnly = parsedUrl.scheme === 'ws' || parsedUrl.scheme === 'wss';
    return {
        repoInfo: new RepoInfo(parsedUrl.host, parsedUrl.secure, namespace, nodeAdmin, webSocketOnly, 
        /*persistenceKey=*/ '', 
        /*includeNamespaceInQueryParams=*/ namespace !== parsedUrl.subdomain),
        path: new Path(parsedUrl.pathString)
    };
};
const parseDatabaseURL = function (dataURL) {
    // Default to empty strings in the event of a malformed string.
    let host = '', domain = '', subdomain = '', pathString = '', namespace = '';
    // Always default to SSL, unless otherwise specified.
    let secure = true, scheme = 'https', port = 443;
    // Don't do any validation here. The caller is responsible for validating the result of parsing.
    if (typeof dataURL === 'string') {
        // Parse scheme.
        let colonInd = dataURL.indexOf('//');
        if (colonInd >= 0) {
            scheme = dataURL.substring(0, colonInd - 1);
            dataURL = dataURL.substring(colonInd + 2);
        }
        // Parse host, path, and query string.
        let slashInd = dataURL.indexOf('/');
        if (slashInd === -1) {
            slashInd = dataURL.length;
        }
        let questionMarkInd = dataURL.indexOf('?');
        if (questionMarkInd === -1) {
            questionMarkInd = dataURL.length;
        }
        host = dataURL.substring(0, Math.min(slashInd, questionMarkInd));
        if (slashInd < questionMarkInd) {
            // For pathString, questionMarkInd will always come after slashInd
            pathString = decodePath(dataURL.substring(slashInd, questionMarkInd));
        }
        const queryParams = decodeQuery(dataURL.substring(Math.min(dataURL.length, questionMarkInd)));
        // If we have a port, use scheme for determining if it's secure.
        colonInd = host.indexOf(':');
        if (colonInd >= 0) {
            secure = scheme === 'https' || scheme === 'wss';
            port = parseInt(host.substring(colonInd + 1), 10);
        }
        else {
            colonInd = host.length;
        }
        const hostWithoutPort = host.slice(0, colonInd);
        if (hostWithoutPort.toLowerCase() === 'localhost') {
            domain = 'localhost';
        }
        else if (hostWithoutPort.split('.').length <= 2) {
            domain = hostWithoutPort;
        }
        else {
            // Interpret the subdomain of a 3 or more component URL as the namespace name.
            const dotInd = host.indexOf('.');
            subdomain = host.substring(0, dotInd).toLowerCase();
            domain = host.substring(dotInd + 1);
            // Normalize namespaces to lowercase to share storage / connection.
            namespace = subdomain;
        }
        // Always treat the value of the `ns` as the namespace name if it is present.
        if ('ns' in queryParams) {
            namespace = queryParams['ns'];
        }
    }
    return {
        host,
        port,
        domain,
        subdomain,
        secure,
        scheme,
        pathString,
        namespace
    };
};

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Encapsulates the data needed to raise an event
 */
class DataEvent {
    /**
     * @param eventType - One of: value, child_added, child_changed, child_moved, child_removed
     * @param eventRegistration - The function to call to with the event data. User provided
     * @param snapshot - The data backing the event
     * @param prevName - Optional, the name of the previous child for child_* events.
     */
    constructor(eventType, eventRegistration, snapshot, prevName) {
        this.eventType = eventType;
        this.eventRegistration = eventRegistration;
        this.snapshot = snapshot;
        this.prevName = prevName;
    }
    getPath() {
        const ref = this.snapshot.ref;
        if (this.eventType === 'value') {
            return ref._path;
        }
        else {
            return ref.parent._path;
        }
    }
    getEventType() {
        return this.eventType;
    }
    getEventRunner() {
        return this.eventRegistration.getEventRunner(this);
    }
    toString() {
        return (this.getPath().toString() +
            ':' +
            this.eventType +
            ':' +
            (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.stringify)(this.snapshot.exportVal()));
    }
}
class CancelEvent {
    constructor(eventRegistration, error, path) {
        this.eventRegistration = eventRegistration;
        this.error = error;
        this.path = path;
    }
    getPath() {
        return this.path;
    }
    getEventType() {
        return 'cancel';
    }
    getEventRunner() {
        return this.eventRegistration.getEventRunner(this);
    }
    toString() {
        return this.path.toString() + ':cancel';
    }
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * A wrapper class that converts events from the database@exp SDK to the legacy
 * Database SDK. Events are not converted directly as event registration relies
 * on reference comparison of the original user callback (see `matches()`) and
 * relies on equality of the legacy SDK's `context` object.
 */
class CallbackContext {
    constructor(snapshotCallback, cancelCallback) {
        this.snapshotCallback = snapshotCallback;
        this.cancelCallback = cancelCallback;
    }
    onValue(expDataSnapshot, previousChildName) {
        this.snapshotCallback.call(null, expDataSnapshot, previousChildName);
    }
    onCancel(error) {
        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(this.hasCancelCallback, 'Raising a cancel event on a listener with no cancel callback');
        return this.cancelCallback.call(null, error);
    }
    get hasCancelCallback() {
        return !!this.cancelCallback;
    }
    matches(other) {
        return (this.snapshotCallback === other.snapshotCallback ||
            (this.snapshotCallback.userCallback !== undefined &&
                this.snapshotCallback.userCallback ===
                    other.snapshotCallback.userCallback &&
                this.snapshotCallback.context === other.snapshotCallback.context));
    }
}

/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * The `onDisconnect` class allows you to write or clear data when your client
 * disconnects from the Database server. These updates occur whether your
 * client disconnects cleanly or not, so you can rely on them to clean up data
 * even if a connection is dropped or a client crashes.
 *
 * The `onDisconnect` class is most commonly used to manage presence in
 * applications where it is useful to detect how many clients are connected and
 * when other clients disconnect. See
 * {@link https://firebase.google.com/docs/database/web/offline-capabilities | Enabling Offline Capabilities in JavaScript}
 * for more information.
 *
 * To avoid problems when a connection is dropped before the requests can be
 * transferred to the Database server, these functions should be called before
 * writing any data.
 *
 * Note that `onDisconnect` operations are only triggered once. If you want an
 * operation to occur each time a disconnect occurs, you'll need to re-establish
 * the `onDisconnect` operations each time you reconnect.
 */
class OnDisconnect {
    /** @hideconstructor */
    constructor(_repo, _path) {
        this._repo = _repo;
        this._path = _path;
    }
    /**
     * Cancels all previously queued `onDisconnect()` set or update events for this
     * location and all children.
     *
     * If a write has been queued for this location via a `set()` or `update()` at a
     * parent location, the write at this location will be canceled, though writes
     * to sibling locations will still occur.
     *
     * @returns Resolves when synchronization to the server is complete.
     */
    cancel() {
        const deferred = new _firebase_util__WEBPACK_IMPORTED_MODULE_2__.Deferred();
        repoOnDisconnectCancel(this._repo, this._path, deferred.wrapCallback(() => { }));
        return deferred.promise;
    }
    /**
     * Ensures the data at this location is deleted when the client is disconnected
     * (due to closing the browser, navigating to a new page, or network issues).
     *
     * @returns Resolves when synchronization to the server is complete.
     */
    remove() {
        validateWritablePath('OnDisconnect.remove', this._path);
        const deferred = new _firebase_util__WEBPACK_IMPORTED_MODULE_2__.Deferred();
        repoOnDisconnectSet(this._repo, this._path, null, deferred.wrapCallback(() => { }));
        return deferred.promise;
    }
    /**
     * Ensures the data at this location is set to the specified value when the
     * client is disconnected (due to closing the browser, navigating to a new page,
     * or network issues).
     *
     * `set()` is especially useful for implementing "presence" systems, where a
     * value should be changed or cleared when a user disconnects so that they
     * appear "offline" to other users. See
     * {@link https://firebase.google.com/docs/database/web/offline-capabilities | Enabling Offline Capabilities in JavaScript}
     * for more information.
     *
     * Note that `onDisconnect` operations are only triggered once. If you want an
     * operation to occur each time a disconnect occurs, you'll need to re-establish
     * the `onDisconnect` operations each time.
     *
     * @param value - The value to be written to this location on disconnect (can
     * be an object, array, string, number, boolean, or null).
     * @returns Resolves when synchronization to the Database is complete.
     */
    set(value) {
        validateWritablePath('OnDisconnect.set', this._path);
        validateFirebaseDataArg('OnDisconnect.set', value, this._path, false);
        const deferred = new _firebase_util__WEBPACK_IMPORTED_MODULE_2__.Deferred();
        repoOnDisconnectSet(this._repo, this._path, value, deferred.wrapCallback(() => { }));
        return deferred.promise;
    }
    /**
     * Ensures the data at this location is set to the specified value and priority
     * when the client is disconnected (due to closing the browser, navigating to a
     * new page, or network issues).
     *
     * @param value - The value to be written to this location on disconnect (can
     * be an object, array, string, number, boolean, or null).
     * @param priority - The priority to be written (string, number, or null).
     * @returns Resolves when synchronization to the Database is complete.
     */
    setWithPriority(value, priority) {
        validateWritablePath('OnDisconnect.setWithPriority', this._path);
        validateFirebaseDataArg('OnDisconnect.setWithPriority', value, this._path, false);
        validatePriority('OnDisconnect.setWithPriority', priority, false);
        const deferred = new _firebase_util__WEBPACK_IMPORTED_MODULE_2__.Deferred();
        repoOnDisconnectSetWithPriority(this._repo, this._path, value, priority, deferred.wrapCallback(() => { }));
        return deferred.promise;
    }
    /**
     * Writes multiple values at this location when the client is disconnected (due
     * to closing the browser, navigating to a new page, or network issues).
     *
     * The `values` argument contains multiple property-value pairs that will be
     * written to the Database together. Each child property can either be a simple
     * property (for example, "name") or a relative path (for example, "name/first")
     * from the current location to the data to update.
     *
     * As opposed to the `set()` method, `update()` can be use to selectively update
     * only the referenced properties at the current location (instead of replacing
     * all the child properties at the current location).
     *
     * @param values - Object containing multiple values.
     * @returns Resolves when synchronization to the Database is complete.
     */
    update(values) {
        validateWritablePath('OnDisconnect.update', this._path);
        validateFirebaseMergeDataArg('OnDisconnect.update', values, this._path, false);
        const deferred = new _firebase_util__WEBPACK_IMPORTED_MODULE_2__.Deferred();
        repoOnDisconnectUpdate(this._repo, this._path, values, deferred.wrapCallback(() => { }));
        return deferred.promise;
    }
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @internal
 */
class QueryImpl {
    /**
     * @hideconstructor
     */
    constructor(_repo, _path, _queryParams, _orderByCalled) {
        this._repo = _repo;
        this._path = _path;
        this._queryParams = _queryParams;
        this._orderByCalled = _orderByCalled;
    }
    get key() {
        if (pathIsEmpty(this._path)) {
            return null;
        }
        else {
            return pathGetBack(this._path);
        }
    }
    get ref() {
        return new ReferenceImpl(this._repo, this._path);
    }
    get _queryIdentifier() {
        const obj = queryParamsGetQueryObject(this._queryParams);
        const id = ObjectToUniqueKey(obj);
        return id === '{}' ? 'default' : id;
    }
    /**
     * An object representation of the query parameters used by this Query.
     */
    get _queryObject() {
        return queryParamsGetQueryObject(this._queryParams);
    }
    isEqual(other) {
        other = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.getModularInstance)(other);
        if (!(other instanceof QueryImpl)) {
            return false;
        }
        const sameRepo = this._repo === other._repo;
        const samePath = pathEquals(this._path, other._path);
        const sameQueryIdentifier = this._queryIdentifier === other._queryIdentifier;
        return sameRepo && samePath && sameQueryIdentifier;
    }
    toJSON() {
        return this.toString();
    }
    toString() {
        return this._repo.toString() + pathToUrlEncodedString(this._path);
    }
}
/**
 * Validates that no other order by call has been made
 */
function validateNoPreviousOrderByCall(query, fnName) {
    if (query._orderByCalled === true) {
        throw new Error(fnName + ": You can't combine multiple orderBy calls.");
    }
}
/**
 * Validates start/end values for queries.
 */
function validateQueryEndpoints(params) {
    let startNode = null;
    let endNode = null;
    if (params.hasStart()) {
        startNode = params.getIndexStartValue();
    }
    if (params.hasEnd()) {
        endNode = params.getIndexEndValue();
    }
    if (params.getIndex() === KEY_INDEX) {
        const tooManyArgsError = 'Query: When ordering by key, you may only pass one argument to ' +
            'startAt(), endAt(), or equalTo().';
        const wrongArgTypeError = 'Query: When ordering by key, the argument passed to startAt(), startAfter(), ' +
            'endAt(), endBefore(), or equalTo() must be a string.';
        if (params.hasStart()) {
            const startName = params.getIndexStartName();
            if (startName !== MIN_NAME) {
                throw new Error(tooManyArgsError);
            }
            else if (typeof startNode !== 'string') {
                throw new Error(wrongArgTypeError);
            }
        }
        if (params.hasEnd()) {
            const endName = params.getIndexEndName();
            if (endName !== MAX_NAME) {
                throw new Error(tooManyArgsError);
            }
            else if (typeof endNode !== 'string') {
                throw new Error(wrongArgTypeError);
            }
        }
    }
    else if (params.getIndex() === PRIORITY_INDEX) {
        if ((startNode != null && !isValidPriority(startNode)) ||
            (endNode != null && !isValidPriority(endNode))) {
            throw new Error('Query: When ordering by priority, the first argument passed to startAt(), ' +
                'startAfter() endAt(), endBefore(), or equalTo() must be a valid priority value ' +
                '(null, a number, or a string).');
        }
    }
    else {
        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(params.getIndex() instanceof PathIndex ||
            params.getIndex() === VALUE_INDEX, 'unknown index type.');
        if ((startNode != null && typeof startNode === 'object') ||
            (endNode != null && typeof endNode === 'object')) {
            throw new Error('Query: First argument passed to startAt(), startAfter(), endAt(), endBefore(), or ' +
                'equalTo() cannot be an object.');
        }
    }
}
/**
 * Validates that limit* has been called with the correct combination of parameters
 */
function validateLimit(params) {
    if (params.hasStart() &&
        params.hasEnd() &&
        params.hasLimit() &&
        !params.hasAnchoredLimit()) {
        throw new Error("Query: Can't combine startAt(), startAfter(), endAt(), endBefore(), and limit(). Use " +
            'limitToFirst() or limitToLast() instead.');
    }
}
/**
 * @internal
 */
class ReferenceImpl extends QueryImpl {
    /** @hideconstructor */
    constructor(repo, path) {
        super(repo, path, new QueryParams(), false);
    }
    get parent() {
        const parentPath = pathParent(this._path);
        return parentPath === null
            ? null
            : new ReferenceImpl(this._repo, parentPath);
    }
    get root() {
        let ref = this;
        while (ref.parent !== null) {
            ref = ref.parent;
        }
        return ref;
    }
}
/**
 * A `DataSnapshot` contains data from a Database location.
 *
 * Any time you read data from the Database, you receive the data as a
 * `DataSnapshot`. A `DataSnapshot` is passed to the event callbacks you attach
 * with `on()` or `once()`. You can extract the contents of the snapshot as a
 * JavaScript object by calling the `val()` method. Alternatively, you can
 * traverse into the snapshot by calling `child()` to return child snapshots
 * (which you could then call `val()` on).
 *
 * A `DataSnapshot` is an efficiently generated, immutable copy of the data at
 * a Database location. It cannot be modified and will never change (to modify
 * data, you always call the `set()` method on a `Reference` directly).
 */
class DataSnapshot {
    /**
     * @param _node - A SnapshotNode to wrap.
     * @param ref - The location this snapshot came from.
     * @param _index - The iteration order for this snapshot
     * @hideconstructor
     */
    constructor(_node, 
    /**
     * The location of this DataSnapshot.
     */
    ref, _index) {
        this._node = _node;
        this.ref = ref;
        this._index = _index;
    }
    /**
     * Gets the priority value of the data in this `DataSnapshot`.
     *
     * Applications need not use priority but can order collections by
     * ordinary properties (see
     * {@link https://firebase.google.com/docs/database/web/lists-of-data#sorting_and_filtering_data |Sorting and filtering data}
     * ).
     */
    get priority() {
        // typecast here because we never return deferred values or internal priorities (MAX_PRIORITY)
        return this._node.getPriority().val();
    }
    /**
     * The key (last part of the path) of the location of this `DataSnapshot`.
     *
     * The last token in a Database location is considered its key. For example,
     * "ada" is the key for the /users/ada/ node. Accessing the key on any
     * `DataSnapshot` will return the key for the location that generated it.
     * However, accessing the key on the root URL of a Database will return
     * `null`.
     */
    get key() {
        return this.ref.key;
    }
    /** Returns the number of child properties of this `DataSnapshot`. */
    get size() {
        return this._node.numChildren();
    }
    /**
     * Gets another `DataSnapshot` for the location at the specified relative path.
     *
     * Passing a relative path to the `child()` method of a DataSnapshot returns
     * another `DataSnapshot` for the location at the specified relative path. The
     * relative path can either be a simple child name (for example, "ada") or a
     * deeper, slash-separated path (for example, "ada/name/first"). If the child
     * location has no data, an empty `DataSnapshot` (that is, a `DataSnapshot`
     * whose value is `null`) is returned.
     *
     * @param path - A relative path to the location of child data.
     */
    child(path) {
        const childPath = new Path(path);
        const childRef = child(this.ref, path);
        return new DataSnapshot(this._node.getChild(childPath), childRef, PRIORITY_INDEX);
    }
    /**
     * Returns true if this `DataSnapshot` contains any data. It is slightly more
     * efficient than using `snapshot.val() !== null`.
     */
    exists() {
        return !this._node.isEmpty();
    }
    /**
     * Exports the entire contents of the DataSnapshot as a JavaScript object.
     *
     * The `exportVal()` method is similar to `val()`, except priority information
     * is included (if available), making it suitable for backing up your data.
     *
     * @returns The DataSnapshot's contents as a JavaScript value (Object,
     *   Array, string, number, boolean, or `null`).
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    exportVal() {
        return this._node.val(true);
    }
    /**
     * Enumerates the top-level children in the `DataSnapshot`.
     *
     * Because of the way JavaScript objects work, the ordering of data in the
     * JavaScript object returned by `val()` is not guaranteed to match the
     * ordering on the server nor the ordering of `onChildAdded()` events. That is
     * where `forEach()` comes in handy. It guarantees the children of a
     * `DataSnapshot` will be iterated in their query order.
     *
     * If no explicit `orderBy*()` method is used, results are returned
     * ordered by key (unless priorities are used, in which case, results are
     * returned by priority).
     *
     * @param action - A function that will be called for each child DataSnapshot.
     * The callback can return true to cancel further enumeration.
     * @returns true if enumeration was canceled due to your callback returning
     * true.
     */
    forEach(action) {
        if (this._node.isLeafNode()) {
            return false;
        }
        const childrenNode = this._node;
        // Sanitize the return value to a boolean. ChildrenNode.forEachChild has a weird return type...
        return !!childrenNode.forEachChild(this._index, (key, node) => {
            return action(new DataSnapshot(node, child(this.ref, key), PRIORITY_INDEX));
        });
    }
    /**
     * Returns true if the specified child path has (non-null) data.
     *
     * @param path - A relative path to the location of a potential child.
     * @returns `true` if data exists at the specified child path; else
     *  `false`.
     */
    hasChild(path) {
        const childPath = new Path(path);
        return !this._node.getChild(childPath).isEmpty();
    }
    /**
     * Returns whether or not the `DataSnapshot` has any non-`null` child
     * properties.
     *
     * You can use `hasChildren()` to determine if a `DataSnapshot` has any
     * children. If it does, you can enumerate them using `forEach()`. If it
     * doesn't, then either this snapshot contains a primitive value (which can be
     * retrieved with `val()`) or it is empty (in which case, `val()` will return
     * `null`).
     *
     * @returns true if this snapshot has any children; else false.
     */
    hasChildren() {
        if (this._node.isLeafNode()) {
            return false;
        }
        else {
            return !this._node.isEmpty();
        }
    }
    /**
     * Returns a JSON-serializable representation of this object.
     */
    toJSON() {
        return this.exportVal();
    }
    /**
     * Extracts a JavaScript value from a `DataSnapshot`.
     *
     * Depending on the data in a `DataSnapshot`, the `val()` method may return a
     * scalar type (string, number, or boolean), an array, or an object. It may
     * also return null, indicating that the `DataSnapshot` is empty (contains no
     * data).
     *
     * @returns The DataSnapshot's contents as a JavaScript value (Object,
     *   Array, string, number, boolean, or `null`).
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    val() {
        return this._node.val();
    }
}
/**
 *
 * Returns a `Reference` representing the location in the Database
 * corresponding to the provided path. If no path is provided, the `Reference`
 * will point to the root of the Database.
 *
 * @param db - The database instance to obtain a reference for.
 * @param path - Optional path representing the location the returned
 *   `Reference` will point. If not provided, the returned `Reference` will
 *   point to the root of the Database.
 * @returns If a path is provided, a `Reference`
 *   pointing to the provided path. Otherwise, a `Reference` pointing to the
 *   root of the Database.
 */
function ref(db, path) {
    db = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.getModularInstance)(db);
    db._checkNotDeleted('ref');
    return path !== undefined ? child(db._root, path) : db._root;
}
/**
 * Returns a `Reference` representing the location in the Database
 * corresponding to the provided Firebase URL.
 *
 * An exception is thrown if the URL is not a valid Firebase Database URL or it
 * has a different domain than the current `Database` instance.
 *
 * Note that all query parameters (`orderBy`, `limitToLast`, etc.) are ignored
 * and are not applied to the returned `Reference`.
 *
 * @param db - The database instance to obtain a reference for.
 * @param url - The Firebase URL at which the returned `Reference` will
 *   point.
 * @returns A `Reference` pointing to the provided
 *   Firebase URL.
 */
function refFromURL(db, url) {
    db = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.getModularInstance)(db);
    db._checkNotDeleted('refFromURL');
    const parsedURL = parseRepoInfo(url, db._repo.repoInfo_.nodeAdmin);
    validateUrl('refFromURL', parsedURL);
    const repoInfo = parsedURL.repoInfo;
    if (!db._repo.repoInfo_.isCustomHost() &&
        repoInfo.host !== db._repo.repoInfo_.host) {
        fatal('refFromURL' +
            ': Host name does not match the current database: ' +
            '(found ' +
            repoInfo.host +
            ' but expected ' +
            db._repo.repoInfo_.host +
            ')');
    }
    return ref(db, parsedURL.path.toString());
}
/**
 * Gets a `Reference` for the location at the specified relative path.
 *
 * The relative path can either be a simple child name (for example, "ada") or
 * a deeper slash-separated path (for example, "ada/name/first").
 *
 * @param parent - The parent location.
 * @param path - A relative path from this location to the desired child
 *   location.
 * @returns The specified child location.
 */
function child(parent, path) {
    parent = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.getModularInstance)(parent);
    if (pathGetFront(parent._path) === null) {
        validateRootPathString('child', 'path', path, false);
    }
    else {
        validatePathString('child', 'path', path, false);
    }
    return new ReferenceImpl(parent._repo, pathChild(parent._path, path));
}
/**
 * Returns an `OnDisconnect` object - see
 * {@link https://firebase.google.com/docs/database/web/offline-capabilities | Enabling Offline Capabilities in JavaScript}
 * for more information on how to use it.
 *
 * @param ref - The reference to add OnDisconnect triggers for.
 */
function onDisconnect(ref) {
    ref = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.getModularInstance)(ref);
    return new OnDisconnect(ref._repo, ref._path);
}
/**
 * Generates a new child location using a unique key and returns its
 * `Reference`.
 *
 * This is the most common pattern for adding data to a collection of items.
 *
 * If you provide a value to `push()`, the value is written to the
 * generated location. If you don't pass a value, nothing is written to the
 * database and the child remains empty (but you can use the `Reference`
 * elsewhere).
 *
 * The unique keys generated by `push()` are ordered by the current time, so the
 * resulting list of items is chronologically sorted. The keys are also
 * designed to be unguessable (they contain 72 random bits of entropy).
 *
 * See {@link https://firebase.google.com/docs/database/web/lists-of-data#append_to_a_list_of_data | Append to a list of data}
 * </br>See {@link ttps://firebase.googleblog.com/2015/02/the-2120-ways-to-ensure-unique_68.html | The 2^120 Ways to Ensure Unique Identifiers}
 *
 * @param parent - The parent location.
 * @param value - Optional value to be written at the generated location.
 * @returns Combined `Promise` and `Reference`; resolves when write is complete,
 * but can be used immediately as the `Reference` to the child location.
 */
function push(parent, value) {
    parent = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.getModularInstance)(parent);
    validateWritablePath('push', parent._path);
    validateFirebaseDataArg('push', value, parent._path, true);
    const now = repoServerTime(parent._repo);
    const name = nextPushId(now);
    // push() returns a ThennableReference whose promise is fulfilled with a
    // regular Reference. We use child() to create handles to two different
    // references. The first is turned into a ThennableReference below by adding
    // then() and catch() methods and is used as the return value of push(). The
    // second remains a regular Reference and is used as the fulfilled value of
    // the first ThennableReference.
    const thennablePushRef = child(parent, name);
    const pushRef = child(parent, name);
    let promise;
    if (value != null) {
        promise = set(pushRef, value).then(() => pushRef);
    }
    else {
        promise = Promise.resolve(pushRef);
    }
    thennablePushRef.then = promise.then.bind(promise);
    thennablePushRef.catch = promise.then.bind(promise, undefined);
    return thennablePushRef;
}
/**
 * Removes the data at this Database location.
 *
 * Any data at child locations will also be deleted.
 *
 * The effect of the remove will be visible immediately and the corresponding
 * event 'value' will be triggered. Synchronization of the remove to the
 * Firebase servers will also be started, and the returned Promise will resolve
 * when complete. If provided, the onComplete callback will be called
 * asynchronously after synchronization has finished.
 *
 * @param ref - The location to remove.
 * @returns Resolves when remove on server is complete.
 */
function remove(ref) {
    validateWritablePath('remove', ref._path);
    return set(ref, null);
}
/**
 * Writes data to this Database location.
 *
 * This will overwrite any data at this location and all child locations.
 *
 * The effect of the write will be visible immediately, and the corresponding
 * events ("value", "child_added", etc.) will be triggered. Synchronization of
 * the data to the Firebase servers will also be started, and the returned
 * Promise will resolve when complete. If provided, the `onComplete` callback
 * will be called asynchronously after synchronization has finished.
 *
 * Passing `null` for the new value is equivalent to calling `remove()`; namely,
 * all data at this location and all child locations will be deleted.
 *
 * `set()` will remove any priority stored at this location, so if priority is
 * meant to be preserved, you need to use `setWithPriority()` instead.
 *
 * Note that modifying data with `set()` will cancel any pending transactions
 * at that location, so extreme care should be taken if mixing `set()` and
 * `transaction()` to modify the same data.
 *
 * A single `set()` will generate a single "value" event at the location where
 * the `set()` was performed.
 *
 * @param ref - The location to write to.
 * @param value - The value to be written (string, number, boolean, object,
 *   array, or null).
 * @returns Resolves when write to server is complete.
 */
function set(ref, value) {
    ref = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.getModularInstance)(ref);
    validateWritablePath('set', ref._path);
    validateFirebaseDataArg('set', value, ref._path, false);
    const deferred = new _firebase_util__WEBPACK_IMPORTED_MODULE_2__.Deferred();
    repoSetWithPriority(ref._repo, ref._path, value, 
    /*priority=*/ null, deferred.wrapCallback(() => { }));
    return deferred.promise;
}
/**
 * Sets a priority for the data at this Database location.
 *
 * Applications need not use priority but can order collections by
 * ordinary properties (see
 * {@link https://firebase.google.com/docs/database/web/lists-of-data#sorting_and_filtering_data | Sorting and filtering data}
 * ).
 *
 * @param ref - The location to write to.
 * @param priority - The priority to be written (string, number, or null).
 * @returns Resolves when write to server is complete.
 */
function setPriority(ref, priority) {
    ref = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.getModularInstance)(ref);
    validateWritablePath('setPriority', ref._path);
    validatePriority('setPriority', priority, false);
    const deferred = new _firebase_util__WEBPACK_IMPORTED_MODULE_2__.Deferred();
    repoSetWithPriority(ref._repo, pathChild(ref._path, '.priority'), priority, null, deferred.wrapCallback(() => { }));
    return deferred.promise;
}
/**
 * Writes data the Database location. Like `set()` but also specifies the
 * priority for that data.
 *
 * Applications need not use priority but can order collections by
 * ordinary properties (see
 * {@link https://firebase.google.com/docs/database/web/lists-of-data#sorting_and_filtering_data | Sorting and filtering data}
 * ).
 *
 * @param ref - The location to write to.
 * @param value - The value to be written (string, number, boolean, object,
 *   array, or null).
 * @param priority - The priority to be written (string, number, or null).
 * @returns Resolves when write to server is complete.
 */
function setWithPriority(ref, value, priority) {
    validateWritablePath('setWithPriority', ref._path);
    validateFirebaseDataArg('setWithPriority', value, ref._path, false);
    validatePriority('setWithPriority', priority, false);
    if (ref.key === '.length' || ref.key === '.keys') {
        throw 'setWithPriority failed: ' + ref.key + ' is a read-only object.';
    }
    const deferred = new _firebase_util__WEBPACK_IMPORTED_MODULE_2__.Deferred();
    repoSetWithPriority(ref._repo, ref._path, value, priority, deferred.wrapCallback(() => { }));
    return deferred.promise;
}
/**
 * Writes multiple values to the Database at once.
 *
 * The `values` argument contains multiple property-value pairs that will be
 * written to the Database together. Each child property can either be a simple
 * property (for example, "name") or a relative path (for example,
 * "name/first") from the current location to the data to update.
 *
 * As opposed to the `set()` method, `update()` can be use to selectively update
 * only the referenced properties at the current location (instead of replacing
 * all the child properties at the current location).
 *
 * The effect of the write will be visible immediately, and the corresponding
 * events ('value', 'child_added', etc.) will be triggered. Synchronization of
 * the data to the Firebase servers will also be started, and the returned
 * Promise will resolve when complete. If provided, the `onComplete` callback
 * will be called asynchronously after synchronization has finished.
 *
 * A single `update()` will generate a single "value" event at the location
 * where the `update()` was performed, regardless of how many children were
 * modified.
 *
 * Note that modifying data with `update()` will cancel any pending
 * transactions at that location, so extreme care should be taken if mixing
 * `update()` and `transaction()` to modify the same data.
 *
 * Passing `null` to `update()` will remove the data at this location.
 *
 * See
 * {@link https://firebase.googleblog.com/2015/09/introducing-multi-location-updates-and_86.html | Introducing multi-location updates and more}.
 *
 * @param ref - The location to write to.
 * @param values - Object containing multiple values.
 * @returns Resolves when update on server is complete.
 */
function update(ref, values) {
    validateFirebaseMergeDataArg('update', values, ref._path, false);
    const deferred = new _firebase_util__WEBPACK_IMPORTED_MODULE_2__.Deferred();
    repoUpdate(ref._repo, ref._path, values, deferred.wrapCallback(() => { }));
    return deferred.promise;
}
/**
 * Gets the most up-to-date result for this query.
 *
 * @param query - The query to run.
 * @returns A `Promise` which resolves to the resulting DataSnapshot if a value is
 * available, or rejects if the client is unable to return a value (e.g., if the
 * server is unreachable and there is nothing cached).
 */
function get(query) {
    query = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.getModularInstance)(query);
    return repoGetValue(query._repo, query).then(node => {
        return new DataSnapshot(node, new ReferenceImpl(query._repo, query._path), query._queryParams.getIndex());
    });
}
/**
 * Represents registration for 'value' events.
 */
class ValueEventRegistration {
    constructor(callbackContext) {
        this.callbackContext = callbackContext;
    }
    respondsTo(eventType) {
        return eventType === 'value';
    }
    createEvent(change, query) {
        const index = query._queryParams.getIndex();
        return new DataEvent('value', this, new DataSnapshot(change.snapshotNode, new ReferenceImpl(query._repo, query._path), index));
    }
    getEventRunner(eventData) {
        if (eventData.getEventType() === 'cancel') {
            return () => this.callbackContext.onCancel(eventData.error);
        }
        else {
            return () => this.callbackContext.onValue(eventData.snapshot, null);
        }
    }
    createCancelEvent(error, path) {
        if (this.callbackContext.hasCancelCallback) {
            return new CancelEvent(this, error, path);
        }
        else {
            return null;
        }
    }
    matches(other) {
        if (!(other instanceof ValueEventRegistration)) {
            return false;
        }
        else if (!other.callbackContext || !this.callbackContext) {
            // If no callback specified, we consider it to match any callback.
            return true;
        }
        else {
            return other.callbackContext.matches(this.callbackContext);
        }
    }
    hasAnyCallback() {
        return this.callbackContext !== null;
    }
}
/**
 * Represents the registration of a child_x event.
 */
class ChildEventRegistration {
    constructor(eventType, callbackContext) {
        this.eventType = eventType;
        this.callbackContext = callbackContext;
    }
    respondsTo(eventType) {
        let eventToCheck = eventType === 'children_added' ? 'child_added' : eventType;
        eventToCheck =
            eventToCheck === 'children_removed' ? 'child_removed' : eventToCheck;
        return this.eventType === eventToCheck;
    }
    createCancelEvent(error, path) {
        if (this.callbackContext.hasCancelCallback) {
            return new CancelEvent(this, error, path);
        }
        else {
            return null;
        }
    }
    createEvent(change, query) {
        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(change.childName != null, 'Child events should have a childName.');
        const childRef = child(new ReferenceImpl(query._repo, query._path), change.childName);
        const index = query._queryParams.getIndex();
        return new DataEvent(change.type, this, new DataSnapshot(change.snapshotNode, childRef, index), change.prevName);
    }
    getEventRunner(eventData) {
        if (eventData.getEventType() === 'cancel') {
            return () => this.callbackContext.onCancel(eventData.error);
        }
        else {
            return () => this.callbackContext.onValue(eventData.snapshot, eventData.prevName);
        }
    }
    matches(other) {
        if (other instanceof ChildEventRegistration) {
            return (this.eventType === other.eventType &&
                (!this.callbackContext ||
                    !other.callbackContext ||
                    this.callbackContext.matches(other.callbackContext)));
        }
        return false;
    }
    hasAnyCallback() {
        return !!this.callbackContext;
    }
}
function addEventListener(query, eventType, callback, cancelCallbackOrListenOptions, options) {
    let cancelCallback;
    if (typeof cancelCallbackOrListenOptions === 'object') {
        cancelCallback = undefined;
        options = cancelCallbackOrListenOptions;
    }
    if (typeof cancelCallbackOrListenOptions === 'function') {
        cancelCallback = cancelCallbackOrListenOptions;
    }
    if (options && options.onlyOnce) {
        const userCallback = callback;
        const onceCallback = (dataSnapshot, previousChildName) => {
            repoRemoveEventCallbackForQuery(query._repo, query, container);
            userCallback(dataSnapshot, previousChildName);
        };
        onceCallback.userCallback = callback.userCallback;
        onceCallback.context = callback.context;
        callback = onceCallback;
    }
    const callbackContext = new CallbackContext(callback, cancelCallback || undefined);
    const container = eventType === 'value'
        ? new ValueEventRegistration(callbackContext)
        : new ChildEventRegistration(eventType, callbackContext);
    repoAddEventCallbackForQuery(query._repo, query, container);
    return () => repoRemoveEventCallbackForQuery(query._repo, query, container);
}
function onValue(query, callback, cancelCallbackOrListenOptions, options) {
    return addEventListener(query, 'value', callback, cancelCallbackOrListenOptions, options);
}
function onChildAdded(query, callback, cancelCallbackOrListenOptions, options) {
    return addEventListener(query, 'child_added', callback, cancelCallbackOrListenOptions, options);
}
function onChildChanged(query, callback, cancelCallbackOrListenOptions, options) {
    return addEventListener(query, 'child_changed', callback, cancelCallbackOrListenOptions, options);
}
function onChildMoved(query, callback, cancelCallbackOrListenOptions, options) {
    return addEventListener(query, 'child_moved', callback, cancelCallbackOrListenOptions, options);
}
function onChildRemoved(query, callback, cancelCallbackOrListenOptions, options) {
    return addEventListener(query, 'child_removed', callback, cancelCallbackOrListenOptions, options);
}
/**
 * Detaches a callback previously attached with `on()`.
 *
 * Detach a callback previously attached with `on()`. Note that if `on()` was
 * called multiple times with the same eventType and callback, the callback
 * will be called multiple times for each event, and `off()` must be called
 * multiple times to remove the callback. Calling `off()` on a parent listener
 * will not automatically remove listeners registered on child nodes, `off()`
 * must also be called on any child listeners to remove the callback.
 *
 * If a callback is not specified, all callbacks for the specified eventType
 * will be removed. Similarly, if no eventType is specified, all callbacks
 * for the `Reference` will be removed.
 *
 * Individual listeners can also be removed by invoking their unsubscribe
 * callbacks.
 *
 * @param query - The query that the listener was registered with.
 * @param eventType - One of the following strings: "value", "child_added",
 * "child_changed", "child_removed", or "child_moved." If omitted, all callbacks
 * for the `Reference` will be removed.
 * @param callback - The callback function that was passed to `on()` or
 * `undefined` to remove all callbacks.
 */
function off(query, eventType, callback) {
    let container = null;
    const expCallback = callback ? new CallbackContext(callback) : null;
    if (eventType === 'value') {
        container = new ValueEventRegistration(expCallback);
    }
    else if (eventType) {
        container = new ChildEventRegistration(eventType, expCallback);
    }
    repoRemoveEventCallbackForQuery(query._repo, query, container);
}
/**
 * A `QueryConstraint` is used to narrow the set of documents returned by a
 * Database query. `QueryConstraint`s are created by invoking {@link endAt},
 * {@link endBefore}, {@link startAt}, {@link startAfter}, {@link
 * limitToFirst}, {@link limitToLast}, {@link orderByChild},
 * {@link orderByChild}, {@link orderByKey} , {@link orderByPriority} ,
 * {@link orderByValue}  or {@link equalTo} and
 * can then be passed to {@link query} to create a new query instance that
 * also contains this `QueryConstraint`.
 */
class QueryConstraint {
}
class QueryEndAtConstraint extends QueryConstraint {
    constructor(_value, _key) {
        super();
        this._value = _value;
        this._key = _key;
    }
    _apply(query) {
        validateFirebaseDataArg('endAt', this._value, query._path, true);
        const newParams = queryParamsEndAt(query._queryParams, this._value, this._key);
        validateLimit(newParams);
        validateQueryEndpoints(newParams);
        if (query._queryParams.hasEnd()) {
            throw new Error('endAt: Starting point was already set (by another call to endAt, ' +
                'endBefore or equalTo).');
        }
        return new QueryImpl(query._repo, query._path, newParams, query._orderByCalled);
    }
}
/**
 * Creates a `QueryConstraint` with the specified ending point.
 *
 * Using `startAt()`, `startAfter()`, `endBefore()`, `endAt()` and `equalTo()`
 * allows you to choose arbitrary starting and ending points for your queries.
 *
 * The ending point is inclusive, so children with exactly the specified value
 * will be included in the query. The optional key argument can be used to
 * further limit the range of the query. If it is specified, then children that
 * have exactly the specified value must also have a key name less than or equal
 * to the specified key.
 *
 * You can read more about `endAt()` in
 * {@link https://firebase.google.com/docs/database/web/lists-of-data#filtering_data | Filtering data}.
 *
 * @param value - The value to end at. The argument type depends on which
 * `orderBy*()` function was used in this query. Specify a value that matches
 * the `orderBy*()` type. When used in combination with `orderByKey()`, the
 * value must be a string.
 * @param key - The child key to end at, among the children with the previously
 * specified priority. This argument is only allowed if ordering by child,
 * value, or priority.
 */
function endAt(value, key) {
    validateKey('endAt', 'key', key, true);
    return new QueryEndAtConstraint(value, key);
}
class QueryEndBeforeConstraint extends QueryConstraint {
    constructor(_value, _key) {
        super();
        this._value = _value;
        this._key = _key;
    }
    _apply(query) {
        validateFirebaseDataArg('endBefore', this._value, query._path, false);
        const newParams = queryParamsEndBefore(query._queryParams, this._value, this._key);
        validateLimit(newParams);
        validateQueryEndpoints(newParams);
        if (query._queryParams.hasEnd()) {
            throw new Error('endBefore: Starting point was already set (by another call to endAt, ' +
                'endBefore or equalTo).');
        }
        return new QueryImpl(query._repo, query._path, newParams, query._orderByCalled);
    }
}
/**
 * Creates a `QueryConstraint` with the specified ending point (exclusive).
 *
 * Using `startAt()`, `startAfter()`, `endBefore()`, `endAt()` and `equalTo()`
 * allows you to choose arbitrary starting and ending points for your queries.
 *
 * The ending point is exclusive. If only a value is provided, children
 * with a value less than the specified value will be included in the query.
 * If a key is specified, then children must have a value lesss than or equal
 * to the specified value and a a key name less than the specified key.
 *
 * @param value - The value to end before. The argument type depends on which
 * `orderBy*()` function was used in this query. Specify a value that matches
 * the `orderBy*()` type. When used in combination with `orderByKey()`, the
 * value must be a string.
 * @param key - The child key to end before, among the children with the
 * previously specified priority. This argument is only allowed if ordering by
 * child, value, or priority.
 */
function endBefore(value, key) {
    validateKey('endBefore', 'key', key, true);
    return new QueryEndBeforeConstraint(value, key);
}
class QueryStartAtConstraint extends QueryConstraint {
    constructor(_value, _key) {
        super();
        this._value = _value;
        this._key = _key;
    }
    _apply(query) {
        validateFirebaseDataArg('startAt', this._value, query._path, true);
        const newParams = queryParamsStartAt(query._queryParams, this._value, this._key);
        validateLimit(newParams);
        validateQueryEndpoints(newParams);
        if (query._queryParams.hasStart()) {
            throw new Error('startAt: Starting point was already set (by another call to startAt, ' +
                'startBefore or equalTo).');
        }
        return new QueryImpl(query._repo, query._path, newParams, query._orderByCalled);
    }
}
/**
 * Creates a `QueryConstraint` with the specified starting point.
 *
 * Using `startAt()`, `startAfter()`, `endBefore()`, `endAt()` and `equalTo()`
 * allows you to choose arbitrary starting and ending points for your queries.
 *
 * The starting point is inclusive, so children with exactly the specified value
 * will be included in the query. The optional key argument can be used to
 * further limit the range of the query. If it is specified, then children that
 * have exactly the specified value must also have a key name greater than or
 * equal to the specified key.
 *
 * You can read more about `startAt()` in
 * {@link https://firebase.google.com/docs/database/web/lists-of-data#filtering_data | Filtering data}.
 *
 * @param value - The value to start at. The argument type depends on which
 * `orderBy*()` function was used in this query. Specify a value that matches
 * the `orderBy*()` type. When used in combination with `orderByKey()`, the
 * value must be a string.
 * @param key - The child key to start at. This argument is only allowed if
 * ordering by child, value, or priority.
 */
function startAt(value = null, key) {
    validateKey('startAt', 'key', key, true);
    return new QueryStartAtConstraint(value, key);
}
class QueryStartAfterConstraint extends QueryConstraint {
    constructor(_value, _key) {
        super();
        this._value = _value;
        this._key = _key;
    }
    _apply(query) {
        validateFirebaseDataArg('startAfter', this._value, query._path, false);
        const newParams = queryParamsStartAfter(query._queryParams, this._value, this._key);
        validateLimit(newParams);
        validateQueryEndpoints(newParams);
        if (query._queryParams.hasStart()) {
            throw new Error('startAfter: Starting point was already set (by another call to startAt, ' +
                'startAfter, or equalTo).');
        }
        return new QueryImpl(query._repo, query._path, newParams, query._orderByCalled);
    }
}
/**
 * Creates a `QueryConstraint` with the specified starting point (exclusive).
 *
 * Using `startAt()`, `startAfter()`, `endBefore()`, `endAt()` and `equalTo()`
 * allows you to choose arbitrary starting and ending points for your queries.
 *
 * The starting point is exclusive. If only a value is provided, children
 * with a value greater than the specified value will be included in the query.
 * If a key is specified, then children must have a value greater than or equal
 * to the specified value and a a key name greater than the specified key.
 *
 * @param value - The value to start after. The argument type depends on which
 * `orderBy*()` function was used in this query. Specify a value that matches
 * the `orderBy*()` type. When used in combination with `orderByKey()`, the
 * value must be a string.
 * @param key - The child key to start after. This argument is only allowed if
 * ordering by child, value, or priority.
 */
function startAfter(value, key) {
    validateKey('startAfter', 'key', key, true);
    return new QueryStartAfterConstraint(value, key);
}
class QueryLimitToFirstConstraint extends QueryConstraint {
    constructor(_limit) {
        super();
        this._limit = _limit;
    }
    _apply(query) {
        if (query._queryParams.hasLimit()) {
            throw new Error('limitToFirst: Limit was already set (by another call to limitToFirst ' +
                'or limitToLast).');
        }
        return new QueryImpl(query._repo, query._path, queryParamsLimitToFirst(query._queryParams, this._limit), query._orderByCalled);
    }
}
/**
 * Creates a new `QueryConstraint` that if limited to the first specific number
 * of children.
 *
 * The `limitToFirst()` method is used to set a maximum number of children to be
 * synced for a given callback. If we set a limit of 100, we will initially only
 * receive up to 100 `child_added` events. If we have fewer than 100 messages
 * stored in our Database, a `child_added` event will fire for each message.
 * However, if we have over 100 messages, we will only receive a `child_added`
 * event for the first 100 ordered messages. As items change, we will receive
 * `child_removed` events for each item that drops out of the active list so
 * that the total number stays at 100.
 *
 * You can read more about `limitToFirst()` in
 * {@link https://firebase.google.com/docs/database/web/lists-of-data#filtering_data | Filtering data}.
 *
 * @param limit - The maximum number of nodes to include in this query.
 */
function limitToFirst(limit) {
    if (typeof limit !== 'number' || Math.floor(limit) !== limit || limit <= 0) {
        throw new Error('limitToFirst: First argument must be a positive integer.');
    }
    return new QueryLimitToFirstConstraint(limit);
}
class QueryLimitToLastConstraint extends QueryConstraint {
    constructor(_limit) {
        super();
        this._limit = _limit;
    }
    _apply(query) {
        if (query._queryParams.hasLimit()) {
            throw new Error('limitToLast: Limit was already set (by another call to limitToFirst ' +
                'or limitToLast).');
        }
        return new QueryImpl(query._repo, query._path, queryParamsLimitToLast(query._queryParams, this._limit), query._orderByCalled);
    }
}
/**
 * Creates a new `QueryConstraint` that is limited to return only the last
 * specified number of children.
 *
 * The `limitToLast()` method is used to set a maximum number of children to be
 * synced for a given callback. If we set a limit of 100, we will initially only
 * receive up to 100 `child_added` events. If we have fewer than 100 messages
 * stored in our Database, a `child_added` event will fire for each message.
 * However, if we have over 100 messages, we will only receive a `child_added`
 * event for the last 100 ordered messages. As items change, we will receive
 * `child_removed` events for each item that drops out of the active list so
 * that the total number stays at 100.
 *
 * You can read more about `limitToLast()` in
 * {@link https://firebase.google.com/docs/database/web/lists-of-data#filtering_data | Filtering data}.
 *
 * @param limit - The maximum number of nodes to include in this query.
 */
function limitToLast(limit) {
    if (typeof limit !== 'number' || Math.floor(limit) !== limit || limit <= 0) {
        throw new Error('limitToLast: First argument must be a positive integer.');
    }
    return new QueryLimitToLastConstraint(limit);
}
class QueryOrderByChildConstraint extends QueryConstraint {
    constructor(_path) {
        super();
        this._path = _path;
    }
    _apply(query) {
        validateNoPreviousOrderByCall(query, 'orderByChild');
        const parsedPath = new Path(this._path);
        if (pathIsEmpty(parsedPath)) {
            throw new Error('orderByChild: cannot pass in empty path. Use orderByValue() instead.');
        }
        const index = new PathIndex(parsedPath);
        const newParams = queryParamsOrderBy(query._queryParams, index);
        validateQueryEndpoints(newParams);
        return new QueryImpl(query._repo, query._path, newParams, 
        /*orderByCalled=*/ true);
    }
}
/**
 * Creates a new `QueryConstraint` that orders by the specified child key.
 *
 * Queries can only order by one key at a time. Calling `orderByChild()`
 * multiple times on the same query is an error.
 *
 * Firebase queries allow you to order your data by any child key on the fly.
 * However, if you know in advance what your indexes will be, you can define
 * them via the .indexOn rule in your Security Rules for better performance. See
 * the{@link https://firebase.google.com/docs/database/security/indexing-data}
 * rule for more information.
 *
 * You can read more about `orderByChild()` in
 * {@link https://firebase.google.com/docs/database/web/lists-of-data#sort_data | Sort data}.
 *
 * @param path - The path to order by.
 */
function orderByChild(path) {
    if (path === '$key') {
        throw new Error('orderByChild: "$key" is invalid.  Use orderByKey() instead.');
    }
    else if (path === '$priority') {
        throw new Error('orderByChild: "$priority" is invalid.  Use orderByPriority() instead.');
    }
    else if (path === '$value') {
        throw new Error('orderByChild: "$value" is invalid.  Use orderByValue() instead.');
    }
    validatePathString('orderByChild', 'path', path, false);
    return new QueryOrderByChildConstraint(path);
}
class QueryOrderByKeyConstraint extends QueryConstraint {
    _apply(query) {
        validateNoPreviousOrderByCall(query, 'orderByKey');
        const newParams = queryParamsOrderBy(query._queryParams, KEY_INDEX);
        validateQueryEndpoints(newParams);
        return new QueryImpl(query._repo, query._path, newParams, 
        /*orderByCalled=*/ true);
    }
}
/**
 * Creates a new `QueryConstraint` that orders by the key.
 *
 * Sorts the results of a query by their (ascending) key values.
 *
 * You can read more about `orderByKey()` in
 * {@link https://firebase.google.com/docs/database/web/lists-of-data#sort_data | Sort data}.
 */
function orderByKey() {
    return new QueryOrderByKeyConstraint();
}
class QueryOrderByPriorityConstraint extends QueryConstraint {
    _apply(query) {
        validateNoPreviousOrderByCall(query, 'orderByPriority');
        const newParams = queryParamsOrderBy(query._queryParams, PRIORITY_INDEX);
        validateQueryEndpoints(newParams);
        return new QueryImpl(query._repo, query._path, newParams, 
        /*orderByCalled=*/ true);
    }
}
/**
 * Creates a new `QueryConstraint` that orders by priority.
 *
 * Applications need not use priority but can order collections by
 * ordinary properties (see
 * {@link https://firebase.google.com/docs/database/web/lists-of-data#sort_data | Sort data}
 * for alternatives to priority.
 */
function orderByPriority() {
    return new QueryOrderByPriorityConstraint();
}
class QueryOrderByValueConstraint extends QueryConstraint {
    _apply(query) {
        validateNoPreviousOrderByCall(query, 'orderByValue');
        const newParams = queryParamsOrderBy(query._queryParams, VALUE_INDEX);
        validateQueryEndpoints(newParams);
        return new QueryImpl(query._repo, query._path, newParams, 
        /*orderByCalled=*/ true);
    }
}
/**
 * Creates a new `QueryConstraint` that orders by value.
 *
 * If the children of a query are all scalar values (string, number, or
 * boolean), you can order the results by their (ascending) values.
 *
 * You can read more about `orderByValue()` in
 * {@link https://firebase.google.com/docs/database/web/lists-of-data#sort_data | Sort data}.
 */
function orderByValue() {
    return new QueryOrderByValueConstraint();
}
class QueryEqualToValueConstraint extends QueryConstraint {
    constructor(_value, _key) {
        super();
        this._value = _value;
        this._key = _key;
    }
    _apply(query) {
        validateFirebaseDataArg('equalTo', this._value, query._path, false);
        if (query._queryParams.hasStart()) {
            throw new Error('equalTo: Starting point was already set (by another call to startAt/startAfter or ' +
                'equalTo).');
        }
        if (query._queryParams.hasEnd()) {
            throw new Error('equalTo: Ending point was already set (by another call to endAt/endBefore or ' +
                'equalTo).');
        }
        return new QueryEndAtConstraint(this._value, this._key)._apply(new QueryStartAtConstraint(this._value, this._key)._apply(query));
    }
}
/**
 * Creates a `QueryConstraint` that includes children that match the specified
 * value.
 *
 * Using `startAt()`, `startAfter()`, `endBefore()`, `endAt()` and `equalTo()`
 * allows you to choose arbitrary starting and ending points for your queries.
 *
 * The optional key argument can be used to further limit the range of the
 * query. If it is specified, then children that have exactly the specified
 * value must also have exactly the specified key as their key name. This can be
 * used to filter result sets with many matches for the same value.
 *
 * You can read more about `equalTo()` in
 * {@link https://firebase.google.com/docs/database/web/lists-of-data#filtering_data | Filtering data}.
 *
 * @param value - The value to match for. The argument type depends on which
 * `orderBy*()` function was used in this query. Specify a value that matches
 * the `orderBy*()` type. When used in combination with `orderByKey()`, the
 * value must be a string.
 * @param key - The child key to start at, among the children with the
 * previously specified priority. This argument is only allowed if ordering by
 * child, value, or priority.
 */
function equalTo(value, key) {
    validateKey('equalTo', 'key', key, true);
    return new QueryEqualToValueConstraint(value, key);
}
/**
 * Creates a new immutable instance of `Query` that is extended to also include
 * additional query constraints.
 *
 * @param query - The Query instance to use as a base for the new constraints.
 * @param queryConstraints - The list of `QueryConstraint`s to apply.
 * @throws if any of the provided query constraints cannot be combined with the
 * existing or new constraints.
 */
function query(query, ...queryConstraints) {
    let queryImpl = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.getModularInstance)(query);
    for (const constraint of queryConstraints) {
        queryImpl = constraint._apply(queryImpl);
    }
    return queryImpl;
}
/**
 * Define reference constructor in various modules
 *
 * We are doing this here to avoid several circular
 * dependency issues
 */
syncPointSetReferenceConstructor(ReferenceImpl);
syncTreeSetReferenceConstructor(ReferenceImpl);

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * This variable is also defined in the firebase Node.js Admin SDK. Before
 * modifying this definition, consult the definition in:
 *
 * https://github.com/firebase/firebase-admin-node
 *
 * and make sure the two are consistent.
 */
const FIREBASE_DATABASE_EMULATOR_HOST_VAR = 'FIREBASE_DATABASE_EMULATOR_HOST';
/**
 * Creates and caches `Repo` instances.
 */
const repos = {};
/**
 * If true, any new `Repo` will be created to use `ReadonlyRestClient` (for testing purposes).
 */
let useRestClient = false;
/**
 * Update an existing `Repo` in place to point to a new host/port.
 */
function repoManagerApplyEmulatorSettings(repo, host, port, tokenProvider) {
    repo.repoInfo_ = new RepoInfo(`${host}:${port}`, 
    /* secure= */ false, repo.repoInfo_.namespace, repo.repoInfo_.webSocketOnly, repo.repoInfo_.nodeAdmin, repo.repoInfo_.persistenceKey, repo.repoInfo_.includeNamespaceInQueryParams);
    if (tokenProvider) {
        repo.authTokenProvider_ = tokenProvider;
    }
}
/**
 * This function should only ever be called to CREATE a new database instance.
 * @internal
 */
function repoManagerDatabaseFromApp(app, authProvider, appCheckProvider, url, nodeAdmin) {
    let dbUrl = url || app.options.databaseURL;
    if (dbUrl === undefined) {
        if (!app.options.projectId) {
            fatal("Can't determine Firebase Database URL. Be sure to include " +
                ' a Project ID when calling firebase.initializeApp().');
        }
        log('Using default host for project ', app.options.projectId);
        dbUrl = `${app.options.projectId}-default-rtdb.firebaseio.com`;
    }
    let parsedUrl = parseRepoInfo(dbUrl, nodeAdmin);
    let repoInfo = parsedUrl.repoInfo;
    let isEmulator;
    let dbEmulatorHost = undefined;
    if (typeof process !== 'undefined') {
        dbEmulatorHost = process.env[FIREBASE_DATABASE_EMULATOR_HOST_VAR];
    }
    if (dbEmulatorHost) {
        isEmulator = true;
        dbUrl = `http://${dbEmulatorHost}?ns=${repoInfo.namespace}`;
        parsedUrl = parseRepoInfo(dbUrl, nodeAdmin);
        repoInfo = parsedUrl.repoInfo;
    }
    else {
        isEmulator = !parsedUrl.repoInfo.secure;
    }
    const authTokenProvider = nodeAdmin && isEmulator
        ? new EmulatorTokenProvider(EmulatorTokenProvider.OWNER)
        : new FirebaseAuthTokenProvider(app.name, app.options, authProvider);
    validateUrl('Invalid Firebase Database URL', parsedUrl);
    if (!pathIsEmpty(parsedUrl.path)) {
        fatal('Database URL must point to the root of a Firebase Database ' +
            '(not including a child path).');
    }
    const repo = repoManagerCreateRepo(repoInfo, app, authTokenProvider, new AppCheckTokenProvider(app.name, appCheckProvider));
    return new Database(repo, app);
}
/**
 * Remove the repo and make sure it is disconnected.
 *
 */
function repoManagerDeleteRepo(repo, appName) {
    const appRepos = repos[appName];
    // This should never happen...
    if (!appRepos || appRepos[repo.key] !== repo) {
        fatal(`Database ${appName}(${repo.repoInfo_}) has already been deleted.`);
    }
    repoInterrupt(repo);
    delete appRepos[repo.key];
}
/**
 * Ensures a repo doesn't already exist and then creates one using the
 * provided app.
 *
 * @param repoInfo - The metadata about the Repo
 * @returns The Repo object for the specified server / repoName.
 */
function repoManagerCreateRepo(repoInfo, app, authTokenProvider, appCheckProvider) {
    let appRepos = repos[app.name];
    if (!appRepos) {
        appRepos = {};
        repos[app.name] = appRepos;
    }
    let repo = appRepos[repoInfo.toURLString()];
    if (repo) {
        fatal('Database initialized multiple times. Please make sure the format of the database URL matches with each database() call.');
    }
    repo = new Repo(repoInfo, useRestClient, authTokenProvider, appCheckProvider);
    appRepos[repoInfo.toURLString()] = repo;
    return repo;
}
/**
 * Forces us to use ReadonlyRestClient instead of PersistentConnection for new Repos.
 */
function repoManagerForceRestClient(forceRestClient) {
    useRestClient = forceRestClient;
}
/**
 * Class representing a Firebase Realtime Database.
 */
class Database {
    /** @hideconstructor */
    constructor(_repoInternal, 
    /** The {@link @firebase/app#FirebaseApp} associated with this Realtime Database instance. */
    app) {
        this._repoInternal = _repoInternal;
        this.app = app;
        /** Represents a `Database` instance. */
        this['type'] = 'database';
        /** Track if the instance has been used (root or repo accessed) */
        this._instanceStarted = false;
    }
    get _repo() {
        if (!this._instanceStarted) {
            repoStart(this._repoInternal, this.app.options.appId, this.app.options['databaseAuthVariableOverride']);
            this._instanceStarted = true;
        }
        return this._repoInternal;
    }
    get _root() {
        if (!this._rootInternal) {
            this._rootInternal = new ReferenceImpl(this._repo, newEmptyPath());
        }
        return this._rootInternal;
    }
    _delete() {
        if (this._rootInternal !== null) {
            repoManagerDeleteRepo(this._repo, this.app.name);
            this._repoInternal = null;
            this._rootInternal = null;
        }
        return Promise.resolve();
    }
    _checkNotDeleted(apiName) {
        if (this._rootInternal === null) {
            fatal('Cannot call ' + apiName + ' on a deleted database.');
        }
    }
}
/**
 * Returns the instance of the Realtime Database SDK that is associated
 * with the provided {@link @firebase/app#FirebaseApp}. Initializes a new instance with
 * with default settings if no instance exists or if the existing instance uses
 * a custom database URL.
 *
 * @param app - The {@link @firebase/app#FirebaseApp} instance that the returned Realtime
 * Database instance is associated with.
 * @param url - The URL of the Realtime Database instance to connect to. If not
 * provided, the SDK connects to the default instance of the Firebase App.
 * @returns The `Database` instance of the provided app.
 */
function getDatabase(app = (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__.getApp)(), url) {
    return (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._getProvider)(app, 'database').getImmediate({
        identifier: url
    });
}
/**
 * Modify the provided instance to communicate with the Realtime Database
 * emulator.
 *
 * <p>Note: This method must be called before performing any other operation.
 *
 * @param db - The instance to modify.
 * @param host - The emulator host (ex: localhost)
 * @param port - The emulator port (ex: 8080)
 * @param options.mockUserToken - the mock auth token to use for unit testing Security Rules
 */
function connectDatabaseEmulator(db, host, port, options = {}) {
    db = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.getModularInstance)(db);
    db._checkNotDeleted('useEmulator');
    if (db._instanceStarted) {
        fatal('Cannot call useEmulator() after instance has already been initialized.');
    }
    const repo = db._repoInternal;
    let tokenProvider = undefined;
    if (repo.repoInfo_.nodeAdmin) {
        if (options.mockUserToken) {
            fatal('mockUserToken is not supported by the Admin SDK. For client access with mock users, please use the "firebase" package instead of "firebase-admin".');
        }
        tokenProvider = new EmulatorTokenProvider(EmulatorTokenProvider.OWNER);
    }
    else if (options.mockUserToken) {
        const token = typeof options.mockUserToken === 'string'
            ? options.mockUserToken
            : (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.createMockUserToken)(options.mockUserToken, db.app.options.projectId);
        tokenProvider = new EmulatorTokenProvider(token);
    }
    // Modify the repo to apply emulator settings
    repoManagerApplyEmulatorSettings(repo, host, port, tokenProvider);
}
/**
 * Disconnects from the server (all Database operations will be completed
 * offline).
 *
 * The client automatically maintains a persistent connection to the Database
 * server, which will remain active indefinitely and reconnect when
 * disconnected. However, the `goOffline()` and `goOnline()` methods may be used
 * to control the client connection in cases where a persistent connection is
 * undesirable.
 *
 * While offline, the client will no longer receive data updates from the
 * Database. However, all Database operations performed locally will continue to
 * immediately fire events, allowing your application to continue behaving
 * normally. Additionally, each operation performed locally will automatically
 * be queued and retried upon reconnection to the Database server.
 *
 * To reconnect to the Database and begin receiving remote events, see
 * `goOnline()`.
 *
 * @param db - The instance to disconnect.
 */
function goOffline(db) {
    db = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.getModularInstance)(db);
    db._checkNotDeleted('goOffline');
    repoInterrupt(db._repo);
}
/**
 * Reconnects to the server and synchronizes the offline Database state
 * with the server state.
 *
 * This method should be used after disabling the active connection with
 * `goOffline()`. Once reconnected, the client will transmit the proper data
 * and fire the appropriate events so that your client "catches up"
 * automatically.
 *
 * @param db - The instance to reconnect.
 */
function goOnline(db) {
    db = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.getModularInstance)(db);
    db._checkNotDeleted('goOnline');
    repoResume(db._repo);
}
function enableLogging(logger, persistent) {
    enableLogging$1(logger, persistent);
}

/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function registerDatabase(variant) {
    setSDKVersion(_firebase_app__WEBPACK_IMPORTED_MODULE_0__.SDK_VERSION);
    (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._registerComponent)(new _firebase_component__WEBPACK_IMPORTED_MODULE_1__.Component('database', (container, { instanceIdentifier: url }) => {
        const app = container.getProvider('app').getImmediate();
        const authProvider = container.getProvider('auth-internal');
        const appCheckProvider = container.getProvider('app-check-internal');
        return repoManagerDatabaseFromApp(app, authProvider, appCheckProvider, url);
    }, "PUBLIC" /* PUBLIC */).setMultipleInstances(true));
    (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__.registerVersion)(name, version, variant);
    // BUILD_TARGET will be replaced by values like esm5, esm2017, cjs5, etc during the compilation
    (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__.registerVersion)(name, version, 'esm2017');
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const SERVER_TIMESTAMP = {
    '.sv': 'timestamp'
};
/**
 * Returns a placeholder value for auto-populating the current timestamp (time
 * since the Unix epoch, in milliseconds) as determined by the Firebase
 * servers.
 */
function serverTimestamp() {
    return SERVER_TIMESTAMP;
}
/**
 * Returns a placeholder value that can be used to atomically increment the
 * current database value by the provided delta.
 *
 * @param delta - the amount to modify the current value atomically.
 * @returns A placeholder value for modifying data atomically server-side.
 */
function increment(delta) {
    return {
        '.sv': {
            'increment': delta
        }
    };
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * A type for the resolve value of {@link runTransaction}.
 */
class TransactionResult {
    /** @hideconstructor */
    constructor(
    /** Whether the transaction was successfully committed. */
    committed, 
    /** The resulting data snapshot. */
    snapshot) {
        this.committed = committed;
        this.snapshot = snapshot;
    }
    /** Returns a JSON-serializable representation of this object. */
    toJSON() {
        return { committed: this.committed, snapshot: this.snapshot.toJSON() };
    }
}
/**
 * Atomically modifies the data at this location.
 *
 * Atomically modify the data at this location. Unlike a normal `set()`, which
 * just overwrites the data regardless of its previous value, `runTransaction()` is
 * used to modify the existing value to a new value, ensuring there are no
 * conflicts with other clients writing to the same location at the same time.
 *
 * To accomplish this, you pass `runTransaction()` an update function which is
 * used to transform the current value into a new value. If another client
 * writes to the location before your new value is successfully written, your
 * update function will be called again with the new current value, and the
 * write will be retried. This will happen repeatedly until your write succeeds
 * without conflict or you abort the transaction by not returning a value from
 * your update function.
 *
 * Note: Modifying data with `set()` will cancel any pending transactions at
 * that location, so extreme care should be taken if mixing `set()` and
 * `runTransaction()` to update the same data.
 *
 * Note: When using transactions with Security and Firebase Rules in place, be
 * aware that a client needs `.read` access in addition to `.write` access in
 * order to perform a transaction. This is because the client-side nature of
 * transactions requires the client to read the data in order to transactionally
 * update it.
 *
 * @param ref - The location to atomically modify.
 * @param transactionUpdate - A developer-supplied function which will be passed
 * the current data stored at this location (as a JavaScript object). The
 * function should return the new value it would like written (as a JavaScript
 * object). If `undefined` is returned (i.e. you return with no arguments) the
 * transaction will be aborted and the data at this location will not be
 * modified.
 * @param options - An options object to configure transactions.
 * @returns A `Promise` that can optionally be used instead of the `onComplete`
 * callback to handle success and failure.
 */
function runTransaction(ref, 
// eslint-disable-next-line @typescript-eslint/no-explicit-any
transactionUpdate, options) {
    var _a;
    ref = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.getModularInstance)(ref);
    validateWritablePath('Reference.transaction', ref._path);
    if (ref.key === '.length' || ref.key === '.keys') {
        throw ('Reference.transaction failed: ' + ref.key + ' is a read-only object.');
    }
    const applyLocally = (_a = options === null || options === void 0 ? void 0 : options.applyLocally) !== null && _a !== void 0 ? _a : true;
    const deferred = new _firebase_util__WEBPACK_IMPORTED_MODULE_2__.Deferred();
    const promiseComplete = (error, committed, node) => {
        let dataSnapshot = null;
        if (error) {
            deferred.reject(error);
        }
        else {
            dataSnapshot = new DataSnapshot(node, new ReferenceImpl(ref._repo, ref._path), PRIORITY_INDEX);
            deferred.resolve(new TransactionResult(committed, dataSnapshot));
        }
    };
    // Add a watch to make sure we get server updates.
    const unwatcher = onValue(ref, () => { });
    repoStartTransaction(ref._repo, ref._path, transactionUpdate, promiseComplete, unwatcher, applyLocally);
    return deferred.promise;
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
PersistentConnection;
// eslint-disable-next-line @typescript-eslint/no-explicit-any
PersistentConnection.prototype.simpleListen = function (pathString, onComplete) {
    this.sendRequest('q', { p: pathString }, onComplete);
};
// eslint-disable-next-line @typescript-eslint/no-explicit-any
PersistentConnection.prototype.echo = function (data, onEcho) {
    this.sendRequest('echo', { d: data }, onEcho);
};
// RealTimeConnection properties that we use in tests.
Connection;
/**
 * @internal
 */
const hijackHash = function (newHash) {
    const oldPut = PersistentConnection.prototype.put;
    PersistentConnection.prototype.put = function (pathString, data, onComplete, hash) {
        if (hash !== undefined) {
            hash = newHash();
        }
        oldPut.call(this, pathString, data, onComplete, hash);
    };
    return function () {
        PersistentConnection.prototype.put = oldPut;
    };
};
RepoInfo;
/**
 * Forces the RepoManager to create Repos that use ReadonlyRestClient instead of PersistentConnection.
 * @internal
 */
const forceRestClient = function (forceRestClient) {
    repoManagerForceRestClient(forceRestClient);
};

/**
 * Firebase Realtime Database
 *
 * @packageDocumentation
 */
registerDatabase();


//# sourceMappingURL=index.esm2017.js.map


/***/ }),

/***/ "./node_modules/@firebase/util/dist/index.esm2017.js":
/*!***********************************************************!*\
  !*** ./node_modules/@firebase/util/dist/index.esm2017.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CONSTANTS": () => (/* binding */ CONSTANTS),
/* harmony export */   "Deferred": () => (/* binding */ Deferred),
/* harmony export */   "ErrorFactory": () => (/* binding */ ErrorFactory),
/* harmony export */   "FirebaseError": () => (/* binding */ FirebaseError),
/* harmony export */   "MAX_VALUE_MILLIS": () => (/* binding */ MAX_VALUE_MILLIS),
/* harmony export */   "RANDOM_FACTOR": () => (/* binding */ RANDOM_FACTOR),
/* harmony export */   "Sha1": () => (/* binding */ Sha1),
/* harmony export */   "areCookiesEnabled": () => (/* binding */ areCookiesEnabled),
/* harmony export */   "assert": () => (/* binding */ assert),
/* harmony export */   "assertionError": () => (/* binding */ assertionError),
/* harmony export */   "async": () => (/* binding */ async),
/* harmony export */   "base64": () => (/* binding */ base64),
/* harmony export */   "base64Decode": () => (/* binding */ base64Decode),
/* harmony export */   "base64Encode": () => (/* binding */ base64Encode),
/* harmony export */   "base64urlEncodeWithoutPadding": () => (/* binding */ base64urlEncodeWithoutPadding),
/* harmony export */   "calculateBackoffMillis": () => (/* binding */ calculateBackoffMillis),
/* harmony export */   "contains": () => (/* binding */ contains),
/* harmony export */   "createMockUserToken": () => (/* binding */ createMockUserToken),
/* harmony export */   "createSubscribe": () => (/* binding */ createSubscribe),
/* harmony export */   "decode": () => (/* binding */ decode),
/* harmony export */   "deepCopy": () => (/* binding */ deepCopy),
/* harmony export */   "deepEqual": () => (/* binding */ deepEqual),
/* harmony export */   "deepExtend": () => (/* binding */ deepExtend),
/* harmony export */   "errorPrefix": () => (/* binding */ errorPrefix),
/* harmony export */   "extractQuerystring": () => (/* binding */ extractQuerystring),
/* harmony export */   "getGlobal": () => (/* binding */ getGlobal),
/* harmony export */   "getModularInstance": () => (/* binding */ getModularInstance),
/* harmony export */   "getUA": () => (/* binding */ getUA),
/* harmony export */   "isAdmin": () => (/* binding */ isAdmin),
/* harmony export */   "isBrowser": () => (/* binding */ isBrowser),
/* harmony export */   "isBrowserExtension": () => (/* binding */ isBrowserExtension),
/* harmony export */   "isElectron": () => (/* binding */ isElectron),
/* harmony export */   "isEmpty": () => (/* binding */ isEmpty),
/* harmony export */   "isIE": () => (/* binding */ isIE),
/* harmony export */   "isIndexedDBAvailable": () => (/* binding */ isIndexedDBAvailable),
/* harmony export */   "isMobileCordova": () => (/* binding */ isMobileCordova),
/* harmony export */   "isNode": () => (/* binding */ isNode),
/* harmony export */   "isNodeSdk": () => (/* binding */ isNodeSdk),
/* harmony export */   "isReactNative": () => (/* binding */ isReactNative),
/* harmony export */   "isSafari": () => (/* binding */ isSafari),
/* harmony export */   "isUWP": () => (/* binding */ isUWP),
/* harmony export */   "isValidFormat": () => (/* binding */ isValidFormat),
/* harmony export */   "isValidTimestamp": () => (/* binding */ isValidTimestamp),
/* harmony export */   "issuedAtTime": () => (/* binding */ issuedAtTime),
/* harmony export */   "jsonEval": () => (/* binding */ jsonEval),
/* harmony export */   "map": () => (/* binding */ map),
/* harmony export */   "ordinal": () => (/* binding */ ordinal),
/* harmony export */   "querystring": () => (/* binding */ querystring),
/* harmony export */   "querystringDecode": () => (/* binding */ querystringDecode),
/* harmony export */   "safeGet": () => (/* binding */ safeGet),
/* harmony export */   "stringLength": () => (/* binding */ stringLength),
/* harmony export */   "stringToByteArray": () => (/* binding */ stringToByteArray),
/* harmony export */   "stringify": () => (/* binding */ stringify),
/* harmony export */   "validateArgCount": () => (/* binding */ validateArgCount),
/* harmony export */   "validateCallback": () => (/* binding */ validateCallback),
/* harmony export */   "validateContextObject": () => (/* binding */ validateContextObject),
/* harmony export */   "validateIndexedDBOpenable": () => (/* binding */ validateIndexedDBOpenable),
/* harmony export */   "validateNamespace": () => (/* binding */ validateNamespace)
/* harmony export */ });
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @fileoverview Firebase constants.  Some of these (@defines) can be overridden at compile-time.
 */
const CONSTANTS = {
    /**
     * @define {boolean} Whether this is the client Node.js SDK.
     */
    NODE_CLIENT: false,
    /**
     * @define {boolean} Whether this is the Admin Node.js SDK.
     */
    NODE_ADMIN: false,
    /**
     * Firebase SDK Version
     */
    SDK_VERSION: '${JSCORE_VERSION}'
};

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Throws an error if the provided assertion is falsy
 */
const assert = function (assertion, message) {
    if (!assertion) {
        throw assertionError(message);
    }
};
/**
 * Returns an Error object suitable for throwing.
 */
const assertionError = function (message) {
    return new Error('Firebase Database (' +
        CONSTANTS.SDK_VERSION +
        ') INTERNAL ASSERT FAILED: ' +
        message);
};

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const stringToByteArray$1 = function (str) {
    // TODO(user): Use native implementations if/when available
    const out = [];
    let p = 0;
    for (let i = 0; i < str.length; i++) {
        let c = str.charCodeAt(i);
        if (c < 128) {
            out[p++] = c;
        }
        else if (c < 2048) {
            out[p++] = (c >> 6) | 192;
            out[p++] = (c & 63) | 128;
        }
        else if ((c & 0xfc00) === 0xd800 &&
            i + 1 < str.length &&
            (str.charCodeAt(i + 1) & 0xfc00) === 0xdc00) {
            // Surrogate Pair
            c = 0x10000 + ((c & 0x03ff) << 10) + (str.charCodeAt(++i) & 0x03ff);
            out[p++] = (c >> 18) | 240;
            out[p++] = ((c >> 12) & 63) | 128;
            out[p++] = ((c >> 6) & 63) | 128;
            out[p++] = (c & 63) | 128;
        }
        else {
            out[p++] = (c >> 12) | 224;
            out[p++] = ((c >> 6) & 63) | 128;
            out[p++] = (c & 63) | 128;
        }
    }
    return out;
};
/**
 * Turns an array of numbers into the string given by the concatenation of the
 * characters to which the numbers correspond.
 * @param bytes Array of numbers representing characters.
 * @return Stringification of the array.
 */
const byteArrayToString = function (bytes) {
    // TODO(user): Use native implementations if/when available
    const out = [];
    let pos = 0, c = 0;
    while (pos < bytes.length) {
        const c1 = bytes[pos++];
        if (c1 < 128) {
            out[c++] = String.fromCharCode(c1);
        }
        else if (c1 > 191 && c1 < 224) {
            const c2 = bytes[pos++];
            out[c++] = String.fromCharCode(((c1 & 31) << 6) | (c2 & 63));
        }
        else if (c1 > 239 && c1 < 365) {
            // Surrogate Pair
            const c2 = bytes[pos++];
            const c3 = bytes[pos++];
            const c4 = bytes[pos++];
            const u = (((c1 & 7) << 18) | ((c2 & 63) << 12) | ((c3 & 63) << 6) | (c4 & 63)) -
                0x10000;
            out[c++] = String.fromCharCode(0xd800 + (u >> 10));
            out[c++] = String.fromCharCode(0xdc00 + (u & 1023));
        }
        else {
            const c2 = bytes[pos++];
            const c3 = bytes[pos++];
            out[c++] = String.fromCharCode(((c1 & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63));
        }
    }
    return out.join('');
};
// We define it as an object literal instead of a class because a class compiled down to es5 can't
// be treeshaked. https://github.com/rollup/rollup/issues/1691
// Static lookup maps, lazily populated by init_()
const base64 = {
    /**
     * Maps bytes to characters.
     */
    byteToCharMap_: null,
    /**
     * Maps characters to bytes.
     */
    charToByteMap_: null,
    /**
     * Maps bytes to websafe characters.
     * @private
     */
    byteToCharMapWebSafe_: null,
    /**
     * Maps websafe characters to bytes.
     * @private
     */
    charToByteMapWebSafe_: null,
    /**
     * Our default alphabet, shared between
     * ENCODED_VALS and ENCODED_VALS_WEBSAFE
     */
    ENCODED_VALS_BASE: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' + 'abcdefghijklmnopqrstuvwxyz' + '0123456789',
    /**
     * Our default alphabet. Value 64 (=) is special; it means "nothing."
     */
    get ENCODED_VALS() {
        return this.ENCODED_VALS_BASE + '+/=';
    },
    /**
     * Our websafe alphabet.
     */
    get ENCODED_VALS_WEBSAFE() {
        return this.ENCODED_VALS_BASE + '-_.';
    },
    /**
     * Whether this browser supports the atob and btoa functions. This extension
     * started at Mozilla but is now implemented by many browsers. We use the
     * ASSUME_* variables to avoid pulling in the full useragent detection library
     * but still allowing the standard per-browser compilations.
     *
     */
    HAS_NATIVE_SUPPORT: typeof atob === 'function',
    /**
     * Base64-encode an array of bytes.
     *
     * @param input An array of bytes (numbers with
     *     value in [0, 255]) to encode.
     * @param webSafe Boolean indicating we should use the
     *     alternative alphabet.
     * @return The base64 encoded string.
     */
    encodeByteArray(input, webSafe) {
        if (!Array.isArray(input)) {
            throw Error('encodeByteArray takes an array as a parameter');
        }
        this.init_();
        const byteToCharMap = webSafe
            ? this.byteToCharMapWebSafe_
            : this.byteToCharMap_;
        const output = [];
        for (let i = 0; i < input.length; i += 3) {
            const byte1 = input[i];
            const haveByte2 = i + 1 < input.length;
            const byte2 = haveByte2 ? input[i + 1] : 0;
            const haveByte3 = i + 2 < input.length;
            const byte3 = haveByte3 ? input[i + 2] : 0;
            const outByte1 = byte1 >> 2;
            const outByte2 = ((byte1 & 0x03) << 4) | (byte2 >> 4);
            let outByte3 = ((byte2 & 0x0f) << 2) | (byte3 >> 6);
            let outByte4 = byte3 & 0x3f;
            if (!haveByte3) {
                outByte4 = 64;
                if (!haveByte2) {
                    outByte3 = 64;
                }
            }
            output.push(byteToCharMap[outByte1], byteToCharMap[outByte2], byteToCharMap[outByte3], byteToCharMap[outByte4]);
        }
        return output.join('');
    },
    /**
     * Base64-encode a string.
     *
     * @param input A string to encode.
     * @param webSafe If true, we should use the
     *     alternative alphabet.
     * @return The base64 encoded string.
     */
    encodeString(input, webSafe) {
        // Shortcut for Mozilla browsers that implement
        // a native base64 encoder in the form of "btoa/atob"
        if (this.HAS_NATIVE_SUPPORT && !webSafe) {
            return btoa(input);
        }
        return this.encodeByteArray(stringToByteArray$1(input), webSafe);
    },
    /**
     * Base64-decode a string.
     *
     * @param input to decode.
     * @param webSafe True if we should use the
     *     alternative alphabet.
     * @return string representing the decoded value.
     */
    decodeString(input, webSafe) {
        // Shortcut for Mozilla browsers that implement
        // a native base64 encoder in the form of "btoa/atob"
        if (this.HAS_NATIVE_SUPPORT && !webSafe) {
            return atob(input);
        }
        return byteArrayToString(this.decodeStringToByteArray(input, webSafe));
    },
    /**
     * Base64-decode a string.
     *
     * In base-64 decoding, groups of four characters are converted into three
     * bytes.  If the encoder did not apply padding, the input length may not
     * be a multiple of 4.
     *
     * In this case, the last group will have fewer than 4 characters, and
     * padding will be inferred.  If the group has one or two characters, it decodes
     * to one byte.  If the group has three characters, it decodes to two bytes.
     *
     * @param input Input to decode.
     * @param webSafe True if we should use the web-safe alphabet.
     * @return bytes representing the decoded value.
     */
    decodeStringToByteArray(input, webSafe) {
        this.init_();
        const charToByteMap = webSafe
            ? this.charToByteMapWebSafe_
            : this.charToByteMap_;
        const output = [];
        for (let i = 0; i < input.length;) {
            const byte1 = charToByteMap[input.charAt(i++)];
            const haveByte2 = i < input.length;
            const byte2 = haveByte2 ? charToByteMap[input.charAt(i)] : 0;
            ++i;
            const haveByte3 = i < input.length;
            const byte3 = haveByte3 ? charToByteMap[input.charAt(i)] : 64;
            ++i;
            const haveByte4 = i < input.length;
            const byte4 = haveByte4 ? charToByteMap[input.charAt(i)] : 64;
            ++i;
            if (byte1 == null || byte2 == null || byte3 == null || byte4 == null) {
                throw Error();
            }
            const outByte1 = (byte1 << 2) | (byte2 >> 4);
            output.push(outByte1);
            if (byte3 !== 64) {
                const outByte2 = ((byte2 << 4) & 0xf0) | (byte3 >> 2);
                output.push(outByte2);
                if (byte4 !== 64) {
                    const outByte3 = ((byte3 << 6) & 0xc0) | byte4;
                    output.push(outByte3);
                }
            }
        }
        return output;
    },
    /**
     * Lazy static initialization function. Called before
     * accessing any of the static map variables.
     * @private
     */
    init_() {
        if (!this.byteToCharMap_) {
            this.byteToCharMap_ = {};
            this.charToByteMap_ = {};
            this.byteToCharMapWebSafe_ = {};
            this.charToByteMapWebSafe_ = {};
            // We want quick mappings back and forth, so we precompute two maps.
            for (let i = 0; i < this.ENCODED_VALS.length; i++) {
                this.byteToCharMap_[i] = this.ENCODED_VALS.charAt(i);
                this.charToByteMap_[this.byteToCharMap_[i]] = i;
                this.byteToCharMapWebSafe_[i] = this.ENCODED_VALS_WEBSAFE.charAt(i);
                this.charToByteMapWebSafe_[this.byteToCharMapWebSafe_[i]] = i;
                // Be forgiving when decoding and correctly decode both encodings.
                if (i >= this.ENCODED_VALS_BASE.length) {
                    this.charToByteMap_[this.ENCODED_VALS_WEBSAFE.charAt(i)] = i;
                    this.charToByteMapWebSafe_[this.ENCODED_VALS.charAt(i)] = i;
                }
            }
        }
    }
};
/**
 * URL-safe base64 encoding
 */
const base64Encode = function (str) {
    const utf8Bytes = stringToByteArray$1(str);
    return base64.encodeByteArray(utf8Bytes, true);
};
/**
 * URL-safe base64 encoding (without "." padding in the end).
 * e.g. Used in JSON Web Token (JWT) parts.
 */
const base64urlEncodeWithoutPadding = function (str) {
    // Use base64url encoding and remove padding in the end (dot characters).
    return base64Encode(str).replace(/\./g, '');
};
/**
 * URL-safe base64 decoding
 *
 * NOTE: DO NOT use the global atob() function - it does NOT support the
 * base64Url variant encoding.
 *
 * @param str To be decoded
 * @return Decoded result, if possible
 */
const base64Decode = function (str) {
    try {
        return base64.decodeString(str, true);
    }
    catch (e) {
        console.error('base64Decode failed: ', e);
    }
    return null;
};

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Do a deep-copy of basic JavaScript Objects or Arrays.
 */
function deepCopy(value) {
    return deepExtend(undefined, value);
}
/**
 * Copy properties from source to target (recursively allows extension
 * of Objects and Arrays).  Scalar values in the target are over-written.
 * If target is undefined, an object of the appropriate type will be created
 * (and returned).
 *
 * We recursively copy all child properties of plain Objects in the source- so
 * that namespace- like dictionaries are merged.
 *
 * Note that the target can be a function, in which case the properties in
 * the source Object are copied onto it as static properties of the Function.
 *
 * Note: we don't merge __proto__ to prevent prototype pollution
 */
function deepExtend(target, source) {
    if (!(source instanceof Object)) {
        return source;
    }
    switch (source.constructor) {
        case Date:
            // Treat Dates like scalars; if the target date object had any child
            // properties - they will be lost!
            const dateValue = source;
            return new Date(dateValue.getTime());
        case Object:
            if (target === undefined) {
                target = {};
            }
            break;
        case Array:
            // Always copy the array source and overwrite the target.
            target = [];
            break;
        default:
            // Not a plain Object - treat it as a scalar.
            return source;
    }
    for (const prop in source) {
        // use isValidKey to guard against prototype pollution. See https://snyk.io/vuln/SNYK-JS-LODASH-450202
        if (!source.hasOwnProperty(prop) || !isValidKey(prop)) {
            continue;
        }
        target[prop] = deepExtend(target[prop], source[prop]);
    }
    return target;
}
function isValidKey(key) {
    return key !== '__proto__';
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Deferred {
    constructor() {
        this.reject = () => { };
        this.resolve = () => { };
        this.promise = new Promise((resolve, reject) => {
            this.resolve = resolve;
            this.reject = reject;
        });
    }
    /**
     * Our API internals are not promiseified and cannot because our callback APIs have subtle expectations around
     * invoking promises inline, which Promises are forbidden to do. This method accepts an optional node-style callback
     * and returns a node-style callback which will resolve or reject the Deferred's promise.
     */
    wrapCallback(callback) {
        return (error, value) => {
            if (error) {
                this.reject(error);
            }
            else {
                this.resolve(value);
            }
            if (typeof callback === 'function') {
                // Attaching noop handler just in case developer wasn't expecting
                // promises
                this.promise.catch(() => { });
                // Some of our callbacks don't expect a value and our own tests
                // assert that the parameter length is 1
                if (callback.length === 1) {
                    callback(error);
                }
                else {
                    callback(error, value);
                }
            }
        };
    }
}

/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function createMockUserToken(token, projectId) {
    if (token.uid) {
        throw new Error('The "uid" field is no longer supported by mockUserToken. Please use "sub" instead for Firebase Auth User ID.');
    }
    // Unsecured JWTs use "none" as the algorithm.
    const header = {
        alg: 'none',
        type: 'JWT'
    };
    const project = projectId || 'demo-project';
    const iat = token.iat || 0;
    const sub = token.sub || token.user_id;
    if (!sub) {
        throw new Error("mockUserToken must contain 'sub' or 'user_id' field!");
    }
    const payload = Object.assign({ 
        // Set all required fields to decent defaults
        iss: `https://securetoken.google.com/${project}`, aud: project, iat, exp: iat + 3600, auth_time: iat, sub, user_id: sub, firebase: {
            sign_in_provider: 'custom',
            identities: {}
        } }, token);
    // Unsecured JWTs use the empty string as a signature.
    const signature = '';
    return [
        base64urlEncodeWithoutPadding(JSON.stringify(header)),
        base64urlEncodeWithoutPadding(JSON.stringify(payload)),
        signature
    ].join('.');
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Returns navigator.userAgent string or '' if it's not defined.
 * @return user agent string
 */
function getUA() {
    if (typeof navigator !== 'undefined' &&
        typeof navigator['userAgent'] === 'string') {
        return navigator['userAgent'];
    }
    else {
        return '';
    }
}
/**
 * Detect Cordova / PhoneGap / Ionic frameworks on a mobile device.
 *
 * Deliberately does not rely on checking `file://` URLs (as this fails PhoneGap
 * in the Ripple emulator) nor Cordova `onDeviceReady`, which would normally
 * wait for a callback.
 */
function isMobileCordova() {
    return (typeof window !== 'undefined' &&
        // @ts-ignore Setting up an broadly applicable index signature for Window
        // just to deal with this case would probably be a bad idea.
        !!(window['cordova'] || window['phonegap'] || window['PhoneGap']) &&
        /ios|iphone|ipod|ipad|android|blackberry|iemobile/i.test(getUA()));
}
/**
 * Detect Node.js.
 *
 * @return true if Node.js environment is detected.
 */
// Node detection logic from: https://github.com/iliakan/detect-node/
function isNode() {
    try {
        return (Object.prototype.toString.call(__webpack_require__.g.process) === '[object process]');
    }
    catch (e) {
        return false;
    }
}
/**
 * Detect Browser Environment
 */
function isBrowser() {
    return typeof self === 'object' && self.self === self;
}
function isBrowserExtension() {
    const runtime = typeof chrome === 'object'
        ? chrome.runtime
        : typeof browser === 'object'
            ? browser.runtime
            : undefined;
    return typeof runtime === 'object' && runtime.id !== undefined;
}
/**
 * Detect React Native.
 *
 * @return true if ReactNative environment is detected.
 */
function isReactNative() {
    return (typeof navigator === 'object' && navigator['product'] === 'ReactNative');
}
/** Detects Electron apps. */
function isElectron() {
    return getUA().indexOf('Electron/') >= 0;
}
/** Detects Internet Explorer. */
function isIE() {
    const ua = getUA();
    return ua.indexOf('MSIE ') >= 0 || ua.indexOf('Trident/') >= 0;
}
/** Detects Universal Windows Platform apps. */
function isUWP() {
    return getUA().indexOf('MSAppHost/') >= 0;
}
/**
 * Detect whether the current SDK build is the Node version.
 *
 * @return true if it's the Node SDK build.
 */
function isNodeSdk() {
    return CONSTANTS.NODE_CLIENT === true || CONSTANTS.NODE_ADMIN === true;
}
/** Returns true if we are running in Safari. */
function isSafari() {
    return (!isNode() &&
        navigator.userAgent.includes('Safari') &&
        !navigator.userAgent.includes('Chrome'));
}
/**
 * This method checks if indexedDB is supported by current browser/service worker context
 * @return true if indexedDB is supported by current browser/service worker context
 */
function isIndexedDBAvailable() {
    return typeof indexedDB === 'object';
}
/**
 * This method validates browser/sw context for indexedDB by opening a dummy indexedDB database and reject
 * if errors occur during the database open operation.
 *
 * @throws exception if current browser/sw context can't run idb.open (ex: Safari iframe, Firefox
 * private browsing)
 */
function validateIndexedDBOpenable() {
    return new Promise((resolve, reject) => {
        try {
            let preExist = true;
            const DB_CHECK_NAME = 'validate-browser-context-for-indexeddb-analytics-module';
            const request = self.indexedDB.open(DB_CHECK_NAME);
            request.onsuccess = () => {
                request.result.close();
                // delete database only when it doesn't pre-exist
                if (!preExist) {
                    self.indexedDB.deleteDatabase(DB_CHECK_NAME);
                }
                resolve(true);
            };
            request.onupgradeneeded = () => {
                preExist = false;
            };
            request.onerror = () => {
                var _a;
                reject(((_a = request.error) === null || _a === void 0 ? void 0 : _a.message) || '');
            };
        }
        catch (error) {
            reject(error);
        }
    });
}
/**
 *
 * This method checks whether cookie is enabled within current browser
 * @return true if cookie is enabled within current browser
 */
function areCookiesEnabled() {
    if (typeof navigator === 'undefined' || !navigator.cookieEnabled) {
        return false;
    }
    return true;
}
/**
 * Polyfill for `globalThis` object.
 * @returns the `globalThis` object for the given environment.
 */
function getGlobal() {
    if (typeof self !== 'undefined') {
        return self;
    }
    if (typeof window !== 'undefined') {
        return window;
    }
    if (typeof __webpack_require__.g !== 'undefined') {
        return __webpack_require__.g;
    }
    throw new Error('Unable to locate global object.');
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @fileoverview Standardized Firebase Error.
 *
 * Usage:
 *
 *   // Typescript string literals for type-safe codes
 *   type Err =
 *     'unknown' |
 *     'object-not-found'
 *     ;
 *
 *   // Closure enum for type-safe error codes
 *   // at-enum {string}
 *   var Err = {
 *     UNKNOWN: 'unknown',
 *     OBJECT_NOT_FOUND: 'object-not-found',
 *   }
 *
 *   let errors: Map<Err, string> = {
 *     'generic-error': "Unknown error",
 *     'file-not-found': "Could not find file: {$file}",
 *   };
 *
 *   // Type-safe function - must pass a valid error code as param.
 *   let error = new ErrorFactory<Err>('service', 'Service', errors);
 *
 *   ...
 *   throw error.create(Err.GENERIC);
 *   ...
 *   throw error.create(Err.FILE_NOT_FOUND, {'file': fileName});
 *   ...
 *   // Service: Could not file file: foo.txt (service/file-not-found).
 *
 *   catch (e) {
 *     assert(e.message === "Could not find file: foo.txt.");
 *     if (e.code === 'service/file-not-found') {
 *       console.log("Could not read file: " + e['file']);
 *     }
 *   }
 */
const ERROR_NAME = 'FirebaseError';
// Based on code from:
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error#Custom_Error_Types
class FirebaseError extends Error {
    constructor(
    /** The error code for this error. */
    code, message, 
    /** Custom data for this error. */
    customData) {
        super(message);
        this.code = code;
        this.customData = customData;
        /** The custom name for all FirebaseErrors. */
        this.name = ERROR_NAME;
        // Fix For ES5
        // https://github.com/Microsoft/TypeScript-wiki/blob/master/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work
        Object.setPrototypeOf(this, FirebaseError.prototype);
        // Maintains proper stack trace for where our error was thrown.
        // Only available on V8.
        if (Error.captureStackTrace) {
            Error.captureStackTrace(this, ErrorFactory.prototype.create);
        }
    }
}
class ErrorFactory {
    constructor(service, serviceName, errors) {
        this.service = service;
        this.serviceName = serviceName;
        this.errors = errors;
    }
    create(code, ...data) {
        const customData = data[0] || {};
        const fullCode = `${this.service}/${code}`;
        const template = this.errors[code];
        const message = template ? replaceTemplate(template, customData) : 'Error';
        // Service Name: Error message (service/code).
        const fullMessage = `${this.serviceName}: ${message} (${fullCode}).`;
        const error = new FirebaseError(fullCode, fullMessage, customData);
        return error;
    }
}
function replaceTemplate(template, data) {
    return template.replace(PATTERN, (_, key) => {
        const value = data[key];
        return value != null ? String(value) : `<${key}?>`;
    });
}
const PATTERN = /\{\$([^}]+)}/g;

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Evaluates a JSON string into a javascript object.
 *
 * @param {string} str A string containing JSON.
 * @return {*} The javascript object representing the specified JSON.
 */
function jsonEval(str) {
    return JSON.parse(str);
}
/**
 * Returns JSON representing a javascript object.
 * @param {*} data Javascript object to be stringified.
 * @return {string} The JSON contents of the object.
 */
function stringify(data) {
    return JSON.stringify(data);
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Decodes a Firebase auth. token into constituent parts.
 *
 * Notes:
 * - May return with invalid / incomplete claims if there's no native base64 decoding support.
 * - Doesn't check if the token is actually valid.
 */
const decode = function (token) {
    let header = {}, claims = {}, data = {}, signature = '';
    try {
        const parts = token.split('.');
        header = jsonEval(base64Decode(parts[0]) || '');
        claims = jsonEval(base64Decode(parts[1]) || '');
        signature = parts[2];
        data = claims['d'] || {};
        delete claims['d'];
    }
    catch (e) { }
    return {
        header,
        claims,
        data,
        signature
    };
};
/**
 * Decodes a Firebase auth. token and checks the validity of its time-based claims. Will return true if the
 * token is within the time window authorized by the 'nbf' (not-before) and 'iat' (issued-at) claims.
 *
 * Notes:
 * - May return a false negative if there's no native base64 decoding support.
 * - Doesn't check if the token is actually valid.
 */
const isValidTimestamp = function (token) {
    const claims = decode(token).claims;
    const now = Math.floor(new Date().getTime() / 1000);
    let validSince = 0, validUntil = 0;
    if (typeof claims === 'object') {
        if (claims.hasOwnProperty('nbf')) {
            validSince = claims['nbf'];
        }
        else if (claims.hasOwnProperty('iat')) {
            validSince = claims['iat'];
        }
        if (claims.hasOwnProperty('exp')) {
            validUntil = claims['exp'];
        }
        else {
            // token will expire after 24h by default
            validUntil = validSince + 86400;
        }
    }
    return (!!now &&
        !!validSince &&
        !!validUntil &&
        now >= validSince &&
        now <= validUntil);
};
/**
 * Decodes a Firebase auth. token and returns its issued at time if valid, null otherwise.
 *
 * Notes:
 * - May return null if there's no native base64 decoding support.
 * - Doesn't check if the token is actually valid.
 */
const issuedAtTime = function (token) {
    const claims = decode(token).claims;
    if (typeof claims === 'object' && claims.hasOwnProperty('iat')) {
        return claims['iat'];
    }
    return null;
};
/**
 * Decodes a Firebase auth. token and checks the validity of its format. Expects a valid issued-at time.
 *
 * Notes:
 * - May return a false negative if there's no native base64 decoding support.
 * - Doesn't check if the token is actually valid.
 */
const isValidFormat = function (token) {
    const decoded = decode(token), claims = decoded.claims;
    return !!claims && typeof claims === 'object' && claims.hasOwnProperty('iat');
};
/**
 * Attempts to peer into an auth token and determine if it's an admin auth token by looking at the claims portion.
 *
 * Notes:
 * - May return a false negative if there's no native base64 decoding support.
 * - Doesn't check if the token is actually valid.
 */
const isAdmin = function (token) {
    const claims = decode(token).claims;
    return typeof claims === 'object' && claims['admin'] === true;
};

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function contains(obj, key) {
    return Object.prototype.hasOwnProperty.call(obj, key);
}
function safeGet(obj, key) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
        return obj[key];
    }
    else {
        return undefined;
    }
}
function isEmpty(obj) {
    for (const key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
            return false;
        }
    }
    return true;
}
function map(obj, fn, contextObj) {
    const res = {};
    for (const key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
            res[key] = fn.call(contextObj, obj[key], key, obj);
        }
    }
    return res;
}
/**
 * Deep equal two objects. Support Arrays and Objects.
 */
function deepEqual(a, b) {
    if (a === b) {
        return true;
    }
    const aKeys = Object.keys(a);
    const bKeys = Object.keys(b);
    for (const k of aKeys) {
        if (!bKeys.includes(k)) {
            return false;
        }
        const aProp = a[k];
        const bProp = b[k];
        if (isObject(aProp) && isObject(bProp)) {
            if (!deepEqual(aProp, bProp)) {
                return false;
            }
        }
        else if (aProp !== bProp) {
            return false;
        }
    }
    for (const k of bKeys) {
        if (!aKeys.includes(k)) {
            return false;
        }
    }
    return true;
}
function isObject(thing) {
    return thing !== null && typeof thing === 'object';
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Returns a querystring-formatted string (e.g. &arg=val&arg2=val2) from a
 * params object (e.g. {arg: 'val', arg2: 'val2'})
 * Note: You must prepend it with ? when adding it to a URL.
 */
function querystring(querystringParams) {
    const params = [];
    for (const [key, value] of Object.entries(querystringParams)) {
        if (Array.isArray(value)) {
            value.forEach(arrayVal => {
                params.push(encodeURIComponent(key) + '=' + encodeURIComponent(arrayVal));
            });
        }
        else {
            params.push(encodeURIComponent(key) + '=' + encodeURIComponent(value));
        }
    }
    return params.length ? '&' + params.join('&') : '';
}
/**
 * Decodes a querystring (e.g. ?arg=val&arg2=val2) into a params object
 * (e.g. {arg: 'val', arg2: 'val2'})
 */
function querystringDecode(querystring) {
    const obj = {};
    const tokens = querystring.replace(/^\?/, '').split('&');
    tokens.forEach(token => {
        if (token) {
            const [key, value] = token.split('=');
            obj[decodeURIComponent(key)] = decodeURIComponent(value);
        }
    });
    return obj;
}
/**
 * Extract the query string part of a URL, including the leading question mark (if present).
 */
function extractQuerystring(url) {
    const queryStart = url.indexOf('?');
    if (!queryStart) {
        return '';
    }
    const fragmentStart = url.indexOf('#', queryStart);
    return url.substring(queryStart, fragmentStart > 0 ? fragmentStart : undefined);
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @fileoverview SHA-1 cryptographic hash.
 * Variable names follow the notation in FIPS PUB 180-3:
 * http://csrc.nist.gov/publications/fips/fips180-3/fips180-3_final.pdf.
 *
 * Usage:
 *   var sha1 = new sha1();
 *   sha1.update(bytes);
 *   var hash = sha1.digest();
 *
 * Performance:
 *   Chrome 23:   ~400 Mbit/s
 *   Firefox 16:  ~250 Mbit/s
 *
 */
/**
 * SHA-1 cryptographic hash constructor.
 *
 * The properties declared here are discussed in the above algorithm document.
 * @constructor
 * @final
 * @struct
 */
class Sha1 {
    constructor() {
        /**
         * Holds the previous values of accumulated variables a-e in the compress_
         * function.
         * @private
         */
        this.chain_ = [];
        /**
         * A buffer holding the partially computed hash result.
         * @private
         */
        this.buf_ = [];
        /**
         * An array of 80 bytes, each a part of the message to be hashed.  Referred to
         * as the message schedule in the docs.
         * @private
         */
        this.W_ = [];
        /**
         * Contains data needed to pad messages less than 64 bytes.
         * @private
         */
        this.pad_ = [];
        /**
         * @private {number}
         */
        this.inbuf_ = 0;
        /**
         * @private {number}
         */
        this.total_ = 0;
        this.blockSize = 512 / 8;
        this.pad_[0] = 128;
        for (let i = 1; i < this.blockSize; ++i) {
            this.pad_[i] = 0;
        }
        this.reset();
    }
    reset() {
        this.chain_[0] = 0x67452301;
        this.chain_[1] = 0xefcdab89;
        this.chain_[2] = 0x98badcfe;
        this.chain_[3] = 0x10325476;
        this.chain_[4] = 0xc3d2e1f0;
        this.inbuf_ = 0;
        this.total_ = 0;
    }
    /**
     * Internal compress helper function.
     * @param buf Block to compress.
     * @param offset Offset of the block in the buffer.
     * @private
     */
    compress_(buf, offset) {
        if (!offset) {
            offset = 0;
        }
        const W = this.W_;
        // get 16 big endian words
        if (typeof buf === 'string') {
            for (let i = 0; i < 16; i++) {
                // TODO(user): [bug 8140122] Recent versions of Safari for Mac OS and iOS
                // have a bug that turns the post-increment ++ operator into pre-increment
                // during JIT compilation.  We have code that depends heavily on SHA-1 for
                // correctness and which is affected by this bug, so I've removed all uses
                // of post-increment ++ in which the result value is used.  We can revert
                // this change once the Safari bug
                // (https://bugs.webkit.org/show_bug.cgi?id=109036) has been fixed and
                // most clients have been updated.
                W[i] =
                    (buf.charCodeAt(offset) << 24) |
                        (buf.charCodeAt(offset + 1) << 16) |
                        (buf.charCodeAt(offset + 2) << 8) |
                        buf.charCodeAt(offset + 3);
                offset += 4;
            }
        }
        else {
            for (let i = 0; i < 16; i++) {
                W[i] =
                    (buf[offset] << 24) |
                        (buf[offset + 1] << 16) |
                        (buf[offset + 2] << 8) |
                        buf[offset + 3];
                offset += 4;
            }
        }
        // expand to 80 words
        for (let i = 16; i < 80; i++) {
            const t = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16];
            W[i] = ((t << 1) | (t >>> 31)) & 0xffffffff;
        }
        let a = this.chain_[0];
        let b = this.chain_[1];
        let c = this.chain_[2];
        let d = this.chain_[3];
        let e = this.chain_[4];
        let f, k;
        // TODO(user): Try to unroll this loop to speed up the computation.
        for (let i = 0; i < 80; i++) {
            if (i < 40) {
                if (i < 20) {
                    f = d ^ (b & (c ^ d));
                    k = 0x5a827999;
                }
                else {
                    f = b ^ c ^ d;
                    k = 0x6ed9eba1;
                }
            }
            else {
                if (i < 60) {
                    f = (b & c) | (d & (b | c));
                    k = 0x8f1bbcdc;
                }
                else {
                    f = b ^ c ^ d;
                    k = 0xca62c1d6;
                }
            }
            const t = (((a << 5) | (a >>> 27)) + f + e + k + W[i]) & 0xffffffff;
            e = d;
            d = c;
            c = ((b << 30) | (b >>> 2)) & 0xffffffff;
            b = a;
            a = t;
        }
        this.chain_[0] = (this.chain_[0] + a) & 0xffffffff;
        this.chain_[1] = (this.chain_[1] + b) & 0xffffffff;
        this.chain_[2] = (this.chain_[2] + c) & 0xffffffff;
        this.chain_[3] = (this.chain_[3] + d) & 0xffffffff;
        this.chain_[4] = (this.chain_[4] + e) & 0xffffffff;
    }
    update(bytes, length) {
        // TODO(johnlenz): tighten the function signature and remove this check
        if (bytes == null) {
            return;
        }
        if (length === undefined) {
            length = bytes.length;
        }
        const lengthMinusBlock = length - this.blockSize;
        let n = 0;
        // Using local instead of member variables gives ~5% speedup on Firefox 16.
        const buf = this.buf_;
        let inbuf = this.inbuf_;
        // The outer while loop should execute at most twice.
        while (n < length) {
            // When we have no data in the block to top up, we can directly process the
            // input buffer (assuming it contains sufficient data). This gives ~25%
            // speedup on Chrome 23 and ~15% speedup on Firefox 16, but requires that
            // the data is provided in large chunks (or in multiples of 64 bytes).
            if (inbuf === 0) {
                while (n <= lengthMinusBlock) {
                    this.compress_(bytes, n);
                    n += this.blockSize;
                }
            }
            if (typeof bytes === 'string') {
                while (n < length) {
                    buf[inbuf] = bytes.charCodeAt(n);
                    ++inbuf;
                    ++n;
                    if (inbuf === this.blockSize) {
                        this.compress_(buf);
                        inbuf = 0;
                        // Jump to the outer loop so we use the full-block optimization.
                        break;
                    }
                }
            }
            else {
                while (n < length) {
                    buf[inbuf] = bytes[n];
                    ++inbuf;
                    ++n;
                    if (inbuf === this.blockSize) {
                        this.compress_(buf);
                        inbuf = 0;
                        // Jump to the outer loop so we use the full-block optimization.
                        break;
                    }
                }
            }
        }
        this.inbuf_ = inbuf;
        this.total_ += length;
    }
    /** @override */
    digest() {
        const digest = [];
        let totalBits = this.total_ * 8;
        // Add pad 0x80 0x00*.
        if (this.inbuf_ < 56) {
            this.update(this.pad_, 56 - this.inbuf_);
        }
        else {
            this.update(this.pad_, this.blockSize - (this.inbuf_ - 56));
        }
        // Add # bits.
        for (let i = this.blockSize - 1; i >= 56; i--) {
            this.buf_[i] = totalBits & 255;
            totalBits /= 256; // Don't use bit-shifting here!
        }
        this.compress_(this.buf_);
        let n = 0;
        for (let i = 0; i < 5; i++) {
            for (let j = 24; j >= 0; j -= 8) {
                digest[n] = (this.chain_[i] >> j) & 255;
                ++n;
            }
        }
        return digest;
    }
}

/**
 * Helper to make a Subscribe function (just like Promise helps make a
 * Thenable).
 *
 * @param executor Function which can make calls to a single Observer
 *     as a proxy.
 * @param onNoObservers Callback when count of Observers goes to zero.
 */
function createSubscribe(executor, onNoObservers) {
    const proxy = new ObserverProxy(executor, onNoObservers);
    return proxy.subscribe.bind(proxy);
}
/**
 * Implement fan-out for any number of Observers attached via a subscribe
 * function.
 */
class ObserverProxy {
    /**
     * @param executor Function which can make calls to a single Observer
     *     as a proxy.
     * @param onNoObservers Callback when count of Observers goes to zero.
     */
    constructor(executor, onNoObservers) {
        this.observers = [];
        this.unsubscribes = [];
        this.observerCount = 0;
        // Micro-task scheduling by calling task.then().
        this.task = Promise.resolve();
        this.finalized = false;
        this.onNoObservers = onNoObservers;
        // Call the executor asynchronously so subscribers that are called
        // synchronously after the creation of the subscribe function
        // can still receive the very first value generated in the executor.
        this.task
            .then(() => {
            executor(this);
        })
            .catch(e => {
            this.error(e);
        });
    }
    next(value) {
        this.forEachObserver((observer) => {
            observer.next(value);
        });
    }
    error(error) {
        this.forEachObserver((observer) => {
            observer.error(error);
        });
        this.close(error);
    }
    complete() {
        this.forEachObserver((observer) => {
            observer.complete();
        });
        this.close();
    }
    /**
     * Subscribe function that can be used to add an Observer to the fan-out list.
     *
     * - We require that no event is sent to a subscriber sychronously to their
     *   call to subscribe().
     */
    subscribe(nextOrObserver, error, complete) {
        let observer;
        if (nextOrObserver === undefined &&
            error === undefined &&
            complete === undefined) {
            throw new Error('Missing Observer.');
        }
        // Assemble an Observer object when passed as callback functions.
        if (implementsAnyMethods(nextOrObserver, [
            'next',
            'error',
            'complete'
        ])) {
            observer = nextOrObserver;
        }
        else {
            observer = {
                next: nextOrObserver,
                error,
                complete
            };
        }
        if (observer.next === undefined) {
            observer.next = noop;
        }
        if (observer.error === undefined) {
            observer.error = noop;
        }
        if (observer.complete === undefined) {
            observer.complete = noop;
        }
        const unsub = this.unsubscribeOne.bind(this, this.observers.length);
        // Attempt to subscribe to a terminated Observable - we
        // just respond to the Observer with the final error or complete
        // event.
        if (this.finalized) {
            // eslint-disable-next-line @typescript-eslint/no-floating-promises
            this.task.then(() => {
                try {
                    if (this.finalError) {
                        observer.error(this.finalError);
                    }
                    else {
                        observer.complete();
                    }
                }
                catch (e) {
                    // nothing
                }
                return;
            });
        }
        this.observers.push(observer);
        return unsub;
    }
    // Unsubscribe is synchronous - we guarantee that no events are sent to
    // any unsubscribed Observer.
    unsubscribeOne(i) {
        if (this.observers === undefined || this.observers[i] === undefined) {
            return;
        }
        delete this.observers[i];
        this.observerCount -= 1;
        if (this.observerCount === 0 && this.onNoObservers !== undefined) {
            this.onNoObservers(this);
        }
    }
    forEachObserver(fn) {
        if (this.finalized) {
            // Already closed by previous event....just eat the additional values.
            return;
        }
        // Since sendOne calls asynchronously - there is no chance that
        // this.observers will become undefined.
        for (let i = 0; i < this.observers.length; i++) {
            this.sendOne(i, fn);
        }
    }
    // Call the Observer via one of it's callback function. We are careful to
    // confirm that the observe has not been unsubscribed since this asynchronous
    // function had been queued.
    sendOne(i, fn) {
        // Execute the callback asynchronously
        // eslint-disable-next-line @typescript-eslint/no-floating-promises
        this.task.then(() => {
            if (this.observers !== undefined && this.observers[i] !== undefined) {
                try {
                    fn(this.observers[i]);
                }
                catch (e) {
                    // Ignore exceptions raised in Observers or missing methods of an
                    // Observer.
                    // Log error to console. b/31404806
                    if (typeof console !== 'undefined' && console.error) {
                        console.error(e);
                    }
                }
            }
        });
    }
    close(err) {
        if (this.finalized) {
            return;
        }
        this.finalized = true;
        if (err !== undefined) {
            this.finalError = err;
        }
        // Proxy is no longer needed - garbage collect references
        // eslint-disable-next-line @typescript-eslint/no-floating-promises
        this.task.then(() => {
            this.observers = undefined;
            this.onNoObservers = undefined;
        });
    }
}
/** Turn synchronous function into one called asynchronously. */
// eslint-disable-next-line @typescript-eslint/ban-types
function async(fn, onError) {
    return (...args) => {
        Promise.resolve(true)
            .then(() => {
            fn(...args);
        })
            .catch((error) => {
            if (onError) {
                onError(error);
            }
        });
    };
}
/**
 * Return true if the object passed in implements any of the named methods.
 */
function implementsAnyMethods(obj, methods) {
    if (typeof obj !== 'object' || obj === null) {
        return false;
    }
    for (const method of methods) {
        if (method in obj && typeof obj[method] === 'function') {
            return true;
        }
    }
    return false;
}
function noop() {
    // do nothing
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Check to make sure the appropriate number of arguments are provided for a public function.
 * Throws an error if it fails.
 *
 * @param fnName The function name
 * @param minCount The minimum number of arguments to allow for the function call
 * @param maxCount The maximum number of argument to allow for the function call
 * @param argCount The actual number of arguments provided.
 */
const validateArgCount = function (fnName, minCount, maxCount, argCount) {
    let argError;
    if (argCount < minCount) {
        argError = 'at least ' + minCount;
    }
    else if (argCount > maxCount) {
        argError = maxCount === 0 ? 'none' : 'no more than ' + maxCount;
    }
    if (argError) {
        const error = fnName +
            ' failed: Was called with ' +
            argCount +
            (argCount === 1 ? ' argument.' : ' arguments.') +
            ' Expects ' +
            argError +
            '.';
        throw new Error(error);
    }
};
/**
 * Generates a string to prefix an error message about failed argument validation
 *
 * @param fnName The function name
 * @param argName The name of the argument
 * @return The prefix to add to the error thrown for validation.
 */
function errorPrefix(fnName, argName) {
    return `${fnName} failed: ${argName} argument `;
}
/**
 * @param fnName
 * @param argumentNumber
 * @param namespace
 * @param optional
 */
function validateNamespace(fnName, namespace, optional) {
    if (optional && !namespace) {
        return;
    }
    if (typeof namespace !== 'string') {
        //TODO: I should do more validation here. We only allow certain chars in namespaces.
        throw new Error(errorPrefix(fnName, 'namespace') + 'must be a valid firebase namespace.');
    }
}
function validateCallback(fnName, argumentName, 
// eslint-disable-next-line @typescript-eslint/ban-types
callback, optional) {
    if (optional && !callback) {
        return;
    }
    if (typeof callback !== 'function') {
        throw new Error(errorPrefix(fnName, argumentName) + 'must be a valid function.');
    }
}
function validateContextObject(fnName, argumentName, context, optional) {
    if (optional && !context) {
        return;
    }
    if (typeof context !== 'object' || context === null) {
        throw new Error(errorPrefix(fnName, argumentName) + 'must be a valid context object.');
    }
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Code originally came from goog.crypt.stringToUtf8ByteArray, but for some reason they
// automatically replaced '\r\n' with '\n', and they didn't handle surrogate pairs,
// so it's been modified.
// Note that not all Unicode characters appear as single characters in JavaScript strings.
// fromCharCode returns the UTF-16 encoding of a character - so some Unicode characters
// use 2 characters in Javascript.  All 4-byte UTF-8 characters begin with a first
// character in the range 0xD800 - 0xDBFF (the first character of a so-called surrogate
// pair).
// See http://www.ecma-international.org/ecma-262/5.1/#sec-15.1.3
/**
 * @param {string} str
 * @return {Array}
 */
const stringToByteArray = function (str) {
    const out = [];
    let p = 0;
    for (let i = 0; i < str.length; i++) {
        let c = str.charCodeAt(i);
        // Is this the lead surrogate in a surrogate pair?
        if (c >= 0xd800 && c <= 0xdbff) {
            const high = c - 0xd800; // the high 10 bits.
            i++;
            assert(i < str.length, 'Surrogate pair missing trail surrogate.');
            const low = str.charCodeAt(i) - 0xdc00; // the low 10 bits.
            c = 0x10000 + (high << 10) + low;
        }
        if (c < 128) {
            out[p++] = c;
        }
        else if (c < 2048) {
            out[p++] = (c >> 6) | 192;
            out[p++] = (c & 63) | 128;
        }
        else if (c < 65536) {
            out[p++] = (c >> 12) | 224;
            out[p++] = ((c >> 6) & 63) | 128;
            out[p++] = (c & 63) | 128;
        }
        else {
            out[p++] = (c >> 18) | 240;
            out[p++] = ((c >> 12) & 63) | 128;
            out[p++] = ((c >> 6) & 63) | 128;
            out[p++] = (c & 63) | 128;
        }
    }
    return out;
};
/**
 * Calculate length without actually converting; useful for doing cheaper validation.
 * @param {string} str
 * @return {number}
 */
const stringLength = function (str) {
    let p = 0;
    for (let i = 0; i < str.length; i++) {
        const c = str.charCodeAt(i);
        if (c < 128) {
            p++;
        }
        else if (c < 2048) {
            p += 2;
        }
        else if (c >= 0xd800 && c <= 0xdbff) {
            // Lead surrogate of a surrogate pair.  The pair together will take 4 bytes to represent.
            p += 4;
            i++; // skip trail surrogate.
        }
        else {
            p += 3;
        }
    }
    return p;
};

/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * The amount of milliseconds to exponentially increase.
 */
const DEFAULT_INTERVAL_MILLIS = 1000;
/**
 * The factor to backoff by.
 * Should be a number greater than 1.
 */
const DEFAULT_BACKOFF_FACTOR = 2;
/**
 * The maximum milliseconds to increase to.
 *
 * <p>Visible for testing
 */
const MAX_VALUE_MILLIS = 4 * 60 * 60 * 1000; // Four hours, like iOS and Android.
/**
 * The percentage of backoff time to randomize by.
 * See
 * http://go/safe-client-behavior#step-1-determine-the-appropriate-retry-interval-to-handle-spike-traffic
 * for context.
 *
 * <p>Visible for testing
 */
const RANDOM_FACTOR = 0.5;
/**
 * Based on the backoff method from
 * https://github.com/google/closure-library/blob/master/closure/goog/math/exponentialbackoff.js.
 * Extracted here so we don't need to pass metadata and a stateful ExponentialBackoff object around.
 */
function calculateBackoffMillis(backoffCount, intervalMillis = DEFAULT_INTERVAL_MILLIS, backoffFactor = DEFAULT_BACKOFF_FACTOR) {
    // Calculates an exponentially increasing value.
    // Deviation: calculates value from count and a constant interval, so we only need to save value
    // and count to restore state.
    const currBaseValue = intervalMillis * Math.pow(backoffFactor, backoffCount);
    // A random "fuzz" to avoid waves of retries.
    // Deviation: randomFactor is required.
    const randomWait = Math.round(
    // A fraction of the backoff value to add/subtract.
    // Deviation: changes multiplication order to improve readability.
    RANDOM_FACTOR *
        currBaseValue *
        // A random float (rounded to int by Math.round above) in the range [-1, 1]. Determines
        // if we add or subtract.
        (Math.random() - 0.5) *
        2);
    // Limits backoff to max to avoid effectively permanent backoff.
    return Math.min(MAX_VALUE_MILLIS, currBaseValue + randomWait);
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Provide English ordinal letters after a number
 */
function ordinal(i) {
    if (!Number.isFinite(i)) {
        return `${i}`;
    }
    return i + indicator(i);
}
function indicator(i) {
    i = Math.abs(i);
    const cent = i % 100;
    if (cent >= 10 && cent <= 20) {
        return 'th';
    }
    const dec = i % 10;
    if (dec === 1) {
        return 'st';
    }
    if (dec === 2) {
        return 'nd';
    }
    if (dec === 3) {
        return 'rd';
    }
    return 'th';
}

/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function getModularInstance(service) {
    if (service && service._delegate) {
        return service._delegate;
    }
    else {
        return service;
    }
}


//# sourceMappingURL=index.esm2017.js.map


/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./node_modules/sass-loader/dist/cjs.js!./src/sass/index.sass":
/*!**********************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./node_modules/sass-loader/dist/cjs.js!./src/sass/index.sass ***!
  \**********************************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/sourceMaps.js */ "./node_modules/css-loader/dist/runtime/sourceMaps.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/getUrl.js */ "./node_modules/css-loader/dist/runtime/getUrl.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2__);
// Imports



var ___CSS_LOADER_URL_IMPORT_0___ = new URL(/* asset import */ __webpack_require__(/*! ../assets/arrow.svg */ "./src/assets/arrow.svg"), __webpack_require__.b);
var ___CSS_LOADER_URL_IMPORT_1___ = new URL(/* asset import */ __webpack_require__(/*! ../assets/large-map.webp */ "./src/assets/large-map.webp"), __webpack_require__.b);
var ___CSS_LOADER_URL_IMPORT_2___ = new URL(/* asset import */ __webpack_require__(/*! ../assets/small-map.webp */ "./src/assets/small-map.webp"), __webpack_require__.b);
var ___CSS_LOADER_URL_IMPORT_3___ = new URL(/* asset import */ __webpack_require__(/*! ../assets/pink-overlay.webp */ "./src/assets/pink-overlay.webp"), __webpack_require__.b);
var ___CSS_LOADER_URL_IMPORT_4___ = new URL(/* asset import */ __webpack_require__(/*! ../assets/download.svg */ "./src/assets/download.svg"), __webpack_require__.b);
var ___CSS_LOADER_URL_IMPORT_5___ = new URL(/* asset import */ __webpack_require__(/*! ../assets/drawing-compass.svg */ "./src/assets/drawing-compass.svg"), __webpack_require__.b);
var ___CSS_LOADER_URL_IMPORT_6___ = new URL(/* asset import */ __webpack_require__(/*! ../assets/card-dribbble.svg */ "./src/assets/card-dribbble.svg"), __webpack_require__.b);
var ___CSS_LOADER_URL_IMPORT_7___ = new URL(/* asset import */ __webpack_require__(/*! ../assets/card-github.svg */ "./src/assets/card-github.svg"), __webpack_require__.b);
var ___CSS_LOADER_URL_IMPORT_8___ = new URL(/* asset import */ __webpack_require__(/*! ../assets/pigdice.svg */ "./src/assets/pigdice.svg"), __webpack_require__.b);
var ___CSS_LOADER_URL_IMPORT_9___ = new URL(/* asset import */ __webpack_require__(/*! ../assets/monster-slayer.svg */ "./src/assets/monster-slayer.svg"), __webpack_require__.b);
var ___CSS_LOADER_URL_IMPORT_10___ = new URL(/* asset import */ __webpack_require__(/*! ../assets/osc-geeks.svg */ "./src/assets/osc-geeks.svg"), __webpack_require__.b);
var ___CSS_LOADER_URL_IMPORT_11___ = new URL(/* asset import */ __webpack_require__(/*! ../assets/contact-theme-1.webp */ "./src/assets/contact-theme-1.webp"), __webpack_require__.b);
var ___CSS_LOADER_URL_IMPORT_12___ = new URL(/* asset import */ __webpack_require__(/*! ../assets/arrow-send.svg */ "./src/assets/arrow-send.svg"), __webpack_require__.b);
var ___CSS_LOADER_URL_IMPORT_13___ = new URL(/* asset import */ __webpack_require__(/*! ../assets/contact-theme-2.webp */ "./src/assets/contact-theme-2.webp"), __webpack_require__.b);
var ___CSS_LOADER_URL_IMPORT_14___ = new URL(/* asset import */ __webpack_require__(/*! ../assets/contact-theme-3.webp */ "./src/assets/contact-theme-3.webp"), __webpack_require__.b);
var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
___CSS_LOADER_EXPORT___.push([module.id, "@import url(https://fonts.googleapis.com/css2?family=Poppins:wght@100;300;500;600;800&display=swap);"]);
var ___CSS_LOADER_URL_REPLACEMENT_0___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_0___);
var ___CSS_LOADER_URL_REPLACEMENT_1___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_1___);
var ___CSS_LOADER_URL_REPLACEMENT_2___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_2___);
var ___CSS_LOADER_URL_REPLACEMENT_3___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_3___);
var ___CSS_LOADER_URL_REPLACEMENT_4___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_4___);
var ___CSS_LOADER_URL_REPLACEMENT_5___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_5___);
var ___CSS_LOADER_URL_REPLACEMENT_6___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_6___);
var ___CSS_LOADER_URL_REPLACEMENT_7___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_7___);
var ___CSS_LOADER_URL_REPLACEMENT_8___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_8___);
var ___CSS_LOADER_URL_REPLACEMENT_9___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_9___);
var ___CSS_LOADER_URL_REPLACEMENT_10___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_10___);
var ___CSS_LOADER_URL_REPLACEMENT_11___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_11___);
var ___CSS_LOADER_URL_REPLACEMENT_12___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_12___);
var ___CSS_LOADER_URL_REPLACEMENT_13___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_13___);
var ___CSS_LOADER_URL_REPLACEMENT_14___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_14___);
// Module
___CSS_LOADER_EXPORT___.push([module.id, "*, *::before, *::after {\n  margin: 0;\n  padding: 0;\n  -webkit-box-sizing: border-box;\n  box-sizing: border-box;\n  -webkit-tap-highlight-color: transparent;\n  -moz-user-select: -moz-none;\n  -khtml-user-select: none;\n  -webkit-user-select: none;\n  -ms-user-select: none;\n  user-select: none; }\n\n*::moz-focus-inner {\n  border: 0; }\n\nhtml,\nbody {\n  width: 100vw;\n  height: 100vh; }\n\nul {\n  list-style-type: none; }\n\n* {\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n  text-rendering: optimizeLegibility;\n  font-family: 'Poppins', sans-serif; }\n\nbody h1 {\n  font-size: 3.052rem; }\n\nbody h2 {\n  font-size: 2.441rem; }\n\nbody h3 {\n  font-size: 1.953rem; }\n\nbody h4 {\n  font-size: 1.563rem; }\n\nbody h5 {\n  font-size: 1.25rem; }\n\nbody h6 {\n  font-size: 0.8rem; }\n\nbody .btn, body .btn-primary,\nbody .btn-secondary {\n  font-size: 0.85rem; }\n\nbody input[type=submit],\nbody input[type=text],\nbody input[type=email],\nbody textarea {\n  font-size: 0.8rem; }\n\nbody small, body label {\n  font-size: 0.8rem; }\n\nbody .tiny-small, body .work .cards-container .card footer .year, .work .cards-container .card footer body .year {\n  font-size: 0.6rem; }\n\np {\n  font-weight: 400; }\n\nh1, h2 {\n  line-height: 130%;\n  font-weight: 700; }\n\nh3 {\n  line-height: 130%;\n  font-weight: 400; }\n\nh4 {\n  line-height: 100%;\n  font-weight: 600; }\n\nh5 {\n  font-weight: 400;\n  line-height: 120%; }\n\nh6 {\n  font-weight: 500; }\n\nstrong {\n  font-weight: 800; }\n\n@media screen and (min-width: 1116px) {\n  html {\n    font-size: 125%; } }\n\n@media screen and (max-width: 1116px) {\n  html {\n    font-size: 115%; } }\n\n@media screen and (max-width: 950px) {\n  html {\n    font-size: 110%; } }\n\n@media screen and (max-width: 750px) {\n  html {\n    font-size: 105%; } }\n\n@media screen and (max-width: 475px) {\n  body * {\n    text-align: center; }\n  body h1 {\n    font-size: 2.2rem; }\n  body h2 {\n    font-size: 1.9rem; }\n  body h3 {\n    font-size: 1.728rem; }\n  body h4 {\n    font-size: 1.44rem; }\n  body h5 {\n    font-size: 1.2rem; }\n  body h6 {\n    font-size: 0.8rem; }\n  body .btn, body .btn-primary,\n  body .btn-secondary,\n  body input[type=submit],\n  body input[type=text],\n  body input[type=email],\n  body textarea {\n    font-size: 0.9rem; }\n  body small, body label {\n    font-size: 0.8rem; } }\n\n@media screen and (max-width: 360px) {\n  html {\n    font-size: 100%; } }\n\n.root, .dark {\n  --primary-pink: #F35E84;\n  --primary-purple: #6E82F9;\n  --primary-green: #9FFBCE;\n  --pink-purple-grd: linear-gradient(90deg, var(--primary-pink) 0%, #AF70C0 50%, var(--primary-purple) 100%);\n  --purple-green-grd: linear-gradient(90deg, var(--primary-purple) 0%, #22B9FF 50.31%, #A6FFD8 100%, var(--primary-green) 100%);\n  --btn-pink-purple-grd: linear-gradient(90deg, var(--primary-pink) 0%, var(--primary-pink) 50%, var(--primary-purple) 100%);\n  --btn-pink-purple-grd-border: linear-gradient(90deg, #FE3064 0, #FE3064 50%, #415CFF 100%);\n  --banner-border-grd: linear-gradient(90deg, #d1ffe8 0%, rgba(0,0,0, 0) 25%, rgba(0,0,0, 0) 75%, #862DF7 100%);\n  --contact-border-grd: linear-gradient(105.8deg, #d1ffe8 0%, rgba(0,0,0, 0) 25%, rgba(0,0,0, 0) 75%, #862DF7 100%);\n  --thumb-grd: linear-gradient(180deg, var(--primary-pink) 0%, var(--primary-purple) 100%);\n  --color-error: #DC3545;\n  --color-success: #28A745; }\n\n.dark {\n  --bg: #000;\n  --fg: #fff;\n  background-color: var(--bg);\n  color: var(--fg); }\n  .dark h1, .dark h2 {\n    background: var(--pink-purple-grd);\n    color: transparent;\n    background-clip: text;\n    -webkit-background-clip: text;\n    display: table-cell; }\n  .dark a {\n    color: var(--fg); }\n  .dark .btn, .dark .btn-primary,\n  .dark .btn-secondary {\n    color: var(--fg);\n    box-shadow: 0 1px 10px rgba(240, 95, 135, 0.5);\n    transition: background-position 0.3s, box-shadow 0.3s; }\n    .dark .btn::before, .dark .btn-primary::before,\n    .dark .btn-secondary::before {\n      content: '';\n      position: absolute;\n      top: 0;\n      bottom: 0;\n      left: 0;\n      right: 0;\n      border-radius: inherit;\n      padding: 2px;\n      background: var(--btn-pink-purple-grd-border);\n      background-size: 200% 100%;\n      background-position: right center;\n      -webkit-mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);\n      -webkit-mask-composite: xor;\n      mask-composite: exclude;\n      transition: inherit; }\n    .dark .btn:hover::before, .dark .btn-primary:hover::before,\n    .dark .btn-secondary:hover::before {\n      background-position: left center; }\n    .dark .btn:hover, .dark .btn-primary:hover,\n    .dark .btn-secondary:hover {\n      box-shadow: 0 1px 25px rgba(240, 95, 135, 0.5); }\n  .dark .btn-primary {\n    background-image: var(--btn-pink-purple-grd);\n    background-size: 200% auto;\n    background-position: 100% 50%; }\n    .dark .btn-primary .btn-icon {\n      transition: transform 0.3s; }\n    .dark .btn-primary:hover {\n      background-position: left center; }\n  .dark .btn-secondary {\n    background-color: var(--bg); }\n  .dark form {\n    background-color: #272727; }\n  .dark input[type=text], .dark input[type=email], .dark textarea {\n    background-color: #1F1F1F;\n    border-color: transparent;\n    transition: border-color 0.1s ease-out, background-color 0.2s ease-out;\n    color: #ffffff; }\n    .dark input[type=text]:hover, .dark input[type=email]:hover, .dark textarea:hover {\n      border-color: #606060 !important; }\n    .dark input[type=text]:focus, .dark input[type=email]:focus, .dark textarea:focus {\n      border-color: var(--primary-purple) !important;\n      background-color: #141414; }\n  .dark .error-msg {\n    color: var(--color-error); }\n  .dark .me .exp {\n    background-color: #1A1A1A; }\n    .dark .me .exp #years {\n      color: var(--primary-green); }\n  .dark .skills .duties .active-duty {\n    background-color: #1A1A1A; }\n  .dark .skills .tech-tools {\n    background-color: #1A1A1A; }\n  .dark label[importance='crucial']::after {\n    content: '*';\n    color: var(--color-error); }\n\n* {\n  scroll-behavior: smooth;\n  margin: 0;\n  padding: 0;\n  box-sizing: border-box; }\n\n*:not(textarea):focus {\n  outline: 2.5px dashed var(--primary-purple);\n  outline-offset: 5px; }\n\nbody::-webkit-scrollbar {\n  background-color: #000;\n  width: 0.55rem;\n  height: 0.55rem; }\n\nbody::-webkit-scrollbar-thumb {\n  border: 4px solid rgba(0, 0, 0, 0);\n  background-clip: padding-box;\n  border-radius: 10px;\n  background-color: #AAAAAA;\n  background-color: var(--primary-pink); }\n\n.container {\n  width: 90%;\n  max-width: 1600px;\n  margin: 0 auto; }\n\n.wide-banner, .landing .hobbies, .me .resume {\n  -webkit-backdrop-filter: blur(50px);\n  backdrop-filter: blur(50px);\n  width: 100vw;\n  position: relative; }\n  @supports not (backdrop-filter: none) {\n    .wide-banner, .landing .hobbies, .me .resume {\n      background-color: #141414; } }\n  .wide-banner::before, .landing .hobbies::before, .me .resume::before, .wide-banner::after, .landing .hobbies::after, .me .resume::after {\n    content: '';\n    position: absolute;\n    left: 0;\n    width: 100vw;\n    height: 1.5px;\n    background: var(--banner-border-grd); }\n  .wide-banner::before, .landing .hobbies::before, .me .resume::before {\n    top: 0; }\n  .wide-banner::after, .landing .hobbies::after, .me .resume::after {\n    bottom: 0; }\n\n.not-centered, .landing .hobbies .hobby, .work .cards-container, .contact {\n  text-align: left !important; }\n  .not-centered *, .landing .hobbies .hobby *, .work .cards-container *, .contact * {\n    text-align: left !important; }\n\na {\n  text-decoration: none;\n  display: inline-block; }\n\na, button {\n  cursor: pointer; }\n\n.btn, .btn-primary,\n.btn-secondary,\nbutton,\ninput[type=submit],\ninput[type=text],\ninput[type=email],\ntextarea {\n  border: none; }\n\ntextarea {\n  resize: none; }\n\ninput[type=text],\ninput[type=email],\ntextarea {\n  position: relative;\n  display: block;\n  width: 100%;\n  border-width: 2px;\n  border-style: solid;\n  border-radius: 10px;\n  padding: 0.5rem 0.7rem;\n  outline: none; }\n\ntextarea {\n  height: auto; }\n\n.btn, .btn-primary,\n.btn-secondary {\n  border-radius: 6px;\n  padding: 0.5rem 1.5rem;\n  position: relative;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  flex-direction: row;\n  grid-gap: 0.25rem;\n  flex-shrink: 0; }\n  .btn .btn-icon, .btn-primary .btn-icon, .btn-secondary .btn-icon {\n    width: 22px;\n    height: 22px;\n    background-repeat: no-repeat;\n    background-size: cover; }\n\n.btn-primary .btn-icon {\n  background-image: url(" + ___CSS_LOADER_URL_REPLACEMENT_0___ + "); }\n\n.btn-primary:hover .btn-icon {\n  transform: translateX(5px); }\n\n.btn-secondary {\n  flex-direction: row-reverse;\n  gap: 10px; }\n\n.header-btn {\n  padding: 0.35rem 1.5rem; }\n  .header-btn .btn-icon {\n    width: 15px;\n    height: 15px; }\n\nhtml {\n  width: 100%;\n  height: 100%;\n  height: -webkit-stretch; }\n\nbody {\n  position: relative;\n  overflow-x: hidden;\n  width: inherit;\n  height: inherit; }\n  body main {\n    width: inherit;\n    height: inherit; }\n\n.fix {\n  position: absolute; }\n\n.landing {\n  position: relative;\n  min-height: 100%;\n  display: grid;\n  grid-template-rows: auto 1fr auto; }\n  .landing > .container {\n    grid-row: 2/3;\n    align-self: center; }\n  .landing header {\n    grid-row: 1/2;\n    min-width: 100vw;\n    width: 100vw;\n    z-index: 3;\n    -webkit-backdrop-filter: blur(50px);\n    backdrop-filter: blur(50px);\n    border-bottom: 1px solid #fff; }\n    @supports not (backdrop-filter: none) {\n      .landing header {\n        background-color: #141414; } }\n    .landing header .container {\n      display: grid;\n      grid-template-columns: 1fr 3fr 1fr; }\n      .landing header .container .desktop-nav {\n        grid-column: 2/3;\n        display: flex;\n        justify-content: center;\n        align-items: center;\n        flex-direction: row;\n        grid-gap: 2rem; }\n        .landing header .container .desktop-nav .logo {\n          width: 70px;\n          height: 70px;\n          overflow: hidden; }\n          .landing header .container .desktop-nav .logo svg {\n            width: inherit;\n            height: inherit; }\n        .landing header .container .desktop-nav .desktop-links {\n          display: flex;\n          justify-content: inherit;\n          align-items: inherit;\n          flex-direction: inherit;\n          grid-gap: inherit; }\n          .landing header .container .desktop-nav .desktop-links .section-link a {\n            text-transform: uppercase;\n            font-size: 90%;\n            padding: 0.25rem 0.4rem;\n            border-radius: 5px;\n            transition: background-color 0.15s ease-in; }\n            .landing header .container .desktop-nav .desktop-links .section-link a:hover {\n              background-color: var(--primary-purple); }\n      .landing header .container .header-btn {\n        grid-column: 3/4;\n        justify-self: end;\n        align-self: center;\n        width: fit-content !important; }\n      .landing header .container .btn-ham {\n        z-index: 2;\n        width: 25px;\n        height: 25px; }\n        .landing header .container .btn-ham img {\n          width: inherit;\n          height: inherit; }\n      .landing header .container .mobile-nav {\n        position: absolute;\n        top: 50px;\n        left: 0;\n        width: 100vw;\n        height: calc(100vh - 50px);\n        background-color: var(--bg);\n        display: none; }\n        .landing header .container .mobile-nav ul {\n          padding: 3rem 1.5rem;\n          display: flex;\n          justify-content: center;\n          align-items: start;\n          flex-direction: column;\n          grid-gap: 0.3rem; }\n          .landing header .container .mobile-nav ul .ham-link {\n            font-size: 130%;\n            text-decoration: underline; }\n        .landing header .container .mobile-nav .ham-img {\n          position: absolute;\n          width: 130%;\n          height: auto;\n          transform: translate(-50%, 0);\n          left: 50%;\n          bottom: -12%;\n          display: none; }\n      .landing header .container .btn-ham, .landing header .container .mobile-nav {\n        display: none; }\n  .landing .sticky {\n    position: fixed;\n    top: 0;\n    width: 100%; }\n  .landing .hero {\n    padding: 2.5rem 0; }\n    .landing .hero .hero-text .hero-heading {\n      display: flex;\n      justify-content: center;\n      align-items: start;\n      flex-direction: column;\n      grid-gap: 0rem; }\n      .landing .hero .hero-text .hero-heading #qualities {\n        line-height: 1.2em;\n        height: 1.2em;\n        background: var(--purple-green-grd);\n        color: transparent;\n        background-clip: text;\n        -webkit-background-clip: text;\n        display: table-cell;\n        text-transform: uppercase; }\n        .landing .hero .hero-text .hero-heading #qualities .typed-cursor {\n          font-weight: 300;\n          animation: blink 1.5s steps(5, start) infinite; }\n\n@keyframes blink {\n  to {\n    visibility: hidden; } }\n    .landing .hero .ctas {\n      margin-top: 2rem;\n      display: flex;\n      justify-content: start;\n      align-items: center;\n      flex-direction: row;\n      grid-gap: 1rem; }\n      .landing .hero .ctas #btn-work .btn-icon {\n        display: none; }\n  .landing .hobbies {\n    grid-row: 3/4;\n    z-index: 2;\n    position: relative;\n    padding: 0.6rem 1rem;\n    overflow: hidden; }\n    .landing .hobbies .container {\n      display: flex;\n      justify-content: space-around;\n      align-items: center;\n      flex-direction: row;\n      grid-gap: 1.5rem; }\n    .landing .hobbies .hobby {\n      padding: 0.5rem 1rem;\n      pointer-events: none; }\n      .landing .hobbies .hobby a {\n        display: flex;\n        justify-content: start;\n        align-items: center;\n        flex-direction: row;\n        grid-gap: 0.5rem; }\n        .landing .hobbies .hobby a .name .hobby-u, .landing .hobbies .hobby a .name .hobby-l {\n          font-weight: 600; }\n        .landing .hobbies .hobby a .name .hobby-l {\n          margin-top: -0.3rem;\n          opacity: 0.6; }\n        .landing .hobbies .hobby a img {\n          width: 65px;\n          height: 65px; }\n    .landing .hobbies #developer .name {\n      position: relative; }\n      .landing .hobbies #developer .name #squiggly-line {\n        position: absolute;\n        top: 50%;\n        left: 50%;\n        transform: translate(-50%, -50%);\n        width: 100%;\n        top: 115%; }\n    .landing .hobbies #designer {\n      position: relative;\n      border: 2px solid #18A0FB; }\n      .landing .hobbies #designer .outline,\n      .landing .hobbies #designer .mini-sq {\n        position: absolute; }\n      .landing .hobbies #designer .mini-sq {\n        width: 14px;\n        height: 14px;\n        background-color: #fff;\n        border: 2px solid #18A0FB;\n        transform: translate(-50%, -50%); }\n      .landing .hobbies #designer #upper-left {\n        top: 0;\n        left: 0; }\n      .landing .hobbies #designer #upper-right {\n        top: 0;\n        left: 100%; }\n      .landing .hobbies #designer #lower-left {\n        top: 100%;\n        left: 0; }\n      .landing .hobbies #designer #lower-right {\n        top: 100%;\n        left: 100%; }\n\n@media screen and (max-width: 1400px) {\n  .landing .container .hero-image {\n    width: auto;\n    height: 65vh; } }\n\n@media screen and (max-width: 1116px) {\n  .landing .hobbies {\n    padding: 0.6rem;\n    grid-gap: 0.75rem; }\n    .landing .hobbies .hobby {\n      padding: 0.5rem;\n      grid-gap: 0.75rem; }\n      .landing .hobbies .hobby .img-hobby {\n        width: 60px;\n        height: 60px; } }\n\n@media screen and (max-width: 950px) {\n  .landing header .container {\n    grid-template-columns: 1fr auto; }\n    .landing header .container .desktop-nav {\n      grid-column: 1;\n      justify-content: start;\n      gap: 1rem; }\n      .landing header .container .desktop-nav .logo {\n        order: 1; }\n      .landing header .container .desktop-nav .desktop-links {\n        order: 2; }\n    .landing header .container .btn, .landing header .container .btn-primary,\n    .landing header .container .btn-secondary {\n      grid-column: 2; }\n  .landing .container .hero-image {\n    width: auto;\n    height: 40vh; } }\n\n@media screen and (max-width: 810px) {\n  .landing .container .hero .hero-text {\n    text-align: center; }\n    .landing .container .hero .hero-text .hero-heading {\n      align-items: center; }\n  .landing .container .hero .ctas {\n    justify-content: center; } }\n\n@media screen and (max-width: 750px) {\n  .landing .container {\n    justify-content: start; } }\n\n@media screen and (max-width: 650px) {\n  .landing header .container {\n    grid-template-columns: 1fr 2fr 1fr;\n    align-items: center; }\n    .landing header .container .desktop-nav {\n      grid-column: 2;\n      justify-self: center; }\n      .landing header .container .desktop-nav .logo {\n        width: 50px;\n        height: 50px; }\n      .landing header .container .desktop-nav .desktop-links {\n        display: none; }\n    .landing header .container .btn-ham, .landing header .container .mobile-nav {\n      display: none; }\n    .landing header .container .btn-ham {\n      display: block;\n      grid-column: 1;\n      grid-row: 1; }\n    .landing header .container .header-btn {\n      display: none; }\n  .landing .hero {\n    align-items: stretch; }\n    .landing .hero .hero-text .hero-heading {\n      align-items: center; }\n    .landing .hero .hero-text p {\n      margin-top: 0.25rem; }\n    .landing .hero .ctas {\n      grid-gap: 1rem; }\n  .landing .hobbies .hobby {\n    border-radius: 10px;\n    pointer-events: all;\n    cursor: pointer;\n    border: 2px solid rgba(255, 255, 255, 0); }\n    .landing .hobbies .hobby a {\n      width: 100%;\n      height: 100%;\n      outline: none; }\n      .landing .hobbies .hobby a .name {\n        display: none; }\n      .landing .hobbies .hobby a .img-hobby {\n        width: 55px;\n        height: 55px; }\n      .landing .hobbies .hobby a:focus .name {\n        display: block; }\n    .landing .hobbies .hobby:hover {\n      border-color: rgba(255, 255, 255, 0.2); }\n  .landing .hobbies #designer {\n    border-radius: 0 !important; }\n    .landing .hobbies #designer .mini-sq {\n      width: 10px;\n      height: 10px; } }\n\n.landing .decoration-card-grid {\n  position: absolute;\n  top: 0;\n  right: 0;\n  z-index: -1;\n  display: grid;\n  grid-template-rows: repeat(6, 1fr);\n  grid-template-columns: 300px 150px;\n  grid-gap: 20px;\n  height: 100%; }\n  .landing .decoration-card-grid .decoration-card {\n    background-color: #2d3436;\n    background-image: linear-gradient(315deg, #2d3436 0%, #191919 74%);\n    opacity: 0.5; }\n    .landing .decoration-card-grid .decoration-card:nth-child(1) {\n      grid-row: 1/4;\n      grid-column: 2;\n      border-radius: 0 0 0 20px; }\n    .landing .decoration-card-grid .decoration-card:nth-child(2) {\n      grid-row: 4/7;\n      grid-column: 2;\n      border-radius: 20px 0 0 0; }\n    .landing .decoration-card-grid .decoration-card:nth-child(3) {\n      grid-row: 1/2;\n      grid-column: 1;\n      border-radius: 0 0 20px 20px; }\n    .landing .decoration-card-grid .decoration-card:nth-child(4) {\n      grid-row: 2/5;\n      grid-column: 1;\n      border-radius: 20px;\n      padding: 1.5rem;\n      display: flex;\n      justify-content: space-between;\n      align-items: start;\n      flex-direction: column;\n      grid-gap: 0rem;\n      position: relative;\n      opacity: 1; }\n      .landing .decoration-card-grid .decoration-card:nth-child(4) svg {\n        width: 100%;\n        border-radius: 3.5px; }\n      .landing .decoration-card-grid .decoration-card:nth-child(4) .cursor {\n        position: absolute;\n        top: 85%;\n        left: 85%; }\n    .landing .decoration-card-grid .decoration-card:nth-child(5) {\n      grid-row: 5/7;\n      grid-column: 1;\n      border-radius: 20px 20px 0 0; }\n\n@media screen and (max-width: 1385px) {\n  .landing .decoration-card-grid {\n    grid-template-columns: 300px 100px; } }\n\n@media screen and (max-width: 1150px) {\n  .landing .decoration-card-grid {\n    grid-template-columns: 250px 0; }\n    .landing .decoration-card-grid .cursor {\n      width: 45px;\n      height: auto; } }\n\n@media screen and (max-width: 950px) {\n  .landing .decoration-card-grid {\n    transform: translateX(50%); }\n    .landing .decoration-card-grid .cursor {\n      display: none; } }\n\n@media screen and (max-width: 810px) {\n  .landing .decoration-card-grid {\n    opacity: 0.6; }\n    .landing .decoration-card-grid svg {\n      opacity: 0.2; } }\n\n@media screen and (min-height: 950px) {\n  .landing .decoration-card-grid .decoration-card:nth-child(4) {\n    justify-content: start;\n    gap: 2rem; }\n    .landing .decoration-card-grid .decoration-card:nth-child(4) #sample-paragraph {\n      flex-grow: 1; } }\n\n@media screen and (max-height: 750px) {\n  .landing .decoration-card-grid .decoration-card:nth-child(4) #sample-paragraph {\n    height: 100px; } }\n\n@media screen and (max-height: 450px) {\n  .landing .decoration-card-grid .decoration-card:nth-child(4) #sample-paragraph {\n    height: 80px; } }\n\n.me {\n  position: relative; }\n  .me .large-map {\n    position: absolute;\n    width: 100%;\n    height: 100%;\n    top: 0;\n    left: 0;\n    background-image: url(" + ___CSS_LOADER_URL_REPLACEMENT_1___ + ");\n    background-repeat: no-repeat;\n    background-size: cover;\n    z-index: -1;\n    opacity: 0.08; }\n  .me .core {\n    display: grid;\n    grid-template-rows: repeat(2, 1fr);\n    grid-template-columns: 0.6fr 2fr 1fr;\n    grid-gap: 1rem; }\n    .me .core article {\n      display: flex;\n      justify-content: start;\n      align-items: start;\n      flex-direction: column;\n      grid-gap: 0rem; }\n      .me .core article header {\n        display: flex;\n        justify-content: start;\n        align-items: center;\n        flex-direction: row;\n        grid-gap: 0.25rem;\n        margin-bottom: 0.25rem; }\n        .me .core article header small {\n          font-weight: 800; }\n    .me .core .exp {\n      padding: 1rem 0;\n      grid-row: 1/2;\n      grid-column: 1/2;\n      position: relative;\n      display: flex;\n      justify-content: center;\n      align-items: start;\n      flex-direction: column;\n      grid-gap: 0; }\n      .me .core .exp #background {\n        position: absolute;\n        background-color: inherit;\n        transform: translate(-100%, 0);\n        width: 1000%;\n        height: 100%;\n        left: 0%; }\n      .me .core .exp small {\n        line-height: 130%; }\n    .me .core .what {\n      grid-row: 2/3;\n      grid-column: 1/3; }\n    .me .core .small-screen-where {\n      display: none; }\n    .me .core .large-screen-where {\n      position: relative;\n      grid-row: 1/3;\n      grid-column: 3/4;\n      max-height: 350px;\n      display: flex;\n      justify-content: start;\n      align-items: stretch;\n      flex-direction: column;\n      grid-gap: 0rem; }\n      .me .core .large-screen-where .question {\n        position: absolute;\n        z-index: 1;\n        top: 10px;\n        left: 10px;\n        filter: drop-shadow(0 0 10px #3f3f3f); }\n      .me .core .large-screen-where .map {\n        flex-basis: 1;\n        flex-grow: 1;\n        position: relative;\n        overflow: hidden;\n        width: 100%; }\n        .me .core .large-screen-where .map .cairo-map, .me .core .large-screen-where .map .overlay {\n          width: 100%;\n          height: 100%;\n          background-repeat: no-repeat;\n          background-size: cover;\n          position: absolute;\n          top: 0;\n          left: 0; }\n        .me .core .large-screen-where .map .cairo-map {\n          background-image: url(" + ___CSS_LOADER_URL_REPLACEMENT_2___ + "); }\n        .me .core .large-screen-where .map .overlay {\n          background-image: url(" + ___CSS_LOADER_URL_REPLACEMENT_3___ + ");\n          opacity: 0.8; }\n        .me .core .large-screen-where .map h4 {\n          position: absolute;\n          z-index: 1;\n          color: var(--primary-green);\n          filter: drop-shadow(0 0 10px rgba(0, 0, 0, 0.2));\n          text-transform: uppercase;\n          font-weight: 800;\n          line-height: 120%;\n          bottom: 0.75rem;\n          left: 0.75rem; }\n  .me .resume {\n    -webkit-backdrop-filter: blur(7px);\n    backdrop-filter: blur(7px);\n    margin-top: 3rem;\n    padding: 1.5rem;\n    text-align: center;\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    flex-direction: row;\n    grid-gap: 1rem;\n    flex-wrap: wrap; }\n    @supports not (backdrop-filter: none) {\n      .me .resume {\n        background-color: #141414; } }\n    .me .resume #btnDownload .btn-icon {\n      background-image: url(" + ___CSS_LOADER_URL_REPLACEMENT_4___ + "); }\n\n@media screen and (max-width: 1116px) {\n  .me .core {\n    grid-template-rows: repeat(2, auto);\n    grid-template-columns: repeat(4, 1fr); }\n    .me .core .exp {\n      grid-row: 1/2;\n      grid-column: 1/2; }\n    .me .core .who {\n      grid-row: 1/2;\n      grid-column: 2/5; }\n    .me .core .large-screen-where {\n      grid-row: 2/4;\n      grid-column: 1/3; }\n    .me .core .what {\n      grid-row: 2/4;\n      grid-column: 3/5;\n      margin: auto 0; } }\n\n@media screen and (max-width: 750px) {\n  .me .core {\n    grid-template-rows: repeat(3, auto);\n    grid-template-columns: 1fr; }\n    .me .core .exp, .me .core .large-screen-where {\n      display: none; }\n    .me .core .who {\n      grid-row: 1/2;\n      grid-column: 1; }\n    .me .core .small-screen-where {\n      display: flex;\n      justify-content: start;\n      align-items: start;\n      flex-direction: column;\n      grid-gap: 0rem;\n      grid-row: 2/3;\n      grid-column: 1; }\n    .me .core .what {\n      grid-row: 3/4;\n      grid-column: 1; }\n  .me .large-map {\n    background-size: auto;\n    display: block; } }\n\n@media screen and (max-width: 650px) {\n  .me .core article .question {\n    position: relative;\n    --question-bars-width: 120%;\n    --question-bars-position: calc(-1 * var(--question-bars-width) - 15%); }\n    .me .core article .question::before, .me .core article .question::after {\n      content: ' ';\n      position: absolute;\n      height: 3px;\n      width: var(--question-bars-width);\n      background-color: #fff;\n      opacity: 1; }\n    .me .core article .question::before {\n      left: var(--question-bars-position); }\n    .me .core article .question::after {\n      right: var(--question-bars-position); } }\n\n@media screen and (max-width: 475px) {\n  .me .core article {\n    align-items: center !important; } }\n\n.skills .duties-container {\n  margin-top: 2rem; }\n\n.skills .duties {\n  display: grid;\n  grid-template-rows: 1fr;\n  grid-template-columns: repeat(4, auto);\n  justify-content: start; }\n  .skills .duties .duty {\n    padding: 1rem;\n    display: grid;\n    place-items: center;\n    border-radius: 10px;\n    transition: background-color 0.15s , transform 0.15s; }\n    .skills .duties .duty img {\n      width: 120px;\n      height: 120px;\n      transition: background-color 0.15s , transform 0.15s;\n      cursor: pointer;\n      border-radius: inherit;\n      -webkit-filter: brightness(0) invert(1);\n      filter: brightness(0) invert(1); }\n    .skills .duties .duty h6 {\n      font-weight: 600;\n      line-height: 100%;\n      opacity: 0;\n      text-align: center;\n      transition: opacity 0.2s; }\n  .skills .duties .active-duty {\n    transform: translateY(-1rem); }\n    .skills .duties .active-duty img {\n      background-color: transparent !important;\n      filter: brightness(1) invert(0); }\n    .skills .duties .active-duty .duty-name {\n      opacity: 1; }\n\n.skills .tech-tools {\n  width: 100%;\n  margin: 2rem 0 0 0;\n  padding: 2rem 0;\n  position: relative; }\n  .skills .tech-tools::before {\n    position: absolute;\n    content: \" \";\n    width: 100%;\n    height: 100%;\n    top: 0;\n    background-image: url(" + ___CSS_LOADER_URL_REPLACEMENT_5___ + ");\n    background-repeat: no-repeat;\n    background-size: 300px;\n    background-position: bottom -4.8rem right;\n    opacity: 0.4; }\n  .skills .tech-tools .container #inner-title {\n    font-weight: 800;\n    text-transform: uppercase;\n    margin-bottom: 1rem; }\n  .skills .tech-tools .container .icons {\n    margin-top: 1rem;\n    display: flex;\n    justify-content: start;\n    align-items: center;\n    flex-direction: row;\n    grid-gap: 0.75rem; }\n    .skills .tech-tools .container .icons li {\n      width: auto;\n      height: 40px; }\n      .skills .tech-tools .container .icons li img {\n        width: inherit;\n        height: inherit; }\n\n@media screen and (max-width: 1116px) {\n  .skills .tech-tools::before {\n    background-size: 400px;\n    background-position: top -0.5rem right;\n    opacity: 0.25; } }\n\n@media screen and (max-width: 950px) {\n  .skills .duties {\n    grid-gap: 0.25rem; }\n    .skills .duties .duty {\n      padding: 1rem 0.75rem; }\n      .skills .duties .duty img {\n        width: 110px;\n        height: 110px; }\n      .skills .duties .duty .duty-name {\n        display: none; }\n  .skills .duty-explained {\n    margin-top: 1rem; }\n    .skills .duty-explained #duty-name {\n      display: block;\n      font-weight: 600; }\n    .skills .duty-explained #duty-description {\n      margin-top: 0.3rem; }\n  .skills .tech-tools .container .icons li {\n    width: auto;\n    height: 35px; } }\n\n@media screen and (max-width: 750px) {\n  .skills .duties .duty img {\n    width: 80px;\n    height: 80px; }\n  .skills .tech-tools .container .icons li {\n    z-index: 1;\n    width: auto;\n    height: 30px; } }\n\n@media screen and (max-width: 650px) {\n  .skills .tech-tools:before {\n    display: none; }\n  .skills .tech-tools .container #inner-title br {\n    display: none; }\n  .skills .tech-tools .container .icons li {\n    width: auto;\n    height: 25px; } }\n\n@media screen and (max-width: 475px) {\n  .skills {\n    text-align: center; }\n    .skills .duties {\n      width: fit-content;\n      margin: 0 auto;\n      grid-template-rows: repeat(2, 1fr);\n      grid-template-columns: repeat(2, auto);\n      justify-content: center;\n      grid-gap: 0; }\n      .skills .duties .active-duty {\n        transform: translateY(0); }\n        .skills .duties .active-duty img {\n          transform: scale(1.15); }\n    .skills .tech-tools .container .icons {\n      display: grid;\n      grid-template-rows: repeat(2, auto);\n      grid-template-columns: repeat(5, auto);\n      width: fit-content;\n      margin: 0 auto; }\n      .skills .tech-tools .container .icons li {\n        width: auto;\n        height: 25px; } }\n\n.work {\n  --gap: 2rem; }\n  .work .cards-container {\n    display: flex;\n    justify-content: start;\n    align-items: center;\n    flex-direction: row;\n    grid-gap: var(--gap);\n    overflow-x: auto;\n    --overlaying-margin: 150px; }\n    .work .cards-container .card {\n      transition: transform .2s ease; }\n    .work .cards-container .card:not(:first-child) {\n      margin-left: calc(var(--overlaying-margin) * -1);\n      box-shadow: -1px 0px 48px rgba(0, 0, 0, 0.8); }\n    .work .cards-container .card:focus-within ~ .card, .work .cards-container .card:hover ~ .card {\n      transform: translateX(calc(var(--overlaying-margin) + 50px)); }\n    .work .cards-container .generic-card, .work .cards-container .card {\n      border-radius: 25px;\n      background-color: #191919;\n      border: 2px solid #3d3d3d;\n      position: relative; }\n    .work .cards-container .card {\n      width: 340px;\n      height: 380px;\n      display: flex;\n      justify-content: space-between;\n      align-items: start;\n      flex-direction: column;\n      grid-gap: 0rem;\n      overflow: hidden;\n      z-index: 2; }\n      .work .cards-container .card .card-bg {\n        position: absolute;\n        top: 0;\n        left: 0;\n        width: 100%;\n        height: 100%;\n        border-radius: inherit;\n        background-repeat: no-repeat;\n        background-size: 70%;\n        background-position: bottom -30% right -40%;\n        opacity: 0.2; }\n      .work .cards-container .card header {\n        width: 100%;\n        padding: 1rem 1rem 0;\n        display: flex;\n        justify-content: start;\n        align-items: start;\n        flex-direction: column;\n        grid-gap: 0.5rem; }\n        .work .cards-container .card header .card-title {\n          display: flex;\n          justify-content: start;\n          align-items: center;\n          flex-direction: row;\n          grid-gap: 0.5rem;\n          z-index: 3; }\n          .work .cards-container .card header .card-title .card-name {\n            font-weight: 800;\n            line-height: 120%;\n            background: var(--purple-green-grd);\n            color: transparent;\n            background-clip: text;\n            -webkit-background-clip: text;\n            display: table-cell; }\n          .work .cards-container .card header .card-title .arrow {\n            transition: transform .2s ease;\n            justify-self: start;\n            align-self: center;\n            width: 22px;\n            height: 22px; }\n          .work .cards-container .card header .card-title:hover {\n            filter: brightness(0.8); }\n        .work .cards-container .card header .work-done {\n          grid-row: 2;\n          grid-column: 1/3;\n          justify-self: start;\n          display: flex;\n          justify-content: start;\n          align-items: start;\n          flex-direction: row;\n          grid-gap: 0.5rem;\n          flex-grow: 1; }\n          .work .cards-container .card header .work-done img {\n            width: 30px;\n            height: auto; }\n      .work .cards-container .card footer {\n        position: relative;\n        display: grid;\n        grid-template-rows: repeat(2, auto);\n        grid-template-columns: 1fr auto;\n        grid-gap: 0.75rem 0;\n        padding: 1rem;\n        border-radius: inherit;\n        z-index: inherit; }\n        .work .cards-container .card footer .card-description {\n          grid-column: 1/3; }\n        .work .cards-container .card footer .year {\n          grid-row: 2/3;\n          grid-column: 2/3;\n          align-self: center;\n          background-color: var(--primary-green);\n          color: rgba(0, 0, 0, 0.7);\n          padding: 0.1rem 0.2rem;\n          border-radius: 5px; }\n        .work .cards-container .card footer .related-links {\n          grid-row: 2/3;\n          grid-column: 1/2;\n          display: flex;\n          justify-content: start;\n          align-items: center;\n          flex-direction: row;\n          grid-gap: 0.3rem; }\n          .work .cards-container .card footer .related-links a {\n            width: 27px;\n            height: 27px;\n            background-size: cover; }\n            @media (hover) {\n              .work .cards-container .card footer .related-links a:hover {\n                filter: brightness(0.8); } }\n            .work .cards-container .card footer .related-links a img {\n              width: inherit;\n              height: inherit; }\n            .work .cards-container .card footer .related-links a:nth-child(1) {\n              background-image: url(" + ___CSS_LOADER_URL_REPLACEMENT_6___ + "); }\n            .work .cards-container .card footer .related-links a:nth-child(2) {\n              background-image: url(" + ___CSS_LOADER_URL_REPLACEMENT_7___ + "); }\n      @media (hover) {\n        .work .cards-container .card header .work-done img {\n          filter: brightness(0) invert(1); }\n        .work .cards-container .card footer {\n          transform: translateY(34%);\n          transition: transform .2s ease .1s; }\n        .work .cards-container .card:hover .work-done img {\n          filter: brightness(1) invert(0); }\n        .work .cards-container .card:hover footer {\n          transform: translateY(0); } }\n    .work .cards-container #pig-dice .card-bg {\n      background-image: url(" + ___CSS_LOADER_URL_REPLACEMENT_8___ + "); }\n    .work .cards-container #monster-slayer .card-bg {\n      background-image: url(" + ___CSS_LOADER_URL_REPLACEMENT_9___ + "); }\n    .work .cards-container #monster-slayer .card-name {\n      width: min-content; }\n    .work .cards-container #osc-geeks .card-bg {\n      background-image: url(" + ___CSS_LOADER_URL_REPLACEMENT_10___ + "); }\n    .work .cards-container .dummy-card {\n      margin: 0 !important;\n      flex-grow: 1;\n      border: 2px dashed #3d3d3d;\n      border-radius: 25px;\n      align-self: stretch;\n      display: grid;\n      place-items: center; }\n      .work .cards-container .dummy-card img {\n        width: 100px;\n        height: auto;\n        opacity: 0.4; }\n  .work .tasks-explained {\n    margin-top: 1rem;\n    display: flex;\n    justify-content: start;\n    align-items: center;\n    flex-direction: row;\n    grid-gap: 15px;\n    flex-wrap: wrap; }\n    .work .tasks-explained .task {\n      display: flex;\n      justify-content: center;\n      align-items: center;\n      flex-direction: row;\n      grid-gap: 5px; }\n      .work .tasks-explained .task img {\n        width: 20px;\n        height: 20px; }\n\n@media screen and (max-width: 1116px) {\n  .work .cards-wrapper .cards-container .card {\n    width: 310px;\n    height: 350px; }\n  .work .cards-wrapper .cards-container .dummy-card {\n    display: none; } }\n\n@media screen and (max-width: 750px) {\n  .work .cards-wrapper .cards-container {\n    --overlaying-margin: 210px; }\n    .work .cards-wrapper .cards-container .card {\n      width: 330px;\n      height: 350px; } }\n\n@media screen and (max-width: 650px) {\n  .work .cards-wrapper {\n    width: 100%; }\n    .work .cards-wrapper .cards-container {\n      width: inherit;\n      display: grid;\n      grid-template-columns: repeat(3, auto);\n      scroll-snap-type: x mandatory;\n      scroll-behavior: smooth; }\n      .work .cards-wrapper .cards-container .card {\n        --overlaying-margin: 0;\n        box-shadow: none;\n        transition: none;\n        margin-left: 0;\n        width: 70vw;\n        margin: 0;\n        scroll-snap-align: center;\n        scroll-snap-stop: always; }\n        .work .cards-wrapper .cards-container .card .work-done img {\n          width: 25px;\n          height: 25px; }\n        .work .cards-wrapper .cards-container .card:first-of-type {\n          margin-left: var(--gap); }\n        .work .cards-wrapper .cards-container .card:last-of-type {\n          margin-right: var(--gap); } }\n\n@media screen and (max-width: 475px) {\n  .work {\n    --gap: 1rem; }\n    .work .cards-wrapper .cards-container .card {\n      width: 80vw; }\n    .work .tasks-explained {\n      justify-content: center; } }\n\n@media screen and (max-width: 360px) {\n  .work .cards-wrapper .cards-container .card {\n    height: 300px; } }\n\n.contact {\n  min-height: clamp(650px, 100%, 100%);\n  display: grid;\n  grid-template-rows: 2.5fr 1fr; }\n  .contact .contact-theme {\n    width: 100%;\n    height: 100%;\n    display: none; }\n  .contact .upper {\n    grid-row: 1/2;\n    background-color: #0F0F0F;\n    background-image: url(" + ___CSS_LOADER_URL_REPLACEMENT_11___ + ");\n    background-repeat: no-repeat;\n    background-size: clamp(600px, 50%, 50%) auto;\n    background-position: bottom left;\n    width: 100%;\n    margin: 0 auto;\n    max-width: 1600px; }\n    .contact .upper .container {\n      height: 100%;\n      display: flex;\n      justify-content: space-between;\n      align-items: center;\n      flex-direction: row;\n      grid-gap: 0rem; }\n      .contact .upper .container .title {\n        align-self: flex-end; }\n      .contact .upper .container form {\n        position: relative;\n        display: flex;\n        justify-content: stretch;\n        align-items: stretch;\n        flex-direction: column;\n        grid-gap: 0.5rem;\n        border-radius: 10px;\n        padding: 0.75rem;\n        width: 40%;\n        height: 85%;\n        min-width: 480px;\n        min-height: auto;\n        max-width: auto;\n        max-height: 470px;\n        position: relative; }\n        .contact .upper .container form .input-container {\n          display: grid;\n          grid-template-rows: auto 1fr;\n          grid-template-columns: auto 1fr;\n          grid-row-gap: 5px; }\n          .contact .upper .container form .input-container label {\n            grid-row: 1;\n            grid-column: 1;\n            justify-self: left;\n            margin: 0 0 0 5px; }\n          .contact .upper .container form .input-container .error-msg {\n            display: none;\n            grid-row: 1;\n            grid-column: 2;\n            justify-self: right;\n            align-self: end; }\n          .contact .upper .container form .input-container .text-box {\n            grid-row: 2;\n            grid-column: 1/3; }\n          .contact .upper .container form .input-container:nth-child(3) {\n            flex-grow: 1; }\n        .contact .upper .container form .invalid-input .error-msg {\n          display: inline-block; }\n        .contact .upper .container form .invalid-input .text-box {\n          border-color: var(--color-error); }\n        .contact .upper .container form .valid-input .error-msg {\n          display: none; }\n        .contact .upper .container form .valid-input .text-box {\n          border-color: var(--color-success); }\n        .contact .upper .container form .btn, .contact .upper .container form .btn-primary,\n        .contact .upper .container form .btn-secondary {\n          position: absolute;\n          border-radius: 999px;\n          padding: 0.75rem;\n          width: fit-content;\n          transform: translate(-50%, -50%);\n          top: 96%;\n          left: 96%;\n          z-index: 3; }\n          .contact .upper .container form .btn .btn-icon, .contact .upper .container form .btn-primary .btn-icon, .contact .upper .container form .btn-secondary .btn-icon {\n            width: 30px;\n            height: 30px;\n            background-image: url(" + ___CSS_LOADER_URL_REPLACEMENT_12___ + "); }\n        .contact .upper .container form .conf {\n          position: absolute;\n          width: 100%;\n          height: 100%;\n          background-color: inherit;\n          border-radius: inherit;\n          padding: 1.5rem;\n          top: 0;\n          left: 0;\n          color: var(--primary-green);\n          text-align: center;\n          display: flex;\n          justify-content: center;\n          align-items: start;\n          flex-direction: column;\n          grid-gap: 0.5rem;\n          display: none; }\n          .contact .upper .container form .conf img {\n            width: 5rem;\n            height: 5rem;\n            margin-bottom: 1rem; }\n          .contact .upper .container form .conf small {\n            opacity: 0.7; }\n      .contact .upper .container .show-conf .btn, .contact .upper .container .show-conf .btn-primary,\n      .contact .upper .container .show-conf .btn-secondary {\n        pointer-events: none; }\n      .contact .upper .container .show-conf .conf {\n        display: flex; }\n  .contact .lower {\n    grid-row: 2/3;\n    display: grid;\n    place-items: center; }\n    .contact .lower .container {\n      display: flex;\n      justify-content: space-between;\n      align-items: center;\n      flex-direction: row;\n      grid-gap: 0rem; }\n      .contact .lower .container .contact-info {\n        display: flex;\n        justify-content: start;\n        align-items: start;\n        flex-direction: row;\n        grid-gap: 3rem; }\n        .contact .lower .container .contact-info li {\n          align-items: center;\n          display: flex;\n          justify-content: start;\n          align-items: start;\n          flex-direction: column;\n          grid-gap: 0.6rem; }\n          .contact .lower .container .contact-info li img {\n            width: 40px;\n            height: 40px; }\n          .contact .lower .container .contact-info li small {\n            display: block; }\n        .contact .lower .container .contact-info #work-phone-number, .contact .lower .container .contact-info #work-email {\n          text-decoration: underline; }\n      .contact .lower .container .social {\n        display: flex;\n        justify-content: center;\n        align-items: center;\n        flex-direction: row-reverse;\n        grid-gap: 2rem; }\n        .contact .lower .container .social small::before {\n          content: '';\n          display: inline-block;\n          width: 20px;\n          height: 4px;\n          background: #fff;\n          margin: 0 0.5rem 3px 0; }\n        .contact .lower .container .social .platforms {\n          display: flex;\n          justify-content: start;\n          align-items: center;\n          flex-direction: row;\n          grid-gap: 0.4rem; }\n          .contact .lower .container .social .platforms li {\n            width: 33px;\n            height: 33px;\n            border-radius: 999px;\n            transition: transform 0.15s ease-out; }\n            .contact .lower .container .social .platforms li * {\n              width: inherit;\n              height: inherit;\n              border-radius: inherit; }\n            .contact .lower .container .social .platforms li:hover {\n              transform: scale(1.15) translateY(-2px); }\n\n@media screen and (max-width: 1116px) {\n  .contact .upper {\n    background-image: url(" + ___CSS_LOADER_URL_REPLACEMENT_13___ + ");\n    background-size: auto 95%;\n    background-position: bottom 60% left -10%; }\n    .contact .upper .container .title {\n      flex-direction: column;\n      align-items: flex-start; }\n    .contact .upper .container form {\n      width: 55%;\n      height: calc(100%, 2rem); }\n  .contact .lower .container {\n    align-items: flex-end; }\n    .contact .lower .container .contact-info {\n      gap: 0.75rem;\n      flex-direction: column; }\n      .contact .lower .container .contact-info li {\n        flex-direction: row;\n        align-items: center; }\n        .contact .lower .container .contact-info li img {\n          width: 35px;\n          height: 35px; }\n        .contact .lower .container .contact-info li br {\n          display: none; }\n    .contact .lower .container .social {\n      flex-direction: column;\n      align-items: flex-end;\n      gap: 0.6rem; } }\n\n@media screen and (max-width: 950px) {\n  .contact .upper .container {\n    padding-bottom: 1.5rem;\n    align-items: flex-end; }\n    .contact .upper .container form {\n      min-width: 380px; }\n    .contact .upper .container .title {\n      margin: 0; } }\n\n@media screen and (max-width: 650px) {\n  .contact {\n    grid-template-rows: 2.5fr 1fr;\n    grid-template-rows: 2fr 1fr; }\n    .contact .upper {\n      background-color: #272727;\n      background-color: #292929;\n      background-image: none; }\n      .contact .upper .container {\n        display: grid;\n        grid-template-rows: auto 1fr;\n        width: 100vw;\n        padding-bottom: 0; }\n        .contact .upper .container .contact-theme {\n          display: none;\n          grid-row: 1/2;\n          background-image: url(" + ___CSS_LOADER_URL_REPLACEMENT_14___ + ");\n          background-repeat: no-repeat;\n          background-size: auto 230%;\n          background-position: center center; }\n        .contact .upper .container .title {\n          grid-row: 2/3;\n          grid-row: 1/2;\n          flex-direction: row;\n          justify-content: center;\n          align-items: center;\n          margin: 0;\n          width: 100vw;\n          padding: 1.5rem 0 0.5rem; }\n        .contact .upper .container form {\n          grid-row: 3/4;\n          grid-row: 2/3;\n          min-width: auto;\n          position: relative;\n          width: 100%;\n          height: 100%; }\n          .contact .upper .container form #message {\n            grid-column: 1/3; }\n          .contact .upper .container form .btn, .contact .upper .container form .btn-primary,\n          .contact .upper .container form .btn-secondary {\n            top: 98%;\n            left: 50%; }\n          .contact .upper .container form .show-conf {\n            background-color: #292929; }\n    .contact .lower .container {\n      padding: 2rem 0 1rem 0;\n      flex-direction: column;\n      align-items: center;\n      gap: 2rem; }\n      .contact .lower .container .social small {\n        display: none; } }\n\n.skills p {\n  max-width: 60ch; }\n\nsection:not(.landing):not(.contact) {\n  margin-top: -70px;\n  padding-top: 140px; }\n\n.contact {\n  padding-top: 70px; }\n\nsection .title {\n  display: flex;\n  justify-content: start;\n  align-items: center;\n  grid-gap: 0.5rem;\n  margin-bottom: 1rem;\n  white-space: nowrap; }\n\n@media screen and (min-width: 1116px) {\n  .img-title {\n    width: 80px; } }\n\n@media screen and (max-width: 1116px) {\n  .img-title {\n    width: 70px; } }\n\n@media screen and (max-width: 750px) {\n  .img-title {\n    width: 65px; }\n  .me p, .skills p {\n    max-width: 100%; } }\n\n@media screen and (max-width: 650px) {\n  section:not(.landing):not(.contact) {\n    margin-top: -50px;\n    padding-top: 100px; }\n  .contact {\n    padding-top: 50px; } }\n\n@media screen and (max-width: 475px) {\n  .img-title {\n    width: 60px; }\n  .btn, .btn-primary,\n  .btn-secondary {\n    justify-content: center; }\n    .btn .btn-icon, .btn-primary .btn-icon, .btn-secondary .btn-icon {\n      width: 15px;\n      height: 15px; }\n  .title {\n    flex-wrap: wrap;\n    justify-content: center !important; }\n    .title h2 {\n      width: min-content; } }\n", "",{"version":3,"sources":["webpack://./src/sass/_normalize.sass","webpack://./src/sass/_mixins.sass","webpack://./src/sass/_typography.sass","webpack://./src/sass/_theming.sass","webpack://./src/sass/_generic.sass","webpack://./src/sass/index.sass","webpack://./src/sass/_landing.sass","webpack://./src/sass/_decorations.sass","webpack://./src/sass/_me.sass","webpack://./src/sass/_skills.sass","webpack://./src/sass/_work.sass","webpack://./src/sass/_contact.sass"],"names":[],"mappings":"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","sourcesContent":["//normalization\n*, *::before, *::after {\n    margin: 0;\n    padding: 0;\n\n    -webkit-box-sizing: border-box;\n    box-sizing: border-box;\n\n    //disable semi-blue highlight on mobile\n    -webkit-tap-highlight-color: transparent;\n    // outline: none\n\n    //disable user select\n    -moz-user-select: -moz-none;\n    -khtml-user-select: none;\n    -webkit-user-select: none;\n    -ms-user-select: none;\n    user-select: none; }\n\n*::moz-focus-inner {\n    border: 0; }\n\nhtml,\nbody {\n    @include size(100vw, 100vh); }\n\nul {\n    list-style-type: none; }\n","@mixin center-align {\n    * {\n        text-align: center; } }\n\n@mixin fill-grd($grd: var(--pink-purple-grd)) {\n    background: $grd;\n    color: transparent;\n    background-clip: text;\n    -webkit-background-clip: text;\n    display: table-cell; }\n\n@mixin btn-border-grd($grd: var(--btn-pink-purple-grd-border), $border-width: 2px) {\n    &::before {\n        content: '';\n        position: absolute;\n        top: 0;\n        bottom: 0;\n        left: 0;\n        right: 0;\n        border-radius: inherit;\n\n        padding: $border-width;\n        background: $grd;\n        background-size: 200% 100%;\n        background-position: right center;\n        -webkit-mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);\n        -webkit-mask-composite: xor;\n        mask-composite: exclude;\n\n        transition: inherit; }\n    &:hover::before {\n        background-position: left center; } }\n\n@mixin apply-cards-effect() {\n    --overlaying-margin: 150px;\n    .card {\n        transition: transform .2s ease; }\n    .card:not(:first-child) {\n        margin-left: calc(var(--overlaying-margin) * -1);\n        box-shadow: -1px 0px 48px rgba(0, 0, 0, 0.8); }\n    .card:focus-within~.card, .card:hover~.card {\n        transform: translateX(calc(var(--overlaying-margin) + 50px)); } }\n\n@mixin disable-cards-effect() { //resets all effects done above\n    --overlaying-margin: 0;\n    box-shadow: none;\n    transition: none;\n    margin-left: 0; }\n\n@mixin set-badge-styles($base-color: var(--primary-green)) {\n    @extend .tiny-small;\n    background-color: $base-color;\n    color: rgba(0, 0, 0, 0.8);\n    padding: 0.1rem 0.2rem;\n    border-radius: 5px; }\n\n@mixin backdrop-blur($blur: 50px) {\n    -webkit-backdrop-filter: blur($blur);\n    backdrop-filter: blur($blur);\n\n    @supports not (backdrop-filter: none) {\n        background-color: #141414; } }\n\n//Generic Mixins\n@mixin min-size($min-width, $min-height) {\n    min-width: $min-width;\n    min-height: $min-height; }\n\n@mixin max-size($max-width, $max-height) {\n    max-width: $max-width;\n    max-height: $max-height; }\n\n@mixin size($width, $height) {\n    width: $width;\n    height: $height; }\n\n@mixin absolute-center() {\n    position: absolute;\n    top: 50%;\n    left: 50%;\n    transform: translate(-50%, -50%); }\n\n@mixin grid-center() {\n    display: grid;\n    place-items: center; }\n\n@mixin flex($justify-centent: start, $align-items: start, $flex-direction: row, $grid-gap: 0rem) {\n    display: flex;\n    justify-content: $justify-centent;\n    align-items: $align-items;\n    flex-direction: $flex-direction;\n    grid-gap: $grid-gap; }\n\n@mixin absolute-cover() {\n    position: absolute;\n    top: 0;\n    left: 0;\n    @include size(100%, 100%); }\n\n//inverts the element to B&W, and back again to it's color when hovered\n\n@mixin darken-on-hover($darkness: 0.8) {\n    @media not (hover) {\n        &:hover {\n            filter: brightness($darkness); } } }\n\n$invert-filter: brightness(0) invert(1);\n@mixin color-on-hover($initial-filter: $invert-filter) {\n    @media not (hover) {\n        filter: $initial-filter;\n        &:hover {\n            filter: brightness(1) invert(0); } } }\n","// Poppins\n@import url('https://fonts.googleapis.com/css2?family=Poppins:wght@100;300;500;600;800&display=swap');\n* {\n    //font smoothing\n    -webkit-font-smoothing: antialiased;\n    -moz-osx-font-smoothing: grayscale;\n    text-rendering: optimizeLegibility;\n\n    font-family: 'Poppins', sans-serif; }\n\n//form factors (not exact)\n$laptop: 1116px;\n$tablet0: 950px;\n$tablet1: 750px;\n$tablet2: 650px;\n$phone1: 475px;\n$phone2: 360px;\n$foldable: 280px;\n\n@mixin major-third {\n    h1 {\n        font-size: 3.052rem; }\n    h2 {\n        font-size: 2.441rem; }\n    h3 {\n        font-size: 1.953rem; }\n    h4 {\n        font-size: 1.563rem; }\n    h5 {\n        font-size: 1.25rem; }\n    h6 {\n        font-size: 0.8rem; }\n    .btn {\n        font-size: 0.85rem; }\n    input[type = submit],\n    input[type = text],\n    input[type = email],\n    textarea {\n        font-size: 0.8rem; }\n    small, label {\n        font-size: 0.8rem; }\n    .tiny-small {\n        font-size: 0.6rem; } }\n\n@mixin minor-third() {\n    h1 {\n        font-size: 2.2rem; }\n    h2 {\n        font-size: 1.9rem; }\n    h3 {\n        font-size: 1.728rem; }\n    h4 {\n        font-size: 1.44rem; }\n    h5 {\n        font-size: 1.2rem; }\n    h6 {\n        font-size: 0.8rem; }\n    .btn,\n    input[type = submit],\n    input[type = text],\n    input[type = email],\n    textarea {\n        font-size: 0.9rem; }\n    small, label {\n        font-size: 0.8rem; } }\n\nbody {\n    @include major-third(); }\n\n//Font weights and line heights\np {\n    font-weight: 400; }\n\nh1, h2 {\n    line-height: 130%;\n    font-weight: 700; }\n\nh3 {\n    line-height: 130%;\n    font-weight: 400; }\n\nh4 {\n    line-height: 100%;\n    font-weight: 600; }\n\nh5 {\n    font-weight: 400;\n    line-height: 120%; }\n\nh6 {\n    font-weight: 500; }\n\nstrong {\n    font-weight: 800; }\n\n@media screen and ( min-width: $laptop ) { //1116px\n    html {\n        font-size: 125%; } } //20px\n\n@media screen and ( max-width: $laptop ) { //1116px\n    html {\n        font-size: 115%; } } //18.4px\n\n@media screen and ( max-width: $tablet0 ) { //950px\n    html {\n        font-size: 110%; } } //17.6px\n\n@media screen and ( max-width: $tablet1 ) { //750px\n    html {\n        font-size: 105%; } } //16.8px\n\n@media screen and ( max-width: $phone1) { //475px\n    body {\n        @include center-align();\n        @include minor-third(); } }\n\n@media screen and ( max-width: $phone2) { //360px\n    html {\n        font-size: 100%; } } //16px\n\n//  Any custom typography will be written in it's place\n//  and not here\n",".root {\n    //======================//\n    //PRIMARY COLOR PALETTE //\n    //======================//\n    --primary-pink: #F35E84;\n    --primary-purple: #6E82F9;\n    --primary-green: #9FFBCE;\n\n    //===================//\n    //PRIMARY GRADIENTS //\n    //==================//\n    --pink-purple-grd: linear-gradient(90deg, var(--primary-pink) 0%, #AF70C0 50%, var(--primary-purple) 100%);\n    --purple-green-grd: linear-gradient(90deg, var(--primary-purple) 0%, #22B9FF 50.31%, #A6FFD8 100%, var(--primary-green) 100%);\n\n    //==================//\n    //BUTTONS GRADIENTS //\n    //=================//\n    --btn-pink-purple-grd: linear-gradient(90deg, var(--primary-pink) 0%, var(--primary-pink) 50%, var(--primary-purple) 100%);\n    --btn-pink-purple-grd-border: linear-gradient(90deg, #FE3064 0, #FE3064 50%, #415CFF 100%);\n\n    //====================//\n    //SECONDARY GRADIENTS //\n    //====================//\n    // Either not often used or made for special cases\n    --banner-border-grd: linear-gradient(90deg, #d1ffe8 0%, rgba(0,0,0, 0) 25%, rgba(0,0,0, 0) 75%, #862DF7 100%);\n    --contact-border-grd: linear-gradient(105.8deg, #d1ffe8 0%, rgba(0,0,0, 0) 25%, rgba(0,0,0, 0) 75%, #862DF7 100%);\n    --thumb-grd: linear-gradient(180deg, var(--primary-pink) 0%, var(--primary-purple) 100%);\n\n    --color-error: #DC3545;\n    --color-success: #28A745; }\n\n$btn-transition-duration: 0.3s;\n\n//sections theming\n@mixin landing-theming($theme: dark) {\n    @if $theme == dark {}\n    @else if $theme == light {} }\n\n@mixin me-theming($theme: dark) {\n    //large-screen-exp\n    $exp-bg: rgba(255, 0, 0, 0.3);\n    $years-fg: rgba(255, 0, 0, 0.3);\n\n    @if $theme == dark {\n        $exp-bg: #1A1A1A;\n        $years-fg: var(--primary-green); }\n\n    @else if $theme == light {}\n\n    .me .exp {\n        background-color: $exp-bg;\n        #years {\n            color: var(--primary-green); } } }\n\n@mixin skills-theming($theme: dark) {\n    //duties\n    $active-duty-bg: rgba(255, 0, 0, 0.3);\n    //tech & tools\n    $tools-banner-bg: rgba(255, 0, 0, 0.3);\n    @if $theme == dark {\n        $active-duty-bg: #1A1A1A;\n        $tools-banner-bg: #1A1A1A; }\n    @else if $theme == light {}\n\n    .skills {\n        .duties .active-duty {\n            background-color: $active-duty-bg; }\n        .tech-tools {\n            background-color: $tools-banner-bg; } } }\n\n@mixin work-theming($theme: dark) {\n    $card-bg: rgba(255, 255, 255, 0.3);\n    $card-border-color: rgba(255, 255, 255, 0.3);\n    @if $theme == dark {}\n    @else if $theme == light {} }\n\n@mixin contact-theming($theme: dark) {\n    label[importance='crucial'] {\n        &::after {\n            content: '*';\n            color: var(--color-error); } }\n    @if $theme == dark {}\n    @else if $theme == light {} }\n\n.dark {\n    @extend .root;\n\n    //Main background and foreground for this theme\n    --bg: #000;\n    --fg: #fff;\n\n    background-color: var(--bg);\n    color: var(--fg);\n    h1, h2 {\n        @include fill-grd(); }\n    a {\n        color: var(--fg); }\n\n    .btn {\n        color: var(--fg);\n        @include btn-border-grd();\n        box-shadow: 0 1px 10px rgba(240,95,135, 0.5);\n\n        transition: background-position $btn-transition-duration, box-shadow $btn-transition-duration;\n        &:hover {\n            box-shadow: 0 1px 25px rgba(240,95,135, 0.5); } }\n\n    .btn-primary {\n        background-image: var(--btn-pink-purple-grd);\n        background-size: 200% auto;\n        background-position: 100% 50%;\n        .btn-icon {\n            transition: transform $btn-transition-duration; }\n        &:hover {\n            background-position: left center; } }\n\n    .btn-secondary {\n        background-color: var(--bg); }\n\n    form {\n        background-color: #272727; }\n\n    input[type = text], input[type = email], textarea {\n        background-color: #1F1F1F;\n        border-color: transparent;\n        transition: border-color 0.1s ease-out, background-color 0.2s ease-out;\n        color: #ffffff;\n        &:hover {\n            border-color: #606060 !important; }\n        &:focus {\n            border-color: var(--primary-purple) !important;\n            background-color: #141414; } }\n    .error-msg {\n        color: var(--color-error); }\n\n    @include landing-theming(dark);\n    @include me-theming(dark);\n    @include skills-theming(dark);\n    @include work-theming(dark);\n    @include contact-theming(dark); }\n\n//#191919\n//#1A1A1A\n//#1A1A1A\n//#0F0F0F\n//#272727\n//#1F1F1F\n","@import \"mixins\";\n@import \"normalize\";\n@import \"typography\";\n@import \"theming\";\n\n//===================//\n// Global Variables //\n//==================//\n$border-radius: 10px;\n$max-width: 1600px;\n$container-width: 90%;\n\n* {\n    scroll-behavior: smooth;\n    margin: 0;\n    padding: 0;\n    box-sizing: border-box; }\n\n*:not(textarea):focus {\n    outline: 2.5px dashed var(--primary-purple);\n    outline-offset: 5px; }\n\nbody {\n    &::-webkit-scrollbar {\n        background-color: #000;\n        @include size(0.55rem, 0.55rem); }\n    &::-webkit-scrollbar-thumb {\n        border: 4px solid rgba(0, 0, 0, 0);\n        background-clip: padding-box;\n        border-radius: $border-radius;\n        background-color: #AAAAAA;\n        background-color: var(--primary-pink); } }\n\n.container {\n    width: $container-width;\n    max-width: $max-width;\n    margin: 0 auto; }\n\n.wide-banner {\n    @include backdrop-blur();\n\n    width: 100vw;\n    position: relative;\n    &::before,\n    &::after {\n        content: '';\n        position: absolute;\n        left: 0;\n        @include size(100vw, 1.5px);\n        background: var(--banner-border-grd); }\n    &::before {\n        top: 0; }\n    &::after {\n        bottom: 0; } }\n\n.not-centered {\n    text-align: left !important;\n    * {\n        text-align: left !important; } }\n\na {\n    text-decoration: none;\n    display: inline-block; }\n\na, button {\n    cursor: pointer; }\n\n.btn,\nbutton,\ninput[type = submit],\ninput[type = text],\ninput[type = email],\ntextarea {\n    border: none; }\n\ntextarea {\n    resize: none; }\n\ninput[type = text],\ninput[type = email],\ntextarea {\n    position: relative;\n    display: block;\n    width: 100%;\n    border-width: 2px;\n    border-style: solid;\n    border-radius: $border-radius;\n    padding: 0.5rem 0.7rem;\n    outline: none; }\n\ntextarea {\n    height: auto; }\n\n.btn {\n    border-radius: 6px;\n\n    padding: 0.5rem 1.5rem;\n\n    position: relative;\n\n    @include flex(center, center, row, 0.25rem);\n    flex-shrink: 0;\n\n    .btn-icon {\n        @include size(22px, 22px);\n        background-repeat: no-repeat;\n        background-size: cover; } }\n\n.btn-primary,\n.btn-secondary {\n    @extend .btn; }\n\n.btn-primary {\n    .btn-icon {\n        background-image: url('../assets/arrow.svg'); }\n    &:hover {\n        .btn-icon {\n            transform: translateX(5px); } } }\n\n.btn-secondary {\n    flex-direction: row-reverse;\n    gap: 10px; }\n\n.header-btn {\n    padding: 0.35rem 1.5rem;\n    .btn-icon {\n        @include size(15px, 15px); } }\n","@import \"generic\";\n\nhtml {\n    @include size(100%, 100%);\n    // height: -webkit-fill-available\n    height: -webkit-stretch; }\n\nbody {\n    position: relative;\n    overflow-x: hidden;\n    @include size(inherit, inherit);\n    main {\n        @include size(inherit, inherit); } }\n\n/////////////////////////////////////////////////////////////////\n// Redundant 2 lines (Just to prevent some SASS indentation issue)\n// Remove the two line to check the issue\n/////////////////////////////////////////////////////////////////\n.fix {\n    position: absolute; }\n\n@import \"landing\";\n@import \"decorations\";\n@import \"me\";\n@import \"skills\";\n@import \"work\";\n@import \"contact\";\n\n.skills {\n    p {\n        max-width: 60ch; } }\n\nsection:not(.landing):not(.contact) {\n    margin-top: -70px;\n    padding-top: 140px; }\n\n.contact {\n    padding-top: 70px; }\n\nsection .title {\n    display: flex;\n    justify-content: start;\n    align-items: center;\n    grid-gap: 0.5rem;\n    margin-bottom: 1rem;\n    white-space: nowrap; }\n\n@media screen and ( min-width: $laptop) { //1116px\n    .img-title {\n        width: 80px; } }\n\n@media screen and ( max-width: $laptop) { //1116px\n    .img-title {\n        width: 70px; } }\n\n@media screen and ( max-width: $tablet1) { //750px\n    .img-title {\n        width: 65px; }\n    .me, .skills {\n        p {\n            max-width: 100%; } } }\n\n@media screen and ( max-width: $tablet2) { //650px\n    section:not(.landing):not(.contact) {\n        margin-top: -50px;\n        padding-top: 100px; }\n    .contact {\n        padding-top: 50px; } }\n\n@media screen and ( max-width: $phone1) { //475px\n    .img-title {\n        width: 60px; }\n    .btn {\n        justify-content: center;\n        .btn-icon {\n            @include size(15px, 15px); } }\n    .title {\n        flex-wrap: wrap;\n        justify-content: center !important;\n        h2 {\n            width: min-content; } } }\n","//scroll animations\n//https://coolcssanimation.com/how-to-make-scroll-animations/\n\n.landing {\n    position: relative;\n\n    min-height: 100%;\n\n    display: grid;\n    grid-template-rows: auto 1fr auto;\n\n    > .container {\n        grid-row: 2/3;\n        align-self: center; }\n\n    header {\n        grid-row: 1/2;\n        min-width: 100vw;\n        width: 100vw;\n        z-index: 3;\n        @include backdrop-blur();\n        border-bottom: 1px solid #fff;\n        .container {\n            display: grid;\n            grid-template-columns: 1fr 3fr 1fr;\n            .desktop-nav {\n                grid-column: 2/3;\n                @include flex(center, center, row, 2rem);\n                .logo {\n                    @include size(70px, 70px);\n                    overflow: hidden;\n                    svg {\n                        @include size(inherit, inherit); } }\n                .desktop-links {\n                    @include flex(inherit, inherit, inherit, inherit);\n                    .section-link a {\n                        text-transform: uppercase;\n                        font-size: 90%;\n                        padding: 0.25rem 0.4rem;\n                        border-radius: 5px;\n                        transition: background-color 0.15s ease-in;\n                        &:hover {\n                            background-color: var(--primary-purple); } } } }\n\n            .header-btn {\n                grid-column: 3/4;\n                justify-self: end;\n                align-self: center;\n                width: fit-content !important; }\n            .btn-ham {\n                z-index: 2;\n                @include size(25px, 25px);\n                img {\n                    @include size(inherit, inherit); } }\n            .mobile-nav {\n                position: absolute;\n                top: 50px;\n                left: 0;\n                width: 100vw;\n                height: calc(100vh - 50px);\n                //TODO: move to theming\n                background-color: var(--bg);\n                display: none;\n\n                ul {\n                    padding: 3rem 1.5rem;\n                    @include flex(center, start, column, 0.3rem);\n                    .ham-link {\n                        font-size: 130%;\n                        text-decoration: underline; } }\n\n                .ham-img {\n                    position: absolute;\n\n                    @include size(130%, auto);\n                    transform: translate(-50%, 0);\n                    left: 50%;\n                    bottom: -12%;\n\n                    display: none; } }\n\n            .btn-ham, .mobile-nav {\n                display: none; } } }\n    .sticky {\n        position: fixed;\n        top: 0;\n        width: 100%; }\n\n    .hero {\n        padding: 2.5rem 0;\n\n        .hero-text {\n            .hero-heading {\n                @include flex(center, start, column);\n                #qualities {\n                    line-height: 1.2em;\n                    height: 1.2em;\n                    @include fill-grd(var(--purple-green-grd));\n                    text-transform: uppercase;\n                    .typed-cursor {\n                        font-weight: 300;\n                        animation: blink 1.5s steps(5, start) infinite;\n                        @keyframes blink {\n                            to {\n                                visibility: hidden; } } } } } }\n        .ctas {\n            margin-top: 2rem;\n            @include flex(start, center, row, 1rem);\n            #btn-work .btn-icon {\n                display: none; } } }\n\n    .hobbies {\n        //---------------PARALLAX---------------\n        grid-row: 3/4;\n        @extend .wide-banner;\n        z-index: 2;\n        position: relative;\n        padding: 0.6rem 1rem;\n        overflow: hidden;\n        .container {\n            @include flex(space-around, center, row, 1.5rem); }\n        .hobby {\n            @extend .not-centered;\n            padding: 0.5rem 1rem;\n            pointer-events: none;\n            a {\n                @include flex(start, center, row, 0.5rem);\n                .name {\n                    .hobby-u, .hobby-l {\n                        font-weight: 600; }\n                    .hobby-l {\n                        margin-top: -0.3rem;\n                        opacity: 0.6; } }\n                img {\n                    @include size(65px, 65px); } } }\n        #developer .name {\n            position: relative;\n            #squiggly-line {\n                @include absolute-center();\n                width: 100%;\n                top: 115%; } }\n        #designer {\n            $obj-select-border: 2px solid #18A0FB;\n            position: relative;\n            border: $obj-select-border;\n            .outline,\n            .mini-sq {\n                position: absolute; }\n            .mini-sq {\n                @include size(14px, 14px);\n                background-color: #fff;\n                border: $obj-select-border;\n                transform: translate(-50%, -50%); }\n            #upper-left {\n                top: 0;\n                left: 0; }\n            #upper-right {\n                top: 0;\n                left: 100%; }\n            #lower-left {\n                top: 100%;\n                left: 0; }\n            #lower-right {\n                top: 100%;\n                left: 100%; } } } }\n\n@media screen and (max-width: 1400px) { //custom\n    .landing {\n        .container {\n            .hero-image {\n                @include size(auto, 65vh); } } } }\n\n@media screen and (max-width: $laptop) { //1116px\n    .landing {\n        .hobbies {\n            padding: 0.6rem;\n            grid-gap: 0.75rem;\n            .hobby {\n                padding: 0.5rem;\n                grid-gap: 0.75rem;\n                .img-hobby {\n                    @include size(60px, 60px); } } } } }\n\n@media screen and (max-width: $tablet0) { //950px\n    .landing {\n        header .container {\n            grid-template-columns: 1fr auto;\n            .desktop-nav {\n                grid-column: 1;\n                justify-content: start;\n                gap: 1rem;\n                .logo {\n                    order: 1; }\n                .desktop-links {\n                    order: 2; } }\n            .btn {\n                grid-column: 2; } }\n        .container {\n            .hero-image {\n                @include size(auto, 40vh); } } } }\n\n@media screen and (max-width: 810px) {\n    .landing {\n        .container .hero {\n            .hero-text {\n                text-align: center;\n                .hero-heading {\n                    align-items: center; } }\n            .ctas {\n                justify-content: center; } } } }\n\n@media screen and (max-width: $tablet1) { //750px\n    .landing {\n        .container {\n            justify-content: start;\n            .hero-image {\n } } } }                // display: none\n\n@media screen and (max-width: $tablet2) { //650px\n    .landing {\n        header .container {\n            grid-template-columns: 1fr 2fr 1fr;\n            align-items: center;\n            .desktop-nav {\n                grid-column: 2;\n                justify-self: center;\n                .logo {\n                    @include size(50px, 50px); }\n                .desktop-links {\n                    display: none; } }\n            .btn-ham, .mobile-nav {\n                display: none; }\n            .btn-ham {\n                display: block;\n                grid-column: 1;\n                grid-row: 1; }\n\n            .header-btn {\n                display: none; } }\n\n        .hero {\n            align-items: stretch;\n            .hero-text {\n                .hero-heading {\n                    align-items: center; }\n                p {\n                    margin-top: 0.25rem; } }\n            .ctas {\n                grid-gap: 1rem;\n } }                // flex-direction: column\n        .hobbies {\n            .hobby {\n                border-radius: $border-radius;\n                pointer-events: all;\n                cursor: pointer;\n                border: 2px solid rgba(255, 255, 255, 0.0);\n                a {\n                    @include size(100%, 100%);\n                    outline: none;\n                    .name {\n                        display: none; }\n                    .img-hobby {\n                        @include size(55px, 55px); }\n                    &:focus {\n                        .name {\n                            display: block; } } }\n                &:hover {\n                    border-color: rgba(255, 255, 255, 0.2); } }\n            #designer {\n                border-radius: 0 !important;\n                .mini-sq {\n                    @include size(10px, 10px); } } } } }\n","$dcard-border-radius: 20px;\n.landing {\n    .decoration-card-grid {\n        position: absolute;\n        top: 0;\n        right: 0;\n        z-index: -1;\n\n        display: grid;\n        grid-template-rows: repeat(6, 1fr);\n        grid-template-columns: 300px 150px;\n        grid-gap: 20px;\n        height: 100%;\n        .decoration-card {\n            background-color: #2d3436;\n            background-image: linear-gradient(315deg, #2d3436 0%, #191919 74%);\n            opacity: 0.5;\n            &:nth-child(1) {\n                grid-row: 1/4;\n                grid-column: 2;\n                border-radius: 0 0 0 $dcard-border-radius; }\n            &:nth-child(2) {\n                grid-row: 4/7;\n                grid-column: 2;\n                border-radius: $dcard-border-radius 0 0 0; }\n            &:nth-child(3) {\n                grid-row: 1/2;\n                grid-column: 1;\n                border-radius: 0 0 $dcard-border-radius $dcard-border-radius; }\n            &:nth-child(4) { //sample card\n                grid-row: 2/5;\n                grid-column: 1;\n                border-radius: $dcard-border-radius;\n                padding: 1.5rem;\n                @include flex(space-between, start, column);\n                position: relative;\n                opacity: 1;\n                svg {\n                    width: 100%;\n                    border-radius: 3.5px; }\n\n                .cursor {\n                    position: absolute;\n                    top: 85%;\n                    left: 85%; } }\n            &:nth-child(5) {\n                grid-row: 5/7;\n                grid-column: 1;\n                border-radius: $dcard-border-radius $dcard-border-radius 0 0; } } } }\n\n@media screen and (max-width: 1385px) {\n    .landing {\n        .decoration-card-grid {\n            grid-template-columns: 300px 100px; } } }\n\n@media screen and (max-width: 1150px) {\n    .landing {\n        .decoration-card-grid {\n            grid-template-columns: 250px 0;\n            .cursor {\n                @include size(45px, auto); } } } }\n\n@media screen and (max-width: $tablet0) { //950px\n    .landing {\n        .decoration-card-grid {\n            transform: translateX(50%);\n            .cursor {\n                display: none; } } } }\n\n@media screen and (max-width: 810px) {\n    .landing {\n        .decoration-card-grid {\n            opacity: 0.6;\n            svg {\n                opacity: 0.2; } } } }\n\n//special height media queries for svgs inside sample card being properly seperated\n@media screen and (min-height: 950px) {\n    .landing .decoration-card-grid .decoration-card:nth-child(4) {\n        justify-content: start;\n        gap: 2rem;\n        #sample-paragraph {\n            flex-grow: 1; } } }\n@media screen and (max-height: 750px) {\n    .landing .decoration-card-grid .decoration-card:nth-child(4) {\n        #sample-paragraph {\n            height: 100px; } } }\n\n@media screen and (max-height: 450px) {\n    .landing .decoration-card-grid .decoration-card:nth-child(4) {\n        #sample-paragraph {\n            height: 80px; } } }\n",".me {\n    position: relative;\n    .large-map {\n        position: absolute;\n        @include size(100%, 100%);\n        top: 0;\n        left: 0;\n        background-image: url('../assets/large-map.webp');\n        background-repeat: no-repeat;\n        background-size: cover;\n        z-index: -1;\n        opacity: 0.08; }\n    .core {\n        display: grid;\n        grid-template-rows: repeat(2, 1fr);\n        grid-template-columns: 0.6fr 2fr 1fr;\n        grid-gap: 1rem;\n        article {\n            @include flex(start, start, column);\n            header {\n                @include flex(start, center, row, 0.25rem);\n                margin-bottom: 0.25rem;\n                small {\n                    font-weight: 800; } } }\n        .exp {\n            padding: 1rem 0;\n            grid-row: 1/2;\n            grid-column: 1/2;\n            position: relative;\n            @include flex(center, start, column, 0);\n            #background {\n                position: absolute;\n                background-color: inherit;\n                transform: translate(-100%, 0);\n                width: 1000%;\n                height: 100%;\n                left: 0%; }\n            small {\n                line-height: 130%; } }\n        .what {\n            grid-row: 2/3;\n            grid-column: 1/3; }\n        .small-screen-where {\n            display: none; }\n        .large-screen-where {\n            position: relative;\n            grid-row: 1/3;\n            grid-column: 3/4;\n            max-height: 350px;\n            @include flex(start, stretch, column);\n            .question {\n                position: absolute;\n                z-index: 1;\n                top: 10px;\n                left: 10px;\n                filter: drop-shadow(0 0 10px #3f3f3f); }\n            .map {\n                flex-basis: 1;\n                flex-grow: 1;\n                position: relative;\n                overflow: hidden;\n                width: 100%;\n                .cairo-map, .overlay {\n                    @include size(100%, 100%);\n                    background-repeat: no-repeat;\n                    background-size: cover;\n                    position: absolute;\n                    top: 0;\n                    left: 0; }\n                .cairo-map {\n                    background-image: url('../assets/small-map.webp'); }\n                .overlay {\n                    background-image: url('../assets/pink-overlay.webp');\n                    opacity: 0.8; }\n                h4 {\n                    position: absolute;\n                    z-index: 1;\n                    color: var(--primary-green);\n                    filter: drop-shadow(0 0 10px rgba(0, 0, 0, 0.2));\n                    text-transform: uppercase;\n                    font-weight: 800;\n                    line-height: 120%;\n                    bottom: 0.75rem;\n                    left: 0.75rem; } } } }\n\n    .resume {\n        @extend .wide-banner;\n        @include backdrop-blur(7px);\n        margin-top: 3rem;\n        padding: 1.5rem;\n        text-align: center;\n        @include flex(center, center, row, 1rem);\n        flex-wrap: wrap;\n        #btnDownload .btn-icon {\n            background-image: url('../assets/download.svg'); } } }\n\n@media screen and(max-width:  $laptop) { //1116px\n    .me {\n        .core {\n            grid-template-rows: repeat(2, auto);\n            grid-template-columns: repeat(4, 1fr);\n            .exp {\n                grid-row: 1/2;\n                grid-column: 1/2; }\n            .who {\n                grid-row: 1/2;\n                grid-column: 2/5; }\n            .large-screen-where {\n                grid-row: 2/4;\n                grid-column: 1/3; }\n            .what {\n                grid-row: 2/4;\n                grid-column: 3/5;\n                margin: auto 0; } } } }\n\n@media screen and ( max-width: $tablet1 ) { //750px\n    .me {\n        .core {\n            grid-template-rows: repeat(3, auto);\n            grid-template-columns: 1fr;\n            .exp, .large-screen-where {\n                display: none; }\n            .who {\n                grid-row: 1/2;\n                grid-column: 1; }\n            .small-screen-where {\n                @include flex(start, start, column);\n                grid-row: 2/3;\n                grid-column: 1; }\n            .what {\n                grid-row: 3/4;\n                grid-column: 1; } }\n        .large-map {\n            background-size: auto;\n            display: block; } } }\n\n@media screen and ( max-width: $tablet2 ) { //650px\n    .me .core {\n        article {\n            .question {\n                position: relative;\n                --question-bars-width: 120%;\n                --question-bars-position: calc(-1 * var(--question-bars-width) - 15%);\n                &::before, &::after {\n                    content: ' ';\n                    position: absolute;\n                    height: 3px;\n                    width: var(--question-bars-width);\n                    background-color: #fff;\n                    opacity: 1; }\n                &::before {\n                    // display: none\n                    left: var(--question-bars-position); }\n                &::after {\n                    right: var(--question-bars-position); } } } } }\n\n@media screen and ( max-width: $phone1) { //475px\n    .me .core {\n        article {\n            align-items: center !important; } } }\n",".skills {\n    //border: 1px dashed orange\n    .duties-container {\n        margin-top: 2rem; }\n    .duties {\n        display: grid;\n        grid-template-rows: 1fr;\n        grid-template-columns: repeat(4, auto);\n        justify-content: start;\n\n        .duty {\n            padding: 1rem;\n\n            @include grid-center();\n\n            border-radius: $border-radius;\n\n            transition: background-color 0.15s , transform 0.15s;\n            img {\n                @include size(120px, 120px);\n\n                transition: background-color 0.15s , transform 0.15s;\n\n                cursor: pointer;\n                border-radius: inherit;\n                -webkit-filter: brightness(0) invert(1);\n                filter: brightness(0) invert(1);\n                // &:hover\n                //  //preventing background change when hovering\n }                //  //in case of already activating done in JS\n\n            h6 {\n                font-weight: 600;\n                line-height: 100%;\n                opacity: 0;\n                text-align: center;\n                transition: opacity 0.2s; } }\n        .active-duty {\n            transform: translateY(-1rem);\n            img {\n                background-color: transparent !important;\n                filter: brightness(1) invert(0); }\n            .duty-name {\n                opacity: 1; } } }\n\n    .tech-tools {\n        width: 100%;\n        margin: 2rem 0 0 0;\n        padding: 2rem 0;\n        position: relative;\n        &::before {\n            position: absolute;\n            content: \" \";\n            @include size(100%, 100%);\n            top: 0;\n\n            background-image: url(../assets/drawing-compass.svg);\n            background-repeat: no-repeat;\n            background-size: 300px;\n            background-position: bottom -4.8rem right;\n            opacity: 0.4; }\n        .container {\n            #inner-title {\n                font-weight: 800;\n                text-transform: uppercase;\n                margin-bottom: 1rem; }\n            .icons {\n                margin-top: 1rem;\n                @include flex(start, center, row, 0.75rem);\n                li {\n                    @include size(auto, 40px);\n                    img {\n                        @include size(inherit, inherit); } } } } } }\n\n@media screen and ( max-width: $laptop ) { //1116px\n    .skills {\n        .tech-tools {\n            &::before {\n                background-size: 400px;\n                background-position: top -0.5rem right;\n                opacity: 0.25; }\n\n            .icons {\n                // display: grid !important\n                // grid-template-rows: repeat(2, auto)\n } } } }                // grid-template-columns: repeat(5, auto)\n\n@media screen and ( max-width: 950px ) {\n    .skills {\n        .duties {\n            grid-gap: 0.25rem;\n            .duty {\n                padding: 1rem 0.75rem;\n                img {\n                    @include size(110px, 110px); }\n                .duty-name {\n                    display: none; } } }\n        .duty-explained {\n            margin-top: 1rem;\n            #duty-name {\n                display: block;\n                font-weight: 600; }\n            #duty-description {\n                margin-top: 0.3rem; } }\n        .tech-tools .container .icons {\n            li {\n                @include size(auto, 35px); } } } }\n\n@media screen and ( max-width: $tablet1 ) {  //750px\n    .skills {\n        .duties .duty img {\n            @include size(80px, 80px); }\n        .tech-tools .container .icons {\n            li {\n                z-index: 1;\n                @include size(auto, 30px); } } } }\n\n@media screen and ( max-width: $tablet2 ) { //650px\n    .skills {\n        .duties {\n            // width: fit-content\n }            // margin: 0 auto\n        .tech-tools {\n            &:before {\n                display: none; }\n            .container {\n                #inner-title br {\n                    display: none; }\n                .icons {\n                    // width: fit-content\n                    // margin: 0 auto\n                    li {\n                        @include size(auto, 25px); } } } } } }\n\n@media screen and ( max-width: $phone1) { //475px\n    .skills {\n        text-align: center;\n        .duties {\n            width: fit-content;\n            margin: 0 auto;\n            grid-template-rows: repeat(2, 1fr);\n            grid-template-columns: repeat(2, auto);\n            justify-content: center;\n            grid-gap: 0;\n            // .duty img\n            //     +size(95px, 95px)\n            .active-duty {\n                transform: translateY(0);\n                img {\n                    transform: scale(1.15); } } }\n        .duty-explained {\n            //TODO: duty-explained height\n }            // height: 5em\n        .tech-tools {\n            .container {\n                .icons {\n                    display: grid;\n                    grid-template-rows: repeat(2, auto);\n                    grid-template-columns: repeat(5, auto);\n                    width: fit-content;\n                    margin: 0 auto;\n                    li {\n                        @include size(auto, 25px); } } } } } }\n","//Global variables used here\n$padding: 1rem;\n\n.work {\n    --gap: 2rem;\n    .cards-container {\n        @extend .not-centered;\n        // width: $container-width\n        // margin: 0 auto\n\n        @include flex(start, center, row, var(--gap));\n\n        overflow-x: auto;\n\n        @include apply-cards-effect();\n\n        //TODO: take card of those\n        .generic-card {\n            border-radius: 25px;\n            background-color: #191919;\n            border: 2px solid #3d3d3d;\n            position: relative; }\n        .card {\n            @extend .generic-card;\n            @include size(340px, 380px);\n            @include flex(space-between, start, column);\n            overflow: hidden;\n            z-index: 2;\n            .card-bg {\n                @include absolute-cover();\n\n                border-radius: inherit;\n                background-repeat: no-repeat;\n                background-size: 70%;\n                background-position: bottom -30% right -40%;\n\n                opacity: 0.2; }\n            header {\n                width: 100%;\n                padding: $padding $padding 0;\n                @include flex(start, start, column, 0.5rem);\n                .card-title {\n                    @include flex(start, center, row, 0.5rem);\n                    z-index: 3;\n                    .card-name {\n                        font-weight: 800;\n                        line-height: 120%;\n                        @include fill-grd(var(--purple-green-grd)); }\n                    .arrow {\n                        transition: transform .2s ease;\n                        justify-self: start;\n                        align-self: center;\n                        @include size(22px, 22px); }\n                    &:hover {\n                        filter: brightness(0.8); } }\n                .work-done {\n                    grid-row: 2;\n                    grid-column: 1/3;\n                    justify-self: start;\n                    @include flex(start, start, row, 0.5rem);\n                    flex-grow: 1;\n                    img {\n                        @include size(30px, auto); } } }\n\n            footer {\n                position: relative;\n                display: grid;\n                grid-template-rows: repeat(2, auto);\n                grid-template-columns: 1fr auto;\n                grid-gap: 0.75rem 0;\n                padding: $padding;\n                border-radius: inherit;\n                z-index: inherit;\n                .card-description {\n                    grid-column: 1/3; }\n                .year {\n                    grid-row: 2/3;\n                    grid-column: 2/3;\n                    align-self: center;\n                    @extend .tiny-small;\n                    background-color: var(--primary-green);\n                    color: rgba(0, 0, 0, 0.7);\n                    padding: 0.1rem 0.2rem;\n                    border-radius: 5px; }\n                .related-links {\n                    grid-row: 2/3;\n                    grid-column: 1/2;\n                    @include flex(start, center, row, 0.3rem);\n                    a {\n                        @include darken-on-hover(0.8);\n                        @include size(27px,27px);\n                        background-size: cover;\n                        img {\n                            @include size(inherit, inherit); }\n                        &:nth-child(1) {\n                            background-image: url(../assets/card-dribbble.svg); }\n                        &:nth-child(2) {\n                            background-image: url(../assets/card-github.svg); } } } }\n            @media not (hover) {\n                header .work-done img {\n                    filter: brightness(0) invert(1); }\n                footer {\n                    transform: translateY(34%);\n                    transition: transform .2s ease .1s; }\n                &:hover {\n                    .work-done img {\n                        filter: brightness(1) invert(0); }\n                    footer {\n                        transform: translateY(0); } } } }\n        #pig-dice .card-bg {\n            background-image: url(../assets/pigdice.svg); }\n        #monster-slayer {\n            .card-bg {\n                background-image: url(../assets/monster-slayer.svg); }\n            .card-name {\n                width: min-content; } }\n        #osc-geeks .card-bg {\n            background-image: url(../assets/osc-geeks.svg); }\n\n        .dummy-card {\n            margin: 0 !important;\n            flex-grow: 1;\n            border: 2px dashed #3d3d3d;\n            border-radius: 25px;\n            align-self: stretch;\n            @include grid-center();\n            img {\n                @include size(100px, auto);\n                opacity: 0.4; } } }\n    .tasks-explained {\n        margin-top: 1rem;\n        @include flex(start, center, row, 15px);\n        flex-wrap: wrap;\n        .task {\n            @include flex(center, center, row, 5px);\n            img {\n                @include size(20px, 20px); } } } }\n//base: +size(340px, 380px)\n@media screen and (max-width: $laptop) { //1116px\n    .work .cards-wrapper .cards-container {\n        .card {\n            @include size(310px, 350px); }\n        .dummy-card {\n            display: none; } } }\n\n@media screen and (max-width: $tablet1) { //750px\n    .work .cards-wrapper .cards-container {\n        --overlaying-margin: 210px;\n        .card {\n            @include size(330px, 350px); } } }\n\n@media screen and (max-width: $tablet2) { //650px\n    .work .cards-wrapper {\n        width: 100%;\n        .cards-container {\n            width: inherit;\n            display: grid;\n            grid-template-columns: repeat(3, auto);\n            scroll-snap-type: x mandatory;\n            scroll-behavior: smooth;\n            .card {\n                @include disable-cards-effect();\n                width: 70vw;\n                margin: 0;\n                scroll-snap-align: center;\n                scroll-snap-stop: always;\n                .work-done {\n                    img {\n                        @include size(25px, 25px); } }\n                &:first-of-type {\n                    margin-left: var(--gap); }\n                &:last-of-type {\n                    margin-right: var(--gap); } } } } }\n\n@media screen and (max-width: $phone1) { //450px\n    .work {\n        --gap: 1rem;\n        .cards-wrapper .cards-container .card {\n            width: 80vw; }\n        .tasks-explained {\n            justify-content: center; } } }\n\n@media screen and (max-width: $phone2) { //360px\n    .work .cards-wrapper .cards-container .card {\n        height: 300px; } }\n",".contact {\n    min-height: clamp(650px, 100%, 100%);\n    display: grid;\n    grid-template-rows: 2.5fr 1fr;\n    @extend .not-centered;\n    .contact-theme {\n        width: 100%;\n        height: 100%;\n        display: none; }\n    .upper {\n        grid-row: 1/2;\n        background-color: #0F0F0F;\n        background-image: url('../assets/contact-theme-1.webp');\n        background-repeat: no-repeat;\n        background-size: clamp(600px, 50%, 50%) auto;\n        background-position: bottom left;\n        width: 100%;\n        margin: 0 auto;\n        max-width: $max-width;\n        .container {\n            height: 100%;\n            @include flex(space-between, center, row);\n            .title {\n                align-self: flex-end; }\n            form {\n                position: relative;\n                @include flex(stretch, stretch, column,  0.5rem);\n                border-radius: $border-radius;\n                padding: 0.75rem;\n                @include size(40%, 85%);\n                @include min-size(480px, auto);\n                @include max-size(auto, 470px);\n                position: relative;\n                .input-container {\n                    display: grid;\n                    grid-template-rows: auto 1fr;\n                    grid-template-columns: auto 1fr;\n                    grid-row-gap: 5px;\n                    label {\n                        grid-row: 1;\n                        grid-column: 1;\n                        justify-self: left;\n                        margin: 0 0 0 5px; }\n                    .error-msg {\n                        display: none;\n                        grid-row: 1;\n                        grid-column: 2;\n                        justify-self: right;\n                        align-self: end; }\n                    .text-box {\n                        grid-row: 2;\n                        grid-column: 1/3; }\n                    &:nth-child(3) { // Message\n                        flex-grow: 1; } }\n                .invalid-input {\n                    .error-msg {\n                        display: inline-block; }\n                    .text-box {\n                        // Not convienient to move to _theming.sass\n                        border-color: var(--color-error); } }\n                .valid-input {\n                    .error-msg {\n                        display: none; }\n                    .text-box {\n                        // Not convienient to move to _theming.sass\n                        border-color: var(--color-success); } }\n                .btn {\n                    position: absolute;\n                    border-radius: 999px;\n                    padding: 0.75rem;\n                    width: fit-content;\n                    transform: translate(-50%, -50%);\n                    top: 96%;\n                    left: 96%;\n                    z-index: 3;\n                    .btn-icon {\n                        @include size(30px, 30px);\n                        background-image: url('../assets/arrow-send.svg'); } }\n                .conf {\n                    position: absolute;\n                    @include size(100%, 100%);\n                    background-color: inherit;\n                    border-radius: inherit;\n                    padding: 1.5rem;\n                    top: 0;\n                    left: 0;\n                    color: var(--primary-green);\n                    text-align: center;\n                    @include flex(center, start, column, 0.5rem);\n                    display: none;\n                    img {\n                        @include size(5rem, 5rem);\n                        margin-bottom: 1rem; }\n                    small {\n                        opacity: 0.7; } } }\n            .show-conf {\n                .btn {\n                    pointer-events: none; }\n                .conf {\n                    display: flex; } } } }\n    .lower {\n        grid-row: 2/3;\n        @include grid-center();\n        .container {\n            @include flex(space-between, center);\n            .contact-info {\n                @include flex(start, start, row, 3rem);\n                li {\n                    align-items: center;\n                    @include flex(start, start, column, 0.6rem);\n                    img {\n                        @include size(40px, 40px); }\n                    small {\n                        display: block; } }\n                #work-phone-number, #work-email {\n                    text-decoration: underline; } }\n            .social {\n                @include flex(center, center, row-reverse, 2rem);\n                small {\n                    &::before {\n                        content: '';\n                        display: inline-block;\n                        @include size(20px, 4px);\n                        background: #fff;\n                        margin: 0 0.5rem 3px 0; } }\n                .platforms {\n                    @include flex(start, center, row, 0.4rem);\n                    li {\n                        @include size(33px, 33px);\n                        border-radius: 999px;\n                        transition: transform 0.15s ease-out;\n                        * {\n                            @include size(inherit, inherit);\n                            border-radius: inherit; }\n                        &:hover {\n                            transform: scale(1.15) translateY(-2px); } } } } } } }\n\n@media screen and(max-width: $laptop) { //1116px\n    .contact {\n        .upper {\n            background-image: url('../assets/contact-theme-2.webp');\n            background-size: auto 95%;\n            background-position: bottom 60% left -10%;\n            .container {\n                .title {\n                    flex-direction: column;\n                    align-items: flex-start; }\n                form {\n                    @include size(55%, calc(100%, 2rem)); } } }\n        .lower .container {\n            align-items: flex-end;\n            .contact-info {\n                gap: 0.75rem;\n                flex-direction: column;\n                li {\n                    flex-direction: row;\n                    align-items: center;\n                    img {\n                        @include size(35px, 35px); }\n                    br {\n                        display: none; } } }\n\n            .social {\n                flex-direction: column;\n                align-items: flex-end;\n                gap: 0.6rem; } } } }\n\n@media screen and ( max-width: $tablet0 ) { //950px\n    .contact {\n        .upper .container {\n            padding-bottom: 1.5rem;\n            align-items: flex-end;\n            form {\n                min-width: 380px; }\n            .title {\n                margin: 0; } } } }\n\n@media screen and ( max-width: $tablet2 ) { //650px\n    .contact {\n        grid-template-rows: 2.5fr 1fr;\n        //New\n        grid-template-rows: 2fr 1fr;\n        .upper {\n            background-color: #272727;\n            //New\n            background-color: #292929;\n            background-image: none;\n            .container {\n                display: grid;\n                // grid-auto-rows: 1fr auto 1.5fr\n                //New\n                grid-template-rows: auto 1fr;\n                width: 100vw;\n                padding-bottom: 0;\n                .contact-theme {\n                    //New\n                    display: none;\n                    grid-row: 1/2;\n                    background-image: url('../assets/contact-theme-3.webp');\n                    background-repeat: no-repeat;\n                    background-size: auto 230%;\n                    background-position: center center; }\n                .title {\n                    grid-row: 2/3;\n                    //New\n                    grid-row: 1/2;\n                    flex-direction: row;\n                    justify-content: center;\n                    align-items: center;\n                    margin: 0;\n                    width: 100vw;\n                    //New\n                    padding: 1.5rem 0 0.5rem; }\n                form {\n                    grid-row: 3/4;\n                    //New\n                    grid-row: 2/3;\n                    min-width: auto;\n                    position: relative;\n                    width: 100%;\n                    height: 100%;\n                    #message {\n                        grid-column: 1/3; }\n                    .btn {\n                        top: 98%;\n                        left: 50%; }\n                    .show-conf {\n                        background-color: #292929; } } } }\n        .lower {\n            .container {\n                padding: 2rem 0 1rem 0;\n                flex-direction: column;\n                align-items: center;\n                gap: 2rem;\n                .social {\n                    small {\n                        display: none; } } } } } }\n\n// @media screen and ( max-width: $phone1) //475px\n//     .contact .upper .container\n//         grid-auto-rows: 0.75fr auto 1.5fr\n//         form\n//             grid-template-rows: auto auto 1fr\n//             grid-template-columns: 1fr\n"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/api.js":
/*!*****************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/api.js ***!
  \*****************************************************/
/***/ ((module) => {

"use strict";


/*
  MIT License http://www.opensource.org/licenses/mit-license.php
  Author Tobias Koppers @sokra
*/
module.exports = function (cssWithMappingToString) {
  var list = []; // return the list of modules as css string

  list.toString = function toString() {
    return this.map(function (item) {
      var content = "";
      var needLayer = typeof item[5] !== "undefined";

      if (item[4]) {
        content += "@supports (".concat(item[4], ") {");
      }

      if (item[2]) {
        content += "@media ".concat(item[2], " {");
      }

      if (needLayer) {
        content += "@layer".concat(item[5].length > 0 ? " ".concat(item[5]) : "", " {");
      }

      content += cssWithMappingToString(item);

      if (needLayer) {
        content += "}";
      }

      if (item[2]) {
        content += "}";
      }

      if (item[4]) {
        content += "}";
      }

      return content;
    }).join("");
  }; // import a list of modules into the list


  list.i = function i(modules, media, dedupe, supports, layer) {
    if (typeof modules === "string") {
      modules = [[null, modules, undefined]];
    }

    var alreadyImportedModules = {};

    if (dedupe) {
      for (var k = 0; k < this.length; k++) {
        var id = this[k][0];

        if (id != null) {
          alreadyImportedModules[id] = true;
        }
      }
    }

    for (var _k = 0; _k < modules.length; _k++) {
      var item = [].concat(modules[_k]);

      if (dedupe && alreadyImportedModules[item[0]]) {
        continue;
      }

      if (typeof layer !== "undefined") {
        if (typeof item[5] === "undefined") {
          item[5] = layer;
        } else {
          item[1] = "@layer".concat(item[5].length > 0 ? " ".concat(item[5]) : "", " {").concat(item[1], "}");
          item[5] = layer;
        }
      }

      if (media) {
        if (!item[2]) {
          item[2] = media;
        } else {
          item[1] = "@media ".concat(item[2], " {").concat(item[1], "}");
          item[2] = media;
        }
      }

      if (supports) {
        if (!item[4]) {
          item[4] = "".concat(supports);
        } else {
          item[1] = "@supports (".concat(item[4], ") {").concat(item[1], "}");
          item[4] = supports;
        }
      }

      list.push(item);
    }
  };

  return list;
};

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/getUrl.js":
/*!********************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/getUrl.js ***!
  \********************************************************/
/***/ ((module) => {

"use strict";


module.exports = function (url, options) {
  if (!options) {
    options = {};
  }

  if (!url) {
    return url;
  }

  url = String(url.__esModule ? url.default : url); // If url is already wrapped in quotes, remove them

  if (/^['"].*['"]$/.test(url)) {
    url = url.slice(1, -1);
  }

  if (options.hash) {
    url += options.hash;
  } // Should url be wrapped?
  // See https://drafts.csswg.org/css-values-3/#urls


  if (/["'() \t\n]|(%20)/.test(url) || options.needQuotes) {
    return "\"".concat(url.replace(/"/g, '\\"').replace(/\n/g, "\\n"), "\"");
  }

  return url;
};

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/sourceMaps.js":
/*!************************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/sourceMaps.js ***!
  \************************************************************/
/***/ ((module) => {

"use strict";


module.exports = function (item) {
  var content = item[1];
  var cssMapping = item[3];

  if (!cssMapping) {
    return content;
  }

  if (typeof btoa === "function") {
    var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(cssMapping))));
    var data = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(base64);
    var sourceMapping = "/*# ".concat(data, " */");
    var sourceURLs = cssMapping.sources.map(function (source) {
      return "/*# sourceURL=".concat(cssMapping.sourceRoot || "").concat(source, " */");
    });
    return [content].concat(sourceURLs).concat([sourceMapping]).join("\n");
  }

  return [content].join("\n");
};

/***/ }),

/***/ "./node_modules/firebase/app/dist/index.esm.js":
/*!*****************************************************!*\
  !*** ./node_modules/firebase/app/dist/index.esm.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FirebaseError": () => (/* reexport safe */ _firebase_app__WEBPACK_IMPORTED_MODULE_0__.FirebaseError),
/* harmony export */   "SDK_VERSION": () => (/* reexport safe */ _firebase_app__WEBPACK_IMPORTED_MODULE_0__.SDK_VERSION),
/* harmony export */   "_DEFAULT_ENTRY_NAME": () => (/* reexport safe */ _firebase_app__WEBPACK_IMPORTED_MODULE_0__._DEFAULT_ENTRY_NAME),
/* harmony export */   "_addComponent": () => (/* reexport safe */ _firebase_app__WEBPACK_IMPORTED_MODULE_0__._addComponent),
/* harmony export */   "_addOrOverwriteComponent": () => (/* reexport safe */ _firebase_app__WEBPACK_IMPORTED_MODULE_0__._addOrOverwriteComponent),
/* harmony export */   "_apps": () => (/* reexport safe */ _firebase_app__WEBPACK_IMPORTED_MODULE_0__._apps),
/* harmony export */   "_clearComponents": () => (/* reexport safe */ _firebase_app__WEBPACK_IMPORTED_MODULE_0__._clearComponents),
/* harmony export */   "_components": () => (/* reexport safe */ _firebase_app__WEBPACK_IMPORTED_MODULE_0__._components),
/* harmony export */   "_getProvider": () => (/* reexport safe */ _firebase_app__WEBPACK_IMPORTED_MODULE_0__._getProvider),
/* harmony export */   "_registerComponent": () => (/* reexport safe */ _firebase_app__WEBPACK_IMPORTED_MODULE_0__._registerComponent),
/* harmony export */   "_removeServiceInstance": () => (/* reexport safe */ _firebase_app__WEBPACK_IMPORTED_MODULE_0__._removeServiceInstance),
/* harmony export */   "deleteApp": () => (/* reexport safe */ _firebase_app__WEBPACK_IMPORTED_MODULE_0__.deleteApp),
/* harmony export */   "getApp": () => (/* reexport safe */ _firebase_app__WEBPACK_IMPORTED_MODULE_0__.getApp),
/* harmony export */   "getApps": () => (/* reexport safe */ _firebase_app__WEBPACK_IMPORTED_MODULE_0__.getApps),
/* harmony export */   "initializeApp": () => (/* reexport safe */ _firebase_app__WEBPACK_IMPORTED_MODULE_0__.initializeApp),
/* harmony export */   "onLog": () => (/* reexport safe */ _firebase_app__WEBPACK_IMPORTED_MODULE_0__.onLog),
/* harmony export */   "registerVersion": () => (/* reexport safe */ _firebase_app__WEBPACK_IMPORTED_MODULE_0__.registerVersion),
/* harmony export */   "setLogLevel": () => (/* reexport safe */ _firebase_app__WEBPACK_IMPORTED_MODULE_0__.setLogLevel)
/* harmony export */ });
/* harmony import */ var _firebase_app__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @firebase/app */ "./node_modules/@firebase/app/dist/esm/index.esm2017.js");



var name = "firebase";
var version = "9.6.8";

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
(0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__.registerVersion)(name, version, 'app');
//# sourceMappingURL=index.esm.js.map


/***/ }),

/***/ "./node_modules/firebase/database/dist/index.esm.js":
/*!**********************************************************!*\
  !*** ./node_modules/firebase/database/dist/index.esm.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DataSnapshot": () => (/* reexport safe */ _firebase_database__WEBPACK_IMPORTED_MODULE_0__.DataSnapshot),
/* harmony export */   "Database": () => (/* reexport safe */ _firebase_database__WEBPACK_IMPORTED_MODULE_0__.Database),
/* harmony export */   "OnDisconnect": () => (/* reexport safe */ _firebase_database__WEBPACK_IMPORTED_MODULE_0__.OnDisconnect),
/* harmony export */   "QueryConstraint": () => (/* reexport safe */ _firebase_database__WEBPACK_IMPORTED_MODULE_0__.QueryConstraint),
/* harmony export */   "TransactionResult": () => (/* reexport safe */ _firebase_database__WEBPACK_IMPORTED_MODULE_0__.TransactionResult),
/* harmony export */   "_QueryImpl": () => (/* reexport safe */ _firebase_database__WEBPACK_IMPORTED_MODULE_0__._QueryImpl),
/* harmony export */   "_QueryParams": () => (/* reexport safe */ _firebase_database__WEBPACK_IMPORTED_MODULE_0__._QueryParams),
/* harmony export */   "_ReferenceImpl": () => (/* reexport safe */ _firebase_database__WEBPACK_IMPORTED_MODULE_0__._ReferenceImpl),
/* harmony export */   "_TEST_ACCESS_forceRestClient": () => (/* reexport safe */ _firebase_database__WEBPACK_IMPORTED_MODULE_0__._TEST_ACCESS_forceRestClient),
/* harmony export */   "_TEST_ACCESS_hijackHash": () => (/* reexport safe */ _firebase_database__WEBPACK_IMPORTED_MODULE_0__._TEST_ACCESS_hijackHash),
/* harmony export */   "_repoManagerDatabaseFromApp": () => (/* reexport safe */ _firebase_database__WEBPACK_IMPORTED_MODULE_0__._repoManagerDatabaseFromApp),
/* harmony export */   "_setSDKVersion": () => (/* reexport safe */ _firebase_database__WEBPACK_IMPORTED_MODULE_0__._setSDKVersion),
/* harmony export */   "_validatePathString": () => (/* reexport safe */ _firebase_database__WEBPACK_IMPORTED_MODULE_0__._validatePathString),
/* harmony export */   "_validateWritablePath": () => (/* reexport safe */ _firebase_database__WEBPACK_IMPORTED_MODULE_0__._validateWritablePath),
/* harmony export */   "child": () => (/* reexport safe */ _firebase_database__WEBPACK_IMPORTED_MODULE_0__.child),
/* harmony export */   "connectDatabaseEmulator": () => (/* reexport safe */ _firebase_database__WEBPACK_IMPORTED_MODULE_0__.connectDatabaseEmulator),
/* harmony export */   "enableLogging": () => (/* reexport safe */ _firebase_database__WEBPACK_IMPORTED_MODULE_0__.enableLogging),
/* harmony export */   "endAt": () => (/* reexport safe */ _firebase_database__WEBPACK_IMPORTED_MODULE_0__.endAt),
/* harmony export */   "endBefore": () => (/* reexport safe */ _firebase_database__WEBPACK_IMPORTED_MODULE_0__.endBefore),
/* harmony export */   "equalTo": () => (/* reexport safe */ _firebase_database__WEBPACK_IMPORTED_MODULE_0__.equalTo),
/* harmony export */   "get": () => (/* reexport safe */ _firebase_database__WEBPACK_IMPORTED_MODULE_0__.get),
/* harmony export */   "getDatabase": () => (/* reexport safe */ _firebase_database__WEBPACK_IMPORTED_MODULE_0__.getDatabase),
/* harmony export */   "goOffline": () => (/* reexport safe */ _firebase_database__WEBPACK_IMPORTED_MODULE_0__.goOffline),
/* harmony export */   "goOnline": () => (/* reexport safe */ _firebase_database__WEBPACK_IMPORTED_MODULE_0__.goOnline),
/* harmony export */   "increment": () => (/* reexport safe */ _firebase_database__WEBPACK_IMPORTED_MODULE_0__.increment),
/* harmony export */   "limitToFirst": () => (/* reexport safe */ _firebase_database__WEBPACK_IMPORTED_MODULE_0__.limitToFirst),
/* harmony export */   "limitToLast": () => (/* reexport safe */ _firebase_database__WEBPACK_IMPORTED_MODULE_0__.limitToLast),
/* harmony export */   "off": () => (/* reexport safe */ _firebase_database__WEBPACK_IMPORTED_MODULE_0__.off),
/* harmony export */   "onChildAdded": () => (/* reexport safe */ _firebase_database__WEBPACK_IMPORTED_MODULE_0__.onChildAdded),
/* harmony export */   "onChildChanged": () => (/* reexport safe */ _firebase_database__WEBPACK_IMPORTED_MODULE_0__.onChildChanged),
/* harmony export */   "onChildMoved": () => (/* reexport safe */ _firebase_database__WEBPACK_IMPORTED_MODULE_0__.onChildMoved),
/* harmony export */   "onChildRemoved": () => (/* reexport safe */ _firebase_database__WEBPACK_IMPORTED_MODULE_0__.onChildRemoved),
/* harmony export */   "onDisconnect": () => (/* reexport safe */ _firebase_database__WEBPACK_IMPORTED_MODULE_0__.onDisconnect),
/* harmony export */   "onValue": () => (/* reexport safe */ _firebase_database__WEBPACK_IMPORTED_MODULE_0__.onValue),
/* harmony export */   "orderByChild": () => (/* reexport safe */ _firebase_database__WEBPACK_IMPORTED_MODULE_0__.orderByChild),
/* harmony export */   "orderByKey": () => (/* reexport safe */ _firebase_database__WEBPACK_IMPORTED_MODULE_0__.orderByKey),
/* harmony export */   "orderByPriority": () => (/* reexport safe */ _firebase_database__WEBPACK_IMPORTED_MODULE_0__.orderByPriority),
/* harmony export */   "orderByValue": () => (/* reexport safe */ _firebase_database__WEBPACK_IMPORTED_MODULE_0__.orderByValue),
/* harmony export */   "push": () => (/* reexport safe */ _firebase_database__WEBPACK_IMPORTED_MODULE_0__.push),
/* harmony export */   "query": () => (/* reexport safe */ _firebase_database__WEBPACK_IMPORTED_MODULE_0__.query),
/* harmony export */   "ref": () => (/* reexport safe */ _firebase_database__WEBPACK_IMPORTED_MODULE_0__.ref),
/* harmony export */   "refFromURL": () => (/* reexport safe */ _firebase_database__WEBPACK_IMPORTED_MODULE_0__.refFromURL),
/* harmony export */   "remove": () => (/* reexport safe */ _firebase_database__WEBPACK_IMPORTED_MODULE_0__.remove),
/* harmony export */   "runTransaction": () => (/* reexport safe */ _firebase_database__WEBPACK_IMPORTED_MODULE_0__.runTransaction),
/* harmony export */   "serverTimestamp": () => (/* reexport safe */ _firebase_database__WEBPACK_IMPORTED_MODULE_0__.serverTimestamp),
/* harmony export */   "set": () => (/* reexport safe */ _firebase_database__WEBPACK_IMPORTED_MODULE_0__.set),
/* harmony export */   "setPriority": () => (/* reexport safe */ _firebase_database__WEBPACK_IMPORTED_MODULE_0__.setPriority),
/* harmony export */   "setWithPriority": () => (/* reexport safe */ _firebase_database__WEBPACK_IMPORTED_MODULE_0__.setWithPriority),
/* harmony export */   "startAfter": () => (/* reexport safe */ _firebase_database__WEBPACK_IMPORTED_MODULE_0__.startAfter),
/* harmony export */   "startAt": () => (/* reexport safe */ _firebase_database__WEBPACK_IMPORTED_MODULE_0__.startAt),
/* harmony export */   "update": () => (/* reexport safe */ _firebase_database__WEBPACK_IMPORTED_MODULE_0__.update)
/* harmony export */ });
/* harmony import */ var _firebase_database__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @firebase/database */ "./node_modules/@firebase/database/dist/index.esm2017.js");

//# sourceMappingURL=index.esm.js.map


/***/ }),

/***/ "./node_modules/idb/build/idb.js":
/*!***************************************!*\
  !*** ./node_modules/idb/build/idb.js ***!
  \***************************************/
/***/ (function(__unused_webpack_module, exports) {

(function (global, factory) {
   true ? factory(exports) :
  0;
}(this, function (exports) { 'use strict';

  function toArray(arr) {
    return Array.prototype.slice.call(arr);
  }

  function promisifyRequest(request) {
    return new Promise(function(resolve, reject) {
      request.onsuccess = function() {
        resolve(request.result);
      };

      request.onerror = function() {
        reject(request.error);
      };
    });
  }

  function promisifyRequestCall(obj, method, args) {
    var request;
    var p = new Promise(function(resolve, reject) {
      request = obj[method].apply(obj, args);
      promisifyRequest(request).then(resolve, reject);
    });

    p.request = request;
    return p;
  }

  function promisifyCursorRequestCall(obj, method, args) {
    var p = promisifyRequestCall(obj, method, args);
    return p.then(function(value) {
      if (!value) return;
      return new Cursor(value, p.request);
    });
  }

  function proxyProperties(ProxyClass, targetProp, properties) {
    properties.forEach(function(prop) {
      Object.defineProperty(ProxyClass.prototype, prop, {
        get: function() {
          return this[targetProp][prop];
        },
        set: function(val) {
          this[targetProp][prop] = val;
        }
      });
    });
  }

  function proxyRequestMethods(ProxyClass, targetProp, Constructor, properties) {
    properties.forEach(function(prop) {
      if (!(prop in Constructor.prototype)) return;
      ProxyClass.prototype[prop] = function() {
        return promisifyRequestCall(this[targetProp], prop, arguments);
      };
    });
  }

  function proxyMethods(ProxyClass, targetProp, Constructor, properties) {
    properties.forEach(function(prop) {
      if (!(prop in Constructor.prototype)) return;
      ProxyClass.prototype[prop] = function() {
        return this[targetProp][prop].apply(this[targetProp], arguments);
      };
    });
  }

  function proxyCursorRequestMethods(ProxyClass, targetProp, Constructor, properties) {
    properties.forEach(function(prop) {
      if (!(prop in Constructor.prototype)) return;
      ProxyClass.prototype[prop] = function() {
        return promisifyCursorRequestCall(this[targetProp], prop, arguments);
      };
    });
  }

  function Index(index) {
    this._index = index;
  }

  proxyProperties(Index, '_index', [
    'name',
    'keyPath',
    'multiEntry',
    'unique'
  ]);

  proxyRequestMethods(Index, '_index', IDBIndex, [
    'get',
    'getKey',
    'getAll',
    'getAllKeys',
    'count'
  ]);

  proxyCursorRequestMethods(Index, '_index', IDBIndex, [
    'openCursor',
    'openKeyCursor'
  ]);

  function Cursor(cursor, request) {
    this._cursor = cursor;
    this._request = request;
  }

  proxyProperties(Cursor, '_cursor', [
    'direction',
    'key',
    'primaryKey',
    'value'
  ]);

  proxyRequestMethods(Cursor, '_cursor', IDBCursor, [
    'update',
    'delete'
  ]);

  // proxy 'next' methods
  ['advance', 'continue', 'continuePrimaryKey'].forEach(function(methodName) {
    if (!(methodName in IDBCursor.prototype)) return;
    Cursor.prototype[methodName] = function() {
      var cursor = this;
      var args = arguments;
      return Promise.resolve().then(function() {
        cursor._cursor[methodName].apply(cursor._cursor, args);
        return promisifyRequest(cursor._request).then(function(value) {
          if (!value) return;
          return new Cursor(value, cursor._request);
        });
      });
    };
  });

  function ObjectStore(store) {
    this._store = store;
  }

  ObjectStore.prototype.createIndex = function() {
    return new Index(this._store.createIndex.apply(this._store, arguments));
  };

  ObjectStore.prototype.index = function() {
    return new Index(this._store.index.apply(this._store, arguments));
  };

  proxyProperties(ObjectStore, '_store', [
    'name',
    'keyPath',
    'indexNames',
    'autoIncrement'
  ]);

  proxyRequestMethods(ObjectStore, '_store', IDBObjectStore, [
    'put',
    'add',
    'delete',
    'clear',
    'get',
    'getAll',
    'getKey',
    'getAllKeys',
    'count'
  ]);

  proxyCursorRequestMethods(ObjectStore, '_store', IDBObjectStore, [
    'openCursor',
    'openKeyCursor'
  ]);

  proxyMethods(ObjectStore, '_store', IDBObjectStore, [
    'deleteIndex'
  ]);

  function Transaction(idbTransaction) {
    this._tx = idbTransaction;
    this.complete = new Promise(function(resolve, reject) {
      idbTransaction.oncomplete = function() {
        resolve();
      };
      idbTransaction.onerror = function() {
        reject(idbTransaction.error);
      };
      idbTransaction.onabort = function() {
        reject(idbTransaction.error);
      };
    });
  }

  Transaction.prototype.objectStore = function() {
    return new ObjectStore(this._tx.objectStore.apply(this._tx, arguments));
  };

  proxyProperties(Transaction, '_tx', [
    'objectStoreNames',
    'mode'
  ]);

  proxyMethods(Transaction, '_tx', IDBTransaction, [
    'abort'
  ]);

  function UpgradeDB(db, oldVersion, transaction) {
    this._db = db;
    this.oldVersion = oldVersion;
    this.transaction = new Transaction(transaction);
  }

  UpgradeDB.prototype.createObjectStore = function() {
    return new ObjectStore(this._db.createObjectStore.apply(this._db, arguments));
  };

  proxyProperties(UpgradeDB, '_db', [
    'name',
    'version',
    'objectStoreNames'
  ]);

  proxyMethods(UpgradeDB, '_db', IDBDatabase, [
    'deleteObjectStore',
    'close'
  ]);

  function DB(db) {
    this._db = db;
  }

  DB.prototype.transaction = function() {
    return new Transaction(this._db.transaction.apply(this._db, arguments));
  };

  proxyProperties(DB, '_db', [
    'name',
    'version',
    'objectStoreNames'
  ]);

  proxyMethods(DB, '_db', IDBDatabase, [
    'close'
  ]);

  // Add cursor iterators
  // TODO: remove this once browsers do the right thing with promises
  ['openCursor', 'openKeyCursor'].forEach(function(funcName) {
    [ObjectStore, Index].forEach(function(Constructor) {
      // Don't create iterateKeyCursor if openKeyCursor doesn't exist.
      if (!(funcName in Constructor.prototype)) return;

      Constructor.prototype[funcName.replace('open', 'iterate')] = function() {
        var args = toArray(arguments);
        var callback = args[args.length - 1];
        var nativeObject = this._store || this._index;
        var request = nativeObject[funcName].apply(nativeObject, args.slice(0, -1));
        request.onsuccess = function() {
          callback(request.result);
        };
      };
    });
  });

  // polyfill getAll
  [Index, ObjectStore].forEach(function(Constructor) {
    if (Constructor.prototype.getAll) return;
    Constructor.prototype.getAll = function(query, count) {
      var instance = this;
      var items = [];

      return new Promise(function(resolve) {
        instance.iterateCursor(query, function(cursor) {
          if (!cursor) {
            resolve(items);
            return;
          }
          items.push(cursor.value);

          if (count !== undefined && items.length == count) {
            resolve(items);
            return;
          }
          cursor.continue();
        });
      });
    };
  });

  function openDb(name, version, upgradeCallback) {
    var p = promisifyRequestCall(indexedDB, 'open', [name, version]);
    var request = p.request;

    if (request) {
      request.onupgradeneeded = function(event) {
        if (upgradeCallback) {
          upgradeCallback(new UpgradeDB(request.result, event.oldVersion, request.transaction));
        }
      };
    }

    return p.then(function(db) {
      return new DB(db);
    });
  }

  function deleteDb(name) {
    return promisifyRequestCall(indexedDB, 'deleteDatabase', [name]);
  }

  exports.openDb = openDb;
  exports.deleteDb = deleteDb;

  Object.defineProperty(exports, '__esModule', { value: true });

}));


/***/ }),

/***/ "./src/sass/index.sass":
/*!*****************************!*\
  !*** ./src/sass/index.sass ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/styleDomAPI.js */ "./node_modules/style-loader/dist/runtime/styleDomAPI.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/insertBySelector.js */ "./node_modules/style-loader/dist/runtime/insertBySelector.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js */ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/insertStyleElement.js */ "./node_modules/style-loader/dist/runtime/insertStyleElement.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/styleTagTransform.js */ "./node_modules/style-loader/dist/runtime/styleTagTransform.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_node_modules_sass_loader_dist_cjs_js_index_sass__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! !!../../node_modules/css-loader/dist/cjs.js!../../node_modules/sass-loader/dist/cjs.js!./index.sass */ "./node_modules/css-loader/dist/cjs.js!./node_modules/sass-loader/dist/cjs.js!./src/sass/index.sass");

      
      
      
      
      
      
      
      
      

var options = {};

options.styleTagTransform = (_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());
options.setAttributes = (_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default());

      options.insert = _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, "head");
    
options.domAPI = (_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());
options.insertStyleElement = (_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());

var update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_node_modules_sass_loader_dist_cjs_js_index_sass__WEBPACK_IMPORTED_MODULE_6__["default"], options);




       /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_css_loader_dist_cjs_js_node_modules_sass_loader_dist_cjs_js_index_sass__WEBPACK_IMPORTED_MODULE_6__["default"] && _node_modules_css_loader_dist_cjs_js_node_modules_sass_loader_dist_cjs_js_index_sass__WEBPACK_IMPORTED_MODULE_6__["default"].locals ? _node_modules_css_loader_dist_cjs_js_node_modules_sass_loader_dist_cjs_js_index_sass__WEBPACK_IMPORTED_MODULE_6__["default"].locals : undefined);


/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js":
/*!****************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js ***!
  \****************************************************************************/
/***/ ((module) => {

"use strict";


var stylesInDOM = [];

function getIndexByIdentifier(identifier) {
  var result = -1;

  for (var i = 0; i < stylesInDOM.length; i++) {
    if (stylesInDOM[i].identifier === identifier) {
      result = i;
      break;
    }
  }

  return result;
}

function modulesToDom(list, options) {
  var idCountMap = {};
  var identifiers = [];

  for (var i = 0; i < list.length; i++) {
    var item = list[i];
    var id = options.base ? item[0] + options.base : item[0];
    var count = idCountMap[id] || 0;
    var identifier = "".concat(id, " ").concat(count);
    idCountMap[id] = count + 1;
    var indexByIdentifier = getIndexByIdentifier(identifier);
    var obj = {
      css: item[1],
      media: item[2],
      sourceMap: item[3],
      supports: item[4],
      layer: item[5]
    };

    if (indexByIdentifier !== -1) {
      stylesInDOM[indexByIdentifier].references++;
      stylesInDOM[indexByIdentifier].updater(obj);
    } else {
      var updater = addElementStyle(obj, options);
      options.byIndex = i;
      stylesInDOM.splice(i, 0, {
        identifier: identifier,
        updater: updater,
        references: 1
      });
    }

    identifiers.push(identifier);
  }

  return identifiers;
}

function addElementStyle(obj, options) {
  var api = options.domAPI(options);
  api.update(obj);

  var updater = function updater(newObj) {
    if (newObj) {
      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap && newObj.supports === obj.supports && newObj.layer === obj.layer) {
        return;
      }

      api.update(obj = newObj);
    } else {
      api.remove();
    }
  };

  return updater;
}

module.exports = function (list, options) {
  options = options || {};
  list = list || [];
  var lastIdentifiers = modulesToDom(list, options);
  return function update(newList) {
    newList = newList || [];

    for (var i = 0; i < lastIdentifiers.length; i++) {
      var identifier = lastIdentifiers[i];
      var index = getIndexByIdentifier(identifier);
      stylesInDOM[index].references--;
    }

    var newLastIdentifiers = modulesToDom(newList, options);

    for (var _i = 0; _i < lastIdentifiers.length; _i++) {
      var _identifier = lastIdentifiers[_i];

      var _index = getIndexByIdentifier(_identifier);

      if (stylesInDOM[_index].references === 0) {
        stylesInDOM[_index].updater();

        stylesInDOM.splice(_index, 1);
      }
    }

    lastIdentifiers = newLastIdentifiers;
  };
};

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertBySelector.js":
/*!********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertBySelector.js ***!
  \********************************************************************/
/***/ ((module) => {

"use strict";


var memo = {};
/* istanbul ignore next  */

function getTarget(target) {
  if (typeof memo[target] === "undefined") {
    var styleTarget = document.querySelector(target); // Special case to return head of iframe instead of iframe itself

    if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {
      try {
        // This will throw an exception if access to iframe is blocked
        // due to cross-origin restrictions
        styleTarget = styleTarget.contentDocument.head;
      } catch (e) {
        // istanbul ignore next
        styleTarget = null;
      }
    }

    memo[target] = styleTarget;
  }

  return memo[target];
}
/* istanbul ignore next  */


function insertBySelector(insert, style) {
  var target = getTarget(insert);

  if (!target) {
    throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");
  }

  target.appendChild(style);
}

module.exports = insertBySelector;

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertStyleElement.js":
/*!**********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertStyleElement.js ***!
  \**********************************************************************/
/***/ ((module) => {

"use strict";


/* istanbul ignore next  */
function insertStyleElement(options) {
  var element = document.createElement("style");
  options.setAttributes(element, options.attributes);
  options.insert(element, options.options);
  return element;
}

module.exports = insertStyleElement;

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


/* istanbul ignore next  */
function setAttributesWithoutAttributes(styleElement) {
  var nonce =  true ? __webpack_require__.nc : 0;

  if (nonce) {
    styleElement.setAttribute("nonce", nonce);
  }
}

module.exports = setAttributesWithoutAttributes;

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleDomAPI.js":
/*!***************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleDomAPI.js ***!
  \***************************************************************/
/***/ ((module) => {

"use strict";


/* istanbul ignore next  */
function apply(styleElement, options, obj) {
  var css = "";

  if (obj.supports) {
    css += "@supports (".concat(obj.supports, ") {");
  }

  if (obj.media) {
    css += "@media ".concat(obj.media, " {");
  }

  var needLayer = typeof obj.layer !== "undefined";

  if (needLayer) {
    css += "@layer".concat(obj.layer.length > 0 ? " ".concat(obj.layer) : "", " {");
  }

  css += obj.css;

  if (needLayer) {
    css += "}";
  }

  if (obj.media) {
    css += "}";
  }

  if (obj.supports) {
    css += "}";
  }

  var sourceMap = obj.sourceMap;

  if (sourceMap && typeof btoa !== "undefined") {
    css += "\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), " */");
  } // For old IE

  /* istanbul ignore if  */


  options.styleTagTransform(css, styleElement, options.options);
}

function removeStyleElement(styleElement) {
  // istanbul ignore if
  if (styleElement.parentNode === null) {
    return false;
  }

  styleElement.parentNode.removeChild(styleElement);
}
/* istanbul ignore next  */


function domAPI(options) {
  var styleElement = options.insertStyleElement(options);
  return {
    update: function update(obj) {
      apply(styleElement, options, obj);
    },
    remove: function remove() {
      removeStyleElement(styleElement);
    }
  };
}

module.exports = domAPI;

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleTagTransform.js":
/*!*********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleTagTransform.js ***!
  \*********************************************************************/
/***/ ((module) => {

"use strict";


/* istanbul ignore next  */
function styleTagTransform(css, styleElement) {
  if (styleElement.styleSheet) {
    styleElement.styleSheet.cssText = css;
  } else {
    while (styleElement.firstChild) {
      styleElement.removeChild(styleElement.firstChild);
    }

    styleElement.appendChild(document.createTextNode(css));
  }
}

module.exports = styleTagTransform;

/***/ }),

/***/ "./node_modules/typed.js/lib/typed.js":
/*!********************************************!*\
  !*** ./node_modules/typed.js/lib/typed.js ***!
  \********************************************/
/***/ (function(module) {

/*!
 * 
 *   typed.js - A JavaScript Typing Animation Library
 *   Author: Matt Boldt <me@mattboldt.com>
 *   Version: v2.0.12
 *   Url: https://github.com/mattboldt/typed.js
 *   License(s): MIT
 * 
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(true)
		module.exports = factory();
	else {}
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __nested_webpack_require_737__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __nested_webpack_require_737__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__nested_webpack_require_737__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__nested_webpack_require_737__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__nested_webpack_require_737__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __nested_webpack_require_737__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __nested_webpack_require_2018__) {

	'use strict';
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	
	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	var _initializerJs = __nested_webpack_require_2018__(1);
	
	var _htmlParserJs = __nested_webpack_require_2018__(3);
	
	/**
	 * Welcome to Typed.js!
	 * @param {string} elementId HTML element ID _OR_ HTML element
	 * @param {object} options options object
	 * @returns {object} a new Typed object
	 */
	
	var Typed = (function () {
	  function Typed(elementId, options) {
	    _classCallCheck(this, Typed);
	
	    // Initialize it up
	    _initializerJs.initializer.load(this, options, elementId);
	    // All systems go!
	    this.begin();
	  }
	
	  /**
	   * Toggle start() and stop() of the Typed instance
	   * @public
	   */
	
	  _createClass(Typed, [{
	    key: 'toggle',
	    value: function toggle() {
	      this.pause.status ? this.start() : this.stop();
	    }
	
	    /**
	     * Stop typing / backspacing and enable cursor blinking
	     * @public
	     */
	  }, {
	    key: 'stop',
	    value: function stop() {
	      if (this.typingComplete) return;
	      if (this.pause.status) return;
	      this.toggleBlinking(true);
	      this.pause.status = true;
	      this.options.onStop(this.arrayPos, this);
	    }
	
	    /**
	     * Start typing / backspacing after being stopped
	     * @public
	     */
	  }, {
	    key: 'start',
	    value: function start() {
	      if (this.typingComplete) return;
	      if (!this.pause.status) return;
	      this.pause.status = false;
	      if (this.pause.typewrite) {
	        this.typewrite(this.pause.curString, this.pause.curStrPos);
	      } else {
	        this.backspace(this.pause.curString, this.pause.curStrPos);
	      }
	      this.options.onStart(this.arrayPos, this);
	    }
	
	    /**
	     * Destroy this instance of Typed
	     * @public
	     */
	  }, {
	    key: 'destroy',
	    value: function destroy() {
	      this.reset(false);
	      this.options.onDestroy(this);
	    }
	
	    /**
	     * Reset Typed and optionally restarts
	     * @param {boolean} restart
	     * @public
	     */
	  }, {
	    key: 'reset',
	    value: function reset() {
	      var restart = arguments.length <= 0 || arguments[0] === undefined ? true : arguments[0];
	
	      clearInterval(this.timeout);
	      this.replaceText('');
	      if (this.cursor && this.cursor.parentNode) {
	        this.cursor.parentNode.removeChild(this.cursor);
	        this.cursor = null;
	      }
	      this.strPos = 0;
	      this.arrayPos = 0;
	      this.curLoop = 0;
	      if (restart) {
	        this.insertCursor();
	        this.options.onReset(this);
	        this.begin();
	      }
	    }
	
	    /**
	     * Begins the typing animation
	     * @private
	     */
	  }, {
	    key: 'begin',
	    value: function begin() {
	      var _this = this;
	
	      this.options.onBegin(this);
	      this.typingComplete = false;
	      this.shuffleStringsIfNeeded(this);
	      this.insertCursor();
	      if (this.bindInputFocusEvents) this.bindFocusEvents();
	      this.timeout = setTimeout(function () {
	        // Check if there is some text in the element, if yes start by backspacing the default message
	        if (!_this.currentElContent || _this.currentElContent.length === 0) {
	          _this.typewrite(_this.strings[_this.sequence[_this.arrayPos]], _this.strPos);
	        } else {
	          // Start typing
	          _this.backspace(_this.currentElContent, _this.currentElContent.length);
	        }
	      }, this.startDelay);
	    }
	
	    /**
	     * Called for each character typed
	     * @param {string} curString the current string in the strings array
	     * @param {number} curStrPos the current position in the curString
	     * @private
	     */
	  }, {
	    key: 'typewrite',
	    value: function typewrite(curString, curStrPos) {
	      var _this2 = this;
	
	      if (this.fadeOut && this.el.classList.contains(this.fadeOutClass)) {
	        this.el.classList.remove(this.fadeOutClass);
	        if (this.cursor) this.cursor.classList.remove(this.fadeOutClass);
	      }
	
	      var humanize = this.humanizer(this.typeSpeed);
	      var numChars = 1;
	
	      if (this.pause.status === true) {
	        this.setPauseStatus(curString, curStrPos, true);
	        return;
	      }
	
	      // contain typing function in a timeout humanize'd delay
	      this.timeout = setTimeout(function () {
	        // skip over any HTML chars
	        curStrPos = _htmlParserJs.htmlParser.typeHtmlChars(curString, curStrPos, _this2);
	
	        var pauseTime = 0;
	        var substr = curString.substr(curStrPos);
	        // check for an escape character before a pause value
	        // format: \^\d+ .. eg: ^1000 .. should be able to print the ^ too using ^^
	        // single ^ are removed from string
	        if (substr.charAt(0) === '^') {
	          if (/^\^\d+/.test(substr)) {
	            var skip = 1; // skip at least 1
	            substr = /\d+/.exec(substr)[0];
	            skip += substr.length;
	            pauseTime = parseInt(substr);
	            _this2.temporaryPause = true;
	            _this2.options.onTypingPaused(_this2.arrayPos, _this2);
	            // strip out the escape character and pause value so they're not printed
	            curString = curString.substring(0, curStrPos) + curString.substring(curStrPos + skip);
	            _this2.toggleBlinking(true);
	          }
	        }
	
	        // check for skip characters formatted as
	        // "this is a `string to print NOW` ..."
	        if (substr.charAt(0) === '`') {
	          while (curString.substr(curStrPos + numChars).charAt(0) !== '`') {
	            numChars++;
	            if (curStrPos + numChars > curString.length) break;
	          }
	          // strip out the escape characters and append all the string in between
	          var stringBeforeSkip = curString.substring(0, curStrPos);
	          var stringSkipped = curString.substring(stringBeforeSkip.length + 1, curStrPos + numChars);
	          var stringAfterSkip = curString.substring(curStrPos + numChars + 1);
	          curString = stringBeforeSkip + stringSkipped + stringAfterSkip;
	          numChars--;
	        }
	
	        // timeout for any pause after a character
	        _this2.timeout = setTimeout(function () {
	          // Accounts for blinking while paused
	          _this2.toggleBlinking(false);
	
	          // We're done with this sentence!
	          if (curStrPos >= curString.length) {
	            _this2.doneTyping(curString, curStrPos);
	          } else {
	            _this2.keepTyping(curString, curStrPos, numChars);
	          }
	          // end of character pause
	          if (_this2.temporaryPause) {
	            _this2.temporaryPause = false;
	            _this2.options.onTypingResumed(_this2.arrayPos, _this2);
	          }
	        }, pauseTime);
	
	        // humanized value for typing
	      }, humanize);
	    }
	
	    /**
	     * Continue to the next string & begin typing
	     * @param {string} curString the current string in the strings array
	     * @param {number} curStrPos the current position in the curString
	     * @private
	     */
	  }, {
	    key: 'keepTyping',
	    value: function keepTyping(curString, curStrPos, numChars) {
	      // call before functions if applicable
	      if (curStrPos === 0) {
	        this.toggleBlinking(false);
	        this.options.preStringTyped(this.arrayPos, this);
	      }
	      // start typing each new char into existing string
	      // curString: arg, this.el.html: original text inside element
	      curStrPos += numChars;
	      var nextString = curString.substr(0, curStrPos);
	      this.replaceText(nextString);
	      // loop the function
	      this.typewrite(curString, curStrPos);
	    }
	
	    /**
	     * We're done typing the current string
	     * @param {string} curString the current string in the strings array
	     * @param {number} curStrPos the current position in the curString
	     * @private
	     */
	  }, {
	    key: 'doneTyping',
	    value: function doneTyping(curString, curStrPos) {
	      var _this3 = this;
	
	      // fires callback function
	      this.options.onStringTyped(this.arrayPos, this);
	      this.toggleBlinking(true);
	      // is this the final string
	      if (this.arrayPos === this.strings.length - 1) {
	        // callback that occurs on the last typed string
	        this.complete();
	        // quit if we wont loop back
	        if (this.loop === false || this.curLoop === this.loopCount) {
	          return;
	        }
	      }
	      this.timeout = setTimeout(function () {
	        _this3.backspace(curString, curStrPos);
	      }, this.backDelay);
	    }
	
	    /**
	     * Backspaces 1 character at a time
	     * @param {string} curString the current string in the strings array
	     * @param {number} curStrPos the current position in the curString
	     * @private
	     */
	  }, {
	    key: 'backspace',
	    value: function backspace(curString, curStrPos) {
	      var _this4 = this;
	
	      if (this.pause.status === true) {
	        this.setPauseStatus(curString, curStrPos, false);
	        return;
	      }
	      if (this.fadeOut) return this.initFadeOut();
	
	      this.toggleBlinking(false);
	      var humanize = this.humanizer(this.backSpeed);
	
	      this.timeout = setTimeout(function () {
	        curStrPos = _htmlParserJs.htmlParser.backSpaceHtmlChars(curString, curStrPos, _this4);
	        // replace text with base text + typed characters
	        var curStringAtPosition = curString.substr(0, curStrPos);
	        _this4.replaceText(curStringAtPosition);
	
	        // if smartBack is enabled
	        if (_this4.smartBackspace) {
	          // the remaining part of the current string is equal of the same part of the new string
	          var nextString = _this4.strings[_this4.arrayPos + 1];
	          if (nextString && curStringAtPosition === nextString.substr(0, curStrPos)) {
	            _this4.stopNum = curStrPos;
	          } else {
	            _this4.stopNum = 0;
	          }
	        }
	
	        // if the number (id of character in current string) is
	        // less than the stop number, keep going
	        if (curStrPos > _this4.stopNum) {
	          // subtract characters one by one
	          curStrPos--;
	          // loop the function
	          _this4.backspace(curString, curStrPos);
	        } else if (curStrPos <= _this4.stopNum) {
	          // if the stop number has been reached, increase
	          // array position to next string
	          _this4.arrayPos++;
	          // When looping, begin at the beginning after backspace complete
	          if (_this4.arrayPos === _this4.strings.length) {
	            _this4.arrayPos = 0;
	            _this4.options.onLastStringBackspaced();
	            _this4.shuffleStringsIfNeeded();
	            _this4.begin();
	          } else {
	            _this4.typewrite(_this4.strings[_this4.sequence[_this4.arrayPos]], curStrPos);
	          }
	        }
	        // humanized value for typing
	      }, humanize);
	    }
	
	    /**
	     * Full animation is complete
	     * @private
	     */
	  }, {
	    key: 'complete',
	    value: function complete() {
	      this.options.onComplete(this);
	      if (this.loop) {
	        this.curLoop++;
	      } else {
	        this.typingComplete = true;
	      }
	    }
	
	    /**
	     * Has the typing been stopped
	     * @param {string} curString the current string in the strings array
	     * @param {number} curStrPos the current position in the curString
	     * @param {boolean} isTyping
	     * @private
	     */
	  }, {
	    key: 'setPauseStatus',
	    value: function setPauseStatus(curString, curStrPos, isTyping) {
	      this.pause.typewrite = isTyping;
	      this.pause.curString = curString;
	      this.pause.curStrPos = curStrPos;
	    }
	
	    /**
	     * Toggle the blinking cursor
	     * @param {boolean} isBlinking
	     * @private
	     */
	  }, {
	    key: 'toggleBlinking',
	    value: function toggleBlinking(isBlinking) {
	      if (!this.cursor) return;
	      // if in paused state, don't toggle blinking a 2nd time
	      if (this.pause.status) return;
	      if (this.cursorBlinking === isBlinking) return;
	      this.cursorBlinking = isBlinking;
	      if (isBlinking) {
	        this.cursor.classList.add('typed-cursor--blink');
	      } else {
	        this.cursor.classList.remove('typed-cursor--blink');
	      }
	    }
	
	    /**
	     * Speed in MS to type
	     * @param {number} speed
	     * @private
	     */
	  }, {
	    key: 'humanizer',
	    value: function humanizer(speed) {
	      return Math.round(Math.random() * speed / 2) + speed;
	    }
	
	    /**
	     * Shuffle the sequence of the strings array
	     * @private
	     */
	  }, {
	    key: 'shuffleStringsIfNeeded',
	    value: function shuffleStringsIfNeeded() {
	      if (!this.shuffle) return;
	      this.sequence = this.sequence.sort(function () {
	        return Math.random() - 0.5;
	      });
	    }
	
	    /**
	     * Adds a CSS class to fade out current string
	     * @private
	     */
	  }, {
	    key: 'initFadeOut',
	    value: function initFadeOut() {
	      var _this5 = this;
	
	      this.el.className += ' ' + this.fadeOutClass;
	      if (this.cursor) this.cursor.className += ' ' + this.fadeOutClass;
	      return setTimeout(function () {
	        _this5.arrayPos++;
	        _this5.replaceText('');
	
	        // Resets current string if end of loop reached
	        if (_this5.strings.length > _this5.arrayPos) {
	          _this5.typewrite(_this5.strings[_this5.sequence[_this5.arrayPos]], 0);
	        } else {
	          _this5.typewrite(_this5.strings[0], 0);
	          _this5.arrayPos = 0;
	        }
	      }, this.fadeOutDelay);
	    }
	
	    /**
	     * Replaces current text in the HTML element
	     * depending on element type
	     * @param {string} str
	     * @private
	     */
	  }, {
	    key: 'replaceText',
	    value: function replaceText(str) {
	      if (this.attr) {
	        this.el.setAttribute(this.attr, str);
	      } else {
	        if (this.isInput) {
	          this.el.value = str;
	        } else if (this.contentType === 'html') {
	          this.el.innerHTML = str;
	        } else {
	          this.el.textContent = str;
	        }
	      }
	    }
	
	    /**
	     * If using input elements, bind focus in order to
	     * start and stop the animation
	     * @private
	     */
	  }, {
	    key: 'bindFocusEvents',
	    value: function bindFocusEvents() {
	      var _this6 = this;
	
	      if (!this.isInput) return;
	      this.el.addEventListener('focus', function (e) {
	        _this6.stop();
	      });
	      this.el.addEventListener('blur', function (e) {
	        if (_this6.el.value && _this6.el.value.length !== 0) {
	          return;
	        }
	        _this6.start();
	      });
	    }
	
	    /**
	     * On init, insert the cursor element
	     * @private
	     */
	  }, {
	    key: 'insertCursor',
	    value: function insertCursor() {
	      if (!this.showCursor) return;
	      if (this.cursor) return;
	      this.cursor = document.createElement('span');
	      this.cursor.className = 'typed-cursor';
	      this.cursor.setAttribute('aria-hidden', true);
	      this.cursor.innerHTML = this.cursorChar;
	      this.el.parentNode && this.el.parentNode.insertBefore(this.cursor, this.el.nextSibling);
	    }
	  }]);
	
	  return Typed;
	})();
	
	exports['default'] = Typed;
	module.exports = exports['default'];

/***/ }),
/* 1 */
/***/ (function(module, exports, __nested_webpack_require_18228__) {

	'use strict';
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	var _defaultsJs = __nested_webpack_require_18228__(2);
	
	var _defaultsJs2 = _interopRequireDefault(_defaultsJs);
	
	/**
	 * Initialize the Typed object
	 */
	
	var Initializer = (function () {
	  function Initializer() {
	    _classCallCheck(this, Initializer);
	  }
	
	  _createClass(Initializer, [{
	    key: 'load',
	
	    /**
	     * Load up defaults & options on the Typed instance
	     * @param {Typed} self instance of Typed
	     * @param {object} options options object
	     * @param {string} elementId HTML element ID _OR_ instance of HTML element
	     * @private
	     */
	
	    value: function load(self, options, elementId) {
	      // chosen element to manipulate text
	      if (typeof elementId === 'string') {
	        self.el = document.querySelector(elementId);
	      } else {
	        self.el = elementId;
	      }
	
	      self.options = _extends({}, _defaultsJs2['default'], options);
	
	      // attribute to type into
	      self.isInput = self.el.tagName.toLowerCase() === 'input';
	      self.attr = self.options.attr;
	      self.bindInputFocusEvents = self.options.bindInputFocusEvents;
	
	      // show cursor
	      self.showCursor = self.isInput ? false : self.options.showCursor;
	
	      // custom cursor
	      self.cursorChar = self.options.cursorChar;
	
	      // Is the cursor blinking
	      self.cursorBlinking = true;
	
	      // text content of element
	      self.elContent = self.attr ? self.el.getAttribute(self.attr) : self.el.textContent;
	
	      // html or plain text
	      self.contentType = self.options.contentType;
	
	      // typing speed
	      self.typeSpeed = self.options.typeSpeed;
	
	      // add a delay before typing starts
	      self.startDelay = self.options.startDelay;
	
	      // backspacing speed
	      self.backSpeed = self.options.backSpeed;
	
	      // only backspace what doesn't match the previous string
	      self.smartBackspace = self.options.smartBackspace;
	
	      // amount of time to wait before backspacing
	      self.backDelay = self.options.backDelay;
	
	      // Fade out instead of backspace
	      self.fadeOut = self.options.fadeOut;
	      self.fadeOutClass = self.options.fadeOutClass;
	      self.fadeOutDelay = self.options.fadeOutDelay;
	
	      // variable to check whether typing is currently paused
	      self.isPaused = false;
	
	      // input strings of text
	      self.strings = self.options.strings.map(function (s) {
	        return s.trim();
	      });
	
	      // div containing strings
	      if (typeof self.options.stringsElement === 'string') {
	        self.stringsElement = document.querySelector(self.options.stringsElement);
	      } else {
	        self.stringsElement = self.options.stringsElement;
	      }
	
	      if (self.stringsElement) {
	        self.strings = [];
	        self.stringsElement.style.display = 'none';
	        var strings = Array.prototype.slice.apply(self.stringsElement.children);
	        var stringsLength = strings.length;
	
	        if (stringsLength) {
	          for (var i = 0; i < stringsLength; i += 1) {
	            var stringEl = strings[i];
	            self.strings.push(stringEl.innerHTML.trim());
	          }
	        }
	      }
	
	      // character number position of current string
	      self.strPos = 0;
	
	      // current array position
	      self.arrayPos = 0;
	
	      // index of string to stop backspacing on
	      self.stopNum = 0;
	
	      // Looping logic
	      self.loop = self.options.loop;
	      self.loopCount = self.options.loopCount;
	      self.curLoop = 0;
	
	      // shuffle the strings
	      self.shuffle = self.options.shuffle;
	      // the order of strings
	      self.sequence = [];
	
	      self.pause = {
	        status: false,
	        typewrite: true,
	        curString: '',
	        curStrPos: 0
	      };
	
	      // When the typing is complete (when not looped)
	      self.typingComplete = false;
	
	      // Set the order in which the strings are typed
	      for (var i in self.strings) {
	        self.sequence[i] = i;
	      }
	
	      // If there is some text in the element
	      self.currentElContent = this.getCurrentElContent(self);
	
	      self.autoInsertCss = self.options.autoInsertCss;
	
	      this.appendAnimationCss(self);
	    }
	  }, {
	    key: 'getCurrentElContent',
	    value: function getCurrentElContent(self) {
	      var elContent = '';
	      if (self.attr) {
	        elContent = self.el.getAttribute(self.attr);
	      } else if (self.isInput) {
	        elContent = self.el.value;
	      } else if (self.contentType === 'html') {
	        elContent = self.el.innerHTML;
	      } else {
	        elContent = self.el.textContent;
	      }
	      return elContent;
	    }
	  }, {
	    key: 'appendAnimationCss',
	    value: function appendAnimationCss(self) {
	      var cssDataName = 'data-typed-js-css';
	      if (!self.autoInsertCss) {
	        return;
	      }
	      if (!self.showCursor && !self.fadeOut) {
	        return;
	      }
	      if (document.querySelector('[' + cssDataName + ']')) {
	        return;
	      }
	
	      var css = document.createElement('style');
	      css.type = 'text/css';
	      css.setAttribute(cssDataName, true);
	
	      var innerCss = '';
	      if (self.showCursor) {
	        innerCss += '\n        .typed-cursor{\n          opacity: 1;\n        }\n        .typed-cursor.typed-cursor--blink{\n          animation: typedjsBlink 0.7s infinite;\n          -webkit-animation: typedjsBlink 0.7s infinite;\n                  animation: typedjsBlink 0.7s infinite;\n        }\n        @keyframes typedjsBlink{\n          50% { opacity: 0.0; }\n        }\n        @-webkit-keyframes typedjsBlink{\n          0% { opacity: 1; }\n          50% { opacity: 0.0; }\n          100% { opacity: 1; }\n        }\n      ';
	      }
	      if (self.fadeOut) {
	        innerCss += '\n        .typed-fade-out{\n          opacity: 0;\n          transition: opacity .25s;\n        }\n        .typed-cursor.typed-cursor--blink.typed-fade-out{\n          -webkit-animation: 0;\n          animation: 0;\n        }\n      ';
	      }
	      if (css.length === 0) {
	        return;
	      }
	      css.innerHTML = innerCss;
	      document.body.appendChild(css);
	    }
	  }]);
	
	  return Initializer;
	})();
	
	exports['default'] = Initializer;
	var initializer = new Initializer();
	exports.initializer = initializer;

/***/ }),
/* 2 */
/***/ (function(module, exports) {

	/**
	 * Defaults & options
	 * @returns {object} Typed defaults & options
	 * @public
	 */
	
	'use strict';
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	var defaults = {
	  /**
	   * @property {array} strings strings to be typed
	   * @property {string} stringsElement ID of element containing string children
	   */
	  strings: ['These are the default values...', 'You know what you should do?', 'Use your own!', 'Have a great day!'],
	  stringsElement: null,
	
	  /**
	   * @property {number} typeSpeed type speed in milliseconds
	   */
	  typeSpeed: 0,
	
	  /**
	   * @property {number} startDelay time before typing starts in milliseconds
	   */
	  startDelay: 0,
	
	  /**
	   * @property {number} backSpeed backspacing speed in milliseconds
	   */
	  backSpeed: 0,
	
	  /**
	   * @property {boolean} smartBackspace only backspace what doesn't match the previous string
	   */
	  smartBackspace: true,
	
	  /**
	   * @property {boolean} shuffle shuffle the strings
	   */
	  shuffle: false,
	
	  /**
	   * @property {number} backDelay time before backspacing in milliseconds
	   */
	  backDelay: 700,
	
	  /**
	   * @property {boolean} fadeOut Fade out instead of backspace
	   * @property {string} fadeOutClass css class for fade animation
	   * @property {boolean} fadeOutDelay Fade out delay in milliseconds
	   */
	  fadeOut: false,
	  fadeOutClass: 'typed-fade-out',
	  fadeOutDelay: 500,
	
	  /**
	   * @property {boolean} loop loop strings
	   * @property {number} loopCount amount of loops
	   */
	  loop: false,
	  loopCount: Infinity,
	
	  /**
	   * @property {boolean} showCursor show cursor
	   * @property {string} cursorChar character for cursor
	   * @property {boolean} autoInsertCss insert CSS for cursor and fadeOut into HTML <head>
	   */
	  showCursor: true,
	  cursorChar: '|',
	  autoInsertCss: true,
	
	  /**
	   * @property {string} attr attribute for typing
	   * Ex: input placeholder, value, or just HTML text
	   */
	  attr: null,
	
	  /**
	   * @property {boolean} bindInputFocusEvents bind to focus and blur if el is text input
	   */
	  bindInputFocusEvents: false,
	
	  /**
	   * @property {string} contentType 'html' or 'null' for plaintext
	   */
	  contentType: 'html',
	
	  /**
	   * Before it begins typing
	   * @param {Typed} self
	   */
	  onBegin: function onBegin(self) {},
	
	  /**
	   * All typing is complete
	   * @param {Typed} self
	   */
	  onComplete: function onComplete(self) {},
	
	  /**
	   * Before each string is typed
	   * @param {number} arrayPos
	   * @param {Typed} self
	   */
	  preStringTyped: function preStringTyped(arrayPos, self) {},
	
	  /**
	   * After each string is typed
	   * @param {number} arrayPos
	   * @param {Typed} self
	   */
	  onStringTyped: function onStringTyped(arrayPos, self) {},
	
	  /**
	   * During looping, after last string is typed
	   * @param {Typed} self
	   */
	  onLastStringBackspaced: function onLastStringBackspaced(self) {},
	
	  /**
	   * Typing has been stopped
	   * @param {number} arrayPos
	   * @param {Typed} self
	   */
	  onTypingPaused: function onTypingPaused(arrayPos, self) {},
	
	  /**
	   * Typing has been started after being stopped
	   * @param {number} arrayPos
	   * @param {Typed} self
	   */
	  onTypingResumed: function onTypingResumed(arrayPos, self) {},
	
	  /**
	   * After reset
	   * @param {Typed} self
	   */
	  onReset: function onReset(self) {},
	
	  /**
	   * After stop
	   * @param {number} arrayPos
	   * @param {Typed} self
	   */
	  onStop: function onStop(arrayPos, self) {},
	
	  /**
	   * After start
	   * @param {number} arrayPos
	   * @param {Typed} self
	   */
	  onStart: function onStart(arrayPos, self) {},
	
	  /**
	   * After destroy
	   * @param {Typed} self
	   */
	  onDestroy: function onDestroy(self) {}
	};
	
	exports['default'] = defaults;
	module.exports = exports['default'];

/***/ }),
/* 3 */
/***/ (function(module, exports) {

	/**
	 * TODO: These methods can probably be combined somehow
	 * Parse HTML tags & HTML Characters
	 */
	
	'use strict';
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	
	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	var HTMLParser = (function () {
	  function HTMLParser() {
	    _classCallCheck(this, HTMLParser);
	  }
	
	  _createClass(HTMLParser, [{
	    key: 'typeHtmlChars',
	
	    /**
	     * Type HTML tags & HTML Characters
	     * @param {string} curString Current string
	     * @param {number} curStrPos Position in current string
	     * @param {Typed} self instance of Typed
	     * @returns {number} a new string position
	     * @private
	     */
	
	    value: function typeHtmlChars(curString, curStrPos, self) {
	      if (self.contentType !== 'html') return curStrPos;
	      var curChar = curString.substr(curStrPos).charAt(0);
	      if (curChar === '<' || curChar === '&') {
	        var endTag = '';
	        if (curChar === '<') {
	          endTag = '>';
	        } else {
	          endTag = ';';
	        }
	        while (curString.substr(curStrPos + 1).charAt(0) !== endTag) {
	          curStrPos++;
	          if (curStrPos + 1 > curString.length) {
	            break;
	          }
	        }
	        curStrPos++;
	      }
	      return curStrPos;
	    }
	
	    /**
	     * Backspace HTML tags and HTML Characters
	     * @param {string} curString Current string
	     * @param {number} curStrPos Position in current string
	     * @param {Typed} self instance of Typed
	     * @returns {number} a new string position
	     * @private
	     */
	  }, {
	    key: 'backSpaceHtmlChars',
	    value: function backSpaceHtmlChars(curString, curStrPos, self) {
	      if (self.contentType !== 'html') return curStrPos;
	      var curChar = curString.substr(curStrPos).charAt(0);
	      if (curChar === '>' || curChar === ';') {
	        var endTag = '';
	        if (curChar === '>') {
	          endTag = '<';
	        } else {
	          endTag = '&';
	        }
	        while (curString.substr(curStrPos - 1).charAt(0) !== endTag) {
	          curStrPos--;
	          if (curStrPos < 0) {
	            break;
	          }
	        }
	        curStrPos--;
	      }
	      return curStrPos;
	    }
	  }]);
	
	  return HTMLParser;
	})();
	
	exports['default'] = HTMLParser;
	var htmlParser = new HTMLParser();
	exports.htmlParser = htmlParser;

/***/ })
/******/ ])
});
;

/***/ }),

/***/ "./src/assets/arrow-send.svg":
/*!***********************************!*\
  !*** ./src/assets/arrow-send.svg ***!
  \***********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "46786ff2a130a41027da.svg";

/***/ }),

/***/ "./src/assets/arrow.svg":
/*!******************************!*\
  !*** ./src/assets/arrow.svg ***!
  \******************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "932c7d05e9e25926444f.svg";

/***/ }),

/***/ "./src/assets/card-dribbble.svg":
/*!**************************************!*\
  !*** ./src/assets/card-dribbble.svg ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "e86966c7fbb89434eea6.svg";

/***/ }),

/***/ "./src/assets/card-github.svg":
/*!************************************!*\
  !*** ./src/assets/card-github.svg ***!
  \************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "ab830f3a3007efb72f12.svg";

/***/ }),

/***/ "./src/assets/contact-theme-1.webp":
/*!*****************************************!*\
  !*** ./src/assets/contact-theme-1.webp ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "13206ac29a1e5aeb1af8.webp";

/***/ }),

/***/ "./src/assets/contact-theme-2.webp":
/*!*****************************************!*\
  !*** ./src/assets/contact-theme-2.webp ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "0c84fbea6a555fa8e077.webp";

/***/ }),

/***/ "./src/assets/contact-theme-3.webp":
/*!*****************************************!*\
  !*** ./src/assets/contact-theme-3.webp ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "0dddfdaf14bc1f79a461.webp";

/***/ }),

/***/ "./src/assets/download.svg":
/*!*********************************!*\
  !*** ./src/assets/download.svg ***!
  \*********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "ccfba299948ae8832a01.svg";

/***/ }),

/***/ "./src/assets/drawing-compass.svg":
/*!****************************************!*\
  !*** ./src/assets/drawing-compass.svg ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "c36ea6f4bd33b68a99be.svg";

/***/ }),

/***/ "./src/assets/large-map.webp":
/*!***********************************!*\
  !*** ./src/assets/large-map.webp ***!
  \***********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "50467ba2b5cd4fe7f005.webp";

/***/ }),

/***/ "./src/assets/monster-slayer.svg":
/*!***************************************!*\
  !*** ./src/assets/monster-slayer.svg ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "c351e70c200ae25cdbfd.svg";

/***/ }),

/***/ "./src/assets/osc-geeks.svg":
/*!**********************************!*\
  !*** ./src/assets/osc-geeks.svg ***!
  \**********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "99ac5a4fdeef104c0580.svg";

/***/ }),

/***/ "./src/assets/pigdice.svg":
/*!********************************!*\
  !*** ./src/assets/pigdice.svg ***!
  \********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "5ba6a585161a6346886f.svg";

/***/ }),

/***/ "./src/assets/pink-overlay.webp":
/*!**************************************!*\
  !*** ./src/assets/pink-overlay.webp ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "cb85b19a5a9794f697e0.webp";

/***/ }),

/***/ "./src/assets/small-map.webp":
/*!***********************************!*\
  !*** ./src/assets/small-map.webp ***!
  \***********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "2c33e6b08a44e7a64bca.webp";

/***/ }),

/***/ "./node_modules/@firebase/app/dist/esm/index.esm2017.js":
/*!**************************************************************!*\
  !*** ./node_modules/@firebase/app/dist/esm/index.esm2017.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FirebaseError": () => (/* reexport safe */ _firebase_util__WEBPACK_IMPORTED_MODULE_2__.FirebaseError),
/* harmony export */   "SDK_VERSION": () => (/* binding */ SDK_VERSION),
/* harmony export */   "_DEFAULT_ENTRY_NAME": () => (/* binding */ DEFAULT_ENTRY_NAME),
/* harmony export */   "_addComponent": () => (/* binding */ _addComponent),
/* harmony export */   "_addOrOverwriteComponent": () => (/* binding */ _addOrOverwriteComponent),
/* harmony export */   "_apps": () => (/* binding */ _apps),
/* harmony export */   "_clearComponents": () => (/* binding */ _clearComponents),
/* harmony export */   "_components": () => (/* binding */ _components),
/* harmony export */   "_getProvider": () => (/* binding */ _getProvider),
/* harmony export */   "_registerComponent": () => (/* binding */ _registerComponent),
/* harmony export */   "_removeServiceInstance": () => (/* binding */ _removeServiceInstance),
/* harmony export */   "deleteApp": () => (/* binding */ deleteApp),
/* harmony export */   "getApp": () => (/* binding */ getApp),
/* harmony export */   "getApps": () => (/* binding */ getApps),
/* harmony export */   "initializeApp": () => (/* binding */ initializeApp),
/* harmony export */   "onLog": () => (/* binding */ onLog),
/* harmony export */   "registerVersion": () => (/* binding */ registerVersion),
/* harmony export */   "setLogLevel": () => (/* binding */ setLogLevel)
/* harmony export */ });
/* harmony import */ var _firebase_component__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @firebase/component */ "./node_modules/@firebase/component/dist/esm/index.esm2017.js");
/* harmony import */ var _firebase_logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @firebase/logger */ "./node_modules/@firebase/logger/dist/esm/index.esm2017.js");
/* harmony import */ var _firebase_util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @firebase/util */ "./node_modules/@firebase/util/dist/index.esm2017.js");
/* harmony import */ var idb__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! idb */ "./node_modules/idb/build/idb.js");






/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class PlatformLoggerServiceImpl {
    constructor(container) {
        this.container = container;
    }
    // In initial implementation, this will be called by installations on
    // auth token refresh, and installations will send this string.
    getPlatformInfoString() {
        const providers = this.container.getProviders();
        // Loop through providers and get library/version pairs from any that are
        // version components.
        return providers
            .map(provider => {
            if (isVersionServiceProvider(provider)) {
                const service = provider.getImmediate();
                return `${service.library}/${service.version}`;
            }
            else {
                return null;
            }
        })
            .filter(logString => logString)
            .join(' ');
    }
}
/**
 *
 * @param provider check if this provider provides a VersionService
 *
 * NOTE: Using Provider<'app-version'> is a hack to indicate that the provider
 * provides VersionService. The provider is not necessarily a 'app-version'
 * provider.
 */
function isVersionServiceProvider(provider) {
    const component = provider.getComponent();
    return (component === null || component === void 0 ? void 0 : component.type) === "VERSION" /* VERSION */;
}

const name$o = "@firebase/app";
const version$1 = "0.7.18";

/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const logger = new _firebase_logger__WEBPACK_IMPORTED_MODULE_1__.Logger('@firebase/app');

const name$n = "@firebase/app-compat";

const name$m = "@firebase/analytics-compat";

const name$l = "@firebase/analytics";

const name$k = "@firebase/app-check-compat";

const name$j = "@firebase/app-check";

const name$i = "@firebase/auth";

const name$h = "@firebase/auth-compat";

const name$g = "@firebase/database";

const name$f = "@firebase/database-compat";

const name$e = "@firebase/functions";

const name$d = "@firebase/functions-compat";

const name$c = "@firebase/installations";

const name$b = "@firebase/installations-compat";

const name$a = "@firebase/messaging";

const name$9 = "@firebase/messaging-compat";

const name$8 = "@firebase/performance";

const name$7 = "@firebase/performance-compat";

const name$6 = "@firebase/remote-config";

const name$5 = "@firebase/remote-config-compat";

const name$4 = "@firebase/storage";

const name$3 = "@firebase/storage-compat";

const name$2 = "@firebase/firestore";

const name$1 = "@firebase/firestore-compat";

const name = "firebase";
const version = "9.6.8";

/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * The default app name
 *
 * @internal
 */
const DEFAULT_ENTRY_NAME = '[DEFAULT]';
const PLATFORM_LOG_STRING = {
    [name$o]: 'fire-core',
    [name$n]: 'fire-core-compat',
    [name$l]: 'fire-analytics',
    [name$m]: 'fire-analytics-compat',
    [name$j]: 'fire-app-check',
    [name$k]: 'fire-app-check-compat',
    [name$i]: 'fire-auth',
    [name$h]: 'fire-auth-compat',
    [name$g]: 'fire-rtdb',
    [name$f]: 'fire-rtdb-compat',
    [name$e]: 'fire-fn',
    [name$d]: 'fire-fn-compat',
    [name$c]: 'fire-iid',
    [name$b]: 'fire-iid-compat',
    [name$a]: 'fire-fcm',
    [name$9]: 'fire-fcm-compat',
    [name$8]: 'fire-perf',
    [name$7]: 'fire-perf-compat',
    [name$6]: 'fire-rc',
    [name$5]: 'fire-rc-compat',
    [name$4]: 'fire-gcs',
    [name$3]: 'fire-gcs-compat',
    [name$2]: 'fire-fst',
    [name$1]: 'fire-fst-compat',
    'fire-js': 'fire-js',
    [name]: 'fire-js-all'
};

/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @internal
 */
const _apps = new Map();
/**
 * Registered components.
 *
 * @internal
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
const _components = new Map();
/**
 * @param component - the component being added to this app's container
 *
 * @internal
 */
function _addComponent(app, component) {
    try {
        app.container.addComponent(component);
    }
    catch (e) {
        logger.debug(`Component ${component.name} failed to register with FirebaseApp ${app.name}`, e);
    }
}
/**
 *
 * @internal
 */
function _addOrOverwriteComponent(app, component) {
    app.container.addOrOverwriteComponent(component);
}
/**
 *
 * @param component - the component to register
 * @returns whether or not the component is registered successfully
 *
 * @internal
 */
function _registerComponent(component) {
    const componentName = component.name;
    if (_components.has(componentName)) {
        logger.debug(`There were multiple attempts to register component ${componentName}.`);
        return false;
    }
    _components.set(componentName, component);
    // add the component to existing app instances
    for (const app of _apps.values()) {
        _addComponent(app, component);
    }
    return true;
}
/**
 *
 * @param app - FirebaseApp instance
 * @param name - service name
 *
 * @returns the provider for the service with the matching name
 *
 * @internal
 */
function _getProvider(app, name) {
    const heartbeatController = app.container
        .getProvider('heartbeat')
        .getImmediate({ optional: true });
    if (heartbeatController) {
        void heartbeatController.triggerHeartbeat();
    }
    return app.container.getProvider(name);
}
/**
 *
 * @param app - FirebaseApp instance
 * @param name - service name
 * @param instanceIdentifier - service instance identifier in case the service supports multiple instances
 *
 * @internal
 */
function _removeServiceInstance(app, name, instanceIdentifier = DEFAULT_ENTRY_NAME) {
    _getProvider(app, name).clearInstance(instanceIdentifier);
}
/**
 * Test only
 *
 * @internal
 */
function _clearComponents() {
    _components.clear();
}

/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const ERRORS = {
    ["no-app" /* NO_APP */]: "No Firebase App '{$appName}' has been created - " +
        'call Firebase App.initializeApp()',
    ["bad-app-name" /* BAD_APP_NAME */]: "Illegal App name: '{$appName}",
    ["duplicate-app" /* DUPLICATE_APP */]: "Firebase App named '{$appName}' already exists with different options or config",
    ["app-deleted" /* APP_DELETED */]: "Firebase App named '{$appName}' already deleted",
    ["invalid-app-argument" /* INVALID_APP_ARGUMENT */]: 'firebase.{$appName}() takes either no argument or a ' +
        'Firebase App instance.',
    ["invalid-log-argument" /* INVALID_LOG_ARGUMENT */]: 'First argument to `onLog` must be null or a function.',
    ["storage-open" /* STORAGE_OPEN */]: 'Error thrown when opening storage. Original error: {$originalErrorMessage}.',
    ["storage-get" /* STORAGE_GET */]: 'Error thrown when reading from storage. Original error: {$originalErrorMessage}.',
    ["storage-set" /* STORAGE_WRITE */]: 'Error thrown when writing to storage. Original error: {$originalErrorMessage}.',
    ["storage-delete" /* STORAGE_DELETE */]: 'Error thrown when deleting from storage. Original error: {$originalErrorMessage}.'
};
const ERROR_FACTORY = new _firebase_util__WEBPACK_IMPORTED_MODULE_2__.ErrorFactory('app', 'Firebase', ERRORS);

/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class FirebaseAppImpl {
    constructor(options, config, container) {
        this._isDeleted = false;
        this._options = Object.assign({}, options);
        this._config = Object.assign({}, config);
        this._name = config.name;
        this._automaticDataCollectionEnabled =
            config.automaticDataCollectionEnabled;
        this._container = container;
        this.container.addComponent(new _firebase_component__WEBPACK_IMPORTED_MODULE_0__.Component('app', () => this, "PUBLIC" /* PUBLIC */));
    }
    get automaticDataCollectionEnabled() {
        this.checkDestroyed();
        return this._automaticDataCollectionEnabled;
    }
    set automaticDataCollectionEnabled(val) {
        this.checkDestroyed();
        this._automaticDataCollectionEnabled = val;
    }
    get name() {
        this.checkDestroyed();
        return this._name;
    }
    get options() {
        this.checkDestroyed();
        return this._options;
    }
    get config() {
        this.checkDestroyed();
        return this._config;
    }
    get container() {
        return this._container;
    }
    get isDeleted() {
        return this._isDeleted;
    }
    set isDeleted(val) {
        this._isDeleted = val;
    }
    /**
     * This function will throw an Error if the App has already been deleted -
     * use before performing API actions on the App.
     */
    checkDestroyed() {
        if (this.isDeleted) {
            throw ERROR_FACTORY.create("app-deleted" /* APP_DELETED */, { appName: this._name });
        }
    }
}

/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * The current SDK version.
 *
 * @public
 */
const SDK_VERSION = version;
function initializeApp(options, rawConfig = {}) {
    if (typeof rawConfig !== 'object') {
        const name = rawConfig;
        rawConfig = { name };
    }
    const config = Object.assign({ name: DEFAULT_ENTRY_NAME, automaticDataCollectionEnabled: false }, rawConfig);
    const name = config.name;
    if (typeof name !== 'string' || !name) {
        throw ERROR_FACTORY.create("bad-app-name" /* BAD_APP_NAME */, {
            appName: String(name)
        });
    }
    const existingApp = _apps.get(name);
    if (existingApp) {
        // return the existing app if options and config deep equal the ones in the existing app.
        if ((0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.deepEqual)(options, existingApp.options) &&
            (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.deepEqual)(config, existingApp.config)) {
            return existingApp;
        }
        else {
            throw ERROR_FACTORY.create("duplicate-app" /* DUPLICATE_APP */, { appName: name });
        }
    }
    const container = new _firebase_component__WEBPACK_IMPORTED_MODULE_0__.ComponentContainer(name);
    for (const component of _components.values()) {
        container.addComponent(component);
    }
    const newApp = new FirebaseAppImpl(options, config, container);
    _apps.set(name, newApp);
    return newApp;
}
/**
 * Retrieves a {@link @firebase/app#FirebaseApp} instance.
 *
 * When called with no arguments, the default app is returned. When an app name
 * is provided, the app corresponding to that name is returned.
 *
 * An exception is thrown if the app being retrieved has not yet been
 * initialized.
 *
 * @example
 * ```javascript
 * // Return the default app
 * const app = getApp();
 * ```
 *
 * @example
 * ```javascript
 * // Return a named app
 * const otherApp = getApp("otherApp");
 * ```
 *
 * @param name - Optional name of the app to return. If no name is
 *   provided, the default is `"[DEFAULT]"`.
 *
 * @returns The app corresponding to the provided app name.
 *   If no app name is provided, the default app is returned.
 *
 * @public
 */
function getApp(name = DEFAULT_ENTRY_NAME) {
    const app = _apps.get(name);
    if (!app) {
        throw ERROR_FACTORY.create("no-app" /* NO_APP */, { appName: name });
    }
    return app;
}
/**
 * A (read-only) array of all initialized apps.
 * @public
 */
function getApps() {
    return Array.from(_apps.values());
}
/**
 * Renders this app unusable and frees the resources of all associated
 * services.
 *
 * @example
 * ```javascript
 * deleteApp(app)
 *   .then(function() {
 *     console.log("App deleted successfully");
 *   })
 *   .catch(function(error) {
 *     console.log("Error deleting app:", error);
 *   });
 * ```
 *
 * @public
 */
async function deleteApp(app) {
    const name = app.name;
    if (_apps.has(name)) {
        _apps.delete(name);
        await Promise.all(app.container
            .getProviders()
            .map(provider => provider.delete()));
        app.isDeleted = true;
    }
}
/**
 * Registers a library's name and version for platform logging purposes.
 * @param library - Name of 1p or 3p library (e.g. firestore, angularfire)
 * @param version - Current version of that library.
 * @param variant - Bundle variant, e.g., node, rn, etc.
 *
 * @public
 */
function registerVersion(libraryKeyOrName, version, variant) {
    var _a;
    // TODO: We can use this check to whitelist strings when/if we set up
    // a good whitelist system.
    let library = (_a = PLATFORM_LOG_STRING[libraryKeyOrName]) !== null && _a !== void 0 ? _a : libraryKeyOrName;
    if (variant) {
        library += `-${variant}`;
    }
    const libraryMismatch = library.match(/\s|\//);
    const versionMismatch = version.match(/\s|\//);
    if (libraryMismatch || versionMismatch) {
        const warning = [
            `Unable to register library "${library}" with version "${version}":`
        ];
        if (libraryMismatch) {
            warning.push(`library name "${library}" contains illegal characters (whitespace or "/")`);
        }
        if (libraryMismatch && versionMismatch) {
            warning.push('and');
        }
        if (versionMismatch) {
            warning.push(`version name "${version}" contains illegal characters (whitespace or "/")`);
        }
        logger.warn(warning.join(' '));
        return;
    }
    _registerComponent(new _firebase_component__WEBPACK_IMPORTED_MODULE_0__.Component(`${library}-version`, () => ({ library, version }), "VERSION" /* VERSION */));
}
/**
 * Sets log handler for all Firebase SDKs.
 * @param logCallback - An optional custom log handler that executes user code whenever
 * the Firebase SDK makes a logging call.
 *
 * @public
 */
function onLog(logCallback, options) {
    if (logCallback !== null && typeof logCallback !== 'function') {
        throw ERROR_FACTORY.create("invalid-log-argument" /* INVALID_LOG_ARGUMENT */);
    }
    (0,_firebase_logger__WEBPACK_IMPORTED_MODULE_1__.setUserLogHandler)(logCallback, options);
}
/**
 * Sets log level for all Firebase SDKs.
 *
 * All of the log types above the current log level are captured (i.e. if
 * you set the log level to `info`, errors are logged, but `debug` and
 * `verbose` logs are not).
 *
 * @public
 */
function setLogLevel(logLevel) {
    (0,_firebase_logger__WEBPACK_IMPORTED_MODULE_1__.setLogLevel)(logLevel);
}

/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const DB_NAME = 'firebase-heartbeat-database';
const DB_VERSION = 1;
const STORE_NAME = 'firebase-heartbeat-store';
let dbPromise = null;
function getDbPromise() {
    if (!dbPromise) {
        dbPromise = (0,idb__WEBPACK_IMPORTED_MODULE_3__.openDb)(DB_NAME, DB_VERSION, upgradeDB => {
            // We don't use 'break' in this switch statement, the fall-through
            // behavior is what we want, because if there are multiple versions between
            // the old version and the current version, we want ALL the migrations
            // that correspond to those versions to run, not only the last one.
            // eslint-disable-next-line default-case
            switch (upgradeDB.oldVersion) {
                case 0:
                    upgradeDB.createObjectStore(STORE_NAME);
            }
        }).catch(e => {
            throw ERROR_FACTORY.create("storage-open" /* STORAGE_OPEN */, {
                originalErrorMessage: e.message
            });
        });
    }
    return dbPromise;
}
async function readHeartbeatsFromIndexedDB(app) {
    try {
        const db = await getDbPromise();
        return db
            .transaction(STORE_NAME)
            .objectStore(STORE_NAME)
            .get(computeKey(app));
    }
    catch (e) {
        throw ERROR_FACTORY.create("storage-get" /* STORAGE_GET */, {
            originalErrorMessage: e.message
        });
    }
}
async function writeHeartbeatsToIndexedDB(app, heartbeatObject) {
    try {
        const db = await getDbPromise();
        const tx = db.transaction(STORE_NAME, 'readwrite');
        const objectStore = tx.objectStore(STORE_NAME);
        await objectStore.put(heartbeatObject, computeKey(app));
        return tx.complete;
    }
    catch (e) {
        throw ERROR_FACTORY.create("storage-set" /* STORAGE_WRITE */, {
            originalErrorMessage: e.message
        });
    }
}
async function deleteHeartbeatsFromIndexedDB(app) {
    try {
        const db = await getDbPromise();
        const tx = db.transaction(STORE_NAME, 'readwrite');
        await tx.objectStore(STORE_NAME).delete(computeKey(app));
        return tx.complete;
    }
    catch (e) {
        throw ERROR_FACTORY.create("storage-delete" /* STORAGE_DELETE */, {
            originalErrorMessage: e.message
        });
    }
}
function computeKey(app) {
    return `${app.name}!${app.options.appId}`;
}

/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const MAX_HEADER_BYTES = 1024;
// 30 days
const STORED_HEARTBEAT_RETENTION_MAX_MILLIS = 30 * 24 * 60 * 60 * 1000;
class HeartbeatServiceImpl {
    constructor(container) {
        this.container = container;
        /**
         * In-memory cache for heartbeats, used by getHeartbeatsHeader() to generate
         * the header string.
         * Stores one record per date. This will be consolidated into the standard
         * format of one record per user agent string before being sent as a header.
         * Populated from indexedDB when the controller is instantiated and should
         * be kept in sync with indexedDB.
         * Leave public for easier testing.
         */
        this._heartbeatsCache = null;
        const app = this.container.getProvider('app').getImmediate();
        this._storage = new HeartbeatStorageImpl(app);
        this._heartbeatsCachePromise = this._storage.read().then(result => {
            this._heartbeatsCache = result;
            return result;
        });
    }
    /**
     * Called to report a heartbeat. The function will generate
     * a HeartbeatsByUserAgent object, update heartbeatsCache, and persist it
     * to IndexedDB.
     * Note that we only store one heartbeat per day. So if a heartbeat for today is
     * already logged, subsequent calls to this function in the same day will be ignored.
     */
    async triggerHeartbeat() {
        const platformLogger = this.container
            .getProvider('platform-logger')
            .getImmediate();
        // This is the "Firebase user agent" string from the platform logger
        // service, not the browser user agent.
        const userAgent = platformLogger.getPlatformInfoString();
        const date = getUTCDateString();
        if (this._heartbeatsCache === null) {
            this._heartbeatsCache = await this._heartbeatsCachePromise;
        }
        if (this._heartbeatsCache.some(singleDateHeartbeat => singleDateHeartbeat.date === date)) {
            // Do not store a heartbeat if one is already stored for this day.
            return;
        }
        else {
            // There is no entry for this date. Create one.
            this._heartbeatsCache.push({ date, userAgent });
        }
        // Remove entries older than 30 days.
        this._heartbeatsCache = this._heartbeatsCache.filter(singleDateHeartbeat => {
            const hbTimestamp = new Date(singleDateHeartbeat.date).valueOf();
            const now = Date.now();
            return now - hbTimestamp <= STORED_HEARTBEAT_RETENTION_MAX_MILLIS;
        });
        return this._storage.overwrite(this._heartbeatsCache);
    }
    /**
     * Returns a base64 encoded string which can be attached to the heartbeat-specific header directly.
     * It also clears all heartbeats from memory as well as in IndexedDB.
     *
     * NOTE: It will read heartbeats from the heartbeatsCache, instead of from indexedDB to reduce latency
     */
    async getHeartbeatsHeader() {
        if (this._heartbeatsCache === null) {
            await this._heartbeatsCachePromise;
        }
        // If it's still null, it's been cleared and has not been repopulated.
        if (this._heartbeatsCache === null) {
            return '';
        }
        // Extract as many heartbeats from the cache as will fit under the size limit.
        const { heartbeatsToSend, unsentEntries } = extractHeartbeatsForHeader(this._heartbeatsCache);
        const headerString = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.base64Encode)(JSON.stringify({ version: 2, heartbeats: heartbeatsToSend }));
        if (unsentEntries.length > 0) {
            // Store any unsent entries if they exist.
            this._heartbeatsCache = unsentEntries;
            // This seems more likely than deleteAll (below) to lead to some odd state
            // since the cache isn't empty and this will be called again on the next request,
            // and is probably safest if we await it.
            await this._storage.overwrite(this._heartbeatsCache);
        }
        else {
            this._heartbeatsCache = null;
            // Do not wait for this, to reduce latency.
            void this._storage.deleteAll();
        }
        return headerString;
    }
}
function getUTCDateString() {
    const today = new Date();
    // Returns date format 'YYYY-MM-DD'
    return today.toISOString().substring(0, 10);
}
function extractHeartbeatsForHeader(heartbeatsCache, maxSize = MAX_HEADER_BYTES) {
    // Heartbeats grouped by user agent in the standard format to be sent in
    // the header.
    const heartbeatsToSend = [];
    // Single date format heartbeats that are not sent.
    let unsentEntries = heartbeatsCache.slice();
    for (const singleDateHeartbeat of heartbeatsCache) {
        // Look for an existing entry with the same user agent.
        const heartbeatEntry = heartbeatsToSend.find(hb => hb.userAgent === singleDateHeartbeat.userAgent);
        if (!heartbeatEntry) {
            // If no entry for this user agent exists, create one.
            heartbeatsToSend.push({
                userAgent: singleDateHeartbeat.userAgent,
                dates: [singleDateHeartbeat.date]
            });
            if (countBytes(heartbeatsToSend) > maxSize) {
                // If the header would exceed max size, remove the added heartbeat
                // entry and stop adding to the header.
                heartbeatsToSend.pop();
                break;
            }
        }
        else {
            heartbeatEntry.dates.push(singleDateHeartbeat.date);
            // If the header would exceed max size, remove the added date
            // and stop adding to the header.
            if (countBytes(heartbeatsToSend) > maxSize) {
                heartbeatEntry.dates.pop();
                break;
            }
        }
        // Pop unsent entry from queue. (Skipped if adding the entry exceeded
        // quota and the loop breaks early.)
        unsentEntries = unsentEntries.slice(1);
    }
    return {
        heartbeatsToSend,
        unsentEntries
    };
}
class HeartbeatStorageImpl {
    constructor(app) {
        this.app = app;
        this._canUseIndexedDBPromise = this.runIndexedDBEnvironmentCheck();
    }
    async runIndexedDBEnvironmentCheck() {
        if (!(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.isIndexedDBAvailable)()) {
            return false;
        }
        else {
            return (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.validateIndexedDBOpenable)()
                .then(() => true)
                .catch(() => false);
        }
    }
    /**
     * Read all heartbeats.
     */
    async read() {
        const canUseIndexedDB = await this._canUseIndexedDBPromise;
        if (!canUseIndexedDB) {
            return [];
        }
        else {
            const idbHeartbeatObject = await readHeartbeatsFromIndexedDB(this.app);
            return (idbHeartbeatObject === null || idbHeartbeatObject === void 0 ? void 0 : idbHeartbeatObject.heartbeats) || [];
        }
    }
    // overwrite the storage with the provided heartbeats
    async overwrite(heartbeats) {
        const canUseIndexedDB = await this._canUseIndexedDBPromise;
        if (!canUseIndexedDB) {
            return;
        }
        else {
            return writeHeartbeatsToIndexedDB(this.app, { heartbeats });
        }
    }
    // add heartbeats
    async add(heartbeats) {
        const canUseIndexedDB = await this._canUseIndexedDBPromise;
        if (!canUseIndexedDB) {
            return;
        }
        else {
            const existingHeartbeats = await this.read();
            return writeHeartbeatsToIndexedDB(this.app, {
                heartbeats: [...existingHeartbeats, ...heartbeats]
            });
        }
    }
    // delete heartbeats
    async delete(heartbeats) {
        const canUseIndexedDB = await this._canUseIndexedDBPromise;
        if (!canUseIndexedDB) {
            return;
        }
        else {
            const existingHeartbeats = await this.read();
            return writeHeartbeatsToIndexedDB(this.app, {
                heartbeats: existingHeartbeats.filter(existingHeartbeat => !heartbeats.includes(existingHeartbeat))
            });
        }
    }
    // delete all heartbeats
    async deleteAll() {
        const canUseIndexedDB = await this._canUseIndexedDBPromise;
        if (!canUseIndexedDB) {
            return;
        }
        else {
            return deleteHeartbeatsFromIndexedDB(this.app);
        }
    }
}
/**
 * Calculate bytes of a HeartbeatsByUserAgent array after being wrapped
 * in a platform logging header JSON object, stringified, and converted
 * to base 64.
 */
function countBytes(heartbeatsCache) {
    // base64 has a restricted set of characters, all of which should be 1 byte.
    return (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.base64Encode)(
    // heartbeatsCache wrapper properties
    JSON.stringify({ version: 2, heartbeats: heartbeatsCache })).length;
}

/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function registerCoreComponents(variant) {
    _registerComponent(new _firebase_component__WEBPACK_IMPORTED_MODULE_0__.Component('platform-logger', container => new PlatformLoggerServiceImpl(container), "PRIVATE" /* PRIVATE */));
    _registerComponent(new _firebase_component__WEBPACK_IMPORTED_MODULE_0__.Component('heartbeat', container => new HeartbeatServiceImpl(container), "PRIVATE" /* PRIVATE */));
    // Register `app` package.
    registerVersion(name$o, version$1, variant);
    // BUILD_TARGET will be replaced by values like esm5, esm2017, cjs5, etc during the compilation
    registerVersion(name$o, version$1, 'esm2017');
    // Register platform SDK identifier (no version).
    registerVersion('fire-js', '');
}

/**
 * Firebase App
 *
 * @remarks This package coordinates the communication between the different Firebase components
 * @packageDocumentation
 */
registerCoreComponents('');


//# sourceMappingURL=index.esm2017.js.map


/***/ }),

/***/ "./node_modules/@firebase/component/dist/esm/index.esm2017.js":
/*!********************************************************************!*\
  !*** ./node_modules/@firebase/component/dist/esm/index.esm2017.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Component": () => (/* binding */ Component),
/* harmony export */   "ComponentContainer": () => (/* binding */ ComponentContainer),
/* harmony export */   "Provider": () => (/* binding */ Provider)
/* harmony export */ });
/* harmony import */ var _firebase_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @firebase/util */ "./node_modules/@firebase/util/dist/index.esm2017.js");


/**
 * Component for service name T, e.g. `auth`, `auth-internal`
 */
class Component {
    /**
     *
     * @param name The public service name, e.g. app, auth, firestore, database
     * @param instanceFactory Service factory responsible for creating the public interface
     * @param type whether the service provided by the component is public or private
     */
    constructor(name, instanceFactory, type) {
        this.name = name;
        this.instanceFactory = instanceFactory;
        this.type = type;
        this.multipleInstances = false;
        /**
         * Properties to be added to the service namespace
         */
        this.serviceProps = {};
        this.instantiationMode = "LAZY" /* LAZY */;
        this.onInstanceCreated = null;
    }
    setInstantiationMode(mode) {
        this.instantiationMode = mode;
        return this;
    }
    setMultipleInstances(multipleInstances) {
        this.multipleInstances = multipleInstances;
        return this;
    }
    setServiceProps(props) {
        this.serviceProps = props;
        return this;
    }
    setInstanceCreatedCallback(callback) {
        this.onInstanceCreated = callback;
        return this;
    }
}

/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const DEFAULT_ENTRY_NAME = '[DEFAULT]';

/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Provider for instance for service name T, e.g. 'auth', 'auth-internal'
 * NameServiceMapping[T] is an alias for the type of the instance
 */
class Provider {
    constructor(name, container) {
        this.name = name;
        this.container = container;
        this.component = null;
        this.instances = new Map();
        this.instancesDeferred = new Map();
        this.instancesOptions = new Map();
        this.onInitCallbacks = new Map();
    }
    /**
     * @param identifier A provider can provide mulitple instances of a service
     * if this.component.multipleInstances is true.
     */
    get(identifier) {
        // if multipleInstances is not supported, use the default name
        const normalizedIdentifier = this.normalizeInstanceIdentifier(identifier);
        if (!this.instancesDeferred.has(normalizedIdentifier)) {
            const deferred = new _firebase_util__WEBPACK_IMPORTED_MODULE_0__.Deferred();
            this.instancesDeferred.set(normalizedIdentifier, deferred);
            if (this.isInitialized(normalizedIdentifier) ||
                this.shouldAutoInitialize()) {
                // initialize the service if it can be auto-initialized
                try {
                    const instance = this.getOrInitializeService({
                        instanceIdentifier: normalizedIdentifier
                    });
                    if (instance) {
                        deferred.resolve(instance);
                    }
                }
                catch (e) {
                    // when the instance factory throws an exception during get(), it should not cause
                    // a fatal error. We just return the unresolved promise in this case.
                }
            }
        }
        return this.instancesDeferred.get(normalizedIdentifier).promise;
    }
    getImmediate(options) {
        var _a;
        // if multipleInstances is not supported, use the default name
        const normalizedIdentifier = this.normalizeInstanceIdentifier(options === null || options === void 0 ? void 0 : options.identifier);
        const optional = (_a = options === null || options === void 0 ? void 0 : options.optional) !== null && _a !== void 0 ? _a : false;
        if (this.isInitialized(normalizedIdentifier) ||
            this.shouldAutoInitialize()) {
            try {
                return this.getOrInitializeService({
                    instanceIdentifier: normalizedIdentifier
                });
            }
            catch (e) {
                if (optional) {
                    return null;
                }
                else {
                    throw e;
                }
            }
        }
        else {
            // In case a component is not initialized and should/can not be auto-initialized at the moment, return null if the optional flag is set, or throw
            if (optional) {
                return null;
            }
            else {
                throw Error(`Service ${this.name} is not available`);
            }
        }
    }
    getComponent() {
        return this.component;
    }
    setComponent(component) {
        if (component.name !== this.name) {
            throw Error(`Mismatching Component ${component.name} for Provider ${this.name}.`);
        }
        if (this.component) {
            throw Error(`Component for ${this.name} has already been provided`);
        }
        this.component = component;
        // return early without attempting to initialize the component if the component requires explicit initialization (calling `Provider.initialize()`)
        if (!this.shouldAutoInitialize()) {
            return;
        }
        // if the service is eager, initialize the default instance
        if (isComponentEager(component)) {
            try {
                this.getOrInitializeService({ instanceIdentifier: DEFAULT_ENTRY_NAME });
            }
            catch (e) {
                // when the instance factory for an eager Component throws an exception during the eager
                // initialization, it should not cause a fatal error.
                // TODO: Investigate if we need to make it configurable, because some component may want to cause
                // a fatal error in this case?
            }
        }
        // Create service instances for the pending promises and resolve them
        // NOTE: if this.multipleInstances is false, only the default instance will be created
        // and all promises with resolve with it regardless of the identifier.
        for (const [instanceIdentifier, instanceDeferred] of this.instancesDeferred.entries()) {
            const normalizedIdentifier = this.normalizeInstanceIdentifier(instanceIdentifier);
            try {
                // `getOrInitializeService()` should always return a valid instance since a component is guaranteed. use ! to make typescript happy.
                const instance = this.getOrInitializeService({
                    instanceIdentifier: normalizedIdentifier
                });
                instanceDeferred.resolve(instance);
            }
            catch (e) {
                // when the instance factory throws an exception, it should not cause
                // a fatal error. We just leave the promise unresolved.
            }
        }
    }
    clearInstance(identifier = DEFAULT_ENTRY_NAME) {
        this.instancesDeferred.delete(identifier);
        this.instancesOptions.delete(identifier);
        this.instances.delete(identifier);
    }
    // app.delete() will call this method on every provider to delete the services
    // TODO: should we mark the provider as deleted?
    async delete() {
        const services = Array.from(this.instances.values());
        await Promise.all([
            ...services
                .filter(service => 'INTERNAL' in service) // legacy services
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                .map(service => service.INTERNAL.delete()),
            ...services
                .filter(service => '_delete' in service) // modularized services
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                .map(service => service._delete())
        ]);
    }
    isComponentSet() {
        return this.component != null;
    }
    isInitialized(identifier = DEFAULT_ENTRY_NAME) {
        return this.instances.has(identifier);
    }
    getOptions(identifier = DEFAULT_ENTRY_NAME) {
        return this.instancesOptions.get(identifier) || {};
    }
    initialize(opts = {}) {
        const { options = {} } = opts;
        const normalizedIdentifier = this.normalizeInstanceIdentifier(opts.instanceIdentifier);
        if (this.isInitialized(normalizedIdentifier)) {
            throw Error(`${this.name}(${normalizedIdentifier}) has already been initialized`);
        }
        if (!this.isComponentSet()) {
            throw Error(`Component ${this.name} has not been registered yet`);
        }
        const instance = this.getOrInitializeService({
            instanceIdentifier: normalizedIdentifier,
            options
        });
        // resolve any pending promise waiting for the service instance
        for (const [instanceIdentifier, instanceDeferred] of this.instancesDeferred.entries()) {
            const normalizedDeferredIdentifier = this.normalizeInstanceIdentifier(instanceIdentifier);
            if (normalizedIdentifier === normalizedDeferredIdentifier) {
                instanceDeferred.resolve(instance);
            }
        }
        return instance;
    }
    /**
     *
     * @param callback - a function that will be invoked  after the provider has been initialized by calling provider.initialize().
     * The function is invoked SYNCHRONOUSLY, so it should not execute any longrunning tasks in order to not block the program.
     *
     * @param identifier An optional instance identifier
     * @returns a function to unregister the callback
     */
    onInit(callback, identifier) {
        var _a;
        const normalizedIdentifier = this.normalizeInstanceIdentifier(identifier);
        const existingCallbacks = (_a = this.onInitCallbacks.get(normalizedIdentifier)) !== null && _a !== void 0 ? _a : new Set();
        existingCallbacks.add(callback);
        this.onInitCallbacks.set(normalizedIdentifier, existingCallbacks);
        const existingInstance = this.instances.get(normalizedIdentifier);
        if (existingInstance) {
            callback(existingInstance, normalizedIdentifier);
        }
        return () => {
            existingCallbacks.delete(callback);
        };
    }
    /**
     * Invoke onInit callbacks synchronously
     * @param instance the service instance`
     */
    invokeOnInitCallbacks(instance, identifier) {
        const callbacks = this.onInitCallbacks.get(identifier);
        if (!callbacks) {
            return;
        }
        for (const callback of callbacks) {
            try {
                callback(instance, identifier);
            }
            catch (_a) {
                // ignore errors in the onInit callback
            }
        }
    }
    getOrInitializeService({ instanceIdentifier, options = {} }) {
        let instance = this.instances.get(instanceIdentifier);
        if (!instance && this.component) {
            instance = this.component.instanceFactory(this.container, {
                instanceIdentifier: normalizeIdentifierForFactory(instanceIdentifier),
                options
            });
            this.instances.set(instanceIdentifier, instance);
            this.instancesOptions.set(instanceIdentifier, options);
            /**
             * Invoke onInit listeners.
             * Note this.component.onInstanceCreated is different, which is used by the component creator,
             * while onInit listeners are registered by consumers of the provider.
             */
            this.invokeOnInitCallbacks(instance, instanceIdentifier);
            /**
             * Order is important
             * onInstanceCreated() should be called after this.instances.set(instanceIdentifier, instance); which
             * makes `isInitialized()` return true.
             */
            if (this.component.onInstanceCreated) {
                try {
                    this.component.onInstanceCreated(this.container, instanceIdentifier, instance);
                }
                catch (_a) {
                    // ignore errors in the onInstanceCreatedCallback
                }
            }
        }
        return instance || null;
    }
    normalizeInstanceIdentifier(identifier = DEFAULT_ENTRY_NAME) {
        if (this.component) {
            return this.component.multipleInstances ? identifier : DEFAULT_ENTRY_NAME;
        }
        else {
            return identifier; // assume multiple instances are supported before the component is provided.
        }
    }
    shouldAutoInitialize() {
        return (!!this.component &&
            this.component.instantiationMode !== "EXPLICIT" /* EXPLICIT */);
    }
}
// undefined should be passed to the service factory for the default instance
function normalizeIdentifierForFactory(identifier) {
    return identifier === DEFAULT_ENTRY_NAME ? undefined : identifier;
}
function isComponentEager(component) {
    return component.instantiationMode === "EAGER" /* EAGER */;
}

/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * ComponentContainer that provides Providers for service name T, e.g. `auth`, `auth-internal`
 */
class ComponentContainer {
    constructor(name) {
        this.name = name;
        this.providers = new Map();
    }
    /**
     *
     * @param component Component being added
     * @param overwrite When a component with the same name has already been registered,
     * if overwrite is true: overwrite the existing component with the new component and create a new
     * provider with the new component. It can be useful in tests where you want to use different mocks
     * for different tests.
     * if overwrite is false: throw an exception
     */
    addComponent(component) {
        const provider = this.getProvider(component.name);
        if (provider.isComponentSet()) {
            throw new Error(`Component ${component.name} has already been registered with ${this.name}`);
        }
        provider.setComponent(component);
    }
    addOrOverwriteComponent(component) {
        const provider = this.getProvider(component.name);
        if (provider.isComponentSet()) {
            // delete the existing provider from the container, so we can register the new component
            this.providers.delete(component.name);
        }
        this.addComponent(component);
    }
    /**
     * getProvider provides a type safe interface where it can only be called with a field name
     * present in NameServiceMapping interface.
     *
     * Firebase SDKs providing services should extend NameServiceMapping interface to register
     * themselves.
     */
    getProvider(name) {
        if (this.providers.has(name)) {
            return this.providers.get(name);
        }
        // create a Provider for a service that hasn't registered with Firebase
        const provider = new Provider(name, this);
        this.providers.set(name, provider);
        return provider;
    }
    getProviders() {
        return Array.from(this.providers.values());
    }
}


//# sourceMappingURL=index.esm2017.js.map


/***/ }),

/***/ "./node_modules/@firebase/logger/dist/esm/index.esm2017.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@firebase/logger/dist/esm/index.esm2017.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LogLevel": () => (/* binding */ LogLevel),
/* harmony export */   "Logger": () => (/* binding */ Logger),
/* harmony export */   "setLogLevel": () => (/* binding */ setLogLevel),
/* harmony export */   "setUserLogHandler": () => (/* binding */ setUserLogHandler)
/* harmony export */ });
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * A container for all of the Logger instances
 */
const instances = [];
/**
 * The JS SDK supports 5 log levels and also allows a user the ability to
 * silence the logs altogether.
 *
 * The order is a follows:
 * DEBUG < VERBOSE < INFO < WARN < ERROR
 *
 * All of the log types above the current log level will be captured (i.e. if
 * you set the log level to `INFO`, errors will still be logged, but `DEBUG` and
 * `VERBOSE` logs will not)
 */
var LogLevel;
(function (LogLevel) {
    LogLevel[LogLevel["DEBUG"] = 0] = "DEBUG";
    LogLevel[LogLevel["VERBOSE"] = 1] = "VERBOSE";
    LogLevel[LogLevel["INFO"] = 2] = "INFO";
    LogLevel[LogLevel["WARN"] = 3] = "WARN";
    LogLevel[LogLevel["ERROR"] = 4] = "ERROR";
    LogLevel[LogLevel["SILENT"] = 5] = "SILENT";
})(LogLevel || (LogLevel = {}));
const levelStringToEnum = {
    'debug': LogLevel.DEBUG,
    'verbose': LogLevel.VERBOSE,
    'info': LogLevel.INFO,
    'warn': LogLevel.WARN,
    'error': LogLevel.ERROR,
    'silent': LogLevel.SILENT
};
/**
 * The default log level
 */
const defaultLogLevel = LogLevel.INFO;
/**
 * By default, `console.debug` is not displayed in the developer console (in
 * chrome). To avoid forcing users to have to opt-in to these logs twice
 * (i.e. once for firebase, and once in the console), we are sending `DEBUG`
 * logs to the `console.log` function.
 */
const ConsoleMethod = {
    [LogLevel.DEBUG]: 'log',
    [LogLevel.VERBOSE]: 'log',
    [LogLevel.INFO]: 'info',
    [LogLevel.WARN]: 'warn',
    [LogLevel.ERROR]: 'error'
};
/**
 * The default log handler will forward DEBUG, VERBOSE, INFO, WARN, and ERROR
 * messages on to their corresponding console counterparts (if the log method
 * is supported by the current log level)
 */
const defaultLogHandler = (instance, logType, ...args) => {
    if (logType < instance.logLevel) {
        return;
    }
    const now = new Date().toISOString();
    const method = ConsoleMethod[logType];
    if (method) {
        console[method](`[${now}]  ${instance.name}:`, ...args);
    }
    else {
        throw new Error(`Attempted to log a message with an invalid logType (value: ${logType})`);
    }
};
class Logger {
    /**
     * Gives you an instance of a Logger to capture messages according to
     * Firebase's logging scheme.
     *
     * @param name The name that the logs will be associated with
     */
    constructor(name) {
        this.name = name;
        /**
         * The log level of the given Logger instance.
         */
        this._logLevel = defaultLogLevel;
        /**
         * The main (internal) log handler for the Logger instance.
         * Can be set to a new function in internal package code but not by user.
         */
        this._logHandler = defaultLogHandler;
        /**
         * The optional, additional, user-defined log handler for the Logger instance.
         */
        this._userLogHandler = null;
        /**
         * Capture the current instance for later use
         */
        instances.push(this);
    }
    get logLevel() {
        return this._logLevel;
    }
    set logLevel(val) {
        if (!(val in LogLevel)) {
            throw new TypeError(`Invalid value "${val}" assigned to \`logLevel\``);
        }
        this._logLevel = val;
    }
    // Workaround for setter/getter having to be the same type.
    setLogLevel(val) {
        this._logLevel = typeof val === 'string' ? levelStringToEnum[val] : val;
    }
    get logHandler() {
        return this._logHandler;
    }
    set logHandler(val) {
        if (typeof val !== 'function') {
            throw new TypeError('Value assigned to `logHandler` must be a function');
        }
        this._logHandler = val;
    }
    get userLogHandler() {
        return this._userLogHandler;
    }
    set userLogHandler(val) {
        this._userLogHandler = val;
    }
    /**
     * The functions below are all based on the `console` interface
     */
    debug(...args) {
        this._userLogHandler && this._userLogHandler(this, LogLevel.DEBUG, ...args);
        this._logHandler(this, LogLevel.DEBUG, ...args);
    }
    log(...args) {
        this._userLogHandler &&
            this._userLogHandler(this, LogLevel.VERBOSE, ...args);
        this._logHandler(this, LogLevel.VERBOSE, ...args);
    }
    info(...args) {
        this._userLogHandler && this._userLogHandler(this, LogLevel.INFO, ...args);
        this._logHandler(this, LogLevel.INFO, ...args);
    }
    warn(...args) {
        this._userLogHandler && this._userLogHandler(this, LogLevel.WARN, ...args);
        this._logHandler(this, LogLevel.WARN, ...args);
    }
    error(...args) {
        this._userLogHandler && this._userLogHandler(this, LogLevel.ERROR, ...args);
        this._logHandler(this, LogLevel.ERROR, ...args);
    }
}
function setLogLevel(level) {
    instances.forEach(inst => {
        inst.setLogLevel(level);
    });
}
function setUserLogHandler(logCallback, options) {
    for (const instance of instances) {
        let customLogLevel = null;
        if (options && options.level) {
            customLogLevel = levelStringToEnum[options.level];
        }
        if (logCallback === null) {
            instance.userLogHandler = null;
        }
        else {
            instance.userLogHandler = (instance, level, ...args) => {
                const message = args
                    .map(arg => {
                    if (arg == null) {
                        return null;
                    }
                    else if (typeof arg === 'string') {
                        return arg;
                    }
                    else if (typeof arg === 'number' || typeof arg === 'boolean') {
                        return arg.toString();
                    }
                    else if (arg instanceof Error) {
                        return arg.message;
                    }
                    else {
                        try {
                            return JSON.stringify(arg);
                        }
                        catch (ignored) {
                            return null;
                        }
                    }
                })
                    .filter(arg => arg)
                    .join(' ');
                if (level >= (customLogLevel !== null && customLogLevel !== void 0 ? customLogLevel : instance.logLevel)) {
                    logCallback({
                        level: LogLevel[level].toLowerCase(),
                        message,
                        args,
                        type: instance.name
                    });
                }
            };
        }
    }
}


//# sourceMappingURL=index.esm2017.js.map


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	(() => {
/******/ 		var scriptUrl;
/******/ 		if (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + "";
/******/ 		var document = __webpack_require__.g.document;
/******/ 		if (!scriptUrl && document) {
/******/ 			if (document.currentScript)
/******/ 				scriptUrl = document.currentScript.src
/******/ 			if (!scriptUrl) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				if(scripts.length) scriptUrl = scripts[scripts.length - 1].src
/******/ 			}
/******/ 		}
/******/ 		// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration
/******/ 		// or pass an empty string ("") and set the __webpack_public_path__ variable from your code to use your own logic.
/******/ 		if (!scriptUrl) throw new Error("Automatic publicPath is not supported in this browser");
/******/ 		scriptUrl = scriptUrl.replace(/#.*$/, "").replace(/\?.*$/, "").replace(/\/[^\/]+$/, "/");
/******/ 		__webpack_require__.p = scriptUrl;
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/jsonp chunk loading */
/******/ 	(() => {
/******/ 		__webpack_require__.b = document.baseURI || self.location.href;
/******/ 		
/******/ 		// object to store loaded and loading chunks
/******/ 		// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 		// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded
/******/ 		var installedChunks = {
/******/ 			"index": 0
/******/ 		};
/******/ 		
/******/ 		// no chunk on demand loading
/******/ 		
/******/ 		// no prefetching
/******/ 		
/******/ 		// no preloaded
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 		
/******/ 		// no on chunks loaded
/******/ 		
/******/ 		// no jsonp function
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
(() => {
"use strict";
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _sass_index_sass__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./sass/index.sass */ "./src/sass/index.sass");
/* harmony import */ var typed_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! typed.js */ "./node_modules/typed.js/lib/typed.js");
/* harmony import */ var typed_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(typed_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var firebase_app__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! firebase/app */ "./node_modules/firebase/app/dist/index.esm.js");
/* harmony import */ var firebase_database__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! firebase/database */ "./node_modules/firebase/database/dist/index.esm.js");
// Main sass file importing all other subfiles (check ./sass)



//#region general


function getWidth() {
  return Math.max(
    document.body.scrollWidth,
    document.documentElement.scrollWidth,
    document.body.offsetWidth,
    document.documentElement.offsetWidth,
    document.documentElement.clientWidth
  );
}

//#endregion


//#region Loading qualities


const qualities = ["Cutting Edge", "Upscale" , "Artistic", "Extraordinary"];

var options = {
  strings: qualities,
  typeSpeed: 150,
  backSpeed: 50,
  shuffle: false,
  backDelay: 1000,
  fadeOut: false,

  //cursor
  showCursor: true,
  cursorChar: '_',
};

var typed = new (typed_js__WEBPACK_IMPORTED_MODULE_1___default())('#qualities strong', options);

//#endregion

//#region hobby handling
const hobbies = document.querySelectorAll('.hobby a');
const hobbiesContainer = document.getElementById('hobbies-container');
hobbies.forEach(hobby => {
    hobby.addEventListener('focus', () => setJustifyContent(hobby, 650));
    hobby.addEventListener('focusout', () => hobbiesContainer.style.justifyContent = "space-around");
})

function widthSmallerThan(width){
    const clientWidth = getWidth();  
    if(clientWidth > width)
        return false;
}

//TODO: refactor
function setJustifyContent(hobby, preferedClientWidth){ //650px
    const clientWidth = getWidth();  
    if(clientWidth > preferedClientWidth)
        return;

    const id = hobby.parentNode.id

    if(id ==  "developer") //justify-content: start;
        hobbiesContainer.style.justifyContent = "flex-start";
    else if(id == "designer") //justify-content: center;
        hobbiesContainer.style.justifyContent = "center";
    else if(id == "collector") //justify-content: end;
        hobbiesContainer.style.justifyContent = "flex-end";
}

//#endregion


//#region sticky header
window.onscroll = function() {stickHeader()};

var header = document.getElementById("header");
var landingContainer = document.getElementById("hero-container");


function stickHeader() {
    var offset = header.offsetTop;
    if (window.pageYOffset > offset) {
        header.classList.add("sticky");
        landingContainer.style.paddingTop = header.clientHeight + "px"; 
    } else {
        header.classList.remove("sticky");
        landingContainer.style.paddingTop = "0px"; 
    }
}
//#endregion


//#region duties handling
const dutyNames = ["Exceptionally Performant",
            "Fully Responsive",
            "Highly Intuitive",
            "SEO Developer Ready"];

const dutyDescriptions = ["My duty is to ensure fast load times and no any issues with rendering and"
                        + " intractions. I’m going to give you the fastest version of your website.",

                    "From 4K screen all the way to foldable devices, my layout will be fluent and eye"
                        + " appealing no matter the user's device form factor or brand.",

                    "Known about me,  I have a strong preference for strong and powerful yet,"
                        + " easy to use UI.",

                    "Ensuring all pages are optimized for search engine results ranking"
                        + " by following SEO best practices and building semantic markup."];

const dutyIcons  = document.querySelectorAll('.duty-icon');
const activeDutyClass = "active-duty";
dutyIcons.forEach(dutyIcon => {
    dutyIcon.addEventListener('mouseenter', () => hobbyIconHoverControl(dutyIcon));
    dutyIcon.addEventListener('mouseleave', () => dutyIcon.style.backgroundColor = "transparent");
    dutyIcon.addEventListener('click', () => activateDuty(dutyIcon));
})

function hobbyIconHoverControl(dutyIcon){
    if(dutyIcon.parentNode.classList.contains(activeDutyClass)){
        dutyIcon.style.backgroundColor = "transparent";
        console.log("active hover");

    }
    else{
        dutyIcon.style.backgroundColor = "rgba(250, 250, 250, 0.075)";
    }
}

function activateDuty(dutyIcon){

    dutyIcons.forEach(allDuties => allDuties.parentNode.classList.remove(activeDutyClass));
    dutyIcon.parentNode.classList.add(activeDutyClass);


    var dutiesSliced = Array.prototype.slice.call( document.getElementById('duties').children );
    const dutyIndex = dutiesSliced.indexOf(dutyIcon.parentNode);

    document.getElementById("duty-description").innerHTML = dutyDescriptions[dutyIndex];
    document.getElementById("duty-name").innerHTML = dutyNames[dutyIndex];
}
//#endregion


window.addEventListener("contextmenu", e => e.preventDefault());


// Form input validation 

document.querySelectorAll('.text-box').forEach(textBox => {
    textBox.addEventListener('keyup', validate);
});

const isInputEmpty = (textBox) => {
    return textBox.value == "" || textBox.value == null;    
}

const validateEmail = (email) => {
  return email.match(
    /^(([^<>()[\]\\.,;:\s@\"]+(\.[^<>()[\]\\.,;:\s@\"]+)*)|(\".+\"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/
  );
};

const capitalizeFirst = (str) => {
    return str[0].toUpperCase() + str.slice(1); 
}

// obj may be the event args or the <input/> iteself depending on the caller
// we'll check for that
function validate(obj){
    let textBox;
    try {
        textBox = obj.path[0];    
    } catch {
        textBox = obj;
    }
     
    const boxId = textBox.id;
    const errorLabel = document.getElementById(boxId + "-error-label"); 
    const parent = textBox.parentElement;

    // general case: no empty textBox
    if(isInputEmpty(textBox)){

        console.log("empty");

        errorLabel.innerText = capitalizeFirst(boxId) + " can't be empty.";
        parent.classList.add("invalid-input");

        return false;
    }

    // email must be formarted correctly and cannot be mine :"
    if(boxId == "email"){
        if(!validateEmail(textBox.value)){
            errorLabel.innerText = "Invalid email";
            parent.classList.add("invalid-input");

            return false;
        }
        else if(textBox.value == "adhamali_4500@outlook.com"){
            errorLabel.innerText = "Email can't be mine";
            parent.classList.add("invalid-input");
        
            return false;
        }
    }

    clearErrorState(textBox);
    return true;
}

function clearErrorState(textBox){ 
    // const parent = document.getElementById(e.target.id).parentElement;
    const parent = textBox.parentElement;
    parent.classList.remove("invalid-input");
}





const firebaseConfig = {
  apiKey: "AIzaSyD2bmYjXuVEqBKhx_ICIQkVhzwBfyubq3k",
  authDomain: "my-portfolio-5c98d.firebaseapp.com",
  databaseURL: "https://my-portfolio-5c98d-default-rtdb.europe-west1.firebasedatabase.app",
  projectId: "my-portfolio-5c98d",
  storageBucket: "my-portfolio-5c98d.appspot.com",
  messagingSenderId: "998620020062",
  appId: "1:998620020062:web:55d8c4c84547e52e0623cf",
  measurementId: "G-M4BPVY0M92"
};

const app = (0,firebase_app__WEBPACK_IMPORTED_MODULE_2__.initializeApp)(firebaseConfig);
const database = (0,firebase_database__WEBPACK_IMPORTED_MODULE_3__.getDatabase)(app);

function storeClientMessage(name, email, message) {
    const db = (0,firebase_database__WEBPACK_IMPORTED_MODULE_3__.getDatabase)();
    (0,firebase_database__WEBPACK_IMPORTED_MODULE_3__.set)((0,firebase_database__WEBPACK_IMPORTED_MODULE_3__.ref)(db, name+'/'), {
        name: name,
        email: email,
        message : message
    });
}


const form = document.getElementById("form"); 
form.addEventListener("submit", (e) => {
    
    e.preventDefault();
    
    const textBoxes = [document.getElementById("name"), 
    document.getElementById("email"),
    document.getElementById("message")]

    for (let i = 0; i < textBoxes.length; i++) {
        if(!validate(textBoxes[i])) {
            textBoxes[i].focus();
            return;
        }
    }

    storeClientMessage(textBoxes[0].value, textBoxes[1].value, textBoxes[2].value);

    form.reset();
    form.classList.add("show-conf");
    setTimeout(()=>form.classList.remove("show-conf"), 2000);
})
})();

/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLHNEQUFNLGtEQUFrRDtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsR0FBRztBQUN2QjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsR0FBRztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsS0FBSztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEhBQTRILGdCQUFnQjtBQUM1STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsY0FBYztBQUMvRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsZ0JBQWdCO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixlQUFlO0FBQ3BDO0FBQ0Esa0JBQWtCLFNBQVMsRUFBRSxVQUFVLEdBQUcsTUFBTTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLHNEQUFNO0FBQ1YsSUFBSSxzREFBTTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHdEQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHdEQUFRO0FBQ3ZCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixzQkFBc0I7QUFDbEQ7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx5REFBUztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix5REFBUztBQUNqQztBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsNERBQVk7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixxQkFBcUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHlEQUFTO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLHlEQUFTO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSx5REFBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEVBQTBFO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELGdCQUFnQjtBQUNqRTtBQUNBLDJCQUEyQixrQkFBa0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQSx3REFBd0Q7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxxQ0FBcUM7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVkseURBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEseURBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IseURBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsaUJBQWlCLEdBQUcsWUFBWSxHQUFHLGlCQUFpQixHQUFHLE9BQU87QUFDaEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLGVBQWU7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELEdBQUcsUUFBUSxHQUFHO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLHdEQUFRO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxzREFBTTtBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHlEQUFTO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHFCQUFxQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLGFBQWEsa0JBQWtCO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGFBQWEsd0JBQXdCO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixhQUFhLDhCQUE4QjtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MscUNBQXFDO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsYUFBYSxrQkFBa0I7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsc0RBQU07QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHNCQUFzQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxtQkFBbUI7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixzQkFBc0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsc0RBQU07QUFDZDtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsK0RBQWU7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsOEJBQThCO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxzREFBTTtBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLHlEQUFTO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix5REFBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxzREFBTTtBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUFjO0FBQzVCO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsc0RBQU07QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHNEQUFNO0FBQ2Q7QUFDQSx3Q0FBd0Msd0RBQVE7QUFDaEQ7QUFDQTtBQUNBLFFBQVEsc0RBQU07QUFDZDtBQUNBO0FBQ0EsSUFBSSxzREFBTTtBQUNWOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHNEQUFNO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksc0RBQU07QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxzREFBTTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxzREFBTTtBQUNkLFFBQVEsc0RBQU07QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixrQkFBa0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxzREFBTTtBQUNkO0FBQ0E7QUFDQSwrQkFBK0IsNkJBQTZCLElBQUksNkJBQTZCO0FBQzdGO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQix1REFBTztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsd0RBQVE7QUFDdkI7QUFDQTtBQUNBLFFBQVEsc0RBQU07QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsbURBQUc7QUFDOUIsMEJBQTBCLHVEQUFPO0FBQ2pDLFlBQVksc0RBQU07QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsbURBQUc7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxzREFBTTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsc0RBQU07QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHNEQUFNO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLHNEQUFNO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUZBQXFGLDZCQUE2QixJQUFJLDZCQUE2QjtBQUNuSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHdEQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsc0RBQU07QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHNEQUFNO0FBQ2Q7QUFDQTtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixtQ0FBbUM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0EsUUFBUSxzREFBTTtBQUNkO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxzREFBTTtBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHNEQUFNO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsc0RBQU07QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsc0RBQU07QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsc0RBQU07QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxzREFBTTtBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxzREFBTTtBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHNEQUFNO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsc0RBQU07QUFDZDtBQUNBO0FBQ0EsbUNBQW1DLHlEQUFTO0FBQzVDO0FBQ0EsdUNBQXVDLHlEQUFTO0FBQ2hEO0FBQ0E7QUFDQSxzQkFBc0IseURBQVM7QUFDL0I7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLHlEQUFTO0FBQzVDO0FBQ0E7QUFDQSxzQkFBc0IseURBQVM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGtCQUFrQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHNEQUFNO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix1REFBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLG9EQUFRO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RDtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDJEQUFXO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0Msd0RBQVE7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsd0RBQVE7QUFDckM7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHNDQUFzQztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHNEQUFNO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLFlBQVksc0RBQU07QUFDbEIseURBQXlEO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksc0RBQU07QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyw4REFBYztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELGFBQWE7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixzREFBTTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLHNEQUFNO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLHNEQUFNO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixnQ0FBZ0M7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUksc0RBQU07QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtQkFBbUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyx1REFBTztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiw4REFBYztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLHNEQUFNO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxzREFBTTtBQUNkO0FBQ0E7QUFDQSxRQUFRLHNEQUFNO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDhEQUFjO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLElBQUksc0RBQU07QUFDVixJQUFJLHNEQUFNO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHNEQUFNO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksc0RBQU07QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLDhEQUFjO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHNEQUFNO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHNEQUFNO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixzREFBTTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxzREFBTTtBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IscUNBQXFDO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHNEQUFNO0FBQ2QsUUFBUSxzREFBTTtBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxzREFBTTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtFQUErRTtBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxzREFBTTtBQUNWO0FBQ0E7QUFDQTtBQUNBLElBQUksc0RBQU07QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHNEQUFNO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxzREFBTTtBQUNWO0FBQ0E7QUFDQTtBQUNBLElBQUksc0RBQU07QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxxQkFBcUI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsc0RBQU07QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLHNEQUFNO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLHNEQUFNO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG9CQUFvQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHNEQUFNO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsU0FBUztBQUNULHdCQUF3QiwwQkFBMEI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksc0RBQU07QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsc0RBQU07QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksc0RBQU07QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHNEQUFNO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsUUFBUSxzREFBTTtBQUNkO0FBQ0E7QUFDQSxJQUFJLHNEQUFNO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELFlB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QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLG1EQUFHO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsbURBQUc7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCx5Q0FBeUMseURBQVM7QUFDbEQ7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLCtDQUErQztBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsUUFBUSx1REFBTztBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxRQUFRLGNBQWMsWUFBWTtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx5REFBUztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRTtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsa0VBQWtCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLGtFQUFrQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsa0VBQWtCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGtFQUFrQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBO0FBQ0EsYUFBYSxrRUFBa0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUU7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxrRUFBa0I7QUFDNUI7QUFDQTtBQUNBLHlCQUF5QixvREFBUTtBQUNqQztBQUNBLHVEQUF1RDtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsa0VBQWtCO0FBQzVCO0FBQ0E7QUFDQSx5QkFBeUIsb0RBQVE7QUFDakMscUhBQXFIO0FBQ3JIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLG9EQUFRO0FBQ2pDLDhGQUE4RjtBQUM5RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksMklBQTJJO0FBQy9JO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLG9EQUFRO0FBQ2pDLDRFQUE0RTtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxrRUFBa0I7QUFDOUI7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsc0RBQU07QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRCxZQUFZO0FBQzNFLElBQUksZ0JBQWdCLEdBQUcsY0FBYyxHQUFHLGlCQUFpQixHQUFHO0FBQzVELGdCQUFnQixHQUFHLGtCQUFrQixHQUFHLG1CQUFtQjtBQUMzRCxJQUFJLG1CQUFtQixHQUFHLGtCQUFrQixHQUFHLHVCQUF1QjtBQUN0RSxJQUFJLHFCQUFxQixJQUFJLGVBQWU7QUFDNUMsMEJBQTBCLGFBQWE7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksa0dBQWtHO0FBQ3RHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxrR0FBa0c7QUFDdEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLGtHQUFrRztBQUN0RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLGtHQUFrRztBQUN0RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsSUFBSSx3RkFBd0Y7QUFDNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLHdGQUF3RjtBQUM1RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSx3RkFBd0Y7QUFDNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxrR0FBa0c7QUFDdEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrRUFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMs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QUMvb2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZUFBZTtBQUNuQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixrQkFBa0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGlCQUFpQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsOEJBQThCO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxRQUFRO0FBQ3ZEO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MscUJBQU07QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHFCQUFNO0FBQ3JCLGVBQWUscUJBQU07QUFDckI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELE1BQU07QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxpQkFBaUI7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGFBQWEsR0FBRyxLQUFLO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixpQkFBaUIsSUFBSSxTQUFTLEdBQUcsU0FBUztBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxJQUFJO0FBQ3ZELEtBQUs7QUFDTDtBQUNBLG1CQUFtQixNQUFNLElBQUk7O0FBRTdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVksR0FBRztBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsYUFBYSxXQUFXO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IseUJBQXlCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSx5QkFBeUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixvQkFBb0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixRQUFRO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsUUFBUTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsUUFBUTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLFNBQVM7QUFDbEQ7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLE9BQU87QUFDL0IsNkJBQTZCLFFBQVE7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDJCQUEyQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRLFVBQVUsU0FBUztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUFDckQsQ0FBQyw0QkFBNEI7O0FBRTdCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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Q0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG9EQUFNOztBQUV6Qjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsZ0JBQWdCLHNDQUFzQyxTQUFTO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVtRDtBQUNuRDs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3haQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDRCQUE0QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixJQUFJLEtBQUssY0FBYztBQUNuRDtBQUNBO0FBQ0Esc0ZBQXNGLFFBQVE7QUFDOUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsSUFBSTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFNEQ7QUFDNUQ7Ozs7Ozs7VUMxTkE7VUFDQTs7VUFFQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTs7VUFFQTtVQUNBOztVQUVBO1VBQ0E7VUFDQTs7VUFFQTtVQUNBOzs7OztXQ3pCQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0EsaUNBQWlDLFdBQVc7V0FDNUM7V0FDQTs7Ozs7V0NQQTtXQUNBO1dBQ0E7V0FDQTtXQUNBLHlDQUF5Qyx3Q0FBd0M7V0FDakY7V0FDQTtXQUNBOzs7OztXQ1BBO1dBQ0E7V0FDQTtXQUNBO1dBQ0EsR0FBRztXQUNIO1dBQ0E7V0FDQSxDQUFDOzs7OztXQ1BEOzs7OztXQ0FBO1dBQ0E7V0FDQTtXQUNBLHVEQUF1RCxpQkFBaUI7V0FDeEU7V0FDQSxnREFBZ0QsYUFBYTtXQUM3RDs7Ozs7V0NOQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTs7Ozs7V0NmQTs7V0FFQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7O1dBRUE7O1dBRUE7O1dBRUE7O1dBRUE7O1dBRUE7O1dBRUE7O1dBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDckJBO0FBQzJCOzs7QUFHM0I7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7QUFDNkI7O0FBRTdCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdCQUFnQixpREFBSzs7QUFFckI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0RBQXdEO0FBQ3hEO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQSw4QkFBOEI7O0FBRTlCO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQkFBc0IseUJBQXlCLGdDQUFnQyxJQUFJLFFBQVEsSUFBSSxRQUFRLElBQUksUUFBUSxJQUFJLGlDQUFpQyxHQUFHO0FBQzNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRTZDO0FBQ2E7OztBQUcxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxZQUFZLDJEQUFhO0FBQ3pCLGlCQUFpQiw4REFBVzs7QUFFNUI7QUFDQSxlQUFlLDhEQUFXO0FBQzFCLElBQUksc0RBQUcsQ0FBQyxzREFBRztBQUNYO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0Isc0JBQXNCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktcG9ydGZvbGlvLy4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9kYXRhYmFzZS9kaXN0L2luZGV4LmVzbTIwMTcuanMiLCJ3ZWJwYWNrOi8vbXktcG9ydGZvbGlvLy4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS91dGlsL2Rpc3QvaW5kZXguZXNtMjAxNy5qcyIsIndlYnBhY2s6Ly9teS1wb3J0Zm9saW8vLi9zcmMvc2Fzcy9pbmRleC5zYXNzIiwid2VicGFjazovL215LXBvcnRmb2xpby8uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9hcGkuanMiLCJ3ZWJwYWNrOi8vbXktcG9ydGZvbGlvLy4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2dldFVybC5qcyIsIndlYnBhY2s6Ly9teS1wb3J0Zm9saW8vLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvc291cmNlTWFwcy5qcyIsIndlYnBhY2s6Ly9teS1wb3J0Zm9saW8vLi9ub2RlX21vZHVsZXMvZmlyZWJhc2UvYXBwL2Rpc3QvaW5kZXguZXNtLmpzIiwid2VicGFjazovL215LXBvcnRmb2xpby8uL25vZGVfbW9kdWxlcy9maXJlYmFzZS9kYXRhYmFzZS9kaXN0L2luZGV4LmVzbS5qcyIsIndlYnBhY2s6Ly9teS1wb3J0Zm9saW8vLi9ub2RlX21vZHVsZXMvaWRiL2J1aWxkL2lkYi5qcyIsIndlYnBhY2s6Ly9teS1wb3J0Zm9saW8vLi9zcmMvc2Fzcy9pbmRleC5zYXNzP2JlYjciLCJ3ZWJwYWNrOi8vbXktcG9ydGZvbGlvLy4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvaW5qZWN0U3R5bGVzSW50b1N0eWxlVGFnLmpzIiwid2VicGFjazovL215LXBvcnRmb2xpby8uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luc2VydEJ5U2VsZWN0b3IuanMiLCJ3ZWJwYWNrOi8vbXktcG9ydGZvbGlvLy4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvaW5zZXJ0U3R5bGVFbGVtZW50LmpzIiwid2VicGFjazovL215LXBvcnRmb2xpby8uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL3NldEF0dHJpYnV0ZXNXaXRob3V0QXR0cmlidXRlcy5qcyIsIndlYnBhY2s6Ly9teS1wb3J0Zm9saW8vLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9zdHlsZURvbUFQSS5qcyIsIndlYnBhY2s6Ly9teS1wb3J0Zm9saW8vLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9zdHlsZVRhZ1RyYW5zZm9ybS5qcyIsIndlYnBhY2s6Ly9teS1wb3J0Zm9saW8vLi9ub2RlX21vZHVsZXMvdHlwZWQuanMvbGliL3R5cGVkLmpzIiwid2VicGFjazovL215LXBvcnRmb2xpby8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvYXBwL2Rpc3QvZXNtL2luZGV4LmVzbTIwMTcuanMiLCJ3ZWJwYWNrOi8vbXktcG9ydGZvbGlvLy4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9jb21wb25lbnQvZGlzdC9lc20vaW5kZXguZXNtMjAxNy5qcyIsIndlYnBhY2s6Ly9teS1wb3J0Zm9saW8vLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2xvZ2dlci9kaXN0L2VzbS9pbmRleC5lc20yMDE3LmpzIiwid2VicGFjazovL215LXBvcnRmb2xpby93ZWJwYWNrL2Jvb3RzdHJhcCIsIndlYnBhY2s6Ly9teS1wb3J0Zm9saW8vd2VicGFjay9ydW50aW1lL2NvbXBhdCBnZXQgZGVmYXVsdCBleHBvcnQiLCJ3ZWJwYWNrOi8vbXktcG9ydGZvbGlvL3dlYnBhY2svcnVudGltZS9kZWZpbmUgcHJvcGVydHkgZ2V0dGVycyIsIndlYnBhY2s6Ly9teS1wb3J0Zm9saW8vd2VicGFjay9ydW50aW1lL2dsb2JhbCIsIndlYnBhY2s6Ly9teS1wb3J0Zm9saW8vd2VicGFjay9ydW50aW1lL2hhc093blByb3BlcnR5IHNob3J0aGFuZCIsIndlYnBhY2s6Ly9teS1wb3J0Zm9saW8vd2VicGFjay9ydW50aW1lL21ha2UgbmFtZXNwYWNlIG9iamVjdCIsIndlYnBhY2s6Ly9teS1wb3J0Zm9saW8vd2VicGFjay9ydW50aW1lL3B1YmxpY1BhdGgiLCJ3ZWJwYWNrOi8vbXktcG9ydGZvbGlvL3dlYnBhY2svcnVudGltZS9qc29ucCBjaHVuayBsb2FkaW5nIiwid2VicGFjazovL215LXBvcnRmb2xpby8uL3NyYy9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBnZXRBcHAsIF9nZXRQcm92aWRlciwgU0RLX1ZFUlNJT04gYXMgU0RLX1ZFUlNJT04kMSwgX3JlZ2lzdGVyQ29tcG9uZW50LCByZWdpc3RlclZlcnNpb24gfSBmcm9tICdAZmlyZWJhc2UvYXBwJztcbmltcG9ydCB7IENvbXBvbmVudCB9IGZyb20gJ0BmaXJlYmFzZS9jb21wb25lbnQnO1xuaW1wb3J0IHsgc3RyaW5naWZ5LCBqc29uRXZhbCwgY29udGFpbnMsIGFzc2VydCwgYmFzZTY0LCBzdHJpbmdUb0J5dGVBcnJheSwgU2hhMSwgaXNOb2RlU2RrLCBkZWVwQ29weSwgYmFzZTY0RW5jb2RlLCBpc01vYmlsZUNvcmRvdmEsIHN0cmluZ0xlbmd0aCwgRGVmZXJyZWQsIHNhZmVHZXQsIGlzQWRtaW4sIGlzVmFsaWRGb3JtYXQsIGlzRW1wdHksIGlzUmVhY3ROYXRpdmUsIGFzc2VydGlvbkVycm9yLCBtYXAsIHF1ZXJ5c3RyaW5nLCBlcnJvclByZWZpeCwgZ2V0TW9kdWxhckluc3RhbmNlLCBjcmVhdGVNb2NrVXNlclRva2VuIH0gZnJvbSAnQGZpcmViYXNlL3V0aWwnO1xuaW1wb3J0IHsgTG9nZ2VyLCBMb2dMZXZlbCB9IGZyb20gJ0BmaXJlYmFzZS9sb2dnZXInO1xuXG5jb25zdCBuYW1lID0gXCJAZmlyZWJhc2UvZGF0YWJhc2VcIjtcbmNvbnN0IHZlcnNpb24gPSBcIjAuMTIuNVwiO1xuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKiogVGhlIHNlbXZlciAod3d3LnNlbXZlci5vcmcpIHZlcnNpb24gb2YgdGhlIFNESy4gKi9cclxubGV0IFNES19WRVJTSU9OID0gJyc7XHJcbi8qKlxyXG4gKiBTREtfVkVSU0lPTiBzaG91bGQgYmUgc2V0IGJlZm9yZSBhbnkgZGF0YWJhc2UgaW5zdGFuY2UgaXMgY3JlYXRlZFxyXG4gKiBAaW50ZXJuYWxcclxuICovXHJcbmZ1bmN0aW9uIHNldFNES1ZlcnNpb24odmVyc2lvbikge1xyXG4gICAgU0RLX1ZFUlNJT04gPSB2ZXJzaW9uO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBXcmFwcyBhIERPTSBTdG9yYWdlIG9iamVjdCBhbmQ6XHJcbiAqIC0gYXV0b21hdGljYWxseSBlbmNvZGUgb2JqZWN0cyBhcyBKU09OIHN0cmluZ3MgYmVmb3JlIHN0b3JpbmcgdGhlbSB0byBhbGxvdyB1cyB0byBzdG9yZSBhcmJpdHJhcnkgdHlwZXMuXHJcbiAqIC0gcHJlZml4ZXMgbmFtZXMgd2l0aCBcImZpcmViYXNlOlwiIHRvIGF2b2lkIGNvbGxpc2lvbnMgd2l0aCBhcHAgZGF0YS5cclxuICpcclxuICogV2UgYXV0b21hdGljYWxseSAoc2VlIHN0b3JhZ2UuanMpIGNyZWF0ZSB0d28gc3VjaCB3cmFwcGVycywgb25lIGZvciBzZXNzaW9uU3RvcmFnZSxcclxuICogYW5kIG9uZSBmb3IgbG9jYWxTdG9yYWdlLlxyXG4gKlxyXG4gKi9cclxuY2xhc3MgRE9NU3RvcmFnZVdyYXBwZXIge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gZG9tU3RvcmFnZV8gLSBUaGUgdW5kZXJseWluZyBzdG9yYWdlIG9iamVjdCAoZS5nLiBsb2NhbFN0b3JhZ2Ugb3Igc2Vzc2lvblN0b3JhZ2UpXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKGRvbVN0b3JhZ2VfKSB7XHJcbiAgICAgICAgdGhpcy5kb21TdG9yYWdlXyA9IGRvbVN0b3JhZ2VfO1xyXG4gICAgICAgIC8vIFVzZSBhIHByZWZpeCB0byBhdm9pZCBjb2xsaXNpb25zIHdpdGggb3RoZXIgc3R1ZmYgc2F2ZWQgYnkgdGhlIGFwcC5cclxuICAgICAgICB0aGlzLnByZWZpeF8gPSAnZmlyZWJhc2U6JztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIGtleSAtIFRoZSBrZXkgdG8gc2F2ZSB0aGUgdmFsdWUgdW5kZXJcclxuICAgICAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSBiZWluZyBzdG9yZWQsIG9yIG51bGwgdG8gcmVtb3ZlIHRoZSBrZXkuXHJcbiAgICAgKi9cclxuICAgIHNldChrZXksIHZhbHVlKSB7XHJcbiAgICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcclxuICAgICAgICAgICAgdGhpcy5kb21TdG9yYWdlXy5yZW1vdmVJdGVtKHRoaXMucHJlZml4ZWROYW1lXyhrZXkpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuZG9tU3RvcmFnZV8uc2V0SXRlbSh0aGlzLnByZWZpeGVkTmFtZV8oa2V5KSwgc3RyaW5naWZ5KHZhbHVlKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgdmFsdWUgdGhhdCB3YXMgc3RvcmVkIHVuZGVyIHRoaXMga2V5LCBvciBudWxsXHJcbiAgICAgKi9cclxuICAgIGdldChrZXkpIHtcclxuICAgICAgICBjb25zdCBzdG9yZWRWYWwgPSB0aGlzLmRvbVN0b3JhZ2VfLmdldEl0ZW0odGhpcy5wcmVmaXhlZE5hbWVfKGtleSkpO1xyXG4gICAgICAgIGlmIChzdG9yZWRWYWwgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBqc29uRXZhbChzdG9yZWRWYWwpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJlbW92ZShrZXkpIHtcclxuICAgICAgICB0aGlzLmRvbVN0b3JhZ2VfLnJlbW92ZUl0ZW0odGhpcy5wcmVmaXhlZE5hbWVfKGtleSkpO1xyXG4gICAgfVxyXG4gICAgcHJlZml4ZWROYW1lXyhuYW1lKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucHJlZml4XyArIG5hbWU7XHJcbiAgICB9XHJcbiAgICB0b1N0cmluZygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5kb21TdG9yYWdlXy50b1N0cmluZygpO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBBbiBpbi1tZW1vcnkgc3RvcmFnZSBpbXBsZW1lbnRhdGlvbiB0aGF0IG1hdGNoZXMgdGhlIEFQSSBvZiBET01TdG9yYWdlV3JhcHBlclxyXG4gKiAoVE9ETzogY3JlYXRlIGludGVyZmFjZSBmb3IgYm90aCB0byBpbXBsZW1lbnQpLlxyXG4gKi9cclxuY2xhc3MgTWVtb3J5U3RvcmFnZSB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLmNhY2hlXyA9IHt9O1xyXG4gICAgICAgIHRoaXMuaXNJbk1lbW9yeVN0b3JhZ2UgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgc2V0KGtleSwgdmFsdWUpIHtcclxuICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBkZWxldGUgdGhpcy5jYWNoZV9ba2V5XTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuY2FjaGVfW2tleV0gPSB2YWx1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBnZXQoa2V5KSB7XHJcbiAgICAgICAgaWYgKGNvbnRhaW5zKHRoaXMuY2FjaGVfLCBrZXkpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNhY2hlX1trZXldO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIHJlbW92ZShrZXkpIHtcclxuICAgICAgICBkZWxldGUgdGhpcy5jYWNoZV9ba2V5XTtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogSGVscGVyIHRvIGNyZWF0ZSBhIERPTVN0b3JhZ2VXcmFwcGVyIG9yIGVsc2UgZmFsbCBiYWNrIHRvIE1lbW9yeVN0b3JhZ2UuXHJcbiAqIFRPRE86IE9uY2UgTWVtb3J5U3RvcmFnZSBhbmQgRE9NU3RvcmFnZVdyYXBwZXIgaGF2ZSBhIHNoYXJlZCBpbnRlcmZhY2UgdGhpcyBtZXRob2QgYW5ub3RhdGlvbiBzaG91bGQgY2hhbmdlXHJcbiAqIHRvIHJlZmxlY3QgdGhpcyB0eXBlXHJcbiAqXHJcbiAqIEBwYXJhbSBkb21TdG9yYWdlTmFtZSAtIE5hbWUgb2YgdGhlIHVuZGVybHlpbmcgc3RvcmFnZSBvYmplY3RcclxuICogICAoZS5nLiAnbG9jYWxTdG9yYWdlJyBvciAnc2Vzc2lvblN0b3JhZ2UnKS5cclxuICogQHJldHVybnMgVHVybmluZyBvZmYgdHlwZSBpbmZvcm1hdGlvbiB1bnRpbCBhIGNvbW1vbiBpbnRlcmZhY2UgaXMgZGVmaW5lZC5cclxuICovXHJcbmNvbnN0IGNyZWF0ZVN0b3JhZ2Vmb3IgPSBmdW5jdGlvbiAoZG9tU3RvcmFnZU5hbWUpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgLy8gTk9URToganVzdCBhY2Nlc3NpbmcgXCJsb2NhbFN0b3JhZ2VcIiBvciBcIndpbmRvd1snbG9jYWxTdG9yYWdlJ11cIiBtYXkgdGhyb3cgYSBzZWN1cml0eSBleGNlcHRpb24sXHJcbiAgICAgICAgLy8gc28gaXQgbXVzdCBiZSBpbnNpZGUgdGhlIHRyeS9jYXRjaC5cclxuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiZcclxuICAgICAgICAgICAgdHlwZW9mIHdpbmRvd1tkb21TdG9yYWdlTmFtZV0gIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgIC8vIE5lZWQgdG8gdGVzdCBjYWNoZS4gSnVzdCBiZWNhdXNlIGl0J3MgaGVyZSBkb2Vzbid0IG1lYW4gaXQgd29ya3NcclxuICAgICAgICAgICAgY29uc3QgZG9tU3RvcmFnZSA9IHdpbmRvd1tkb21TdG9yYWdlTmFtZV07XHJcbiAgICAgICAgICAgIGRvbVN0b3JhZ2Uuc2V0SXRlbSgnZmlyZWJhc2U6c2VudGluZWwnLCAnY2FjaGUnKTtcclxuICAgICAgICAgICAgZG9tU3RvcmFnZS5yZW1vdmVJdGVtKCdmaXJlYmFzZTpzZW50aW5lbCcpO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IERPTVN0b3JhZ2VXcmFwcGVyKGRvbVN0b3JhZ2UpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGNhdGNoIChlKSB7IH1cclxuICAgIC8vIEZhaWxlZCB0byBjcmVhdGUgd3JhcHBlci4gIEp1c3QgcmV0dXJuIGluLW1lbW9yeSBzdG9yYWdlLlxyXG4gICAgLy8gVE9ETzogbG9nP1xyXG4gICAgcmV0dXJuIG5ldyBNZW1vcnlTdG9yYWdlKCk7XHJcbn07XHJcbi8qKiBBIHN0b3JhZ2Ugb2JqZWN0IHRoYXQgbGFzdHMgYWNyb3NzIHNlc3Npb25zICovXHJcbmNvbnN0IFBlcnNpc3RlbnRTdG9yYWdlID0gY3JlYXRlU3RvcmFnZWZvcignbG9jYWxTdG9yYWdlJyk7XHJcbi8qKiBBIHN0b3JhZ2Ugb2JqZWN0IHRoYXQgb25seSBsYXN0cyBvbmUgc2Vzc2lvbiAqL1xyXG5jb25zdCBTZXNzaW9uU3RvcmFnZSA9IGNyZWF0ZVN0b3JhZ2Vmb3IoJ3Nlc3Npb25TdG9yYWdlJyk7XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmNvbnN0IGxvZ0NsaWVudCA9IG5ldyBMb2dnZXIoJ0BmaXJlYmFzZS9kYXRhYmFzZScpO1xyXG4vKipcclxuICogUmV0dXJucyBhIGxvY2FsbHktdW5pcXVlIElEIChnZW5lcmF0ZWQgYnkganVzdCBpbmNyZW1lbnRpbmcgdXAgZnJvbSAwIGVhY2ggdGltZSBpdHMgY2FsbGVkKS5cclxuICovXHJcbmNvbnN0IExVSURHZW5lcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgbGV0IGlkID0gMTtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIGlkKys7XHJcbiAgICB9O1xyXG59KSgpO1xyXG4vKipcclxuICogU2hhMSBoYXNoIG9mIHRoZSBpbnB1dCBzdHJpbmdcclxuICogQHBhcmFtIHN0ciAtIFRoZSBzdHJpbmcgdG8gaGFzaFxyXG4gKiBAcmV0dXJucyB7IXN0cmluZ30gVGhlIHJlc3VsdGluZyBoYXNoXHJcbiAqL1xyXG5jb25zdCBzaGExID0gZnVuY3Rpb24gKHN0cikge1xyXG4gICAgY29uc3QgdXRmOEJ5dGVzID0gc3RyaW5nVG9CeXRlQXJyYXkoc3RyKTtcclxuICAgIGNvbnN0IHNoYTEgPSBuZXcgU2hhMSgpO1xyXG4gICAgc2hhMS51cGRhdGUodXRmOEJ5dGVzKTtcclxuICAgIGNvbnN0IHNoYTFCeXRlcyA9IHNoYTEuZGlnZXN0KCk7XHJcbiAgICByZXR1cm4gYmFzZTY0LmVuY29kZUJ5dGVBcnJheShzaGExQnl0ZXMpO1xyXG59O1xyXG5jb25zdCBidWlsZExvZ01lc3NhZ2VfID0gZnVuY3Rpb24gKC4uLnZhckFyZ3MpIHtcclxuICAgIGxldCBtZXNzYWdlID0gJyc7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhckFyZ3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjb25zdCBhcmcgPSB2YXJBcmdzW2ldO1xyXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGFyZykgfHxcclxuICAgICAgICAgICAgKGFyZyAmJlxyXG4gICAgICAgICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiZcclxuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XHJcbiAgICAgICAgICAgICAgICB0eXBlb2YgYXJnLmxlbmd0aCA9PT0gJ251bWJlcicpKSB7XHJcbiAgICAgICAgICAgIG1lc3NhZ2UgKz0gYnVpbGRMb2dNZXNzYWdlXy5hcHBseShudWxsLCBhcmcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgYXJnID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgICAgICBtZXNzYWdlICs9IHN0cmluZ2lmeShhcmcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgbWVzc2FnZSArPSBhcmc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG1lc3NhZ2UgKz0gJyAnO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG1lc3NhZ2U7XHJcbn07XHJcbi8qKlxyXG4gKiBVc2UgdGhpcyBmb3IgYWxsIGRlYnVnIG1lc3NhZ2VzIGluIEZpcmViYXNlLlxyXG4gKi9cclxubGV0IGxvZ2dlciA9IG51bGw7XHJcbi8qKlxyXG4gKiBGbGFnIHRvIGNoZWNrIGZvciBsb2cgYXZhaWxhYmlsaXR5IG9uIGZpcnN0IGxvZyBtZXNzYWdlXHJcbiAqL1xyXG5sZXQgZmlyc3RMb2dfID0gdHJ1ZTtcclxuLyoqXHJcbiAqIFRoZSBpbXBsZW1lbnRhdGlvbiBvZiBGaXJlYmFzZS5lbmFibGVMb2dnaW5nIChkZWZpbmVkIGhlcmUgdG8gYnJlYWsgZGVwZW5kZW5jaWVzKVxyXG4gKiBAcGFyYW0gbG9nZ2VyXyAtIEEgZmxhZyB0byB0dXJuIG9uIGxvZ2dpbmcsIG9yIGEgY3VzdG9tIGxvZ2dlclxyXG4gKiBAcGFyYW0gcGVyc2lzdGVudCAtIFdoZXRoZXIgb3Igbm90IHRvIHBlcnNpc3QgbG9nZ2luZyBzZXR0aW5ncyBhY3Jvc3MgcmVmcmVzaGVzXHJcbiAqL1xyXG5jb25zdCBlbmFibGVMb2dnaW5nJDEgPSBmdW5jdGlvbiAobG9nZ2VyXywgcGVyc2lzdGVudCkge1xyXG4gICAgYXNzZXJ0KCFwZXJzaXN0ZW50IHx8IGxvZ2dlcl8gPT09IHRydWUgfHwgbG9nZ2VyXyA9PT0gZmFsc2UsIFwiQ2FuJ3QgdHVybiBvbiBjdXN0b20gbG9nZ2VycyBwZXJzaXN0ZW50bHkuXCIpO1xyXG4gICAgaWYgKGxvZ2dlcl8gPT09IHRydWUpIHtcclxuICAgICAgICBsb2dDbGllbnQubG9nTGV2ZWwgPSBMb2dMZXZlbC5WRVJCT1NFO1xyXG4gICAgICAgIGxvZ2dlciA9IGxvZ0NsaWVudC5sb2cuYmluZChsb2dDbGllbnQpO1xyXG4gICAgICAgIGlmIChwZXJzaXN0ZW50KSB7XHJcbiAgICAgICAgICAgIFNlc3Npb25TdG9yYWdlLnNldCgnbG9nZ2luZ19lbmFibGVkJywgdHJ1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodHlwZW9mIGxvZ2dlcl8gPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICBsb2dnZXIgPSBsb2dnZXJfO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgbG9nZ2VyID0gbnVsbDtcclxuICAgICAgICBTZXNzaW9uU3RvcmFnZS5yZW1vdmUoJ2xvZ2dpbmdfZW5hYmxlZCcpO1xyXG4gICAgfVxyXG59O1xyXG5jb25zdCBsb2cgPSBmdW5jdGlvbiAoLi4udmFyQXJncykge1xyXG4gICAgaWYgKGZpcnN0TG9nXyA9PT0gdHJ1ZSkge1xyXG4gICAgICAgIGZpcnN0TG9nXyA9IGZhbHNlO1xyXG4gICAgICAgIGlmIChsb2dnZXIgPT09IG51bGwgJiYgU2Vzc2lvblN0b3JhZ2UuZ2V0KCdsb2dnaW5nX2VuYWJsZWQnKSA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICBlbmFibGVMb2dnaW5nJDEodHJ1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKGxvZ2dlcikge1xyXG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBidWlsZExvZ01lc3NhZ2VfLmFwcGx5KG51bGwsIHZhckFyZ3MpO1xyXG4gICAgICAgIGxvZ2dlcihtZXNzYWdlKTtcclxuICAgIH1cclxufTtcclxuY29uc3QgbG9nV3JhcHBlciA9IGZ1bmN0aW9uIChwcmVmaXgpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoLi4udmFyQXJncykge1xyXG4gICAgICAgIGxvZyhwcmVmaXgsIC4uLnZhckFyZ3MpO1xyXG4gICAgfTtcclxufTtcclxuY29uc3QgZXJyb3IgPSBmdW5jdGlvbiAoLi4udmFyQXJncykge1xyXG4gICAgY29uc3QgbWVzc2FnZSA9ICdGSVJFQkFTRSBJTlRFUk5BTCBFUlJPUjogJyArIGJ1aWxkTG9nTWVzc2FnZV8oLi4udmFyQXJncyk7XHJcbiAgICBsb2dDbGllbnQuZXJyb3IobWVzc2FnZSk7XHJcbn07XHJcbmNvbnN0IGZhdGFsID0gZnVuY3Rpb24gKC4uLnZhckFyZ3MpIHtcclxuICAgIGNvbnN0IG1lc3NhZ2UgPSBgRklSRUJBU0UgRkFUQUwgRVJST1I6ICR7YnVpbGRMb2dNZXNzYWdlXyguLi52YXJBcmdzKX1gO1xyXG4gICAgbG9nQ2xpZW50LmVycm9yKG1lc3NhZ2UpO1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xyXG59O1xyXG5jb25zdCB3YXJuID0gZnVuY3Rpb24gKC4uLnZhckFyZ3MpIHtcclxuICAgIGNvbnN0IG1lc3NhZ2UgPSAnRklSRUJBU0UgV0FSTklORzogJyArIGJ1aWxkTG9nTWVzc2FnZV8oLi4udmFyQXJncyk7XHJcbiAgICBsb2dDbGllbnQud2FybihtZXNzYWdlKTtcclxufTtcclxuLyoqXHJcbiAqIExvZ3MgYSB3YXJuaW5nIGlmIHRoZSBjb250YWluaW5nIHBhZ2UgdXNlcyBodHRwcy4gQ2FsbGVkIHdoZW4gYSBjYWxsIHRvIG5ldyBGaXJlYmFzZVxyXG4gKiBkb2VzIG5vdCB1c2UgaHR0cHMuXHJcbiAqL1xyXG5jb25zdCB3YXJuSWZQYWdlSXNTZWN1cmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAvLyBCZSB2ZXJ5IGNhcmVmdWwgYWNjZXNzaW5nIGJyb3dzZXIgZ2xvYmFscy4gV2hvIGtub3dzIHdoYXQgbWF5IG9yIG1heSBub3QgZXhpc3QuXHJcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiZcclxuICAgICAgICB3aW5kb3cubG9jYXRpb24gJiZcclxuICAgICAgICB3aW5kb3cubG9jYXRpb24ucHJvdG9jb2wgJiZcclxuICAgICAgICB3aW5kb3cubG9jYXRpb24ucHJvdG9jb2wuaW5kZXhPZignaHR0cHM6JykgIT09IC0xKSB7XHJcbiAgICAgICAgd2FybignSW5zZWN1cmUgRmlyZWJhc2UgYWNjZXNzIGZyb20gYSBzZWN1cmUgcGFnZS4gJyArXHJcbiAgICAgICAgICAgICdQbGVhc2UgdXNlIGh0dHBzIGluIGNhbGxzIHRvIG5ldyBGaXJlYmFzZSgpLicpO1xyXG4gICAgfVxyXG59O1xyXG4vKipcclxuICogUmV0dXJucyB0cnVlIGlmIGRhdGEgaXMgTmFOLCBvciArLy0gSW5maW5pdHkuXHJcbiAqL1xyXG5jb25zdCBpc0ludmFsaWRKU09OTnVtYmVyID0gZnVuY3Rpb24gKGRhdGEpIHtcclxuICAgIHJldHVybiAodHlwZW9mIGRhdGEgPT09ICdudW1iZXInICYmXHJcbiAgICAgICAgKGRhdGEgIT09IGRhdGEgfHwgLy8gTmFOXHJcbiAgICAgICAgICAgIGRhdGEgPT09IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSB8fFxyXG4gICAgICAgICAgICBkYXRhID09PSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFkpKTtcclxufTtcclxuY29uc3QgZXhlY3V0ZVdoZW5ET01SZWFkeSA9IGZ1bmN0aW9uIChmbikge1xyXG4gICAgaWYgKGlzTm9kZVNkaygpIHx8IGRvY3VtZW50LnJlYWR5U3RhdGUgPT09ICdjb21wbGV0ZScpIHtcclxuICAgICAgICBmbigpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgLy8gTW9kZWxlZCBhZnRlciBqUXVlcnkuIFRyeSBET01Db250ZW50TG9hZGVkIGFuZCBvbnJlYWR5c3RhdGVjaGFuZ2UgKHdoaWNoXHJcbiAgICAgICAgLy8gZmlyZSBiZWZvcmUgb25sb2FkKSwgYnV0IGZhbGwgYmFjayB0byBvbmxvYWQuXHJcbiAgICAgICAgbGV0IGNhbGxlZCA9IGZhbHNlO1xyXG4gICAgICAgIGNvbnN0IHdyYXBwZWRGbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKCFkb2N1bWVudC5ib2R5KSB7XHJcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KHdyYXBwZWRGbiwgTWF0aC5mbG9vcigxMCkpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghY2FsbGVkKSB7XHJcbiAgICAgICAgICAgICAgICBjYWxsZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgZm4oKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgaWYgKGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIpIHtcclxuICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsIHdyYXBwZWRGbiwgZmFsc2UpO1xyXG4gICAgICAgICAgICAvLyBmYWxsYmFjayB0byBvbmxvYWQuXHJcbiAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgd3JhcHBlZEZuLCBmYWxzZSk7XHJcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGRvY3VtZW50LmF0dGFjaEV2ZW50KSB7XHJcbiAgICAgICAgICAgIC8vIElFLlxyXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxyXG4gICAgICAgICAgICBkb2N1bWVudC5hdHRhY2hFdmVudCgnb25yZWFkeXN0YXRlY2hhbmdlJywgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKGRvY3VtZW50LnJlYWR5U3RhdGUgPT09ICdjb21wbGV0ZScpIHtcclxuICAgICAgICAgICAgICAgICAgICB3cmFwcGVkRm4oKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIC8vIGZhbGxiYWNrIHRvIG9ubG9hZC5cclxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcclxuICAgICAgICAgICAgd2luZG93LmF0dGFjaEV2ZW50KCdvbmxvYWQnLCB3cmFwcGVkRm4pO1xyXG4gICAgICAgICAgICAvLyBqUXVlcnkgaGFzIGFuIGV4dHJhIGhhY2sgZm9yIElFIHRoYXQgd2UgY291bGQgZW1wbG95IChiYXNlZCBvblxyXG4gICAgICAgICAgICAvLyBodHRwOi8vamF2YXNjcmlwdC5ud2JveC5jb20vSUVDb250ZW50TG9hZGVkLykgQnV0IGl0IGxvb2tzIHJlYWxseSBvbGQuXHJcbiAgICAgICAgICAgIC8vIEknbSBob3Bpbmcgd2UgZG9uJ3QgbmVlZCBpdC5cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcbi8qKlxyXG4gKiBNaW5pbXVtIGtleSBuYW1lLiBJbnZhbGlkIGZvciBhY3R1YWwgZGF0YSwgdXNlZCBhcyBhIG1hcmtlciB0byBzb3J0IGJlZm9yZSBhbnkgdmFsaWQgbmFtZXNcclxuICovXHJcbmNvbnN0IE1JTl9OQU1FID0gJ1tNSU5fTkFNRV0nO1xyXG4vKipcclxuICogTWF4aW11bSBrZXkgbmFtZS4gSW52YWxpZCBmb3IgYWN0dWFsIGRhdGEsIHVzZWQgYXMgYSBtYXJrZXIgdG8gc29ydCBhYm92ZSBhbnkgdmFsaWQgbmFtZXNcclxuICovXHJcbmNvbnN0IE1BWF9OQU1FID0gJ1tNQVhfTkFNRV0nO1xyXG4vKipcclxuICogQ29tcGFyZXMgdmFsaWQgRmlyZWJhc2Uga2V5IG5hbWVzLCBwbHVzIG1pbiBhbmQgbWF4IG5hbWVcclxuICovXHJcbmNvbnN0IG5hbWVDb21wYXJlID0gZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgIGlmIChhID09PSBiKSB7XHJcbiAgICAgICAgcmV0dXJuIDA7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChhID09PSBNSU5fTkFNRSB8fCBiID09PSBNQVhfTkFNRSkge1xyXG4gICAgICAgIHJldHVybiAtMTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGIgPT09IE1JTl9OQU1FIHx8IGEgPT09IE1BWF9OQU1FKSB7XHJcbiAgICAgICAgcmV0dXJuIDE7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBjb25zdCBhQXNJbnQgPSB0cnlQYXJzZUludChhKSwgYkFzSW50ID0gdHJ5UGFyc2VJbnQoYik7XHJcbiAgICAgICAgaWYgKGFBc0ludCAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBpZiAoYkFzSW50ICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYUFzSW50IC0gYkFzSW50ID09PSAwID8gYS5sZW5ndGggLSBiLmxlbmd0aCA6IGFBc0ludCAtIGJBc0ludDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChiQXNJbnQgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gYSA8IGIgPyAtMSA6IDE7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG4vKipcclxuICogQHJldHVybnMgeyFudW1iZXJ9IGNvbXBhcmlzb24gcmVzdWx0LlxyXG4gKi9cclxuY29uc3Qgc3RyaW5nQ29tcGFyZSA9IGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICBpZiAoYSA9PT0gYikge1xyXG4gICAgICAgIHJldHVybiAwO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoYSA8IGIpIHtcclxuICAgICAgICByZXR1cm4gLTE7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gMTtcclxuICAgIH1cclxufTtcclxuY29uc3QgcmVxdWlyZUtleSA9IGZ1bmN0aW9uIChrZXksIG9iaikge1xyXG4gICAgaWYgKG9iaiAmJiBrZXkgaW4gb2JqKSB7XHJcbiAgICAgICAgcmV0dXJuIG9ialtrZXldO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIHJlcXVpcmVkIGtleSAoJyArIGtleSArICcpIGluIG9iamVjdDogJyArIHN0cmluZ2lmeShvYmopKTtcclxuICAgIH1cclxufTtcclxuY29uc3QgT2JqZWN0VG9VbmlxdWVLZXkgPSBmdW5jdGlvbiAob2JqKSB7XHJcbiAgICBpZiAodHlwZW9mIG9iaiAhPT0gJ29iamVjdCcgfHwgb2JqID09PSBudWxsKSB7XHJcbiAgICAgICAgcmV0dXJuIHN0cmluZ2lmeShvYmopO1xyXG4gICAgfVxyXG4gICAgY29uc3Qga2V5cyA9IFtdO1xyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGd1YXJkLWZvci1pblxyXG4gICAgZm9yIChjb25zdCBrIGluIG9iaikge1xyXG4gICAgICAgIGtleXMucHVzaChrKTtcclxuICAgIH1cclxuICAgIC8vIEV4cG9ydCBhcyBqc29uLCBidXQgd2l0aCB0aGUga2V5cyBzb3J0ZWQuXHJcbiAgICBrZXlzLnNvcnQoKTtcclxuICAgIGxldCBrZXkgPSAneyc7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBpZiAoaSAhPT0gMCkge1xyXG4gICAgICAgICAgICBrZXkgKz0gJywnO1xyXG4gICAgICAgIH1cclxuICAgICAgICBrZXkgKz0gc3RyaW5naWZ5KGtleXNbaV0pO1xyXG4gICAgICAgIGtleSArPSAnOic7XHJcbiAgICAgICAga2V5ICs9IE9iamVjdFRvVW5pcXVlS2V5KG9ialtrZXlzW2ldXSk7XHJcbiAgICB9XHJcbiAgICBrZXkgKz0gJ30nO1xyXG4gICAgcmV0dXJuIGtleTtcclxufTtcclxuLyoqXHJcbiAqIFNwbGl0cyBhIHN0cmluZyBpbnRvIGEgbnVtYmVyIG9mIHNtYWxsZXIgc2VnbWVudHMgb2YgbWF4aW11bSBzaXplXHJcbiAqIEBwYXJhbSBzdHIgLSBUaGUgc3RyaW5nXHJcbiAqIEBwYXJhbSBzZWdzaXplIC0gVGhlIG1heGltdW0gbnVtYmVyIG9mIGNoYXJzIGluIHRoZSBzdHJpbmcuXHJcbiAqIEByZXR1cm5zIFRoZSBzdHJpbmcsIHNwbGl0IGludG8gYXBwcm9wcmlhdGVseS1zaXplZCBjaHVua3NcclxuICovXHJcbmNvbnN0IHNwbGl0U3RyaW5nQnlTaXplID0gZnVuY3Rpb24gKHN0ciwgc2Vnc2l6ZSkge1xyXG4gICAgY29uc3QgbGVuID0gc3RyLmxlbmd0aDtcclxuICAgIGlmIChsZW4gPD0gc2Vnc2l6ZSkge1xyXG4gICAgICAgIHJldHVybiBbc3RyXTtcclxuICAgIH1cclxuICAgIGNvbnN0IGRhdGFTZWdzID0gW107XHJcbiAgICBmb3IgKGxldCBjID0gMDsgYyA8IGxlbjsgYyArPSBzZWdzaXplKSB7XHJcbiAgICAgICAgaWYgKGMgKyBzZWdzaXplID4gbGVuKSB7XHJcbiAgICAgICAgICAgIGRhdGFTZWdzLnB1c2goc3RyLnN1YnN0cmluZyhjLCBsZW4pKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGRhdGFTZWdzLnB1c2goc3RyLnN1YnN0cmluZyhjLCBjICsgc2Vnc2l6ZSkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBkYXRhU2VncztcclxufTtcclxuLyoqXHJcbiAqIEFwcGx5IGEgZnVuY3Rpb24gdG8gZWFjaCAoa2V5LCB2YWx1ZSkgcGFpciBpbiBhbiBvYmplY3Qgb3JcclxuICogYXBwbHkgYSBmdW5jdGlvbiB0byBlYWNoIChpbmRleCwgdmFsdWUpIHBhaXIgaW4gYW4gYXJyYXlcclxuICogQHBhcmFtIG9iaiAtIFRoZSBvYmplY3Qgb3IgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyXHJcbiAqIEBwYXJhbSBmbiAtIFRoZSBmdW5jdGlvbiB0byBhcHBseVxyXG4gKi9cclxuZnVuY3Rpb24gZWFjaChvYmosIGZuKSB7XHJcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBvYmopIHtcclxuICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGtleSkpIHtcclxuICAgICAgICAgICAgZm4oa2V5LCBvYmpba2V5XSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBCb3Jyb3dlZCBmcm9tIGh0dHA6Ly9oZy5zZWNvbmRsaWZlLmNvbS9sbHNkL3NyYy90aXAvanMvdHlwZWRhcnJheS5qcyAoTUlUIExpY2Vuc2UpXHJcbiAqIEkgbWFkZSBvbmUgbW9kaWZpY2F0aW9uIGF0IHRoZSBlbmQgYW5kIHJlbW92ZWQgdGhlIE5hTiAvIEluZmluaXR5XHJcbiAqIGhhbmRsaW5nIChzaW5jZSBpdCBzZWVtZWQgYnJva2VuIFtjYXVzZWQgYW4gb3ZlcmZsb3ddIGFuZCB3ZSBkb24ndCBuZWVkIGl0KS4gIFNlZSBNSkwgY29tbWVudHMuXHJcbiAqIEBwYXJhbSB2IC0gQSBkb3VibGVcclxuICpcclxuICovXHJcbmNvbnN0IGRvdWJsZVRvSUVFRTc1NFN0cmluZyA9IGZ1bmN0aW9uICh2KSB7XHJcbiAgICBhc3NlcnQoIWlzSW52YWxpZEpTT05OdW1iZXIodiksICdJbnZhbGlkIEpTT04gbnVtYmVyJyk7IC8vIE1KTFxyXG4gICAgY29uc3QgZWJpdHMgPSAxMSwgZmJpdHMgPSA1MjtcclxuICAgIGNvbnN0IGJpYXMgPSAoMSA8PCAoZWJpdHMgLSAxKSkgLSAxO1xyXG4gICAgbGV0IHMsIGUsIGYsIGxuLCBpO1xyXG4gICAgLy8gQ29tcHV0ZSBzaWduLCBleHBvbmVudCwgZnJhY3Rpb25cclxuICAgIC8vIFNraXAgTmFOIC8gSW5maW5pdHkgaGFuZGxpbmcgLS1NSkwuXHJcbiAgICBpZiAodiA9PT0gMCkge1xyXG4gICAgICAgIGUgPSAwO1xyXG4gICAgICAgIGYgPSAwO1xyXG4gICAgICAgIHMgPSAxIC8gdiA9PT0gLUluZmluaXR5ID8gMSA6IDA7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBzID0gdiA8IDA7XHJcbiAgICAgICAgdiA9IE1hdGguYWJzKHYpO1xyXG4gICAgICAgIGlmICh2ID49IE1hdGgucG93KDIsIDEgLSBiaWFzKSkge1xyXG4gICAgICAgICAgICAvLyBOb3JtYWxpemVkXHJcbiAgICAgICAgICAgIGxuID0gTWF0aC5taW4oTWF0aC5mbG9vcihNYXRoLmxvZyh2KSAvIE1hdGguTE4yKSwgYmlhcyk7XHJcbiAgICAgICAgICAgIGUgPSBsbiArIGJpYXM7XHJcbiAgICAgICAgICAgIGYgPSBNYXRoLnJvdW5kKHYgKiBNYXRoLnBvdygyLCBmYml0cyAtIGxuKSAtIE1hdGgucG93KDIsIGZiaXRzKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBEZW5vcm1hbGl6ZWRcclxuICAgICAgICAgICAgZSA9IDA7XHJcbiAgICAgICAgICAgIGYgPSBNYXRoLnJvdW5kKHYgLyBNYXRoLnBvdygyLCAxIC0gYmlhcyAtIGZiaXRzKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gUGFjayBzaWduLCBleHBvbmVudCwgZnJhY3Rpb25cclxuICAgIGNvbnN0IGJpdHMgPSBbXTtcclxuICAgIGZvciAoaSA9IGZiaXRzOyBpOyBpIC09IDEpIHtcclxuICAgICAgICBiaXRzLnB1c2goZiAlIDIgPyAxIDogMCk7XHJcbiAgICAgICAgZiA9IE1hdGguZmxvb3IoZiAvIDIpO1xyXG4gICAgfVxyXG4gICAgZm9yIChpID0gZWJpdHM7IGk7IGkgLT0gMSkge1xyXG4gICAgICAgIGJpdHMucHVzaChlICUgMiA/IDEgOiAwKTtcclxuICAgICAgICBlID0gTWF0aC5mbG9vcihlIC8gMik7XHJcbiAgICB9XHJcbiAgICBiaXRzLnB1c2gocyA/IDEgOiAwKTtcclxuICAgIGJpdHMucmV2ZXJzZSgpO1xyXG4gICAgY29uc3Qgc3RyID0gYml0cy5qb2luKCcnKTtcclxuICAgIC8vIFJldHVybiB0aGUgZGF0YSBhcyBhIGhleCBzdHJpbmcuIC0tTUpMXHJcbiAgICBsZXQgaGV4Qnl0ZVN0cmluZyA9ICcnO1xyXG4gICAgZm9yIChpID0gMDsgaSA8IDY0OyBpICs9IDgpIHtcclxuICAgICAgICBsZXQgaGV4Qnl0ZSA9IHBhcnNlSW50KHN0ci5zdWJzdHIoaSwgOCksIDIpLnRvU3RyaW5nKDE2KTtcclxuICAgICAgICBpZiAoaGV4Qnl0ZS5sZW5ndGggPT09IDEpIHtcclxuICAgICAgICAgICAgaGV4Qnl0ZSA9ICcwJyArIGhleEJ5dGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGhleEJ5dGVTdHJpbmcgPSBoZXhCeXRlU3RyaW5nICsgaGV4Qnl0ZTtcclxuICAgIH1cclxuICAgIHJldHVybiBoZXhCeXRlU3RyaW5nLnRvTG93ZXJDYXNlKCk7XHJcbn07XHJcbi8qKlxyXG4gKiBVc2VkIHRvIGRldGVjdCBpZiB3ZSdyZSBpbiBhIENocm9tZSBjb250ZW50IHNjcmlwdCAod2hpY2ggZXhlY3V0ZXMgaW4gYW5cclxuICogaXNvbGF0ZWQgZW52aXJvbm1lbnQgd2hlcmUgbG9uZy1wb2xsaW5nIGRvZXNuJ3Qgd29yaykuXHJcbiAqL1xyXG5jb25zdCBpc0Nocm9tZUV4dGVuc2lvbkNvbnRlbnRTY3JpcHQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gISEodHlwZW9mIHdpbmRvdyA9PT0gJ29iamVjdCcgJiZcclxuICAgICAgICB3aW5kb3dbJ2Nocm9tZSddICYmXHJcbiAgICAgICAgd2luZG93WydjaHJvbWUnXVsnZXh0ZW5zaW9uJ10gJiZcclxuICAgICAgICAhL15jaHJvbWUvLnRlc3Qod2luZG93LmxvY2F0aW9uLmhyZWYpKTtcclxufTtcclxuLyoqXHJcbiAqIFVzZWQgdG8gZGV0ZWN0IGlmIHdlJ3JlIGluIGEgV2luZG93cyA4IFN0b3JlIGFwcC5cclxuICovXHJcbmNvbnN0IGlzV2luZG93c1N0b3JlQXBwID0gZnVuY3Rpb24gKCkge1xyXG4gICAgLy8gQ2hlY2sgZm9yIHRoZSBwcmVzZW5jZSBvZiBhIGNvdXBsZSBXaW5SVCBnbG9iYWxzXHJcbiAgICByZXR1cm4gdHlwZW9mIFdpbmRvd3MgPT09ICdvYmplY3QnICYmIHR5cGVvZiBXaW5kb3dzLlVJID09PSAnb2JqZWN0JztcclxufTtcclxuLyoqXHJcbiAqIENvbnZlcnRzIGEgc2VydmVyIGVycm9yIGNvZGUgdG8gYSBKYXZhc2NyaXB0IEVycm9yXHJcbiAqL1xyXG5mdW5jdGlvbiBlcnJvckZvclNlcnZlckNvZGUoY29kZSwgcXVlcnkpIHtcclxuICAgIGxldCByZWFzb24gPSAnVW5rbm93biBFcnJvcic7XHJcbiAgICBpZiAoY29kZSA9PT0gJ3Rvb19iaWcnKSB7XHJcbiAgICAgICAgcmVhc29uID1cclxuICAgICAgICAgICAgJ1RoZSBkYXRhIHJlcXVlc3RlZCBleGNlZWRzIHRoZSBtYXhpbXVtIHNpemUgJyArXHJcbiAgICAgICAgICAgICAgICAndGhhdCBjYW4gYmUgYWNjZXNzZWQgd2l0aCBhIHNpbmdsZSByZXF1ZXN0Lic7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChjb2RlID09PSAncGVybWlzc2lvbl9kZW5pZWQnKSB7XHJcbiAgICAgICAgcmVhc29uID0gXCJDbGllbnQgZG9lc24ndCBoYXZlIHBlcm1pc3Npb24gdG8gYWNjZXNzIHRoZSBkZXNpcmVkIGRhdGEuXCI7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChjb2RlID09PSAndW5hdmFpbGFibGUnKSB7XHJcbiAgICAgICAgcmVhc29uID0gJ1RoZSBzZXJ2aWNlIGlzIHVuYXZhaWxhYmxlJztcclxuICAgIH1cclxuICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGNvZGUgKyAnIGF0ICcgKyBxdWVyeS5fcGF0aC50b1N0cmluZygpICsgJzogJyArIHJlYXNvbik7XHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxyXG4gICAgZXJyb3IuY29kZSA9IGNvZGUudG9VcHBlckNhc2UoKTtcclxuICAgIHJldHVybiBlcnJvcjtcclxufVxyXG4vKipcclxuICogVXNlZCB0byB0ZXN0IGZvciBpbnRlZ2VyLWxvb2tpbmcgc3RyaW5nc1xyXG4gKi9cclxuY29uc3QgSU5URUdFUl9SRUdFWFBfID0gbmV3IFJlZ0V4cCgnXi0/KDAqKVxcXFxkezEsMTB9JCcpO1xyXG4vKipcclxuICogRm9yIHVzZSBpbiBrZXlzLCB0aGUgbWluaW11bSBwb3NzaWJsZSAzMi1iaXQgaW50ZWdlci5cclxuICovXHJcbmNvbnN0IElOVEVHRVJfMzJfTUlOID0gLTIxNDc0ODM2NDg7XHJcbi8qKlxyXG4gKiBGb3IgdXNlIGluIGt5ZXMsIHRoZSBtYXhpbXVtIHBvc3NpYmxlIDMyLWJpdCBpbnRlZ2VyLlxyXG4gKi9cclxuY29uc3QgSU5URUdFUl8zMl9NQVggPSAyMTQ3NDgzNjQ3O1xyXG4vKipcclxuICogSWYgdGhlIHN0cmluZyBjb250YWlucyBhIDMyLWJpdCBpbnRlZ2VyLCByZXR1cm4gaXQuICBFbHNlIHJldHVybiBudWxsLlxyXG4gKi9cclxuY29uc3QgdHJ5UGFyc2VJbnQgPSBmdW5jdGlvbiAoc3RyKSB7XHJcbiAgICBpZiAoSU5URUdFUl9SRUdFWFBfLnRlc3Qoc3RyKSkge1xyXG4gICAgICAgIGNvbnN0IGludFZhbCA9IE51bWJlcihzdHIpO1xyXG4gICAgICAgIGlmIChpbnRWYWwgPj0gSU5URUdFUl8zMl9NSU4gJiYgaW50VmFsIDw9IElOVEVHRVJfMzJfTUFYKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpbnRWYWw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIG51bGw7XHJcbn07XHJcbi8qKlxyXG4gKiBIZWxwZXIgdG8gcnVuIHNvbWUgY29kZSBidXQgY2F0Y2ggYW55IGV4Y2VwdGlvbnMgYW5kIHJlLXRocm93IHRoZW0gbGF0ZXIuXHJcbiAqIFVzZWZ1bCBmb3IgcHJldmVudGluZyB1c2VyIGNhbGxiYWNrcyBmcm9tIGJyZWFraW5nIGludGVybmFsIGNvZGUuXHJcbiAqXHJcbiAqIFJlLXRocm93aW5nIHRoZSBleGNlcHRpb24gZnJvbSBhIHNldFRpbWVvdXQgaXMgYSBsaXR0bGUgZXZpbCwgYnV0IGl0J3MgdmVyeVxyXG4gKiBjb252ZW5pZW50ICh3ZSBkb24ndCBoYXZlIHRvIHRyeSB0byBmaWd1cmUgb3V0IHdoZW4gaXMgYSBzYWZlIHBvaW50IHRvXHJcbiAqIHJlLXRocm93IGl0KSwgYW5kIHRoZSBiZWhhdmlvciBzZWVtcyByZWFzb25hYmxlOlxyXG4gKlxyXG4gKiAqIElmIHlvdSBhcmVuJ3QgcGF1c2luZyBvbiBleGNlcHRpb25zLCB5b3UgZ2V0IGFuIGVycm9yIGluIHRoZSBjb25zb2xlIHdpdGhcclxuICogICB0aGUgY29ycmVjdCBzdGFjayB0cmFjZS5cclxuICogKiBJZiB5b3UncmUgcGF1c2luZyBvbiBhbGwgZXhjZXB0aW9ucywgdGhlIGRlYnVnZ2VyIHdpbGwgcGF1c2Ugb24geW91clxyXG4gKiAgIGV4Y2VwdGlvbiBhbmQgdGhlbiBhZ2FpbiB3aGVuIHdlIHJldGhyb3cgaXQuXHJcbiAqICogSWYgeW91J3JlIG9ubHkgcGF1c2luZyBvbiB1bmNhdWdodCBleGNlcHRpb25zLCB0aGUgZGVidWdnZXIgd2lsbCBvbmx5IHBhdXNlXHJcbiAqICAgb24gdXMgcmUtdGhyb3dpbmcgaXQuXHJcbiAqXHJcbiAqIEBwYXJhbSBmbiAtIFRoZSBjb2RlIHRvIGd1YXJkLlxyXG4gKi9cclxuY29uc3QgZXhjZXB0aW9uR3VhcmQgPSBmdW5jdGlvbiAoZm4pIHtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgZm4oKTtcclxuICAgIH1cclxuICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgLy8gUmUtdGhyb3cgZXhjZXB0aW9uIHdoZW4gaXQncyBzYWZlLlxyXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICAvLyBJdCB1c2VkIHRvIGJlIHRoYXQgXCJ0aHJvdyBlXCIgd291bGQgcmVzdWx0IGluIGEgZ29vZCBjb25zb2xlIGVycm9yIHdpdGhcclxuICAgICAgICAgICAgLy8gcmVsZXZhbnQgY29udGV4dCwgYnV0IGFzIG9mIENocm9tZSAzOSwgeW91IGp1c3QgZ2V0IHRoZSBmaXJlYmFzZS5qc1xyXG4gICAgICAgICAgICAvLyBmaWxlL2xpbmUgbnVtYmVyIHdoZXJlIHdlIHJlLXRocm93IGl0LCB3aGljaCBpcyB1c2VsZXNzLiBTbyB3ZSBsb2dcclxuICAgICAgICAgICAgLy8gZS5zdGFjayBleHBsaWNpdGx5LlxyXG4gICAgICAgICAgICBjb25zdCBzdGFjayA9IGUuc3RhY2sgfHwgJyc7XHJcbiAgICAgICAgICAgIHdhcm4oJ0V4Y2VwdGlvbiB3YXMgdGhyb3duIGJ5IHVzZXIgY2FsbGJhY2suJywgc3RhY2spO1xyXG4gICAgICAgICAgICB0aHJvdyBlO1xyXG4gICAgICAgIH0sIE1hdGguZmxvb3IoMCkpO1xyXG4gICAgfVxyXG59O1xyXG4vKipcclxuICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgd2UgdGhpbmsgd2UncmUgY3VycmVudGx5IGJlaW5nIGNyYXdsZWQuXHJcbiAqL1xyXG5jb25zdCBiZWluZ0NyYXdsZWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICBjb25zdCB1c2VyQWdlbnQgPSAodHlwZW9mIHdpbmRvdyA9PT0gJ29iamVjdCcgJiZcclxuICAgICAgICB3aW5kb3dbJ25hdmlnYXRvciddICYmXHJcbiAgICAgICAgd2luZG93WyduYXZpZ2F0b3InXVsndXNlckFnZW50J10pIHx8XHJcbiAgICAgICAgJyc7XHJcbiAgICAvLyBGb3Igbm93IHdlIHdoaXRlbGlzdCB0aGUgbW9zdCBwb3B1bGFyIGNyYXdsZXJzLiAgV2Ugc2hvdWxkIHJlZmluZSB0aGlzIHRvIGJlIHRoZSBzZXQgb2YgY3Jhd2xlcnMgd2VcclxuICAgIC8vIGJlbGlldmUgdG8gc3VwcG9ydCBKYXZhU2NyaXB0L0FKQVggcmVuZGVyaW5nLlxyXG4gICAgLy8gTk9URTogR29vZ2xlIFdlYm1hc3RlciBUb29scyBkb2Vzbid0IHJlYWxseSBiZWxvbmcsIGJ1dCB0aGVpciBcIlRoaXMgaXMgaG93IGEgdmlzaXRvciB0byB5b3VyIHdlYnNpdGVcclxuICAgIC8vIHdvdWxkIGhhdmUgc2VlbiB0aGUgcGFnZVwiIGlzIGZsYWt5IGlmIHdlIGRvbid0IHRyZWF0IGl0IGFzIGEgY3Jhd2xlci5cclxuICAgIHJldHVybiAodXNlckFnZW50LnNlYXJjaCgvZ29vZ2xlYm90fGdvb2dsZSB3ZWJtYXN0ZXIgdG9vbHN8YmluZ2JvdHx5YWhvbyEgc2x1cnB8YmFpZHVzcGlkZXJ8eWFuZGV4Ym90fGR1Y2tkdWNrYm90L2kpID49IDApO1xyXG59O1xyXG4vKipcclxuICogU2FtZSBhcyBzZXRUaW1lb3V0KCkgZXhjZXB0IG9uIE5vZGUuSlMgaXQgd2lsbCAvbm90LyBwcmV2ZW50IHRoZSBwcm9jZXNzIGZyb20gZXhpdGluZy5cclxuICpcclxuICogSXQgaXMgcmVtb3ZlZCB3aXRoIGNsZWFyVGltZW91dCgpIGFzIG5vcm1hbC5cclxuICpcclxuICogQHBhcmFtIGZuIC0gRnVuY3Rpb24gdG8gcnVuLlxyXG4gKiBAcGFyYW0gdGltZSAtIE1pbGxpc2Vjb25kcyB0byB3YWl0IGJlZm9yZSBydW5uaW5nLlxyXG4gKiBAcmV0dXJucyBUaGUgc2V0VGltZW91dCgpIHJldHVybiB2YWx1ZS5cclxuICovXHJcbmNvbnN0IHNldFRpbWVvdXROb25CbG9ja2luZyA9IGZ1bmN0aW9uIChmbiwgdGltZSkge1xyXG4gICAgY29uc3QgdGltZW91dCA9IHNldFRpbWVvdXQoZm4sIHRpbWUpO1xyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcclxuICAgIGlmICh0eXBlb2YgdGltZW91dCA9PT0gJ29iamVjdCcgJiYgdGltZW91dFsndW5yZWYnXSkge1xyXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XHJcbiAgICAgICAgdGltZW91dFsndW5yZWYnXSgpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRpbWVvdXQ7XHJcbn07XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMSBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBBYnN0cmFjdGlvbiBhcm91bmQgQXBwQ2hlY2sncyB0b2tlbiBmZXRjaGluZyBjYXBhYmlsaXRpZXMuXHJcbiAqL1xyXG5jbGFzcyBBcHBDaGVja1Rva2VuUHJvdmlkZXIge1xyXG4gICAgY29uc3RydWN0b3IoYXBwTmFtZV8sIGFwcENoZWNrUHJvdmlkZXIpIHtcclxuICAgICAgICB0aGlzLmFwcE5hbWVfID0gYXBwTmFtZV87XHJcbiAgICAgICAgdGhpcy5hcHBDaGVja1Byb3ZpZGVyID0gYXBwQ2hlY2tQcm92aWRlcjtcclxuICAgICAgICB0aGlzLmFwcENoZWNrID0gYXBwQ2hlY2tQcm92aWRlciA9PT0gbnVsbCB8fCBhcHBDaGVja1Byb3ZpZGVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhcHBDaGVja1Byb3ZpZGVyLmdldEltbWVkaWF0ZSh7IG9wdGlvbmFsOiB0cnVlIH0pO1xyXG4gICAgICAgIGlmICghdGhpcy5hcHBDaGVjaykge1xyXG4gICAgICAgICAgICBhcHBDaGVja1Byb3ZpZGVyID09PSBudWxsIHx8IGFwcENoZWNrUHJvdmlkZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGFwcENoZWNrUHJvdmlkZXIuZ2V0KCkudGhlbihhcHBDaGVjayA9PiAodGhpcy5hcHBDaGVjayA9IGFwcENoZWNrKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZ2V0VG9rZW4oZm9yY2VSZWZyZXNoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmFwcENoZWNrKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAvLyBTdXBwb3J0IGRlbGF5ZWQgaW5pdGlhbGl6YXRpb24gb2YgRmlyZWJhc2VBcHBDaGVjay4gVGhpcyBhbGxvd3Mgb3VyXHJcbiAgICAgICAgICAgICAgICAvLyBjdXN0b21lcnMgdG8gaW5pdGlhbGl6ZSB0aGUgUlREQiBTREsgYmVmb3JlIGluaXRpYWxpemluZyBGaXJlYmFzZVxyXG4gICAgICAgICAgICAgICAgLy8gQXBwQ2hlY2sgYW5kIGVuc3VyZXMgdGhhdCBhbGwgcmVxdWVzdHMgYXJlIGF1dGhlbnRpY2F0ZWQgaWYgYSB0b2tlblxyXG4gICAgICAgICAgICAgICAgLy8gYmVjb21lcyBhdmFpbGFibGUgYmVmb3JlIHRoZSB0aW1vZW91dCBiZWxvdyBleHBpcmVzLlxyXG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuYXBwQ2hlY2spIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5nZXRUb2tlbihmb3JjZVJlZnJlc2gpLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUobnVsbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSwgMCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5hcHBDaGVjay5nZXRUb2tlbihmb3JjZVJlZnJlc2gpO1xyXG4gICAgfVxyXG4gICAgYWRkVG9rZW5DaGFuZ2VMaXN0ZW5lcihsaXN0ZW5lcikge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICAoX2EgPSB0aGlzLmFwcENoZWNrUHJvdmlkZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXQoKS50aGVuKGFwcENoZWNrID0+IGFwcENoZWNrLmFkZFRva2VuTGlzdGVuZXIobGlzdGVuZXIpKTtcclxuICAgIH1cclxuICAgIG5vdGlmeUZvckludmFsaWRUb2tlbigpIHtcclxuICAgICAgICB3YXJuKGBQcm92aWRlZCBBcHBDaGVjayBjcmVkZW50aWFscyBmb3IgdGhlIGFwcCBuYW1lZCBcIiR7dGhpcy5hcHBOYW1lX31cIiBgICtcclxuICAgICAgICAgICAgJ2FyZSBpbnZhbGlkLiBUaGlzIHVzdWFsbHkgaW5kaWNhdGVzIHlvdXIgYXBwIHdhcyBub3QgaW5pdGlhbGl6ZWQgY29ycmVjdGx5LicpO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBBYnN0cmFjdGlvbiBhcm91bmQgRmlyZWJhc2VBcHAncyB0b2tlbiBmZXRjaGluZyBjYXBhYmlsaXRpZXMuXHJcbiAqL1xyXG5jbGFzcyBGaXJlYmFzZUF1dGhUb2tlblByb3ZpZGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKGFwcE5hbWVfLCBmaXJlYmFzZU9wdGlvbnNfLCBhdXRoUHJvdmlkZXJfKSB7XHJcbiAgICAgICAgdGhpcy5hcHBOYW1lXyA9IGFwcE5hbWVfO1xyXG4gICAgICAgIHRoaXMuZmlyZWJhc2VPcHRpb25zXyA9IGZpcmViYXNlT3B0aW9uc187XHJcbiAgICAgICAgdGhpcy5hdXRoUHJvdmlkZXJfID0gYXV0aFByb3ZpZGVyXztcclxuICAgICAgICB0aGlzLmF1dGhfID0gbnVsbDtcclxuICAgICAgICB0aGlzLmF1dGhfID0gYXV0aFByb3ZpZGVyXy5nZXRJbW1lZGlhdGUoeyBvcHRpb25hbDogdHJ1ZSB9KTtcclxuICAgICAgICBpZiAoIXRoaXMuYXV0aF8pIHtcclxuICAgICAgICAgICAgYXV0aFByb3ZpZGVyXy5vbkluaXQoYXV0aCA9PiAodGhpcy5hdXRoXyA9IGF1dGgpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBnZXRUb2tlbihmb3JjZVJlZnJlc2gpIHtcclxuICAgICAgICBpZiAoIXRoaXMuYXV0aF8pIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICAgICAgICAgIC8vIFN1cHBvcnQgZGVsYXllZCBpbml0aWFsaXphdGlvbiBvZiBGaXJlYmFzZUF1dGguIFRoaXMgYWxsb3dzIG91clxyXG4gICAgICAgICAgICAgICAgLy8gY3VzdG9tZXJzIHRvIGluaXRpYWxpemUgdGhlIFJUREIgU0RLIGJlZm9yZSBpbml0aWFsaXppbmcgRmlyZWJhc2VcclxuICAgICAgICAgICAgICAgIC8vIEF1dGggYW5kIGVuc3VyZXMgdGhhdCBhbGwgcmVxdWVzdHMgYXJlIGF1dGhlbnRpY2F0ZWQgaWYgYSB0b2tlblxyXG4gICAgICAgICAgICAgICAgLy8gYmVjb21lcyBhdmFpbGFibGUgYmVmb3JlIHRoZSB0aW1vZW91dCBiZWxvdyBleHBpcmVzLlxyXG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuYXV0aF8pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5nZXRUb2tlbihmb3JjZVJlZnJlc2gpLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUobnVsbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSwgMCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5hdXRoXy5nZXRUb2tlbihmb3JjZVJlZnJlc2gpLmNhdGNoKGVycm9yID0+IHtcclxuICAgICAgICAgICAgLy8gVE9ETzogTmVlZCB0byBmaWd1cmUgb3V0IGFsbCB0aGUgY2FzZXMgdGhpcyBpcyByYWlzZWQgYW5kIHdoZXRoZXJcclxuICAgICAgICAgICAgLy8gdGhpcyBtYWtlcyBzZW5zZS5cclxuICAgICAgICAgICAgaWYgKGVycm9yICYmIGVycm9yLmNvZGUgPT09ICdhdXRoL3Rva2VuLW5vdC1pbml0aWFsaXplZCcpIHtcclxuICAgICAgICAgICAgICAgIGxvZygnR290IGF1dGgvdG9rZW4tbm90LWluaXRpYWxpemVkIGVycm9yLiAgVHJlYXRpbmcgYXMgbnVsbCB0b2tlbi4nKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgYWRkVG9rZW5DaGFuZ2VMaXN0ZW5lcihsaXN0ZW5lcikge1xyXG4gICAgICAgIC8vIFRPRE86IFdlIG1pZ2h0IHdhbnQgdG8gd3JhcCB0aGUgbGlzdGVuZXIgYW5kIGNhbGwgaXQgd2l0aCBubyBhcmdzIHRvXHJcbiAgICAgICAgLy8gYXZvaWQgYSBsZWFreSBhYnN0cmFjdGlvbiwgYnV0IHRoYXQgbWFrZXMgcmVtb3ZpbmcgdGhlIGxpc3RlbmVyIGhhcmRlci5cclxuICAgICAgICBpZiAodGhpcy5hdXRoXykge1xyXG4gICAgICAgICAgICB0aGlzLmF1dGhfLmFkZEF1dGhUb2tlbkxpc3RlbmVyKGxpc3RlbmVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuYXV0aFByb3ZpZGVyX1xyXG4gICAgICAgICAgICAgICAgLmdldCgpXHJcbiAgICAgICAgICAgICAgICAudGhlbihhdXRoID0+IGF1dGguYWRkQXV0aFRva2VuTGlzdGVuZXIobGlzdGVuZXIpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZW1vdmVUb2tlbkNoYW5nZUxpc3RlbmVyKGxpc3RlbmVyKSB7XHJcbiAgICAgICAgdGhpcy5hdXRoUHJvdmlkZXJfXHJcbiAgICAgICAgICAgIC5nZXQoKVxyXG4gICAgICAgICAgICAudGhlbihhdXRoID0+IGF1dGgucmVtb3ZlQXV0aFRva2VuTGlzdGVuZXIobGlzdGVuZXIpKTtcclxuICAgIH1cclxuICAgIG5vdGlmeUZvckludmFsaWRUb2tlbigpIHtcclxuICAgICAgICBsZXQgZXJyb3JNZXNzYWdlID0gJ1Byb3ZpZGVkIGF1dGhlbnRpY2F0aW9uIGNyZWRlbnRpYWxzIGZvciB0aGUgYXBwIG5hbWVkIFwiJyArXHJcbiAgICAgICAgICAgIHRoaXMuYXBwTmFtZV8gK1xyXG4gICAgICAgICAgICAnXCIgYXJlIGludmFsaWQuIFRoaXMgdXN1YWxseSBpbmRpY2F0ZXMgeW91ciBhcHAgd2FzIG5vdCAnICtcclxuICAgICAgICAgICAgJ2luaXRpYWxpemVkIGNvcnJlY3RseS4gJztcclxuICAgICAgICBpZiAoJ2NyZWRlbnRpYWwnIGluIHRoaXMuZmlyZWJhc2VPcHRpb25zXykge1xyXG4gICAgICAgICAgICBlcnJvck1lc3NhZ2UgKz1cclxuICAgICAgICAgICAgICAgICdNYWtlIHN1cmUgdGhlIFwiY3JlZGVudGlhbFwiIHByb3BlcnR5IHByb3ZpZGVkIHRvIGluaXRpYWxpemVBcHAoKSAnICtcclxuICAgICAgICAgICAgICAgICAgICAnaXMgYXV0aG9yaXplZCB0byBhY2Nlc3MgdGhlIHNwZWNpZmllZCBcImRhdGFiYXNlVVJMXCIgYW5kIGlzIGZyb20gdGhlIGNvcnJlY3QgJyArXHJcbiAgICAgICAgICAgICAgICAgICAgJ3Byb2plY3QuJztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoJ3NlcnZpY2VBY2NvdW50JyBpbiB0aGlzLmZpcmViYXNlT3B0aW9uc18pIHtcclxuICAgICAgICAgICAgZXJyb3JNZXNzYWdlICs9XHJcbiAgICAgICAgICAgICAgICAnTWFrZSBzdXJlIHRoZSBcInNlcnZpY2VBY2NvdW50XCIgcHJvcGVydHkgcHJvdmlkZWQgdG8gaW5pdGlhbGl6ZUFwcCgpICcgK1xyXG4gICAgICAgICAgICAgICAgICAgICdpcyBhdXRob3JpemVkIHRvIGFjY2VzcyB0aGUgc3BlY2lmaWVkIFwiZGF0YWJhc2VVUkxcIiBhbmQgaXMgZnJvbSB0aGUgY29ycmVjdCAnICtcclxuICAgICAgICAgICAgICAgICAgICAncHJvamVjdC4nO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZXJyb3JNZXNzYWdlICs9XHJcbiAgICAgICAgICAgICAgICAnTWFrZSBzdXJlIHRoZSBcImFwaUtleVwiIGFuZCBcImRhdGFiYXNlVVJMXCIgcHJvcGVydGllcyBwcm92aWRlZCB0byAnICtcclxuICAgICAgICAgICAgICAgICAgICAnaW5pdGlhbGl6ZUFwcCgpIG1hdGNoIHRoZSB2YWx1ZXMgcHJvdmlkZWQgZm9yIHlvdXIgYXBwIGF0ICcgK1xyXG4gICAgICAgICAgICAgICAgICAgICdodHRwczovL2NvbnNvbGUuZmlyZWJhc2UuZ29vZ2xlLmNvbS8uJztcclxuICAgICAgICB9XHJcbiAgICAgICAgd2FybihlcnJvck1lc3NhZ2UpO1xyXG4gICAgfVxyXG59XHJcbi8qIEF1dGhUb2tlblByb3ZpZGVyIHRoYXQgc3VwcGxpZXMgYSBjb25zdGFudCB0b2tlbi4gVXNlZCBieSBBZG1pbiBTREsgb3IgbW9ja1VzZXJUb2tlbiB3aXRoIGVtdWxhdG9ycy4gKi9cclxuY2xhc3MgRW11bGF0b3JUb2tlblByb3ZpZGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKGFjY2Vzc1Rva2VuKSB7XHJcbiAgICAgICAgdGhpcy5hY2Nlc3NUb2tlbiA9IGFjY2Vzc1Rva2VuO1xyXG4gICAgfVxyXG4gICAgZ2V0VG9rZW4oZm9yY2VSZWZyZXNoKSB7XHJcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7XHJcbiAgICAgICAgICAgIGFjY2Vzc1Rva2VuOiB0aGlzLmFjY2Vzc1Rva2VuXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBhZGRUb2tlbkNoYW5nZUxpc3RlbmVyKGxpc3RlbmVyKSB7XHJcbiAgICAgICAgLy8gSW52b2tlIHRoZSBsaXN0ZW5lciBpbW1lZGlhdGVseSB0byBtYXRjaCB0aGUgYmVoYXZpb3IgaW4gRmlyZWJhc2UgQXV0aFxyXG4gICAgICAgIC8vIChzZWUgcGFja2FnZXMvYXV0aC9zcmMvYXV0aC5qcyNMMTgwNylcclxuICAgICAgICBsaXN0ZW5lcih0aGlzLmFjY2Vzc1Rva2VuKTtcclxuICAgIH1cclxuICAgIHJlbW92ZVRva2VuQ2hhbmdlTGlzdGVuZXIobGlzdGVuZXIpIHsgfVxyXG4gICAgbm90aWZ5Rm9ySW52YWxpZFRva2VuKCkgeyB9XHJcbn1cclxuLyoqIEEgc3RyaW5nIHRoYXQgaXMgdHJlYXRlZCBhcyBhbiBhZG1pbiBhY2Nlc3MgdG9rZW4gYnkgdGhlIFJUREIgZW11bGF0b3IuIFVzZWQgYnkgQWRtaW4gU0RLLiAqL1xyXG5FbXVsYXRvclRva2VuUHJvdmlkZXIuT1dORVIgPSAnb3duZXInO1xuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5jb25zdCBQUk9UT0NPTF9WRVJTSU9OID0gJzUnO1xyXG5jb25zdCBWRVJTSU9OX1BBUkFNID0gJ3YnO1xyXG5jb25zdCBUUkFOU1BPUlRfU0VTU0lPTl9QQVJBTSA9ICdzJztcclxuY29uc3QgUkVGRVJFUl9QQVJBTSA9ICdyJztcclxuY29uc3QgRk9SR0VfUkVGID0gJ2YnO1xyXG4vLyBNYXRjaGVzIGNvbnNvbGUuZmlyZWJhc2UuZ29vZ2xlLmNvbSwgZmlyZWJhc2UtY29uc29sZS0qLmNvcnAuZ29vZ2xlLmNvbSBhbmRcclxuLy8gZmlyZWJhc2UuY29ycC5nb29nbGUuY29tXHJcbmNvbnN0IEZPUkdFX0RPTUFJTl9SRSA9IC8oY29uc29sZVxcLmZpcmViYXNlfGZpcmViYXNlLWNvbnNvbGUtXFx3K1xcLmNvcnB8ZmlyZWJhc2VcXC5jb3JwKVxcLmdvb2dsZVxcLmNvbS87XHJcbmNvbnN0IExBU1RfU0VTU0lPTl9QQVJBTSA9ICdscyc7XHJcbmNvbnN0IEFQUExJQ0FUSU9OX0lEX1BBUkFNID0gJ3AnO1xyXG5jb25zdCBBUFBfQ0hFQ0tfVE9LRU5fUEFSQU0gPSAnYWMnO1xyXG5jb25zdCBXRUJTT0NLRVQgPSAnd2Vic29ja2V0JztcclxuY29uc3QgTE9OR19QT0xMSU5HID0gJ2xvbmdfcG9sbGluZyc7XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBBIGNsYXNzIHRoYXQgaG9sZHMgbWV0YWRhdGEgYWJvdXQgYSBSZXBvIG9iamVjdFxyXG4gKi9cclxuY2xhc3MgUmVwb0luZm8ge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gaG9zdCAtIEhvc3RuYW1lIHBvcnRpb24gb2YgdGhlIHVybCBmb3IgdGhlIHJlcG9cclxuICAgICAqIEBwYXJhbSBzZWN1cmUgLSBXaGV0aGVyIG9yIG5vdCB0aGlzIHJlcG8gaXMgYWNjZXNzZWQgb3ZlciBzc2xcclxuICAgICAqIEBwYXJhbSBuYW1lc3BhY2UgLSBUaGUgbmFtZXNwYWNlIHJlcHJlc2VudGVkIGJ5IHRoZSByZXBvXHJcbiAgICAgKiBAcGFyYW0gd2ViU29ja2V0T25seSAtIFdoZXRoZXIgdG8gcHJlZmVyIHdlYnNvY2tldHMgb3ZlciBhbGwgb3RoZXIgdHJhbnNwb3J0cyAodXNlZCBieSBOZXN0KS5cclxuICAgICAqIEBwYXJhbSBub2RlQWRtaW4gLSBXaGV0aGVyIHRoaXMgaW5zdGFuY2UgdXNlcyBBZG1pbiBTREsgY3JlZGVudGlhbHNcclxuICAgICAqIEBwYXJhbSBwZXJzaXN0ZW5jZUtleSAtIE92ZXJyaWRlIHRoZSBkZWZhdWx0IHNlc3Npb24gcGVyc2lzdGVuY2Ugc3RvcmFnZSBrZXlcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoaG9zdCwgc2VjdXJlLCBuYW1lc3BhY2UsIHdlYlNvY2tldE9ubHksIG5vZGVBZG1pbiA9IGZhbHNlLCBwZXJzaXN0ZW5jZUtleSA9ICcnLCBpbmNsdWRlTmFtZXNwYWNlSW5RdWVyeVBhcmFtcyA9IGZhbHNlKSB7XHJcbiAgICAgICAgdGhpcy5zZWN1cmUgPSBzZWN1cmU7XHJcbiAgICAgICAgdGhpcy5uYW1lc3BhY2UgPSBuYW1lc3BhY2U7XHJcbiAgICAgICAgdGhpcy53ZWJTb2NrZXRPbmx5ID0gd2ViU29ja2V0T25seTtcclxuICAgICAgICB0aGlzLm5vZGVBZG1pbiA9IG5vZGVBZG1pbjtcclxuICAgICAgICB0aGlzLnBlcnNpc3RlbmNlS2V5ID0gcGVyc2lzdGVuY2VLZXk7XHJcbiAgICAgICAgdGhpcy5pbmNsdWRlTmFtZXNwYWNlSW5RdWVyeVBhcmFtcyA9IGluY2x1ZGVOYW1lc3BhY2VJblF1ZXJ5UGFyYW1zO1xyXG4gICAgICAgIHRoaXMuX2hvc3QgPSBob3N0LnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgdGhpcy5fZG9tYWluID0gdGhpcy5faG9zdC5zdWJzdHIodGhpcy5faG9zdC5pbmRleE9mKCcuJykgKyAxKTtcclxuICAgICAgICB0aGlzLmludGVybmFsSG9zdCA9XHJcbiAgICAgICAgICAgIFBlcnNpc3RlbnRTdG9yYWdlLmdldCgnaG9zdDonICsgaG9zdCkgfHwgdGhpcy5faG9zdDtcclxuICAgIH1cclxuICAgIGlzQ2FjaGVhYmxlSG9zdCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5pbnRlcm5hbEhvc3Quc3Vic3RyKDAsIDIpID09PSAncy0nO1xyXG4gICAgfVxyXG4gICAgaXNDdXN0b21Ib3N0KCkge1xyXG4gICAgICAgIHJldHVybiAodGhpcy5fZG9tYWluICE9PSAnZmlyZWJhc2Vpby5jb20nICYmXHJcbiAgICAgICAgICAgIHRoaXMuX2RvbWFpbiAhPT0gJ2ZpcmViYXNlaW8tZGVtby5jb20nKTtcclxuICAgIH1cclxuICAgIGdldCBob3N0KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9ob3N0O1xyXG4gICAgfVxyXG4gICAgc2V0IGhvc3QobmV3SG9zdCkge1xyXG4gICAgICAgIGlmIChuZXdIb3N0ICE9PSB0aGlzLmludGVybmFsSG9zdCkge1xyXG4gICAgICAgICAgICB0aGlzLmludGVybmFsSG9zdCA9IG5ld0hvc3Q7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmlzQ2FjaGVhYmxlSG9zdCgpKSB7XHJcbiAgICAgICAgICAgICAgICBQZXJzaXN0ZW50U3RvcmFnZS5zZXQoJ2hvc3Q6JyArIHRoaXMuX2hvc3QsIHRoaXMuaW50ZXJuYWxIb3N0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHRvU3RyaW5nKCkge1xyXG4gICAgICAgIGxldCBzdHIgPSB0aGlzLnRvVVJMU3RyaW5nKCk7XHJcbiAgICAgICAgaWYgKHRoaXMucGVyc2lzdGVuY2VLZXkpIHtcclxuICAgICAgICAgICAgc3RyICs9ICc8JyArIHRoaXMucGVyc2lzdGVuY2VLZXkgKyAnPic7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzdHI7XHJcbiAgICB9XHJcbiAgICB0b1VSTFN0cmluZygpIHtcclxuICAgICAgICBjb25zdCBwcm90b2NvbCA9IHRoaXMuc2VjdXJlID8gJ2h0dHBzOi8vJyA6ICdodHRwOi8vJztcclxuICAgICAgICBjb25zdCBxdWVyeSA9IHRoaXMuaW5jbHVkZU5hbWVzcGFjZUluUXVlcnlQYXJhbXNcclxuICAgICAgICAgICAgPyBgP25zPSR7dGhpcy5uYW1lc3BhY2V9YFxyXG4gICAgICAgICAgICA6ICcnO1xyXG4gICAgICAgIHJldHVybiBgJHtwcm90b2NvbH0ke3RoaXMuaG9zdH0vJHtxdWVyeX1gO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHJlcG9JbmZvTmVlZHNRdWVyeVBhcmFtKHJlcG9JbmZvKSB7XHJcbiAgICByZXR1cm4gKHJlcG9JbmZvLmhvc3QgIT09IHJlcG9JbmZvLmludGVybmFsSG9zdCB8fFxyXG4gICAgICAgIHJlcG9JbmZvLmlzQ3VzdG9tSG9zdCgpIHx8XHJcbiAgICAgICAgcmVwb0luZm8uaW5jbHVkZU5hbWVzcGFjZUluUXVlcnlQYXJhbXMpO1xyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSB3ZWJzb2NrZXQgVVJMIGZvciB0aGlzIHJlcG9cclxuICogQHBhcmFtIHJlcG9JbmZvIC0gUmVwb0luZm8gb2JqZWN0XHJcbiAqIEBwYXJhbSB0eXBlIC0gb2YgY29ubmVjdGlvblxyXG4gKiBAcGFyYW0gcGFyYW1zIC0gbGlzdFxyXG4gKiBAcmV0dXJucyBUaGUgVVJMIGZvciB0aGlzIHJlcG9cclxuICovXHJcbmZ1bmN0aW9uIHJlcG9JbmZvQ29ubmVjdGlvblVSTChyZXBvSW5mbywgdHlwZSwgcGFyYW1zKSB7XHJcbiAgICBhc3NlcnQodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnLCAndHlwZW9mIHR5cGUgbXVzdCA9PSBzdHJpbmcnKTtcclxuICAgIGFzc2VydCh0eXBlb2YgcGFyYW1zID09PSAnb2JqZWN0JywgJ3R5cGVvZiBwYXJhbXMgbXVzdCA9PSBvYmplY3QnKTtcclxuICAgIGxldCBjb25uVVJMO1xyXG4gICAgaWYgKHR5cGUgPT09IFdFQlNPQ0tFVCkge1xyXG4gICAgICAgIGNvbm5VUkwgPVxyXG4gICAgICAgICAgICAocmVwb0luZm8uc2VjdXJlID8gJ3dzczovLycgOiAnd3M6Ly8nKSArIHJlcG9JbmZvLmludGVybmFsSG9zdCArICcvLndzPyc7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh0eXBlID09PSBMT05HX1BPTExJTkcpIHtcclxuICAgICAgICBjb25uVVJMID1cclxuICAgICAgICAgICAgKHJlcG9JbmZvLnNlY3VyZSA/ICdodHRwczovLycgOiAnaHR0cDovLycpICtcclxuICAgICAgICAgICAgICAgIHJlcG9JbmZvLmludGVybmFsSG9zdCArXHJcbiAgICAgICAgICAgICAgICAnLy5scD8nO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGNvbm5lY3Rpb24gdHlwZTogJyArIHR5cGUpO1xyXG4gICAgfVxyXG4gICAgaWYgKHJlcG9JbmZvTmVlZHNRdWVyeVBhcmFtKHJlcG9JbmZvKSkge1xyXG4gICAgICAgIHBhcmFtc1snbnMnXSA9IHJlcG9JbmZvLm5hbWVzcGFjZTtcclxuICAgIH1cclxuICAgIGNvbnN0IHBhaXJzID0gW107XHJcbiAgICBlYWNoKHBhcmFtcywgKGtleSwgdmFsdWUpID0+IHtcclxuICAgICAgICBwYWlycy5wdXNoKGtleSArICc9JyArIHZhbHVlKTtcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIGNvbm5VUkwgKyBwYWlycy5qb2luKCcmJyk7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIFRyYWNrcyBhIGNvbGxlY3Rpb24gb2Ygc3RhdHMuXHJcbiAqL1xyXG5jbGFzcyBTdGF0c0NvbGxlY3Rpb24ge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5jb3VudGVyc18gPSB7fTtcclxuICAgIH1cclxuICAgIGluY3JlbWVudENvdW50ZXIobmFtZSwgYW1vdW50ID0gMSkge1xyXG4gICAgICAgIGlmICghY29udGFpbnModGhpcy5jb3VudGVyc18sIG5hbWUpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY291bnRlcnNfW25hbWVdID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5jb3VudGVyc19bbmFtZV0gKz0gYW1vdW50O1xyXG4gICAgfVxyXG4gICAgZ2V0KCkge1xyXG4gICAgICAgIHJldHVybiBkZWVwQ29weSh0aGlzLmNvdW50ZXJzXyk7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuY29uc3QgY29sbGVjdGlvbnMgPSB7fTtcclxuY29uc3QgcmVwb3J0ZXJzID0ge307XHJcbmZ1bmN0aW9uIHN0YXRzTWFuYWdlckdldENvbGxlY3Rpb24ocmVwb0luZm8pIHtcclxuICAgIGNvbnN0IGhhc2hTdHJpbmcgPSByZXBvSW5mby50b1N0cmluZygpO1xyXG4gICAgaWYgKCFjb2xsZWN0aW9uc1toYXNoU3RyaW5nXSkge1xyXG4gICAgICAgIGNvbGxlY3Rpb25zW2hhc2hTdHJpbmddID0gbmV3IFN0YXRzQ29sbGVjdGlvbigpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGNvbGxlY3Rpb25zW2hhc2hTdHJpbmddO1xyXG59XHJcbmZ1bmN0aW9uIHN0YXRzTWFuYWdlckdldE9yQ3JlYXRlUmVwb3J0ZXIocmVwb0luZm8sIGNyZWF0b3JGdW5jdGlvbikge1xyXG4gICAgY29uc3QgaGFzaFN0cmluZyA9IHJlcG9JbmZvLnRvU3RyaW5nKCk7XHJcbiAgICBpZiAoIXJlcG9ydGVyc1toYXNoU3RyaW5nXSkge1xyXG4gICAgICAgIHJlcG9ydGVyc1toYXNoU3RyaW5nXSA9IGNyZWF0b3JGdW5jdGlvbigpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlcG9ydGVyc1toYXNoU3RyaW5nXTtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogVGhpcyBjbGFzcyBlbnN1cmVzIHRoZSBwYWNrZXRzIGZyb20gdGhlIHNlcnZlciBhcnJpdmUgaW4gb3JkZXJcclxuICogVGhpcyBjbGFzcyB0YWtlcyBkYXRhIGZyb20gdGhlIHNlcnZlciBhbmQgZW5zdXJlcyBpdCBnZXRzIHBhc3NlZCBpbnRvIHRoZSBjYWxsYmFja3MgaW4gb3JkZXIuXHJcbiAqL1xyXG5jbGFzcyBQYWNrZXRSZWNlaXZlciB7XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSBvbk1lc3NhZ2VfXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKG9uTWVzc2FnZV8pIHtcclxuICAgICAgICB0aGlzLm9uTWVzc2FnZV8gPSBvbk1lc3NhZ2VfO1xyXG4gICAgICAgIHRoaXMucGVuZGluZ1Jlc3BvbnNlcyA9IFtdO1xyXG4gICAgICAgIHRoaXMuY3VycmVudFJlc3BvbnNlTnVtID0gMDtcclxuICAgICAgICB0aGlzLmNsb3NlQWZ0ZXJSZXNwb25zZSA9IC0xO1xyXG4gICAgICAgIHRoaXMub25DbG9zZSA9IG51bGw7XHJcbiAgICB9XHJcbiAgICBjbG9zZUFmdGVyKHJlc3BvbnNlTnVtLCBjYWxsYmFjaykge1xyXG4gICAgICAgIHRoaXMuY2xvc2VBZnRlclJlc3BvbnNlID0gcmVzcG9uc2VOdW07XHJcbiAgICAgICAgdGhpcy5vbkNsb3NlID0gY2FsbGJhY2s7XHJcbiAgICAgICAgaWYgKHRoaXMuY2xvc2VBZnRlclJlc3BvbnNlIDwgdGhpcy5jdXJyZW50UmVzcG9uc2VOdW0pIHtcclxuICAgICAgICAgICAgdGhpcy5vbkNsb3NlKCk7XHJcbiAgICAgICAgICAgIHRoaXMub25DbG9zZSA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBFYWNoIG1lc3NhZ2UgZnJvbSB0aGUgc2VydmVyIGNvbWVzIHdpdGggYSByZXNwb25zZSBudW1iZXIsIGFuZCBhbiBhcnJheSBvZiBkYXRhLiBUaGUgcmVzcG9uc2VOdW1iZXJcclxuICAgICAqIGFsbG93cyB1cyB0byBlbnN1cmUgdGhhdCB3ZSBwcm9jZXNzIHRoZW0gaW4gdGhlIHJpZ2h0IG9yZGVyLCBzaW5jZSB3ZSBjYW4ndCBiZSBndWFyYW50ZWVkIHRoYXQgYWxsXHJcbiAgICAgKiBicm93c2VycyB3aWxsIHJlc3BvbmQgaW4gdGhlIHNhbWUgb3JkZXIgYXMgdGhlIHJlcXVlc3RzIHdlIHNlbnRcclxuICAgICAqL1xyXG4gICAgaGFuZGxlUmVzcG9uc2UocmVxdWVzdE51bSwgZGF0YSkge1xyXG4gICAgICAgIHRoaXMucGVuZGluZ1Jlc3BvbnNlc1tyZXF1ZXN0TnVtXSA9IGRhdGE7XHJcbiAgICAgICAgd2hpbGUgKHRoaXMucGVuZGluZ1Jlc3BvbnNlc1t0aGlzLmN1cnJlbnRSZXNwb25zZU51bV0pIHtcclxuICAgICAgICAgICAgY29uc3QgdG9Qcm9jZXNzID0gdGhpcy5wZW5kaW5nUmVzcG9uc2VzW3RoaXMuY3VycmVudFJlc3BvbnNlTnVtXTtcclxuICAgICAgICAgICAgZGVsZXRlIHRoaXMucGVuZGluZ1Jlc3BvbnNlc1t0aGlzLmN1cnJlbnRSZXNwb25zZU51bV07XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdG9Qcm9jZXNzLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodG9Qcm9jZXNzW2ldKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXhjZXB0aW9uR3VhcmQoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9uTWVzc2FnZV8odG9Qcm9jZXNzW2ldKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50UmVzcG9uc2VOdW0gPT09IHRoaXMuY2xvc2VBZnRlclJlc3BvbnNlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vbkNsb3NlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vbkNsb3NlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vbkNsb3NlID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFJlc3BvbnNlTnVtKys7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8vIFVSTCBxdWVyeSBwYXJhbWV0ZXJzIGFzc29jaWF0ZWQgd2l0aCBsb25ncG9sbGluZ1xyXG5jb25zdCBGSVJFQkFTRV9MT05HUE9MTF9TVEFSVF9QQVJBTSA9ICdzdGFydCc7XHJcbmNvbnN0IEZJUkVCQVNFX0xPTkdQT0xMX0NMT1NFX0NPTU1BTkQgPSAnY2xvc2UnO1xyXG5jb25zdCBGSVJFQkFTRV9MT05HUE9MTF9DT01NQU5EX0NCX05BTUUgPSAncExQQ29tbWFuZCc7XHJcbmNvbnN0IEZJUkVCQVNFX0xPTkdQT0xMX0RBVEFfQ0JfTkFNRSA9ICdwUlRMUENCJztcclxuY29uc3QgRklSRUJBU0VfTE9OR1BPTExfSURfUEFSQU0gPSAnaWQnO1xyXG5jb25zdCBGSVJFQkFTRV9MT05HUE9MTF9QV19QQVJBTSA9ICdwdyc7XHJcbmNvbnN0IEZJUkVCQVNFX0xPTkdQT0xMX1NFUklBTF9QQVJBTSA9ICdzZXInO1xyXG5jb25zdCBGSVJFQkFTRV9MT05HUE9MTF9DQUxMQkFDS19JRF9QQVJBTSA9ICdjYic7XHJcbmNvbnN0IEZJUkVCQVNFX0xPTkdQT0xMX1NFR01FTlRfTlVNX1BBUkFNID0gJ3NlZyc7XHJcbmNvbnN0IEZJUkVCQVNFX0xPTkdQT0xMX1NFR01FTlRTX0lOX1BBQ0tFVCA9ICd0cyc7XHJcbmNvbnN0IEZJUkVCQVNFX0xPTkdQT0xMX0RBVEFfUEFSQU0gPSAnZCc7XHJcbmNvbnN0IEZJUkVCQVNFX0xPTkdQT0xMX0RJU0NPTk5fRlJBTUVfUkVRVUVTVF9QQVJBTSA9ICdkZnJhbWUnO1xyXG4vL0RhdGEgc2l6ZSBjb25zdGFudHMuXHJcbi8vVE9ETzogUGVyZjogdGhlIG1heGltdW0gbGVuZ3RoIGFjdHVhbGx5IGRpZmZlcnMgZnJvbSBicm93c2VyIHRvIGJyb3dzZXIuXHJcbi8vIFdlIHNob3VsZCBjaGVjayB3aGF0IGJyb3dzZXIgd2UncmUgb24gYW5kIHNldCBhY2NvcmRpbmdseS5cclxuY29uc3QgTUFYX1VSTF9EQVRBX1NJWkUgPSAxODcwO1xyXG5jb25zdCBTRUdfSEVBREVSX1NJWkUgPSAzMDsgLy9pZTogJnNlZz04Mjk5MjM0JnRzPTk4MjM4OTEyMyZkPVxyXG5jb25zdCBNQVhfUEFZTE9BRF9TSVpFID0gTUFYX1VSTF9EQVRBX1NJWkUgLSBTRUdfSEVBREVSX1NJWkU7XHJcbi8qKlxyXG4gKiBLZWVwYWxpdmUgcGVyaW9kXHJcbiAqIHNlbmQgYSBmcmVzaCByZXF1ZXN0IGF0IG1pbmltdW0gZXZlcnkgMjUgc2Vjb25kcy4gT3BlcmEgaGFzIGEgbWF4aW11bSByZXF1ZXN0XHJcbiAqIGxlbmd0aCBvZiAzMCBzZWNvbmRzIHRoYXQgd2UgY2FuJ3QgZXhjZWVkLlxyXG4gKi9cclxuY29uc3QgS0VFUEFMSVZFX1JFUVVFU1RfSU5URVJWQUwgPSAyNTAwMDtcclxuLyoqXHJcbiAqIEhvdyBsb25nIHRvIHdhaXQgYmVmb3JlIGFib3J0aW5nIGEgbG9uZy1wb2xsaW5nIGNvbm5lY3Rpb24gYXR0ZW1wdC5cclxuICovXHJcbmNvbnN0IExQX0NPTk5FQ1RfVElNRU9VVCA9IDMwMDAwO1xyXG4vKipcclxuICogVGhpcyBjbGFzcyBtYW5hZ2VzIGEgc2luZ2xlIGxvbmctcG9sbGluZyBjb25uZWN0aW9uLlxyXG4gKi9cclxuY2xhc3MgQnJvd3NlclBvbGxDb25uZWN0aW9uIHtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIGNvbm5JZCBBbiBpZGVudGlmaWVyIGZvciB0aGlzIGNvbm5lY3Rpb24sIHVzZWQgZm9yIGxvZ2dpbmdcclxuICAgICAqIEBwYXJhbSByZXBvSW5mbyBUaGUgaW5mbyBmb3IgdGhlIGVuZHBvaW50IHRvIHNlbmQgZGF0YSB0by5cclxuICAgICAqIEBwYXJhbSBhcHBsaWNhdGlvbklkIFRoZSBGaXJlYmFzZSBBcHAgSUQgZm9yIHRoaXMgcHJvamVjdC5cclxuICAgICAqIEBwYXJhbSBhcHBDaGVja1Rva2VuIFRoZSBBcHBDaGVjayB0b2tlbiBmb3IgdGhpcyBjbGllbnQuXHJcbiAgICAgKiBAcGFyYW0gYXV0aFRva2VuIFRoZSBBdXRoVG9rZW4gdG8gdXNlIGZvciB0aGlzIGNvbm5lY3Rpb24uXHJcbiAgICAgKiBAcGFyYW0gdHJhbnNwb3J0U2Vzc2lvbklkIE9wdGlvbmFsIHRyYW5zcG9ydFNlc3Npb25pZCBpZiB3ZSBhcmVcclxuICAgICAqIHJlY29ubmVjdGluZyBmb3IgYW4gZXhpc3RpbmcgdHJhbnNwb3J0IHNlc3Npb25cclxuICAgICAqIEBwYXJhbSBsYXN0U2Vzc2lvbklkIE9wdGlvbmFsIGxhc3RTZXNzaW9uSWQgaWYgdGhlIFBlcnNpc3RlbnRDb25uZWN0aW9uIGhhc1xyXG4gICAgICogYWxyZWFkeSBjcmVhdGVkIGEgY29ubmVjdGlvbiBwcmV2aW91c2x5XHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKGNvbm5JZCwgcmVwb0luZm8sIGFwcGxpY2F0aW9uSWQsIGFwcENoZWNrVG9rZW4sIGF1dGhUb2tlbiwgdHJhbnNwb3J0U2Vzc2lvbklkLCBsYXN0U2Vzc2lvbklkKSB7XHJcbiAgICAgICAgdGhpcy5jb25uSWQgPSBjb25uSWQ7XHJcbiAgICAgICAgdGhpcy5yZXBvSW5mbyA9IHJlcG9JbmZvO1xyXG4gICAgICAgIHRoaXMuYXBwbGljYXRpb25JZCA9IGFwcGxpY2F0aW9uSWQ7XHJcbiAgICAgICAgdGhpcy5hcHBDaGVja1Rva2VuID0gYXBwQ2hlY2tUb2tlbjtcclxuICAgICAgICB0aGlzLmF1dGhUb2tlbiA9IGF1dGhUb2tlbjtcclxuICAgICAgICB0aGlzLnRyYW5zcG9ydFNlc3Npb25JZCA9IHRyYW5zcG9ydFNlc3Npb25JZDtcclxuICAgICAgICB0aGlzLmxhc3RTZXNzaW9uSWQgPSBsYXN0U2Vzc2lvbklkO1xyXG4gICAgICAgIHRoaXMuYnl0ZXNTZW50ID0gMDtcclxuICAgICAgICB0aGlzLmJ5dGVzUmVjZWl2ZWQgPSAwO1xyXG4gICAgICAgIHRoaXMuZXZlckNvbm5lY3RlZF8gPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmxvZ18gPSBsb2dXcmFwcGVyKGNvbm5JZCk7XHJcbiAgICAgICAgdGhpcy5zdGF0c18gPSBzdGF0c01hbmFnZXJHZXRDb2xsZWN0aW9uKHJlcG9JbmZvKTtcclxuICAgICAgICB0aGlzLnVybEZuID0gKHBhcmFtcykgPT4ge1xyXG4gICAgICAgICAgICAvLyBBbHdheXMgYWRkIHRoZSB0b2tlbiBpZiB3ZSBoYXZlIG9uZS5cclxuICAgICAgICAgICAgaWYgKHRoaXMuYXBwQ2hlY2tUb2tlbikge1xyXG4gICAgICAgICAgICAgICAgcGFyYW1zW0FQUF9DSEVDS19UT0tFTl9QQVJBTV0gPSB0aGlzLmFwcENoZWNrVG9rZW47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHJlcG9JbmZvQ29ubmVjdGlvblVSTChyZXBvSW5mbywgTE9OR19QT0xMSU5HLCBwYXJhbXMpO1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSBvbk1lc3NhZ2UgLSBDYWxsYmFjayB3aGVuIG1lc3NhZ2VzIGFycml2ZVxyXG4gICAgICogQHBhcmFtIG9uRGlzY29ubmVjdCAtIENhbGxiYWNrIHdpdGggY29ubmVjdGlvbiBsb3N0LlxyXG4gICAgICovXHJcbiAgICBvcGVuKG9uTWVzc2FnZSwgb25EaXNjb25uZWN0KSB7XHJcbiAgICAgICAgdGhpcy5jdXJTZWdtZW50TnVtID0gMDtcclxuICAgICAgICB0aGlzLm9uRGlzY29ubmVjdF8gPSBvbkRpc2Nvbm5lY3Q7XHJcbiAgICAgICAgdGhpcy5teVBhY2tldE9yZGVyZXIgPSBuZXcgUGFja2V0UmVjZWl2ZXIob25NZXNzYWdlKTtcclxuICAgICAgICB0aGlzLmlzQ2xvc2VkXyA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuY29ubmVjdFRpbWVvdXRUaW1lcl8gPSBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5sb2dfKCdUaW1lZCBvdXQgdHJ5aW5nIHRvIGNvbm5lY3QuJyk7XHJcbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB3ZSBjbGVhciB0aGUgaG9zdCBjYWNoZVxyXG4gICAgICAgICAgICB0aGlzLm9uQ2xvc2VkXygpO1xyXG4gICAgICAgICAgICB0aGlzLmNvbm5lY3RUaW1lb3V0VGltZXJfID0gbnVsbDtcclxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcclxuICAgICAgICB9LCBNYXRoLmZsb29yKExQX0NPTk5FQ1RfVElNRU9VVCkpO1xyXG4gICAgICAgIC8vIEVuc3VyZSB3ZSBkZWxheSB0aGUgY3JlYXRpb24gb2YgdGhlIGlmcmFtZSB1bnRpbCB0aGUgRE9NIGlzIGxvYWRlZC5cclxuICAgICAgICBleGVjdXRlV2hlbkRPTVJlYWR5KCgpID0+IHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuaXNDbG9zZWRfKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy9TZXQgdXAgYSBjYWxsYmFjayB0aGF0IGdldHMgdHJpZ2dlcmVkIG9uY2UgYSBjb25uZWN0aW9uIGlzIHNldCB1cC5cclxuICAgICAgICAgICAgdGhpcy5zY3JpcHRUYWdIb2xkZXIgPSBuZXcgRmlyZWJhc2VJRnJhbWVTY3JpcHRIb2xkZXIoKC4uLmFyZ3MpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IFtjb21tYW5kLCBhcmcxLCBhcmcyLCBhcmczLCBhcmc0XSA9IGFyZ3M7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmluY3JlbWVudEluY29taW5nQnl0ZXNfKGFyZ3MpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLnNjcmlwdFRhZ0hvbGRlcikge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjsgLy8gd2UgY2xvc2VkIHRoZSBjb25uZWN0aW9uLlxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY29ubmVjdFRpbWVvdXRUaW1lcl8pIHtcclxuICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5jb25uZWN0VGltZW91dFRpbWVyXyk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25uZWN0VGltZW91dFRpbWVyXyA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZXJDb25uZWN0ZWRfID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGlmIChjb21tYW5kID09PSBGSVJFQkFTRV9MT05HUE9MTF9TVEFSVF9QQVJBTSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaWQgPSBhcmcxO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFzc3dvcmQgPSBhcmcyO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY29tbWFuZCA9PT0gRklSRUJBU0VfTE9OR1BPTExfQ0xPU0VfQ09NTUFORCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIERvbid0IGNsZWFyIHRoZSBob3N0IGNhY2hlLiBXZSBnb3QgYSByZXNwb25zZSBmcm9tIHRoZSBzZXJ2ZXIsIHNvIHdlIGtub3cgaXQncyByZWFjaGFibGVcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYXJnMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBhcmVuJ3QgZXhwZWN0aW5nIGFueSBtb3JlIGRhdGEgKG90aGVyIHRoYW4gd2hhdCB0aGUgc2VydmVyJ3MgYWxyZWFkeSBpbiB0aGUgcHJvY2VzcyBvZiBzZW5kaW5nIHVzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRocm91Z2ggb3VyIGFscmVhZHkgb3BlbiBwb2xscyksIHNvIGRvbid0IHNlbmQgYW55IG1vcmUuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2NyaXB0VGFnSG9sZGVyLnNlbmROZXdQb2xscyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhcmcxIGluIHRoaXMgY2FzZSBpcyB0aGUgbGFzdCByZXNwb25zZSBudW1iZXIgc2VudCBieSB0aGUgc2VydmVyLiBXZSBzaG91bGQgdHJ5IHRvIHJlY2VpdmVcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWxsIG9mIHRoZSByZXNwb25zZXMgdXAgdG8gdGhpcyBvbmUgYmVmb3JlIGNsb3NpbmdcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5teVBhY2tldE9yZGVyZXIuY2xvc2VBZnRlcihhcmcxLCAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9uQ2xvc2VkXygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub25DbG9zZWRfKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnJlY29nbml6ZWQgY29tbWFuZCByZWNlaXZlZDogJyArIGNvbW1hbmQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LCAoLi4uYXJncykgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgW3BOLCBkYXRhXSA9IGFyZ3M7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmluY3JlbWVudEluY29taW5nQnl0ZXNfKGFyZ3MpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5teVBhY2tldE9yZGVyZXIuaGFuZGxlUmVzcG9uc2UocE4sIGRhdGEpO1xyXG4gICAgICAgICAgICB9LCAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9uQ2xvc2VkXygpO1xyXG4gICAgICAgICAgICB9LCB0aGlzLnVybEZuKTtcclxuICAgICAgICAgICAgLy9TZW5kIHRoZSBpbml0aWFsIHJlcXVlc3QgdG8gY29ubmVjdC4gVGhlIHNlcmlhbCBudW1iZXIgaXMgc2ltcGx5IHRvIGtlZXAgdGhlIGJyb3dzZXIgZnJvbSBwdWxsaW5nIHByZXZpb3VzIHJlc3VsdHNcclxuICAgICAgICAgICAgLy9mcm9tIGNhY2hlLlxyXG4gICAgICAgICAgICBjb25zdCB1cmxQYXJhbXMgPSB7fTtcclxuICAgICAgICAgICAgdXJsUGFyYW1zW0ZJUkVCQVNFX0xPTkdQT0xMX1NUQVJUX1BBUkFNXSA9ICd0JztcclxuICAgICAgICAgICAgdXJsUGFyYW1zW0ZJUkVCQVNFX0xPTkdQT0xMX1NFUklBTF9QQVJBTV0gPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxMDAwMDAwMDApO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5zY3JpcHRUYWdIb2xkZXIudW5pcXVlQ2FsbGJhY2tJZGVudGlmaWVyKSB7XHJcbiAgICAgICAgICAgICAgICB1cmxQYXJhbXNbRklSRUJBU0VfTE9OR1BPTExfQ0FMTEJBQ0tfSURfUEFSQU1dID1cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNjcmlwdFRhZ0hvbGRlci51bmlxdWVDYWxsYmFja0lkZW50aWZpZXI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdXJsUGFyYW1zW1ZFUlNJT05fUEFSQU1dID0gUFJPVE9DT0xfVkVSU0lPTjtcclxuICAgICAgICAgICAgaWYgKHRoaXMudHJhbnNwb3J0U2Vzc2lvbklkKSB7XHJcbiAgICAgICAgICAgICAgICB1cmxQYXJhbXNbVFJBTlNQT1JUX1NFU1NJT05fUEFSQU1dID0gdGhpcy50cmFuc3BvcnRTZXNzaW9uSWQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRoaXMubGFzdFNlc3Npb25JZCkge1xyXG4gICAgICAgICAgICAgICAgdXJsUGFyYW1zW0xBU1RfU0VTU0lPTl9QQVJBTV0gPSB0aGlzLmxhc3RTZXNzaW9uSWQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRoaXMuYXBwbGljYXRpb25JZCkge1xyXG4gICAgICAgICAgICAgICAgdXJsUGFyYW1zW0FQUExJQ0FUSU9OX0lEX1BBUkFNXSA9IHRoaXMuYXBwbGljYXRpb25JZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodGhpcy5hcHBDaGVja1Rva2VuKSB7XHJcbiAgICAgICAgICAgICAgICB1cmxQYXJhbXNbQVBQX0NIRUNLX1RPS0VOX1BBUkFNXSA9IHRoaXMuYXBwQ2hlY2tUb2tlbjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGxvY2F0aW9uICE9PSAndW5kZWZpbmVkJyAmJlxyXG4gICAgICAgICAgICAgICAgbG9jYXRpb24uaG9zdG5hbWUgJiZcclxuICAgICAgICAgICAgICAgIEZPUkdFX0RPTUFJTl9SRS50ZXN0KGxvY2F0aW9uLmhvc3RuYW1lKSkge1xyXG4gICAgICAgICAgICAgICAgdXJsUGFyYW1zW1JFRkVSRVJfUEFSQU1dID0gRk9SR0VfUkVGO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IGNvbm5lY3RVUkwgPSB0aGlzLnVybEZuKHVybFBhcmFtcyk7XHJcbiAgICAgICAgICAgIHRoaXMubG9nXygnQ29ubmVjdGluZyB2aWEgbG9uZy1wb2xsIHRvICcgKyBjb25uZWN0VVJMKTtcclxuICAgICAgICAgICAgdGhpcy5zY3JpcHRUYWdIb2xkZXIuYWRkVGFnKGNvbm5lY3RVUkwsICgpID0+IHtcclxuICAgICAgICAgICAgICAgIC8qIGRvIG5vdGhpbmcgKi9cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENhbGwgdGhpcyB3aGVuIGEgaGFuZHNoYWtlIGhhcyBjb21wbGV0ZWQgc3VjY2Vzc2Z1bGx5IGFuZCB3ZSB3YW50IHRvIGNvbnNpZGVyIHRoZSBjb25uZWN0aW9uIGVzdGFibGlzaGVkXHJcbiAgICAgKi9cclxuICAgIHN0YXJ0KCkge1xyXG4gICAgICAgIHRoaXMuc2NyaXB0VGFnSG9sZGVyLnN0YXJ0TG9uZ1BvbGwodGhpcy5pZCwgdGhpcy5wYXNzd29yZCk7XHJcbiAgICAgICAgdGhpcy5hZGREaXNjb25uZWN0UGluZ0ZyYW1lKHRoaXMuaWQsIHRoaXMucGFzc3dvcmQpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBGb3JjZXMgbG9uZyBwb2xsaW5nIHRvIGJlIGNvbnNpZGVyZWQgYXMgYSBwb3RlbnRpYWwgdHJhbnNwb3J0XHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBmb3JjZUFsbG93KCkge1xyXG4gICAgICAgIEJyb3dzZXJQb2xsQ29ubmVjdGlvbi5mb3JjZUFsbG93XyA9IHRydWU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEZvcmNlcyBsb25ncG9sbGluZyB0byBub3QgYmUgY29uc2lkZXJlZCBhcyBhIHBvdGVudGlhbCB0cmFuc3BvcnRcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGZvcmNlRGlzYWxsb3coKSB7XHJcbiAgICAgICAgQnJvd3NlclBvbGxDb25uZWN0aW9uLmZvcmNlRGlzYWxsb3dfID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIC8vIFN0YXRpYyBtZXRob2QsIHVzZSBzdHJpbmcgbGl0ZXJhbCBzbyBpdCBjYW4gYmUgYWNjZXNzZWQgaW4gYSBnZW5lcmljIHdheVxyXG4gICAgc3RhdGljIGlzQXZhaWxhYmxlKCkge1xyXG4gICAgICAgIGlmIChpc05vZGVTZGsoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKEJyb3dzZXJQb2xsQ29ubmVjdGlvbi5mb3JjZUFsbG93Xykge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIE5PVEU6IEluIFJlYWN0LU5hdGl2ZSB0aGVyZSdzIG5vcm1hbGx5IG5vICdkb2N1bWVudCcsIGJ1dCBpZiB5b3UgZGVidWcgYSBSZWFjdC1OYXRpdmUgYXBwIGluXHJcbiAgICAgICAgICAgIC8vIHRoZSBDaHJvbWUgZGVidWdnZXIsICdkb2N1bWVudCcgaXMgZGVmaW5lZCwgYnV0IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgaXMgbnVsbCAoMjAxNS8wNi8wOCkuXHJcbiAgICAgICAgICAgIHJldHVybiAoIUJyb3dzZXJQb2xsQ29ubmVjdGlvbi5mb3JjZURpc2FsbG93XyAmJlxyXG4gICAgICAgICAgICAgICAgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJlxyXG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCAhPSBudWxsICYmXHJcbiAgICAgICAgICAgICAgICAhaXNDaHJvbWVFeHRlbnNpb25Db250ZW50U2NyaXB0KCkgJiZcclxuICAgICAgICAgICAgICAgICFpc1dpbmRvd3NTdG9yZUFwcCgpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIE5vLW9wIGZvciBwb2xsaW5nXHJcbiAgICAgKi9cclxuICAgIG1hcmtDb25uZWN0aW9uSGVhbHRoeSgpIHsgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTdG9wcyBwb2xsaW5nIGFuZCBjbGVhbnMgdXAgdGhlIGlmcmFtZVxyXG4gICAgICovXHJcbiAgICBzaHV0ZG93bl8oKSB7XHJcbiAgICAgICAgdGhpcy5pc0Nsb3NlZF8gPSB0cnVlO1xyXG4gICAgICAgIGlmICh0aGlzLnNjcmlwdFRhZ0hvbGRlcikge1xyXG4gICAgICAgICAgICB0aGlzLnNjcmlwdFRhZ0hvbGRlci5jbG9zZSgpO1xyXG4gICAgICAgICAgICB0aGlzLnNjcmlwdFRhZ0hvbGRlciA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vcmVtb3ZlIHRoZSBkaXNjb25uZWN0IGZyYW1lLCB3aGljaCB3aWxsIHRyaWdnZXIgYW4gWEhSIGNhbGwgdG8gdGhlIHNlcnZlciB0byB0ZWxsIGl0IHdlJ3JlIGxlYXZpbmcuXHJcbiAgICAgICAgaWYgKHRoaXMubXlEaXNjb25uRnJhbWUpIHtcclxuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZCh0aGlzLm15RGlzY29ubkZyYW1lKTtcclxuICAgICAgICAgICAgdGhpcy5teURpc2Nvbm5GcmFtZSA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmNvbm5lY3RUaW1lb3V0VGltZXJfKSB7XHJcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmNvbm5lY3RUaW1lb3V0VGltZXJfKTtcclxuICAgICAgICAgICAgdGhpcy5jb25uZWN0VGltZW91dFRpbWVyXyA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUcmlnZ2VyZWQgd2hlbiB0aGlzIHRyYW5zcG9ydCBpcyBjbG9zZWRcclxuICAgICAqL1xyXG4gICAgb25DbG9zZWRfKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5pc0Nsb3NlZF8pIHtcclxuICAgICAgICAgICAgdGhpcy5sb2dfKCdMb25ncG9sbCBpcyBjbG9zaW5nIGl0c2VsZicpO1xyXG4gICAgICAgICAgICB0aGlzLnNodXRkb3duXygpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5vbkRpc2Nvbm5lY3RfKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9uRGlzY29ubmVjdF8odGhpcy5ldmVyQ29ubmVjdGVkXyk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9uRGlzY29ubmVjdF8gPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBFeHRlcm5hbC1mYWNpbmcgY2xvc2UgaGFuZGxlci4gUmVhbFRpbWUgaGFzIHJlcXVlc3RlZCB3ZSBzaHV0IGRvd24uIEtpbGwgb3VyIGNvbm5lY3Rpb24gYW5kIHRlbGwgdGhlIHNlcnZlclxyXG4gICAgICogdGhhdCB3ZSd2ZSBsZWZ0LlxyXG4gICAgICovXHJcbiAgICBjbG9zZSgpIHtcclxuICAgICAgICBpZiAoIXRoaXMuaXNDbG9zZWRfKSB7XHJcbiAgICAgICAgICAgIHRoaXMubG9nXygnTG9uZ3BvbGwgaXMgYmVpbmcgY2xvc2VkLicpO1xyXG4gICAgICAgICAgICB0aGlzLnNodXRkb3duXygpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2VuZCB0aGUgSlNPTiBvYmplY3QgZG93biB0byB0aGUgc2VydmVyLiBJdCB3aWxsIG5lZWQgdG8gYmUgc3RyaW5naWZpZWQsIGJhc2U2NCBlbmNvZGVkLCBhbmQgdGhlblxyXG4gICAgICogYnJva2VuIGludG8gY2h1bmtzIChzaW5jZSBVUkxzIGhhdmUgYSBzbWFsbCBtYXhpbXVtIGxlbmd0aCkuXHJcbiAgICAgKiBAcGFyYW0gZGF0YSAtIFRoZSBKU09OIGRhdGEgdG8gdHJhbnNtaXQuXHJcbiAgICAgKi9cclxuICAgIHNlbmQoZGF0YSkge1xyXG4gICAgICAgIGNvbnN0IGRhdGFTdHIgPSBzdHJpbmdpZnkoZGF0YSk7XHJcbiAgICAgICAgdGhpcy5ieXRlc1NlbnQgKz0gZGF0YVN0ci5sZW5ndGg7XHJcbiAgICAgICAgdGhpcy5zdGF0c18uaW5jcmVtZW50Q291bnRlcignYnl0ZXNfc2VudCcsIGRhdGFTdHIubGVuZ3RoKTtcclxuICAgICAgICAvL2ZpcnN0LCBsZXRzIGdldCB0aGUgYmFzZTY0LWVuY29kZWQgZGF0YVxyXG4gICAgICAgIGNvbnN0IGJhc2U2NGRhdGEgPSBiYXNlNjRFbmNvZGUoZGF0YVN0cik7XHJcbiAgICAgICAgLy9XZSBjYW4gb25seSBmaXQgYSBjZXJ0YWluIGFtb3VudCBpbiBlYWNoIFVSTCwgc28gd2UgbmVlZCB0byBzcGxpdCB0aGlzIHJlcXVlc3RcclxuICAgICAgICAvL3VwIGludG8gbXVsdGlwbGUgcGllY2VzIGlmIGl0IGRvZXNuJ3QgZml0IGluIG9uZSByZXF1ZXN0LlxyXG4gICAgICAgIGNvbnN0IGRhdGFTZWdzID0gc3BsaXRTdHJpbmdCeVNpemUoYmFzZTY0ZGF0YSwgTUFYX1BBWUxPQURfU0laRSk7XHJcbiAgICAgICAgLy9FbnF1ZXVlIGVhY2ggc2VnbWVudCBmb3IgdHJhbnNtaXNzaW9uLiBXZSBhc3NpZ24gZWFjaCBjaHVuayBhIHNlcXVlbnRpYWwgSUQgYW5kIGEgdG90YWwgbnVtYmVyXHJcbiAgICAgICAgLy9vZiBzZWdtZW50cyBzbyB0aGF0IHdlIGNhbiByZWFzc2VtYmxlIHRoZSBwYWNrZXQgb24gdGhlIHNlcnZlci5cclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGFTZWdzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2NyaXB0VGFnSG9sZGVyLmVucXVldWVTZWdtZW50KHRoaXMuY3VyU2VnbWVudE51bSwgZGF0YVNlZ3MubGVuZ3RoLCBkYXRhU2Vnc1tpXSk7XHJcbiAgICAgICAgICAgIHRoaXMuY3VyU2VnbWVudE51bSsrO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBpcyBob3cgd2Ugbm90aWZ5IHRoZSBzZXJ2ZXIgdGhhdCB3ZSdyZSBsZWF2aW5nLlxyXG4gICAgICogV2UgYXJlbid0IGFibGUgdG8gc2VuZCByZXF1ZXN0cyB3aXRoIERIVE1MIG9uIGEgd2luZG93IGNsb3NlIGV2ZW50LCBidXQgd2UgY2FuXHJcbiAgICAgKiB0cmlnZ2VyIFhIUiByZXF1ZXN0cyBpbiBzb21lIGJyb3dzZXJzIChldmVyeXRoaW5nIGJ1dCBPcGVyYSBiYXNpY2FsbHkpLlxyXG4gICAgICovXHJcbiAgICBhZGREaXNjb25uZWN0UGluZ0ZyYW1lKGlkLCBwdykge1xyXG4gICAgICAgIGlmIChpc05vZGVTZGsoKSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMubXlEaXNjb25uRnJhbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpZnJhbWUnKTtcclxuICAgICAgICBjb25zdCB1cmxQYXJhbXMgPSB7fTtcclxuICAgICAgICB1cmxQYXJhbXNbRklSRUJBU0VfTE9OR1BPTExfRElTQ09OTl9GUkFNRV9SRVFVRVNUX1BBUkFNXSA9ICd0JztcclxuICAgICAgICB1cmxQYXJhbXNbRklSRUJBU0VfTE9OR1BPTExfSURfUEFSQU1dID0gaWQ7XHJcbiAgICAgICAgdXJsUGFyYW1zW0ZJUkVCQVNFX0xPTkdQT0xMX1BXX1BBUkFNXSA9IHB3O1xyXG4gICAgICAgIHRoaXMubXlEaXNjb25uRnJhbWUuc3JjID0gdGhpcy51cmxGbih1cmxQYXJhbXMpO1xyXG4gICAgICAgIHRoaXMubXlEaXNjb25uRnJhbWUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcclxuICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRoaXMubXlEaXNjb25uRnJhbWUpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBVc2VkIHRvIHRyYWNrIHRoZSBieXRlcyByZWNlaXZlZCBieSB0aGlzIGNsaWVudFxyXG4gICAgICovXHJcbiAgICBpbmNyZW1lbnRJbmNvbWluZ0J5dGVzXyhhcmdzKSB7XHJcbiAgICAgICAgLy8gVE9ETzogVGhpcyBpcyBhbiBhbm5veWluZyBwZXJmIGhpdCBqdXN0IHRvIHRyYWNrIHRoZSBudW1iZXIgb2YgaW5jb21pbmcgYnl0ZXMuICBNYXliZSBpdCBzaG91bGQgYmUgb3B0LWluLlxyXG4gICAgICAgIGNvbnN0IGJ5dGVzUmVjZWl2ZWQgPSBzdHJpbmdpZnkoYXJncykubGVuZ3RoO1xyXG4gICAgICAgIHRoaXMuYnl0ZXNSZWNlaXZlZCArPSBieXRlc1JlY2VpdmVkO1xyXG4gICAgICAgIHRoaXMuc3RhdHNfLmluY3JlbWVudENvdW50ZXIoJ2J5dGVzX3JlY2VpdmVkJywgYnl0ZXNSZWNlaXZlZCk7XHJcbiAgICB9XHJcbn1cclxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG4gKiBBIHdyYXBwZXIgYXJvdW5kIGFuIGlmcmFtZSB0aGF0IGlzIHVzZWQgYXMgYSBsb25nLXBvbGxpbmcgc2NyaXB0IGhvbGRlci5cclxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cclxuY2xhc3MgRmlyZWJhc2VJRnJhbWVTY3JpcHRIb2xkZXIge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gY29tbWFuZENCIC0gVGhlIGNhbGxiYWNrIHRvIGJlIGNhbGxlZCB3aGVuIGNvbnRyb2wgY29tbWFuZHMgYXJlIHJlY2V2aWVkIGZyb20gdGhlIHNlcnZlci5cclxuICAgICAqIEBwYXJhbSBvbk1lc3NhZ2VDQiAtIFRoZSBjYWxsYmFjayB0byBiZSB0cmlnZ2VyZWQgd2hlbiByZXNwb25zZXMgYXJyaXZlIGZyb20gdGhlIHNlcnZlci5cclxuICAgICAqIEBwYXJhbSBvbkRpc2Nvbm5lY3QgLSBUaGUgY2FsbGJhY2sgdG8gYmUgdHJpZ2dlcmVkIHdoZW4gdGhpcyB0YWcgaG9sZGVyIGlzIGNsb3NlZFxyXG4gICAgICogQHBhcmFtIHVybEZuIC0gQSBmdW5jdGlvbiB0aGF0IHByb3ZpZGVzIHRoZSBVUkwgb2YgdGhlIGVuZHBvaW50IHRvIHNlbmQgZGF0YSB0by5cclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoY29tbWFuZENCLCBvbk1lc3NhZ2VDQiwgb25EaXNjb25uZWN0LCB1cmxGbikge1xyXG4gICAgICAgIHRoaXMub25EaXNjb25uZWN0ID0gb25EaXNjb25uZWN0O1xyXG4gICAgICAgIHRoaXMudXJsRm4gPSB1cmxGbjtcclxuICAgICAgICAvL1dlIG1haW50YWluIGEgY291bnQgb2YgYWxsIG9mIHRoZSBvdXRzdGFuZGluZyByZXF1ZXN0cywgYmVjYXVzZSBpZiB3ZSBoYXZlIHRvbyBtYW55IGFjdGl2ZSBhdCBvbmNlIGl0IGNhbiBjYXVzZVxyXG4gICAgICAgIC8vcHJvYmxlbXMgaW4gc29tZSBicm93c2Vycy5cclxuICAgICAgICB0aGlzLm91dHN0YW5kaW5nUmVxdWVzdHMgPSBuZXcgU2V0KCk7XHJcbiAgICAgICAgLy9BIHF1ZXVlIG9mIHRoZSBwZW5kaW5nIHNlZ21lbnRzIHdhaXRpbmcgZm9yIHRyYW5zbWlzc2lvbiB0byB0aGUgc2VydmVyLlxyXG4gICAgICAgIHRoaXMucGVuZGluZ1NlZ3MgPSBbXTtcclxuICAgICAgICAvL0Egc2VyaWFsIG51bWJlci4gV2UgdXNlIHRoaXMgZm9yIHR3byB0aGluZ3M6XHJcbiAgICAgICAgLy8gMSkgQSB3YXkgdG8gZW5zdXJlIHRoZSBicm93c2VyIGRvZXNuJ3QgY2FjaGUgcmVzcG9uc2VzIHRvIHBvbGxzXHJcbiAgICAgICAgLy8gMikgQSB3YXkgdG8gbWFrZSB0aGUgc2VydmVyIGF3YXJlIHdoZW4gbG9uZy1wb2xscyBhcnJpdmUgaW4gYSBkaWZmZXJlbnQgb3JkZXIgdGhhbiB3ZSBzdGFydGVkIHRoZW0uIFRoZVxyXG4gICAgICAgIC8vICAgIHNlcnZlciBuZWVkcyB0byByZWxlYXNlIGJvdGggcG9sbHMgaW4gdGhpcyBjYXNlIG9yIGl0IHdpbGwgY2F1c2UgcHJvYmxlbXMgaW4gT3BlcmEgc2luY2UgT3BlcmEgY2FuIG9ubHkgZXhlY3V0ZVxyXG4gICAgICAgIC8vICAgIEpTT05QIGNvZGUgaW4gdGhlIG9yZGVyIGl0IHdhcyBhZGRlZCB0byB0aGUgaWZyYW1lLlxyXG4gICAgICAgIHRoaXMuY3VycmVudFNlcmlhbCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDEwMDAwMDAwMCk7XHJcbiAgICAgICAgLy8gVGhpcyBnZXRzIHNldCB0byBmYWxzZSB3aGVuIHdlJ3JlIFwiY2xvc2luZyBkb3duXCIgdGhlIGNvbm5lY3Rpb24gKGUuZy4gd2UncmUgc3dpdGNoaW5nIHRyYW5zcG9ydHMgYnV0IHRoZXJlJ3Mgc3RpbGxcclxuICAgICAgICAvLyBpbmNvbWluZyBkYXRhIGZyb20gdGhlIHNlcnZlciB0aGF0IHdlJ3JlIHdhaXRpbmcgZm9yKS5cclxuICAgICAgICB0aGlzLnNlbmROZXdQb2xscyA9IHRydWU7XHJcbiAgICAgICAgaWYgKCFpc05vZGVTZGsoKSkge1xyXG4gICAgICAgICAgICAvL0VhY2ggc2NyaXB0IGhvbGRlciByZWdpc3RlcnMgYSBjb3VwbGUgb2YgdW5pcXVlbHkgbmFtZWQgY2FsbGJhY2tzIHdpdGggdGhlIHdpbmRvdy4gVGhlc2UgYXJlIGNhbGxlZCBmcm9tIHRoZVxyXG4gICAgICAgICAgICAvL2lmcmFtZXMgd2hlcmUgd2UgcHV0IHRoZSBsb25nLXBvbGxpbmcgc2NyaXB0IHRhZ3MuIFdlIGhhdmUgdHdvIGNhbGxiYWNrczpcclxuICAgICAgICAgICAgLy8gICAxKSBDb21tYW5kIENhbGxiYWNrIC0gVHJpZ2dlcmVkIGZvciBjb250cm9sIGlzc3VlcywgbGlrZSBzdGFydGluZyBhIGNvbm5lY3Rpb24uXHJcbiAgICAgICAgICAgIC8vICAgMikgTWVzc2FnZSBDYWxsYmFjayAtIFRyaWdnZXJlZCB3aGVuIG5ldyBkYXRhIGFycml2ZXMuXHJcbiAgICAgICAgICAgIHRoaXMudW5pcXVlQ2FsbGJhY2tJZGVudGlmaWVyID0gTFVJREdlbmVyYXRvcigpO1xyXG4gICAgICAgICAgICB3aW5kb3dbRklSRUJBU0VfTE9OR1BPTExfQ09NTUFORF9DQl9OQU1FICsgdGhpcy51bmlxdWVDYWxsYmFja0lkZW50aWZpZXJdID0gY29tbWFuZENCO1xyXG4gICAgICAgICAgICB3aW5kb3dbRklSRUJBU0VfTE9OR1BPTExfREFUQV9DQl9OQU1FICsgdGhpcy51bmlxdWVDYWxsYmFja0lkZW50aWZpZXJdID1cclxuICAgICAgICAgICAgICAgIG9uTWVzc2FnZUNCO1xyXG4gICAgICAgICAgICAvL0NyZWF0ZSBhbiBpZnJhbWUgZm9yIHVzIHRvIGFkZCBzY3JpcHQgdGFncyB0by5cclxuICAgICAgICAgICAgdGhpcy5teUlGcmFtZSA9IEZpcmViYXNlSUZyYW1lU2NyaXB0SG9sZGVyLmNyZWF0ZUlGcmFtZV8oKTtcclxuICAgICAgICAgICAgLy8gU2V0IHRoZSBpZnJhbWUncyBjb250ZW50cy5cclxuICAgICAgICAgICAgbGV0IHNjcmlwdCA9ICcnO1xyXG4gICAgICAgICAgICAvLyBpZiB3ZSBzZXQgYSBqYXZhc2NyaXB0IHVybCwgaXQncyBJRSBhbmQgd2UgbmVlZCB0byBzZXQgdGhlIGRvY3VtZW50IGRvbWFpbi4gVGhlIGphdmFzY3JpcHQgdXJsIGlzIHN1ZmZpY2llbnRcclxuICAgICAgICAgICAgLy8gZm9yIGllOSwgYnV0IGllOCBuZWVkcyB0byBkbyBpdCBhZ2FpbiBpbiB0aGUgZG9jdW1lbnQgaXRzZWxmLlxyXG4gICAgICAgICAgICBpZiAodGhpcy5teUlGcmFtZS5zcmMgJiZcclxuICAgICAgICAgICAgICAgIHRoaXMubXlJRnJhbWUuc3JjLnN1YnN0cigwLCAnamF2YXNjcmlwdDonLmxlbmd0aCkgPT09ICdqYXZhc2NyaXB0OicpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnREb21haW4gPSBkb2N1bWVudC5kb21haW47XHJcbiAgICAgICAgICAgICAgICBzY3JpcHQgPSAnPHNjcmlwdD5kb2N1bWVudC5kb21haW49XCInICsgY3VycmVudERvbWFpbiArICdcIjs8L3NjcmlwdD4nO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IGlmcmFtZUNvbnRlbnRzID0gJzxodG1sPjxib2R5PicgKyBzY3JpcHQgKyAnPC9ib2R5PjwvaHRtbD4nO1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5teUlGcmFtZS5kb2Mub3BlbigpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5teUlGcmFtZS5kb2Mud3JpdGUoaWZyYW1lQ29udGVudHMpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5teUlGcmFtZS5kb2MuY2xvc2UoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgbG9nKCdmcmFtZSB3cml0aW5nIGV4Y2VwdGlvbicpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGUuc3RhY2spIHtcclxuICAgICAgICAgICAgICAgICAgICBsb2coZS5zdGFjayk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBsb2coZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuY29tbWFuZENCID0gY29tbWFuZENCO1xyXG4gICAgICAgICAgICB0aGlzLm9uTWVzc2FnZUNCID0gb25NZXNzYWdlQ0I7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBFYWNoIGJyb3dzZXIgaGFzIGl0cyBvd24gZnVubnkgd2F5IHRvIGhhbmRsZSBpZnJhbWVzLiBIZXJlIHdlIG11c2ggdGhlbSBhbGwgdG9nZXRoZXIgaW50byBvbmUgb2JqZWN0IHRoYXQgSSBjYW5cclxuICAgICAqIGFjdHVhbGx5IHVzZS5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGNyZWF0ZUlGcmFtZV8oKSB7XHJcbiAgICAgICAgY29uc3QgaWZyYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaWZyYW1lJyk7XHJcbiAgICAgICAgaWZyYW1lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XHJcbiAgICAgICAgLy8gVGhpcyBpcyBuZWNlc3NhcnkgaW4gb3JkZXIgdG8gaW5pdGlhbGl6ZSB0aGUgZG9jdW1lbnQgaW5zaWRlIHRoZSBpZnJhbWVcclxuICAgICAgICBpZiAoZG9jdW1lbnQuYm9keSkge1xyXG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGlmcmFtZSk7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAvLyBJZiBkb2N1bWVudC5kb21haW4gaGFzIGJlZW4gbW9kaWZpZWQgaW4gSUUsIHRoaXMgd2lsbCB0aHJvdyBhbiBlcnJvciwgYW5kIHdlIG5lZWQgdG8gc2V0IHRoZVxyXG4gICAgICAgICAgICAgICAgLy8gZG9tYWluIG9mIHRoZSBpZnJhbWUncyBkb2N1bWVudCBtYW51YWxseS4gV2UgY2FuIGRvIHRoaXMgdmlhIGEgamF2YXNjcmlwdDogdXJsIGFzIHRoZSBzcmMgYXR0cmlidXRlXHJcbiAgICAgICAgICAgICAgICAvLyBBbHNvIG5vdGUgdGhhdCB3ZSBtdXN0IGRvIHRoaXMgKmFmdGVyKiB0aGUgaWZyYW1lIGhhcyBiZWVuIGFwcGVuZGVkIHRvIHRoZSBwYWdlLiBPdGhlcndpc2UgaXQgZG9lc24ndCB3b3JrLlxyXG4gICAgICAgICAgICAgICAgY29uc3QgYSA9IGlmcmFtZS5jb250ZW50V2luZG93LmRvY3VtZW50O1xyXG4gICAgICAgICAgICAgICAgaWYgKCFhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQXBvbG9naWVzIGZvciB0aGUgbG9nLXNwYW0sIEkgbmVlZCB0byBkbyBzb21ldGhpbmcgdG8ga2VlcCBjbG9zdXJlIGZyb20gb3B0aW1pemluZyBvdXQgdGhlIGFzc2lnbm1lbnQgYWJvdmUuXHJcbiAgICAgICAgICAgICAgICAgICAgbG9nKCdObyBJRSBkb21haW4gc2V0dGluZyByZXF1aXJlZCcpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBkb21haW4gPSBkb2N1bWVudC5kb21haW47XHJcbiAgICAgICAgICAgICAgICBpZnJhbWUuc3JjID1cclxuICAgICAgICAgICAgICAgICAgICBcImphdmFzY3JpcHQ6dm9pZCgoZnVuY3Rpb24oKXtkb2N1bWVudC5vcGVuKCk7ZG9jdW1lbnQuZG9tYWluPSdcIiArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvbWFpbiArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiJztkb2N1bWVudC5jbG9zZSgpO30pKCkpXCI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIExvbmdQb2xsQ29ubmVjdGlvbiBhdHRlbXB0cyB0byBkZWxheSBpbml0aWFsaXphdGlvbiB1bnRpbCB0aGUgZG9jdW1lbnQgaXMgcmVhZHksIHNvIGhvcGVmdWxseSB0aGlzXHJcbiAgICAgICAgICAgIC8vIG5ldmVyIGdldHMgaGl0LlxyXG4gICAgICAgICAgICB0aHJvdyAnRG9jdW1lbnQgYm9keSBoYXMgbm90IGluaXRpYWxpemVkLiBXYWl0IHRvIGluaXRpYWxpemUgRmlyZWJhc2UgdW50aWwgYWZ0ZXIgdGhlIGRvY3VtZW50IGlzIHJlYWR5Lic7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEdldCB0aGUgZG9jdW1lbnQgb2YgdGhlIGlmcmFtZSBpbiBhIGJyb3dzZXItc3BlY2lmaWMgd2F5LlxyXG4gICAgICAgIGlmIChpZnJhbWUuY29udGVudERvY3VtZW50KSB7XHJcbiAgICAgICAgICAgIGlmcmFtZS5kb2MgPSBpZnJhbWUuY29udGVudERvY3VtZW50OyAvLyBGaXJlZm94LCBPcGVyYSwgU2FmYXJpXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGlmcmFtZS5jb250ZW50V2luZG93KSB7XHJcbiAgICAgICAgICAgIGlmcmFtZS5kb2MgPSBpZnJhbWUuY29udGVudFdpbmRvdy5kb2N1bWVudDsgLy8gSW50ZXJuZXQgRXhwbG9yZXJcclxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoaWZyYW1lLmRvY3VtZW50KSB7XHJcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XHJcbiAgICAgICAgICAgIGlmcmFtZS5kb2MgPSBpZnJhbWUuZG9jdW1lbnQ7IC8vb3RoZXJzP1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gaWZyYW1lO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDYW5jZWwgYWxsIG91dHN0YW5kaW5nIHF1ZXJpZXMgYW5kIHJlbW92ZSB0aGUgZnJhbWUuXHJcbiAgICAgKi9cclxuICAgIGNsb3NlKCkge1xyXG4gICAgICAgIC8vTWFyayB0aGlzIGlmcmFtZSBhcyBkZWFkLCBzbyBubyBuZXcgcmVxdWVzdHMgYXJlIHNlbnQuXHJcbiAgICAgICAgdGhpcy5hbGl2ZSA9IGZhbHNlO1xyXG4gICAgICAgIGlmICh0aGlzLm15SUZyYW1lKSB7XHJcbiAgICAgICAgICAgIC8vV2UgaGF2ZSB0byBhY3R1YWxseSByZW1vdmUgYWxsIG9mIHRoZSBodG1sIGluc2lkZSB0aGlzIGlmcmFtZSBiZWZvcmUgcmVtb3ZpbmcgaXQgZnJvbSB0aGVcclxuICAgICAgICAgICAgLy93aW5kb3csIG9yIElFIHdpbGwgY29udGludWUgbG9hZGluZyBhbmQgZXhlY3V0aW5nIHRoZSBzY3JpcHQgdGFncyB3ZSd2ZSBhbHJlYWR5IGFkZGVkLCB3aGljaFxyXG4gICAgICAgICAgICAvL2NhbiBsZWFkIHRvIHNvbWUgZXJyb3JzIGJlaW5nIHRocm93bi4gU2V0dGluZyBpbm5lckhUTUwgc2VlbXMgdG8gYmUgdGhlIGVhc2llc3Qgd2F5IHRvIGRvIHRoaXMuXHJcbiAgICAgICAgICAgIHRoaXMubXlJRnJhbWUuZG9jLmJvZHkuaW5uZXJIVE1MID0gJyc7XHJcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubXlJRnJhbWUgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKHRoaXMubXlJRnJhbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubXlJRnJhbWUgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LCBNYXRoLmZsb29yKDApKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gUHJvdGVjdCBmcm9tIGJlaW5nIGNhbGxlZCByZWN1cnNpdmVseS5cclxuICAgICAgICBjb25zdCBvbkRpc2Nvbm5lY3QgPSB0aGlzLm9uRGlzY29ubmVjdDtcclxuICAgICAgICBpZiAob25EaXNjb25uZWN0KSB7XHJcbiAgICAgICAgICAgIHRoaXMub25EaXNjb25uZWN0ID0gbnVsbDtcclxuICAgICAgICAgICAgb25EaXNjb25uZWN0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBY3R1YWxseSBzdGFydCB0aGUgbG9uZy1wb2xsaW5nIHNlc3Npb24gYnkgYWRkaW5nIHRoZSBmaXJzdCBzY3JpcHQgdGFnKHMpIHRvIHRoZSBpZnJhbWUuXHJcbiAgICAgKiBAcGFyYW0gaWQgLSBUaGUgSUQgb2YgdGhpcyBjb25uZWN0aW9uXHJcbiAgICAgKiBAcGFyYW0gcHcgLSBUaGUgcGFzc3dvcmQgZm9yIHRoaXMgY29ubmVjdGlvblxyXG4gICAgICovXHJcbiAgICBzdGFydExvbmdQb2xsKGlkLCBwdykge1xyXG4gICAgICAgIHRoaXMubXlJRCA9IGlkO1xyXG4gICAgICAgIHRoaXMubXlQVyA9IHB3O1xyXG4gICAgICAgIHRoaXMuYWxpdmUgPSB0cnVlO1xyXG4gICAgICAgIC8vc2VuZCB0aGUgaW5pdGlhbCByZXF1ZXN0LiBJZiB0aGVyZSBhcmUgcmVxdWVzdHMgcXVldWVkLCBtYWtlIHN1cmUgdGhhdCB3ZSB0cmFuc21pdCBhcyBtYW55IGFzIHdlIGFyZSBjdXJyZW50bHkgYWJsZSB0by5cclxuICAgICAgICB3aGlsZSAodGhpcy5uZXdSZXF1ZXN0XygpKSB7IH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBpcyBjYWxsZWQgYW55IHRpbWUgc29tZW9uZSBtaWdodCB3YW50IGEgc2NyaXB0IHRhZyB0byBiZSBhZGRlZC4gSXQgYWRkcyBhIHNjcmlwdCB0YWcgd2hlbiB0aGVyZSBhcmVuJ3RcclxuICAgICAqIHRvbyBtYW55IG91dHN0YW5kaW5nIHJlcXVlc3RzIGFuZCB3ZSBhcmUgc3RpbGwgYWxpdmUuXHJcbiAgICAgKlxyXG4gICAgICogSWYgdGhlcmUgYXJlIG91dHN0YW5kaW5nIHBhY2tldCBzZWdtZW50cyB0byBzZW5kLCBpdCBzZW5kcyBvbmUuIElmIHRoZXJlIGFyZW4ndCwgaXQgc2VuZHMgYSBsb25nLXBvbGwgYW55d2F5cyBpZlxyXG4gICAgICogbmVlZGVkLlxyXG4gICAgICovXHJcbiAgICBuZXdSZXF1ZXN0XygpIHtcclxuICAgICAgICAvLyBXZSBrZWVwIG9uZSBvdXRzdGFuZGluZyByZXF1ZXN0IG9wZW4gYWxsIHRoZSB0aW1lIHRvIHJlY2VpdmUgZGF0YSwgYnV0IGlmIHdlIG5lZWQgdG8gc2VuZCBkYXRhXHJcbiAgICAgICAgLy8gKHBlbmRpbmdTZWdzLmxlbmd0aCA+IDApIHRoZW4gd2UgY3JlYXRlIGEgbmV3IHJlcXVlc3QgdG8gc2VuZCB0aGUgZGF0YS4gIFRoZSBzZXJ2ZXIgd2lsbCBhdXRvbWF0aWNhbGx5XHJcbiAgICAgICAgLy8gY2xvc2UgdGhlIG9sZCByZXF1ZXN0LlxyXG4gICAgICAgIGlmICh0aGlzLmFsaXZlICYmXHJcbiAgICAgICAgICAgIHRoaXMuc2VuZE5ld1BvbGxzICYmXHJcbiAgICAgICAgICAgIHRoaXMub3V0c3RhbmRpbmdSZXF1ZXN0cy5zaXplIDwgKHRoaXMucGVuZGluZ1NlZ3MubGVuZ3RoID4gMCA/IDIgOiAxKSkge1xyXG4gICAgICAgICAgICAvL2NvbnN0cnVjdCBvdXIgdXJsXHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFNlcmlhbCsrO1xyXG4gICAgICAgICAgICBjb25zdCB1cmxQYXJhbXMgPSB7fTtcclxuICAgICAgICAgICAgdXJsUGFyYW1zW0ZJUkVCQVNFX0xPTkdQT0xMX0lEX1BBUkFNXSA9IHRoaXMubXlJRDtcclxuICAgICAgICAgICAgdXJsUGFyYW1zW0ZJUkVCQVNFX0xPTkdQT0xMX1BXX1BBUkFNXSA9IHRoaXMubXlQVztcclxuICAgICAgICAgICAgdXJsUGFyYW1zW0ZJUkVCQVNFX0xPTkdQT0xMX1NFUklBTF9QQVJBTV0gPSB0aGlzLmN1cnJlbnRTZXJpYWw7XHJcbiAgICAgICAgICAgIGxldCB0aGVVUkwgPSB0aGlzLnVybEZuKHVybFBhcmFtcyk7XHJcbiAgICAgICAgICAgIC8vTm93IGFkZCBhcyBtdWNoIGRhdGEgYXMgd2UgY2FuLlxyXG4gICAgICAgICAgICBsZXQgY3VyRGF0YVN0cmluZyA9ICcnO1xyXG4gICAgICAgICAgICBsZXQgaSA9IDA7XHJcbiAgICAgICAgICAgIHdoaWxlICh0aGlzLnBlbmRpbmdTZWdzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgIC8vZmlyc3QsIGxldHMgc2VlIGlmIHRoZSBuZXh0IHNlZ21lbnQgd2lsbCBmaXQuXHJcbiAgICAgICAgICAgICAgICBjb25zdCBuZXh0U2VnID0gdGhpcy5wZW5kaW5nU2Vnc1swXTtcclxuICAgICAgICAgICAgICAgIGlmIChuZXh0U2VnLmQubGVuZ3RoICtcclxuICAgICAgICAgICAgICAgICAgICBTRUdfSEVBREVSX1NJWkUgK1xyXG4gICAgICAgICAgICAgICAgICAgIGN1ckRhdGFTdHJpbmcubGVuZ3RoIDw9XHJcbiAgICAgICAgICAgICAgICAgICAgTUFYX1VSTF9EQVRBX1NJWkUpIHtcclxuICAgICAgICAgICAgICAgICAgICAvL2dyZWF0LCB0aGUgc2VnbWVudCB3aWxsIGZpdC4gTGV0cyBhcHBlbmQgaXQuXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGhlU2VnID0gdGhpcy5wZW5kaW5nU2Vncy5zaGlmdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGN1ckRhdGFTdHJpbmcgPVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJEYXRhU3RyaW5nICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICcmJyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBGSVJFQkFTRV9MT05HUE9MTF9TRUdNRU5UX05VTV9QQVJBTSArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICc9JyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGVTZWcuc2VnICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICcmJyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBGSVJFQkFTRV9MT05HUE9MTF9TRUdNRU5UU19JTl9QQUNLRVQgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaSArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnPScgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlU2VnLnRzICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICcmJyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBGSVJFQkFTRV9MT05HUE9MTF9EQVRBX1BBUkFNICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJz0nICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZVNlZy5kO1xyXG4gICAgICAgICAgICAgICAgICAgIGkrKztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoZVVSTCA9IHRoZVVSTCArIGN1ckRhdGFTdHJpbmc7XHJcbiAgICAgICAgICAgIHRoaXMuYWRkTG9uZ1BvbGxUYWdfKHRoZVVSTCwgdGhpcy5jdXJyZW50U2VyaWFsKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBRdWV1ZSBhIHBhY2tldCBmb3IgdHJhbnNtaXNzaW9uIHRvIHRoZSBzZXJ2ZXIuXHJcbiAgICAgKiBAcGFyYW0gc2VnbnVtIC0gQSBzZXF1ZW50aWFsIGlkIGZvciB0aGlzIHBhY2tldCBzZWdtZW50IHVzZWQgZm9yIHJlYXNzZW1ibHlcclxuICAgICAqIEBwYXJhbSB0b3RhbHNlZ3MgLSBUaGUgdG90YWwgbnVtYmVyIG9mIHNlZ21lbnRzIGluIHRoaXMgcGFja2V0XHJcbiAgICAgKiBAcGFyYW0gZGF0YSAtIFRoZSBkYXRhIGZvciB0aGlzIHNlZ21lbnQuXHJcbiAgICAgKi9cclxuICAgIGVucXVldWVTZWdtZW50KHNlZ251bSwgdG90YWxzZWdzLCBkYXRhKSB7XHJcbiAgICAgICAgLy9hZGQgdGhpcyB0byB0aGUgcXVldWUgb2Ygc2VnbWVudHMgdG8gc2VuZC5cclxuICAgICAgICB0aGlzLnBlbmRpbmdTZWdzLnB1c2goeyBzZWc6IHNlZ251bSwgdHM6IHRvdGFsc2VncywgZDogZGF0YSB9KTtcclxuICAgICAgICAvL3NlbmQgdGhlIGRhdGEgaW1tZWRpYXRlbHkgaWYgdGhlcmUgaXNuJ3QgYWxyZWFkeSBkYXRhIGJlaW5nIHRyYW5zbWl0dGVkLCB1bmxlc3NcclxuICAgICAgICAvL3N0YXJ0TG9uZ1BvbGwgaGFzbid0IGJlZW4gY2FsbGVkIHlldC5cclxuICAgICAgICBpZiAodGhpcy5hbGl2ZSkge1xyXG4gICAgICAgICAgICB0aGlzLm5ld1JlcXVlc3RfKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGQgYSBzY3JpcHQgdGFnIGZvciBhIHJlZ3VsYXIgbG9uZy1wb2xsIHJlcXVlc3QuXHJcbiAgICAgKiBAcGFyYW0gdXJsIC0gVGhlIFVSTCBvZiB0aGUgc2NyaXB0IHRhZy5cclxuICAgICAqIEBwYXJhbSBzZXJpYWwgLSBUaGUgc2VyaWFsIG51bWJlciBvZiB0aGUgcmVxdWVzdC5cclxuICAgICAqL1xyXG4gICAgYWRkTG9uZ1BvbGxUYWdfKHVybCwgc2VyaWFsKSB7XHJcbiAgICAgICAgLy9yZW1lbWJlciB0aGF0IHdlIHNlbnQgdGhpcyByZXF1ZXN0LlxyXG4gICAgICAgIHRoaXMub3V0c3RhbmRpbmdSZXF1ZXN0cy5hZGQoc2VyaWFsKTtcclxuICAgICAgICBjb25zdCBkb05ld1JlcXVlc3QgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMub3V0c3RhbmRpbmdSZXF1ZXN0cy5kZWxldGUoc2VyaWFsKTtcclxuICAgICAgICAgICAgdGhpcy5uZXdSZXF1ZXN0XygpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLy8gSWYgdGhpcyByZXF1ZXN0IGRvZXNuJ3QgcmV0dXJuIG9uIGl0cyBvd24gYWNjb3JkIChieSB0aGUgc2VydmVyIHNlbmRpbmcgdXMgc29tZSBkYXRhKSwgd2UnbGxcclxuICAgICAgICAvLyBjcmVhdGUgYSBuZXcgb25lIGFmdGVyIHRoZSBLRUVQQUxJVkUgaW50ZXJ2YWwgdG8gbWFrZSBzdXJlIHdlIGFsd2F5cyBrZWVwIGEgZnJlc2ggcmVxdWVzdCBvcGVuLlxyXG4gICAgICAgIGNvbnN0IGtlZXBhbGl2ZVRpbWVvdXQgPSBzZXRUaW1lb3V0KGRvTmV3UmVxdWVzdCwgTWF0aC5mbG9vcihLRUVQQUxJVkVfUkVRVUVTVF9JTlRFUlZBTCkpO1xyXG4gICAgICAgIGNvbnN0IHJlYWR5U3RhdGVDQiA9ICgpID0+IHtcclxuICAgICAgICAgICAgLy8gUmVxdWVzdCBjb21wbGV0ZWQuICBDYW5jZWwgdGhlIGtlZXBhbGl2ZS5cclxuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KGtlZXBhbGl2ZVRpbWVvdXQpO1xyXG4gICAgICAgICAgICAvLyBUcmlnZ2VyIGEgbmV3IHJlcXVlc3Qgc28gd2UgY2FuIGNvbnRpbnVlIHJlY2VpdmluZyBkYXRhLlxyXG4gICAgICAgICAgICBkb05ld1JlcXVlc3QoKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuYWRkVGFnKHVybCwgcmVhZHlTdGF0ZUNCKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQWRkIGFuIGFyYml0cmFyeSBzY3JpcHQgdGFnIHRvIHRoZSBpZnJhbWUuXHJcbiAgICAgKiBAcGFyYW0gdXJsIC0gVGhlIFVSTCBmb3IgdGhlIHNjcmlwdCB0YWcgc291cmNlLlxyXG4gICAgICogQHBhcmFtIGxvYWRDQiAtIEEgY2FsbGJhY2sgdG8gYmUgdHJpZ2dlcmVkIG9uY2UgdGhlIHNjcmlwdCBoYXMgbG9hZGVkLlxyXG4gICAgICovXHJcbiAgICBhZGRUYWcodXJsLCBsb2FkQ0IpIHtcclxuICAgICAgICBpZiAoaXNOb2RlU2RrKCkpIHtcclxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcclxuICAgICAgICAgICAgdGhpcy5kb05vZGVMb25nUG9sbCh1cmwsIGxvYWRDQik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgd2UncmUgYWxyZWFkeSBjbG9zZWQsIGRvbid0IGFkZCB0aGlzIHBvbGxcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuc2VuZE5ld1BvbGxzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV3U2NyaXB0ID0gdGhpcy5teUlGcmFtZS5kb2MuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3U2NyaXB0LnR5cGUgPSAndGV4dC9qYXZhc2NyaXB0JztcclxuICAgICAgICAgICAgICAgICAgICBuZXdTY3JpcHQuYXN5bmMgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIG5ld1NjcmlwdC5zcmMgPSB1cmw7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcclxuICAgICAgICAgICAgICAgICAgICBuZXdTY3JpcHQub25sb2FkID0gbmV3U2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByc3RhdGUgPSBuZXdTY3JpcHQucmVhZHlTdGF0ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcnN0YXRlIHx8IHJzdGF0ZSA9PT0gJ2xvYWRlZCcgfHwgcnN0YXRlID09PSAnY29tcGxldGUnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdTY3JpcHQub25sb2FkID0gbmV3U2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5ld1NjcmlwdC5wYXJlbnROb2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld1NjcmlwdC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKG5ld1NjcmlwdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvYWRDQigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIG5ld1NjcmlwdC5vbmVycm9yID0gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2coJ0xvbmctcG9sbCBzY3JpcHQgZmFpbGVkIHRvIGxvYWQ6ICcgKyB1cmwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbmROZXdQb2xscyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNsb3NlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm15SUZyYW1lLmRvYy5ib2R5LmFwcGVuZENoaWxkKG5ld1NjcmlwdCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IHdlIHNob3VsZCBtYWtlIHRoaXMgZXJyb3IgdmlzaWJsZSBzb21laG93XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sIE1hdGguZmxvb3IoMSkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5jb25zdCBXRUJTT0NLRVRfTUFYX0ZSQU1FX1NJWkUgPSAxNjM4NDtcclxuY29uc3QgV0VCU09DS0VUX0tFRVBBTElWRV9JTlRFUlZBTCA9IDQ1MDAwO1xyXG5sZXQgV2ViU29ja2V0SW1wbCA9IG51bGw7XHJcbmlmICh0eXBlb2YgTW96V2ViU29ja2V0ICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgV2ViU29ja2V0SW1wbCA9IE1veldlYlNvY2tldDtcclxufVxyXG5lbHNlIGlmICh0eXBlb2YgV2ViU29ja2V0ICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgV2ViU29ja2V0SW1wbCA9IFdlYlNvY2tldDtcclxufVxyXG4vKipcclxuICogQ3JlYXRlIGEgbmV3IHdlYnNvY2tldCBjb25uZWN0aW9uIHdpdGggdGhlIGdpdmVuIGNhbGxiYWNrcy5cclxuICovXHJcbmNsYXNzIFdlYlNvY2tldENvbm5lY3Rpb24ge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gY29ubklkIGlkZW50aWZpZXIgZm9yIHRoaXMgdHJhbnNwb3J0XHJcbiAgICAgKiBAcGFyYW0gcmVwb0luZm8gVGhlIGluZm8gZm9yIHRoZSB3ZWJzb2NrZXQgZW5kcG9pbnQuXHJcbiAgICAgKiBAcGFyYW0gYXBwbGljYXRpb25JZCBUaGUgRmlyZWJhc2UgQXBwIElEIGZvciB0aGlzIHByb2plY3QuXHJcbiAgICAgKiBAcGFyYW0gYXBwQ2hlY2tUb2tlbiBUaGUgQXBwIENoZWNrIFRva2VuIGZvciB0aGlzIGNsaWVudC5cclxuICAgICAqIEBwYXJhbSBhdXRoVG9rZW4gVGhlIEF1dGggVG9rZW4gZm9yIHRoaXMgY2xpZW50LlxyXG4gICAgICogQHBhcmFtIHRyYW5zcG9ydFNlc3Npb25JZCBPcHRpb25hbCB0cmFuc3BvcnRTZXNzaW9uSWQgaWYgdGhpcyBpcyBjb25uZWN0aW5nXHJcbiAgICAgKiB0byBhbiBleGlzdGluZyB0cmFuc3BvcnQgc2Vzc2lvblxyXG4gICAgICogQHBhcmFtIGxhc3RTZXNzaW9uSWQgT3B0aW9uYWwgbGFzdFNlc3Npb25JZCBpZiB0aGVyZSB3YXMgYSBwcmV2aW91c1xyXG4gICAgICogY29ubmVjdGlvblxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3Rvcihjb25uSWQsIHJlcG9JbmZvLCBhcHBsaWNhdGlvbklkLCBhcHBDaGVja1Rva2VuLCBhdXRoVG9rZW4sIHRyYW5zcG9ydFNlc3Npb25JZCwgbGFzdFNlc3Npb25JZCkge1xyXG4gICAgICAgIHRoaXMuY29ubklkID0gY29ubklkO1xyXG4gICAgICAgIHRoaXMuYXBwbGljYXRpb25JZCA9IGFwcGxpY2F0aW9uSWQ7XHJcbiAgICAgICAgdGhpcy5hcHBDaGVja1Rva2VuID0gYXBwQ2hlY2tUb2tlbjtcclxuICAgICAgICB0aGlzLmF1dGhUb2tlbiA9IGF1dGhUb2tlbjtcclxuICAgICAgICB0aGlzLmtlZXBhbGl2ZVRpbWVyID0gbnVsbDtcclxuICAgICAgICB0aGlzLmZyYW1lcyA9IG51bGw7XHJcbiAgICAgICAgdGhpcy50b3RhbEZyYW1lcyA9IDA7XHJcbiAgICAgICAgdGhpcy5ieXRlc1NlbnQgPSAwO1xyXG4gICAgICAgIHRoaXMuYnl0ZXNSZWNlaXZlZCA9IDA7XHJcbiAgICAgICAgdGhpcy5sb2dfID0gbG9nV3JhcHBlcih0aGlzLmNvbm5JZCk7XHJcbiAgICAgICAgdGhpcy5zdGF0c18gPSBzdGF0c01hbmFnZXJHZXRDb2xsZWN0aW9uKHJlcG9JbmZvKTtcclxuICAgICAgICB0aGlzLmNvbm5VUkwgPSBXZWJTb2NrZXRDb25uZWN0aW9uLmNvbm5lY3Rpb25VUkxfKHJlcG9JbmZvLCB0cmFuc3BvcnRTZXNzaW9uSWQsIGxhc3RTZXNzaW9uSWQsIGFwcENoZWNrVG9rZW4pO1xyXG4gICAgICAgIHRoaXMubm9kZUFkbWluID0gcmVwb0luZm8ubm9kZUFkbWluO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gcmVwb0luZm8gLSBUaGUgaW5mbyBmb3IgdGhlIHdlYnNvY2tldCBlbmRwb2ludC5cclxuICAgICAqIEBwYXJhbSB0cmFuc3BvcnRTZXNzaW9uSWQgLSBPcHRpb25hbCB0cmFuc3BvcnRTZXNzaW9uSWQgaWYgdGhpcyBpcyBjb25uZWN0aW5nIHRvIGFuIGV4aXN0aW5nIHRyYW5zcG9ydFxyXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlc3Npb25cclxuICAgICAqIEBwYXJhbSBsYXN0U2Vzc2lvbklkIC0gT3B0aW9uYWwgbGFzdFNlc3Npb25JZCBpZiB0aGVyZSB3YXMgYSBwcmV2aW91cyBjb25uZWN0aW9uXHJcbiAgICAgKiBAcmV0dXJucyBjb25uZWN0aW9uIHVybFxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgY29ubmVjdGlvblVSTF8ocmVwb0luZm8sIHRyYW5zcG9ydFNlc3Npb25JZCwgbGFzdFNlc3Npb25JZCwgYXBwQ2hlY2tUb2tlbikge1xyXG4gICAgICAgIGNvbnN0IHVybFBhcmFtcyA9IHt9O1xyXG4gICAgICAgIHVybFBhcmFtc1tWRVJTSU9OX1BBUkFNXSA9IFBST1RPQ09MX1ZFUlNJT047XHJcbiAgICAgICAgaWYgKCFpc05vZGVTZGsoKSAmJlxyXG4gICAgICAgICAgICB0eXBlb2YgbG9jYXRpb24gIT09ICd1bmRlZmluZWQnICYmXHJcbiAgICAgICAgICAgIGxvY2F0aW9uLmhvc3RuYW1lICYmXHJcbiAgICAgICAgICAgIEZPUkdFX0RPTUFJTl9SRS50ZXN0KGxvY2F0aW9uLmhvc3RuYW1lKSkge1xyXG4gICAgICAgICAgICB1cmxQYXJhbXNbUkVGRVJFUl9QQVJBTV0gPSBGT1JHRV9SRUY7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0cmFuc3BvcnRTZXNzaW9uSWQpIHtcclxuICAgICAgICAgICAgdXJsUGFyYW1zW1RSQU5TUE9SVF9TRVNTSU9OX1BBUkFNXSA9IHRyYW5zcG9ydFNlc3Npb25JZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGxhc3RTZXNzaW9uSWQpIHtcclxuICAgICAgICAgICAgdXJsUGFyYW1zW0xBU1RfU0VTU0lPTl9QQVJBTV0gPSBsYXN0U2Vzc2lvbklkO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoYXBwQ2hlY2tUb2tlbikge1xyXG4gICAgICAgICAgICB1cmxQYXJhbXNbQVBQX0NIRUNLX1RPS0VOX1BBUkFNXSA9IGFwcENoZWNrVG9rZW47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXBvSW5mb0Nvbm5lY3Rpb25VUkwocmVwb0luZm8sIFdFQlNPQ0tFVCwgdXJsUGFyYW1zKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIG9uTWVzc2FnZSAtIENhbGxiYWNrIHdoZW4gbWVzc2FnZXMgYXJyaXZlXHJcbiAgICAgKiBAcGFyYW0gb25EaXNjb25uZWN0IC0gQ2FsbGJhY2sgd2l0aCBjb25uZWN0aW9uIGxvc3QuXHJcbiAgICAgKi9cclxuICAgIG9wZW4ob25NZXNzYWdlLCBvbkRpc2Nvbm5lY3QpIHtcclxuICAgICAgICB0aGlzLm9uRGlzY29ubmVjdCA9IG9uRGlzY29ubmVjdDtcclxuICAgICAgICB0aGlzLm9uTWVzc2FnZSA9IG9uTWVzc2FnZTtcclxuICAgICAgICB0aGlzLmxvZ18oJ1dlYnNvY2tldCBjb25uZWN0aW5nIHRvICcgKyB0aGlzLmNvbm5VUkwpO1xyXG4gICAgICAgIHRoaXMuZXZlckNvbm5lY3RlZF8gPSBmYWxzZTtcclxuICAgICAgICAvLyBBc3N1bWUgZmFpbHVyZSB1bnRpbCBwcm92ZW4gb3RoZXJ3aXNlLlxyXG4gICAgICAgIFBlcnNpc3RlbnRTdG9yYWdlLnNldCgncHJldmlvdXNfd2Vic29ja2V0X2ZhaWx1cmUnLCB0cnVlKTtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBpZiAoaXNOb2RlU2RrKCkpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGRldmljZSA9IHRoaXMubm9kZUFkbWluID8gJ0FkbWluTm9kZScgOiAnTm9kZSc7XHJcbiAgICAgICAgICAgICAgICAvLyBVQSBGb3JtYXQ6IEZpcmViYXNlLzx3aXJlX3Byb3RvY29sPi88c2RrX3ZlcnNpb24+LzxwbGF0Zm9ybT4vPGRldmljZT5cclxuICAgICAgICAgICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAnVXNlci1BZ2VudCc6IGBGaXJlYmFzZS8ke1BST1RPQ09MX1ZFUlNJT059LyR7U0RLX1ZFUlNJT059LyR7cHJvY2Vzcy5wbGF0Zm9ybX0vJHtkZXZpY2V9YCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgJ1gtRmlyZWJhc2UtR01QSUQnOiB0aGlzLmFwcGxpY2F0aW9uSWQgfHwgJydcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgLy8gSWYgdXNpbmcgTm9kZSB3aXRoIGFkbWluIGNyZWRzLCBBcHBDaGVjay1yZWxhdGVkIGNoZWNrcyBhcmUgdW5uZWNlc3NhcnkuXHJcbiAgICAgICAgICAgICAgICAvLyBOb3RlIHRoYXQgd2Ugc2VuZCB0aGUgY3JlZGVudGlhbHMgaGVyZSBldmVuIGlmIHRoZXkgYXJlbid0IGFkbWluIGNyZWRlbnRpYWxzLCB3aGljaCBpc1xyXG4gICAgICAgICAgICAgICAgLy8gbm90IGEgcHJvYmxlbS5cclxuICAgICAgICAgICAgICAgIC8vIE5vdGUgdGhhdCB0aGlzIGhlYWRlciBpcyBqdXN0IHVzZWQgdG8gYnlwYXNzIGFwcGNoZWNrLCBhbmQgdGhlIHRva2VuIHNob3VsZCBzdGlsbCBiZSBzZW50XHJcbiAgICAgICAgICAgICAgICAvLyB0aHJvdWdoIHRoZSB3ZWJzb2NrZXQgY29ubmVjdGlvbiBvbmNlIGl0IGlzIGVzdGFibGlzaGVkLlxyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYXV0aFRva2VuKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5oZWFkZXJzWydBdXRob3JpemF0aW9uJ10gPSBgQmVhcmVyICR7dGhpcy5hdXRoVG9rZW59YDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmFwcENoZWNrVG9rZW4pIHtcclxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmhlYWRlcnNbJ1gtRmlyZWJhc2UtQXBwQ2hlY2snXSA9IHRoaXMuYXBwQ2hlY2tUb2tlbjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIFBsdW1iIGFwcHJvcHJpYXRlIGh0dHBfcHJveHkgZW52aXJvbm1lbnQgdmFyaWFibGUgaW50byBmYXllLXdlYnNvY2tldCBpZiBpdCBleGlzdHMuXHJcbiAgICAgICAgICAgICAgICBjb25zdCBlbnYgPSBwcm9jZXNzWydlbnYnXTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHByb3h5ID0gdGhpcy5jb25uVVJMLmluZGV4T2YoJ3dzczovLycpID09PSAwXHJcbiAgICAgICAgICAgICAgICAgICAgPyBlbnZbJ0hUVFBTX1BST1hZJ10gfHwgZW52WydodHRwc19wcm94eSddXHJcbiAgICAgICAgICAgICAgICAgICAgOiBlbnZbJ0hUVFBfUFJPWFknXSB8fCBlbnZbJ2h0dHBfcHJveHknXTtcclxuICAgICAgICAgICAgICAgIGlmIChwcm94eSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnNbJ3Byb3h5J10gPSB7IG9yaWdpbjogcHJveHkgfTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMubXlTb2NrID0gbmV3IFdlYlNvY2tldEltcGwodGhpcy5jb25uVVJMLCBbXSwgb3B0aW9ucyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBvcHRpb25zID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgJ1gtRmlyZWJhc2UtR01QSUQnOiB0aGlzLmFwcGxpY2F0aW9uSWQgfHwgJycsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICdYLUZpcmViYXNlLUFwcENoZWNrJzogdGhpcy5hcHBDaGVja1Rva2VuIHx8ICcnXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIHRoaXMubXlTb2NrID0gbmV3IFdlYlNvY2tldEltcGwodGhpcy5jb25uVVJMLCBbXSwgb3B0aW9ucyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgdGhpcy5sb2dfKCdFcnJvciBpbnN0YW50aWF0aW5nIFdlYlNvY2tldC4nKTtcclxuICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBlLm1lc3NhZ2UgfHwgZS5kYXRhO1xyXG4gICAgICAgICAgICBpZiAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubG9nXyhlcnJvcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5vbkNsb3NlZF8oKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLm15U29jay5vbm9wZW4gPSAoKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMubG9nXygnV2Vic29ja2V0IGNvbm5lY3RlZC4nKTtcclxuICAgICAgICAgICAgdGhpcy5ldmVyQ29ubmVjdGVkXyA9IHRydWU7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLm15U29jay5vbmNsb3NlID0gKCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLmxvZ18oJ1dlYnNvY2tldCBjb25uZWN0aW9uIHdhcyBkaXNjb25uZWN0ZWQuJyk7XHJcbiAgICAgICAgICAgIHRoaXMubXlTb2NrID0gbnVsbDtcclxuICAgICAgICAgICAgdGhpcy5vbkNsb3NlZF8oKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMubXlTb2NrLm9ubWVzc2FnZSA9IG0gPT4ge1xyXG4gICAgICAgICAgICB0aGlzLmhhbmRsZUluY29taW5nRnJhbWUobSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLm15U29jay5vbmVycm9yID0gZSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMubG9nXygnV2ViU29ja2V0IGVycm9yLiAgQ2xvc2luZyBjb25uZWN0aW9uLicpO1xyXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxyXG4gICAgICAgICAgICBjb25zdCBlcnJvciA9IGUubWVzc2FnZSB8fCBlLmRhdGE7XHJcbiAgICAgICAgICAgIGlmIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sb2dfKGVycm9yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLm9uQ2xvc2VkXygpO1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIE5vLW9wIGZvciB3ZWJzb2NrZXRzLCB3ZSBkb24ndCBuZWVkIHRvIGRvIGFueXRoaW5nIG9uY2UgdGhlIGNvbm5lY3Rpb24gaXMgY29uZmlybWVkIGFzIG9wZW5cclxuICAgICAqL1xyXG4gICAgc3RhcnQoKSB7IH1cclxuICAgIHN0YXRpYyBmb3JjZURpc2FsbG93KCkge1xyXG4gICAgICAgIFdlYlNvY2tldENvbm5lY3Rpb24uZm9yY2VEaXNhbGxvd18gPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGlzQXZhaWxhYmxlKCkge1xyXG4gICAgICAgIGxldCBpc09sZEFuZHJvaWQgPSBmYWxzZTtcclxuICAgICAgICBpZiAodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCkge1xyXG4gICAgICAgICAgICBjb25zdCBvbGRBbmRyb2lkUmVnZXggPSAvQW5kcm9pZCAoWzAtOV17MCx9XFwuWzAtOV17MCx9KS87XHJcbiAgICAgICAgICAgIGNvbnN0IG9sZEFuZHJvaWRNYXRjaCA9IG5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2gob2xkQW5kcm9pZFJlZ2V4KTtcclxuICAgICAgICAgICAgaWYgKG9sZEFuZHJvaWRNYXRjaCAmJiBvbGRBbmRyb2lkTWF0Y2gubGVuZ3RoID4gMSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHBhcnNlRmxvYXQob2xkQW5kcm9pZE1hdGNoWzFdKSA8IDQuNCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlzT2xkQW5kcm9pZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuICghaXNPbGRBbmRyb2lkICYmXHJcbiAgICAgICAgICAgIFdlYlNvY2tldEltcGwgIT09IG51bGwgJiZcclxuICAgICAgICAgICAgIVdlYlNvY2tldENvbm5lY3Rpb24uZm9yY2VEaXNhbGxvd18pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgd2UgcHJldmlvdXNseSBmYWlsZWQgdG8gY29ubmVjdCB3aXRoIHRoaXMgdHJhbnNwb3J0LlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgcHJldmlvdXNseUZhaWxlZCgpIHtcclxuICAgICAgICAvLyBJZiBvdXIgcGVyc2lzdGVudCBzdG9yYWdlIGlzIGFjdHVhbGx5IG9ubHkgaW4tbWVtb3J5IHN0b3JhZ2UsXHJcbiAgICAgICAgLy8gd2UgZGVmYXVsdCB0byBhc3N1bWluZyB0aGF0IGl0IHByZXZpb3VzbHkgZmFpbGVkIHRvIGJlIHNhZmUuXHJcbiAgICAgICAgcmV0dXJuIChQZXJzaXN0ZW50U3RvcmFnZS5pc0luTWVtb3J5U3RvcmFnZSB8fFxyXG4gICAgICAgICAgICBQZXJzaXN0ZW50U3RvcmFnZS5nZXQoJ3ByZXZpb3VzX3dlYnNvY2tldF9mYWlsdXJlJykgPT09IHRydWUpO1xyXG4gICAgfVxyXG4gICAgbWFya0Nvbm5lY3Rpb25IZWFsdGh5KCkge1xyXG4gICAgICAgIFBlcnNpc3RlbnRTdG9yYWdlLnJlbW92ZSgncHJldmlvdXNfd2Vic29ja2V0X2ZhaWx1cmUnKTtcclxuICAgIH1cclxuICAgIGFwcGVuZEZyYW1lXyhkYXRhKSB7XHJcbiAgICAgICAgdGhpcy5mcmFtZXMucHVzaChkYXRhKTtcclxuICAgICAgICBpZiAodGhpcy5mcmFtZXMubGVuZ3RoID09PSB0aGlzLnRvdGFsRnJhbWVzKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGZ1bGxNZXNzID0gdGhpcy5mcmFtZXMuam9pbignJyk7XHJcbiAgICAgICAgICAgIHRoaXMuZnJhbWVzID0gbnVsbDtcclxuICAgICAgICAgICAgY29uc3QganNvbk1lc3MgPSBqc29uRXZhbChmdWxsTWVzcyk7XHJcbiAgICAgICAgICAgIC8vaGFuZGxlIHRoZSBtZXNzYWdlXHJcbiAgICAgICAgICAgIHRoaXMub25NZXNzYWdlKGpzb25NZXNzKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSBmcmFtZUNvdW50IC0gVGhlIG51bWJlciBvZiBmcmFtZXMgd2UgYXJlIGV4cGVjdGluZyBmcm9tIHRoZSBzZXJ2ZXJcclxuICAgICAqL1xyXG4gICAgaGFuZGxlTmV3RnJhbWVDb3VudF8oZnJhbWVDb3VudCkge1xyXG4gICAgICAgIHRoaXMudG90YWxGcmFtZXMgPSBmcmFtZUNvdW50O1xyXG4gICAgICAgIHRoaXMuZnJhbWVzID0gW107XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEF0dGVtcHRzIHRvIHBhcnNlIGEgZnJhbWUgY291bnQgb3V0IG9mIHNvbWUgdGV4dC4gSWYgaXQgY2FuJ3QsIGFzc3VtZXMgYSB2YWx1ZSBvZiAxXHJcbiAgICAgKiBAcmV0dXJucyBBbnkgcmVtYWluaW5nIGRhdGEgdG8gYmUgcHJvY2Vzcywgb3IgbnVsbCBpZiB0aGVyZSBpcyBub25lXHJcbiAgICAgKi9cclxuICAgIGV4dHJhY3RGcmFtZUNvdW50XyhkYXRhKSB7XHJcbiAgICAgICAgYXNzZXJ0KHRoaXMuZnJhbWVzID09PSBudWxsLCAnV2UgYWxyZWFkeSBoYXZlIGEgZnJhbWUgYnVmZmVyJyk7XHJcbiAgICAgICAgLy8gVE9ETzogVGhlIHNlcnZlciBpcyBvbmx5IHN1cHBvc2VkIHRvIHNlbmQgdXAgdG8gOTk5OSBmcmFtZXMgKGkuZS4gbGVuZ3RoIDw9IDQpLCBidXQgdGhhdCBpc24ndCBiZWluZyBlbmZvcmNlZFxyXG4gICAgICAgIC8vIGN1cnJlbnRseS4gIFNvIGFsbG93aW5nIGxhcmdlciBmcmFtZSBjb3VudHMgKGxlbmd0aCA8PSA2KS4gIFNlZSBodHRwczovL2FwcC5hc2FuYS5jb20vMC9zZWFyY2gvODY4ODU5ODk5ODM4MC84MjM3NjA4MDQyNTA4XHJcbiAgICAgICAgaWYgKGRhdGEubGVuZ3RoIDw9IDYpIHtcclxuICAgICAgICAgICAgY29uc3QgZnJhbWVDb3VudCA9IE51bWJlcihkYXRhKTtcclxuICAgICAgICAgICAgaWYgKCFpc05hTihmcmFtZUNvdW50KSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVOZXdGcmFtZUNvdW50XyhmcmFtZUNvdW50KTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuaGFuZGxlTmV3RnJhbWVDb3VudF8oMSk7XHJcbiAgICAgICAgcmV0dXJuIGRhdGE7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFByb2Nlc3MgYSB3ZWJzb2NrZXQgZnJhbWUgdGhhdCBoYXMgYXJyaXZlZCBmcm9tIHRoZSBzZXJ2ZXIuXHJcbiAgICAgKiBAcGFyYW0gbWVzcyAtIFRoZSBmcmFtZSBkYXRhXHJcbiAgICAgKi9cclxuICAgIGhhbmRsZUluY29taW5nRnJhbWUobWVzcykge1xyXG4gICAgICAgIGlmICh0aGlzLm15U29jayA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm47IC8vIENocm9tZSBhcHBhcmVudGx5IGRlbGl2ZXJzIGluY29taW5nIHBhY2tldHMgZXZlbiBhZnRlciB3ZSAuY2xvc2UoKSB0aGUgY29ubmVjdGlvbiBzb21ldGltZXMuXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGRhdGEgPSBtZXNzWydkYXRhJ107XHJcbiAgICAgICAgdGhpcy5ieXRlc1JlY2VpdmVkICs9IGRhdGEubGVuZ3RoO1xyXG4gICAgICAgIHRoaXMuc3RhdHNfLmluY3JlbWVudENvdW50ZXIoJ2J5dGVzX3JlY2VpdmVkJywgZGF0YS5sZW5ndGgpO1xyXG4gICAgICAgIHRoaXMucmVzZXRLZWVwQWxpdmUoKTtcclxuICAgICAgICBpZiAodGhpcy5mcmFtZXMgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgLy8gd2UncmUgYnVmZmVyaW5nXHJcbiAgICAgICAgICAgIHRoaXMuYXBwZW5kRnJhbWVfKGRhdGEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gdHJ5IHRvIHBhcnNlIG91dCBhIGZyYW1lIGNvdW50LCBvdGhlcndpc2UsIGFzc3VtZSAxIGFuZCBwcm9jZXNzIGl0XHJcbiAgICAgICAgICAgIGNvbnN0IHJlbWFpbmluZ0RhdGEgPSB0aGlzLmV4dHJhY3RGcmFtZUNvdW50XyhkYXRhKTtcclxuICAgICAgICAgICAgaWYgKHJlbWFpbmluZ0RhdGEgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYXBwZW5kRnJhbWVfKHJlbWFpbmluZ0RhdGEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTZW5kIGEgbWVzc2FnZSB0byB0aGUgc2VydmVyXHJcbiAgICAgKiBAcGFyYW0gZGF0YSAtIFRoZSBKU09OIG9iamVjdCB0byB0cmFuc21pdFxyXG4gICAgICovXHJcbiAgICBzZW5kKGRhdGEpIHtcclxuICAgICAgICB0aGlzLnJlc2V0S2VlcEFsaXZlKCk7XHJcbiAgICAgICAgY29uc3QgZGF0YVN0ciA9IHN0cmluZ2lmeShkYXRhKTtcclxuICAgICAgICB0aGlzLmJ5dGVzU2VudCArPSBkYXRhU3RyLmxlbmd0aDtcclxuICAgICAgICB0aGlzLnN0YXRzXy5pbmNyZW1lbnRDb3VudGVyKCdieXRlc19zZW50JywgZGF0YVN0ci5sZW5ndGgpO1xyXG4gICAgICAgIC8vV2UgY2FuIG9ubHkgZml0IGEgY2VydGFpbiBhbW91bnQgaW4gZWFjaCB3ZWJzb2NrZXQgZnJhbWUsIHNvIHdlIG5lZWQgdG8gc3BsaXQgdGhpcyByZXF1ZXN0XHJcbiAgICAgICAgLy91cCBpbnRvIG11bHRpcGxlIHBpZWNlcyBpZiBpdCBkb2Vzbid0IGZpdCBpbiBvbmUgcmVxdWVzdC5cclxuICAgICAgICBjb25zdCBkYXRhU2VncyA9IHNwbGl0U3RyaW5nQnlTaXplKGRhdGFTdHIsIFdFQlNPQ0tFVF9NQVhfRlJBTUVfU0laRSk7XHJcbiAgICAgICAgLy9TZW5kIHRoZSBsZW5ndGggaGVhZGVyXHJcbiAgICAgICAgaWYgKGRhdGFTZWdzLmxlbmd0aCA+IDEpIHtcclxuICAgICAgICAgICAgdGhpcy5zZW5kU3RyaW5nXyhTdHJpbmcoZGF0YVNlZ3MubGVuZ3RoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vU2VuZCB0aGUgYWN0dWFsIGRhdGEgaW4gc2VnbWVudHMuXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhU2Vncy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB0aGlzLnNlbmRTdHJpbmdfKGRhdGFTZWdzW2ldKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBzaHV0ZG93bl8oKSB7XHJcbiAgICAgICAgdGhpcy5pc0Nsb3NlZF8gPSB0cnVlO1xyXG4gICAgICAgIGlmICh0aGlzLmtlZXBhbGl2ZVRpbWVyKSB7XHJcbiAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5rZWVwYWxpdmVUaW1lcik7XHJcbiAgICAgICAgICAgIHRoaXMua2VlcGFsaXZlVGltZXIgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5teVNvY2spIHtcclxuICAgICAgICAgICAgdGhpcy5teVNvY2suY2xvc2UoKTtcclxuICAgICAgICAgICAgdGhpcy5teVNvY2sgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIG9uQ2xvc2VkXygpIHtcclxuICAgICAgICBpZiAoIXRoaXMuaXNDbG9zZWRfKSB7XHJcbiAgICAgICAgICAgIHRoaXMubG9nXygnV2ViU29ja2V0IGlzIGNsb3NpbmcgaXRzZWxmJyk7XHJcbiAgICAgICAgICAgIHRoaXMuc2h1dGRvd25fKCk7XHJcbiAgICAgICAgICAgIC8vIHNpbmNlIHRoaXMgaXMgYW4gaW50ZXJuYWwgY2xvc2UsIHRyaWdnZXIgdGhlIGNsb3NlIGxpc3RlbmVyXHJcbiAgICAgICAgICAgIGlmICh0aGlzLm9uRGlzY29ubmVjdCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vbkRpc2Nvbm5lY3QodGhpcy5ldmVyQ29ubmVjdGVkXyk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9uRGlzY29ubmVjdCA9IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEV4dGVybmFsLWZhY2luZyBjbG9zZSBoYW5kbGVyLlxyXG4gICAgICogQ2xvc2UgdGhlIHdlYnNvY2tldCBhbmQga2lsbCB0aGUgY29ubmVjdGlvbi5cclxuICAgICAqL1xyXG4gICAgY2xvc2UoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmlzQ2xvc2VkXykge1xyXG4gICAgICAgICAgICB0aGlzLmxvZ18oJ1dlYlNvY2tldCBpcyBiZWluZyBjbG9zZWQnKTtcclxuICAgICAgICAgICAgdGhpcy5zaHV0ZG93bl8oKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEtpbGwgdGhlIGN1cnJlbnQga2VlcGFsaXZlIHRpbWVyIGFuZCBzdGFydCBhIG5ldyBvbmUsIHRvIGVuc3VyZSB0aGF0IGl0IGFsd2F5cyBmaXJlcyBOIHNlY29uZHMgYWZ0ZXJcclxuICAgICAqIHRoZSBsYXN0IGFjdGl2aXR5LlxyXG4gICAgICovXHJcbiAgICByZXNldEtlZXBBbGl2ZSgpIHtcclxuICAgICAgICBjbGVhckludGVydmFsKHRoaXMua2VlcGFsaXZlVGltZXIpO1xyXG4gICAgICAgIHRoaXMua2VlcGFsaXZlVGltZXIgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XHJcbiAgICAgICAgICAgIC8vSWYgdGhlcmUgaGFzIGJlZW4gbm8gd2Vic29ja2V0IGFjdGl2aXR5IGZvciBhIHdoaWxlLCBzZW5kIGEgbm8tb3BcclxuICAgICAgICAgICAgaWYgKHRoaXMubXlTb2NrKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNlbmRTdHJpbmdfKCcwJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5yZXNldEtlZXBBbGl2ZSgpO1xyXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxyXG4gICAgICAgIH0sIE1hdGguZmxvb3IoV0VCU09DS0VUX0tFRVBBTElWRV9JTlRFUlZBTCkpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTZW5kIGEgc3RyaW5nIG92ZXIgdGhlIHdlYnNvY2tldC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gc3RyIC0gU3RyaW5nIHRvIHNlbmQuXHJcbiAgICAgKi9cclxuICAgIHNlbmRTdHJpbmdfKHN0cikge1xyXG4gICAgICAgIC8vIEZpcmVmb3ggc2VlbXMgdG8gc29tZXRpbWVzIHRocm93IGV4Y2VwdGlvbnMgKE5TX0VSUk9SX1VORVhQRUNURUQpIGZyb20gd2Vic29ja2V0IC5zZW5kKClcclxuICAgICAgICAvLyBjYWxscyBmb3Igc29tZSB1bmtub3duIHJlYXNvbi4gIFdlIHRyZWF0IHRoZXNlIGFzIGFuIGVycm9yIGFuZCBkaXNjb25uZWN0LlxyXG4gICAgICAgIC8vIFNlZSBodHRwczovL2FwcC5hc2FuYS5jb20vMC81ODkyNjExMTQwMjI5Mi82ODAyMTM0MDI1MDQxMFxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHRoaXMubXlTb2NrLnNlbmQoc3RyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgdGhpcy5sb2dfKCdFeGNlcHRpb24gdGhyb3duIGZyb20gV2ViU29ja2V0LnNlbmQoKTonLCBlLm1lc3NhZ2UgfHwgZS5kYXRhLCAnQ2xvc2luZyBjb25uZWN0aW9uLicpO1xyXG4gICAgICAgICAgICBzZXRUaW1lb3V0KHRoaXMub25DbG9zZWRfLmJpbmQodGhpcyksIDApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4vKipcclxuICogTnVtYmVyIG9mIHJlc3BvbnNlIGJlZm9yZSB3ZSBjb25zaWRlciB0aGUgY29ubmVjdGlvbiBcImhlYWx0aHkuXCJcclxuICovXHJcbldlYlNvY2tldENvbm5lY3Rpb24ucmVzcG9uc2VzUmVxdWlyZWRUb0JlSGVhbHRoeSA9IDI7XHJcbi8qKlxyXG4gKiBUaW1lIHRvIHdhaXQgZm9yIHRoZSBjb25uZWN0aW9uIHRlIGJlY29tZSBoZWFsdGh5IGJlZm9yZSBnaXZpbmcgdXAuXHJcbiAqL1xyXG5XZWJTb2NrZXRDb25uZWN0aW9uLmhlYWx0aHlUaW1lb3V0ID0gMzAwMDA7XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBDdXJyZW50bHkgc2ltcGxpc3RpYywgdGhpcyBjbGFzcyBtYW5hZ2VzIHdoYXQgdHJhbnNwb3J0IGEgQ29ubmVjdGlvbiBzaG91bGQgdXNlIGF0IHZhcmlvdXMgc3RhZ2VzIG9mIGl0c1xyXG4gKiBsaWZlY3ljbGUuXHJcbiAqXHJcbiAqIEl0IHN0YXJ0cyB3aXRoIGxvbmdwb2xsaW5nIGluIGEgYnJvd3NlciwgYW5kIGh0dHBwb2xsaW5nIG9uIG5vZGUuIEl0IHRoZW4gdXBncmFkZXMgdG8gd2Vic29ja2V0cyBpZlxyXG4gKiB0aGV5IGFyZSBhdmFpbGFibGUuXHJcbiAqL1xyXG5jbGFzcyBUcmFuc3BvcnRNYW5hZ2VyIHtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHJlcG9JbmZvIC0gTWV0YWRhdGEgYXJvdW5kIHRoZSBuYW1lc3BhY2Ugd2UncmUgY29ubmVjdGluZyB0b1xyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihyZXBvSW5mbykge1xyXG4gICAgICAgIHRoaXMuaW5pdFRyYW5zcG9ydHNfKHJlcG9JbmZvKTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBnZXQgQUxMX1RSQU5TUE9SVFMoKSB7XHJcbiAgICAgICAgcmV0dXJuIFtCcm93c2VyUG9sbENvbm5lY3Rpb24sIFdlYlNvY2tldENvbm5lY3Rpb25dO1xyXG4gICAgfVxyXG4gICAgaW5pdFRyYW5zcG9ydHNfKHJlcG9JbmZvKSB7XHJcbiAgICAgICAgY29uc3QgaXNXZWJTb2NrZXRzQXZhaWxhYmxlID0gV2ViU29ja2V0Q29ubmVjdGlvbiAmJiBXZWJTb2NrZXRDb25uZWN0aW9uWydpc0F2YWlsYWJsZSddKCk7XHJcbiAgICAgICAgbGV0IGlzU2tpcFBvbGxDb25uZWN0aW9uID0gaXNXZWJTb2NrZXRzQXZhaWxhYmxlICYmICFXZWJTb2NrZXRDb25uZWN0aW9uLnByZXZpb3VzbHlGYWlsZWQoKTtcclxuICAgICAgICBpZiAocmVwb0luZm8ud2ViU29ja2V0T25seSkge1xyXG4gICAgICAgICAgICBpZiAoIWlzV2ViU29ja2V0c0F2YWlsYWJsZSkge1xyXG4gICAgICAgICAgICAgICAgd2FybihcIndzczovLyBVUkwgdXNlZCwgYnV0IGJyb3dzZXIgaXNuJ3Qga25vd24gdG8gc3VwcG9ydCB3ZWJzb2NrZXRzLiAgVHJ5aW5nIGFueXdheS5cIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaXNTa2lwUG9sbENvbm5lY3Rpb24gPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaXNTa2lwUG9sbENvbm5lY3Rpb24pIHtcclxuICAgICAgICAgICAgdGhpcy50cmFuc3BvcnRzXyA9IFtXZWJTb2NrZXRDb25uZWN0aW9uXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHRyYW5zcG9ydHMgPSAodGhpcy50cmFuc3BvcnRzXyA9IFtdKTtcclxuICAgICAgICAgICAgZm9yIChjb25zdCB0cmFuc3BvcnQgb2YgVHJhbnNwb3J0TWFuYWdlci5BTExfVFJBTlNQT1JUUykge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRyYW5zcG9ydCAmJiB0cmFuc3BvcnRbJ2lzQXZhaWxhYmxlJ10oKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zcG9ydHMucHVzaCh0cmFuc3BvcnQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgY29uc3RydWN0b3IgZm9yIHRoZSBpbml0aWFsIHRyYW5zcG9ydCB0byB1c2VcclxuICAgICAqL1xyXG4gICAgaW5pdGlhbFRyYW5zcG9ydCgpIHtcclxuICAgICAgICBpZiAodGhpcy50cmFuc3BvcnRzXy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRyYW5zcG9ydHNfWzBdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyB0cmFuc3BvcnRzIGF2YWlsYWJsZScpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybnMgVGhlIGNvbnN0cnVjdG9yIGZvciB0aGUgbmV4dCB0cmFuc3BvcnQsIG9yIG51bGxcclxuICAgICAqL1xyXG4gICAgdXBncmFkZVRyYW5zcG9ydCgpIHtcclxuICAgICAgICBpZiAodGhpcy50cmFuc3BvcnRzXy5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRyYW5zcG9ydHNfWzFdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8vIEFib3J0IHVwZ3JhZGUgYXR0ZW1wdCBpZiBpdCB0YWtlcyBsb25nZXIgdGhhbiA2MHMuXHJcbmNvbnN0IFVQR1JBREVfVElNRU9VVCA9IDYwMDAwO1xyXG4vLyBGb3Igc29tZSB0cmFuc3BvcnRzIChXZWJTb2NrZXRzKSwgd2UgbmVlZCB0byBcInZhbGlkYXRlXCIgdGhlIHRyYW5zcG9ydCBieSBleGNoYW5naW5nIGEgZmV3IHJlcXVlc3RzIGFuZCByZXNwb25zZXMuXHJcbi8vIElmIHdlIGhhdmVuJ3Qgc2VudCBlbm91Z2ggcmVxdWVzdHMgd2l0aGluIDVzLCB3ZSdsbCBzdGFydCBzZW5kaW5nIG5vb3AgcGluZyByZXF1ZXN0cy5cclxuY29uc3QgREVMQVlfQkVGT1JFX1NFTkRJTkdfRVhUUkFfUkVRVUVTVFMgPSA1MDAwO1xyXG4vLyBJZiB0aGUgaW5pdGlhbCBkYXRhIHNlbnQgdHJpZ2dlcnMgYSBsb3Qgb2YgYmFuZHdpZHRoIChpLmUuIGl0J3MgYSBsYXJnZSBwdXQgb3IgYSBsaXN0ZW4gZm9yIGEgbGFyZ2UgYW1vdW50IG9mIGRhdGEpXHJcbi8vIHRoZW4gd2UgbWF5IG5vdCBiZSBhYmxlIHRvIGV4Y2hhbmdlIG91ciBwaW5nL3BvbmcgcmVxdWVzdHMgd2l0aGluIHRoZSBoZWFsdGh5IHRpbWVvdXQuICBTbyBpZiB3ZSByZWFjaCB0aGUgdGltZW91dFxyXG4vLyBidXQgd2UndmUgc2VudC9yZWNlaXZlZCBlbm91Z2ggYnl0ZXMsIHdlIGRvbid0IGNhbmNlbCB0aGUgY29ubmVjdGlvbi5cclxuY29uc3QgQllURVNfU0VOVF9IRUFMVEhZX09WRVJSSURFID0gMTAgKiAxMDI0O1xyXG5jb25zdCBCWVRFU19SRUNFSVZFRF9IRUFMVEhZX09WRVJSSURFID0gMTAwICogMTAyNDtcclxuY29uc3QgTUVTU0FHRV9UWVBFID0gJ3QnO1xyXG5jb25zdCBNRVNTQUdFX0RBVEEgPSAnZCc7XHJcbmNvbnN0IENPTlRST0xfU0hVVERPV04gPSAncyc7XHJcbmNvbnN0IENPTlRST0xfUkVTRVQgPSAncic7XHJcbmNvbnN0IENPTlRST0xfRVJST1IgPSAnZSc7XHJcbmNvbnN0IENPTlRST0xfUE9ORyA9ICdvJztcclxuY29uc3QgU1dJVENIX0FDSyA9ICdhJztcclxuY29uc3QgRU5EX1RSQU5TTUlTU0lPTiA9ICduJztcclxuY29uc3QgUElORyA9ICdwJztcclxuY29uc3QgU0VSVkVSX0hFTExPID0gJ2gnO1xyXG4vKipcclxuICogQ3JlYXRlcyBhIG5ldyByZWFsLXRpbWUgY29ubmVjdGlvbiB0byB0aGUgc2VydmVyIHVzaW5nIHdoaWNoZXZlciBtZXRob2Qgd29ya3NcclxuICogYmVzdCBpbiB0aGUgY3VycmVudCBicm93c2VyLlxyXG4gKi9cclxuY2xhc3MgQ29ubmVjdGlvbiB7XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSBpZCAtIGFuIGlkIGZvciB0aGlzIGNvbm5lY3Rpb25cclxuICAgICAqIEBwYXJhbSByZXBvSW5mb18gLSB0aGUgaW5mbyBmb3IgdGhlIGVuZHBvaW50IHRvIGNvbm5lY3QgdG9cclxuICAgICAqIEBwYXJhbSBhcHBsaWNhdGlvbklkXyAtIHRoZSBGaXJlYmFzZSBBcHAgSUQgZm9yIHRoaXMgcHJvamVjdFxyXG4gICAgICogQHBhcmFtIGFwcENoZWNrVG9rZW5fIC0gVGhlIEFwcCBDaGVjayBUb2tlbiBmb3IgdGhpcyBkZXZpY2UuXHJcbiAgICAgKiBAcGFyYW0gYXV0aFRva2VuXyAtIFRoZSBhdXRoIHRva2VuIGZvciB0aGlzIHNlc3Npb24uXHJcbiAgICAgKiBAcGFyYW0gb25NZXNzYWdlXyAtIHRoZSBjYWxsYmFjayB0byBiZSB0cmlnZ2VyZWQgd2hlbiBhIHNlcnZlci1wdXNoIG1lc3NhZ2UgYXJyaXZlc1xyXG4gICAgICogQHBhcmFtIG9uUmVhZHlfIC0gdGhlIGNhbGxiYWNrIHRvIGJlIHRyaWdnZXJlZCB3aGVuIHRoaXMgY29ubmVjdGlvbiBpcyByZWFkeSB0byBzZW5kIG1lc3NhZ2VzLlxyXG4gICAgICogQHBhcmFtIG9uRGlzY29ubmVjdF8gLSB0aGUgY2FsbGJhY2sgdG8gYmUgdHJpZ2dlcmVkIHdoZW4gYSBjb25uZWN0aW9uIHdhcyBsb3N0XHJcbiAgICAgKiBAcGFyYW0gb25LaWxsXyAtIHRoZSBjYWxsYmFjayB0byBiZSB0cmlnZ2VyZWQgd2hlbiB0aGlzIGNvbm5lY3Rpb24gaGFzIHBlcm1hbmVudGx5IHNodXQgZG93bi5cclxuICAgICAqIEBwYXJhbSBsYXN0U2Vzc2lvbklkIC0gbGFzdCBzZXNzaW9uIGlkIGluIHBlcnNpc3RlbnQgY29ubmVjdGlvbi4gaXMgdXNlZCB0byBjbGVhbiB1cCBvbGQgc2Vzc2lvbiBpbiByZWFsLXRpbWUgc2VydmVyXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKGlkLCByZXBvSW5mb18sIGFwcGxpY2F0aW9uSWRfLCBhcHBDaGVja1Rva2VuXywgYXV0aFRva2VuXywgb25NZXNzYWdlXywgb25SZWFkeV8sIG9uRGlzY29ubmVjdF8sIG9uS2lsbF8sIGxhc3RTZXNzaW9uSWQpIHtcclxuICAgICAgICB0aGlzLmlkID0gaWQ7XHJcbiAgICAgICAgdGhpcy5yZXBvSW5mb18gPSByZXBvSW5mb187XHJcbiAgICAgICAgdGhpcy5hcHBsaWNhdGlvbklkXyA9IGFwcGxpY2F0aW9uSWRfO1xyXG4gICAgICAgIHRoaXMuYXBwQ2hlY2tUb2tlbl8gPSBhcHBDaGVja1Rva2VuXztcclxuICAgICAgICB0aGlzLmF1dGhUb2tlbl8gPSBhdXRoVG9rZW5fO1xyXG4gICAgICAgIHRoaXMub25NZXNzYWdlXyA9IG9uTWVzc2FnZV87XHJcbiAgICAgICAgdGhpcy5vblJlYWR5XyA9IG9uUmVhZHlfO1xyXG4gICAgICAgIHRoaXMub25EaXNjb25uZWN0XyA9IG9uRGlzY29ubmVjdF87XHJcbiAgICAgICAgdGhpcy5vbktpbGxfID0gb25LaWxsXztcclxuICAgICAgICB0aGlzLmxhc3RTZXNzaW9uSWQgPSBsYXN0U2Vzc2lvbklkO1xyXG4gICAgICAgIHRoaXMuY29ubmVjdGlvbkNvdW50ID0gMDtcclxuICAgICAgICB0aGlzLnBlbmRpbmdEYXRhTWVzc2FnZXMgPSBbXTtcclxuICAgICAgICB0aGlzLnN0YXRlXyA9IDAgLyogQ09OTkVDVElORyAqLztcclxuICAgICAgICB0aGlzLmxvZ18gPSBsb2dXcmFwcGVyKCdjOicgKyB0aGlzLmlkICsgJzonKTtcclxuICAgICAgICB0aGlzLnRyYW5zcG9ydE1hbmFnZXJfID0gbmV3IFRyYW5zcG9ydE1hbmFnZXIocmVwb0luZm9fKTtcclxuICAgICAgICB0aGlzLmxvZ18oJ0Nvbm5lY3Rpb24gY3JlYXRlZCcpO1xyXG4gICAgICAgIHRoaXMuc3RhcnRfKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFN0YXJ0cyBhIGNvbm5lY3Rpb24gYXR0ZW1wdFxyXG4gICAgICovXHJcbiAgICBzdGFydF8oKSB7XHJcbiAgICAgICAgY29uc3QgY29ubiA9IHRoaXMudHJhbnNwb3J0TWFuYWdlcl8uaW5pdGlhbFRyYW5zcG9ydCgpO1xyXG4gICAgICAgIHRoaXMuY29ubl8gPSBuZXcgY29ubih0aGlzLm5leHRUcmFuc3BvcnRJZF8oKSwgdGhpcy5yZXBvSW5mb18sIHRoaXMuYXBwbGljYXRpb25JZF8sIHRoaXMuYXBwQ2hlY2tUb2tlbl8sIHRoaXMuYXV0aFRva2VuXywgbnVsbCwgdGhpcy5sYXN0U2Vzc2lvbklkKTtcclxuICAgICAgICAvLyBGb3IgY2VydGFpbiB0cmFuc3BvcnRzIChXZWJTb2NrZXRzKSwgd2UgbmVlZCB0byBzZW5kIGFuZCByZWNlaXZlIHNldmVyYWwgbWVzc2FnZXMgYmFjayBhbmQgZm9ydGggYmVmb3JlIHdlXHJcbiAgICAgICAgLy8gY2FuIGNvbnNpZGVyIHRoZSB0cmFuc3BvcnQgaGVhbHRoeS5cclxuICAgICAgICB0aGlzLnByaW1hcnlSZXNwb25zZXNSZXF1aXJlZF8gPSBjb25uWydyZXNwb25zZXNSZXF1aXJlZFRvQmVIZWFsdGh5J10gfHwgMDtcclxuICAgICAgICBjb25zdCBvbk1lc3NhZ2VSZWNlaXZlZCA9IHRoaXMuY29ublJlY2VpdmVyXyh0aGlzLmNvbm5fKTtcclxuICAgICAgICBjb25zdCBvbkNvbm5lY3Rpb25Mb3N0ID0gdGhpcy5kaXNjb25uUmVjZWl2ZXJfKHRoaXMuY29ubl8pO1xyXG4gICAgICAgIHRoaXMudHhfID0gdGhpcy5jb25uXztcclxuICAgICAgICB0aGlzLnJ4XyA9IHRoaXMuY29ubl87XHJcbiAgICAgICAgdGhpcy5zZWNvbmRhcnlDb25uXyA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5pc0hlYWx0aHlfID0gZmFsc2U7XHJcbiAgICAgICAgLypcclxuICAgICAgICAgKiBGaXJlZm94IGRvZXNuJ3QgbGlrZSB3aGVuIGNvZGUgZnJvbSBvbmUgaWZyYW1lIHRyaWVzIHRvIGNyZWF0ZSBhbm90aGVyIGlmcmFtZSBieSB3YXkgb2YgdGhlIHBhcmVudCBmcmFtZS5cclxuICAgICAgICAgKiBUaGlzIGNhbiBvY2N1ciBpbiB0aGUgY2FzZSBvZiBhIHJlZGlyZWN0LCBpLmUuIHdlIGd1ZXNzZWQgd3Jvbmcgb24gd2hhdCBzZXJ2ZXIgdG8gY29ubmVjdCB0byBhbmQgcmVjZWl2ZWQgYSByZXNldC5cclxuICAgICAgICAgKiBTb21laG93LCBzZXRUaW1lb3V0IHNlZW1zIHRvIG1ha2UgdGhpcyBvay4gVGhhdCBkb2Vzbid0IG1ha2Ugc2Vuc2UgZnJvbSBhIHNlY3VyaXR5IHBlcnNwZWN0aXZlLCBzaW5jZSB5b3Ugc2hvdWxkXHJcbiAgICAgICAgICogc3RpbGwgaGF2ZSB0aGUgY29udGV4dCBvZiB5b3VyIG9yaWdpbmF0aW5nIGZyYW1lLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICAvLyB0aGlzLmNvbm5fIGdldHMgc2V0IHRvIG51bGwgaW4gc29tZSBvZiB0aGUgdGVzdHMuIENoZWNrIHRvIG1ha2Ugc3VyZSBpdCBzdGlsbCBleGlzdHMgYmVmb3JlIHVzaW5nIGl0XHJcbiAgICAgICAgICAgIHRoaXMuY29ubl8gJiYgdGhpcy5jb25uXy5vcGVuKG9uTWVzc2FnZVJlY2VpdmVkLCBvbkNvbm5lY3Rpb25Mb3N0KTtcclxuICAgICAgICB9LCBNYXRoLmZsb29yKDApKTtcclxuICAgICAgICBjb25zdCBoZWFsdGh5VGltZW91dE1TID0gY29ublsnaGVhbHRoeVRpbWVvdXQnXSB8fCAwO1xyXG4gICAgICAgIGlmIChoZWFsdGh5VGltZW91dE1TID4gMCkge1xyXG4gICAgICAgICAgICB0aGlzLmhlYWx0aHlUaW1lb3V0XyA9IHNldFRpbWVvdXROb25CbG9ja2luZygoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmhlYWx0aHlUaW1lb3V0XyA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuaXNIZWFsdGh5Xykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbm5fICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29ubl8uYnl0ZXNSZWNlaXZlZCA+IEJZVEVTX1JFQ0VJVkVEX0hFQUxUSFlfT1ZFUlJJREUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2dfKCdDb25uZWN0aW9uIGV4Y2VlZGVkIGhlYWx0aHkgdGltZW91dCBidXQgaGFzIHJlY2VpdmVkICcgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25uXy5ieXRlc1JlY2VpdmVkICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICcgYnl0ZXMuICBNYXJraW5nIGNvbm5lY3Rpb24gaGVhbHRoeS4nKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pc0hlYWx0aHlfID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25uXy5tYXJrQ29ubmVjdGlvbkhlYWx0aHkoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5jb25uXyAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbm5fLmJ5dGVzU2VudCA+IEJZVEVTX1NFTlRfSEVBTFRIWV9PVkVSUklERSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxvZ18oJ0Nvbm5lY3Rpb24gZXhjZWVkZWQgaGVhbHRoeSB0aW1lb3V0IGJ1dCBoYXMgc2VudCAnICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29ubl8uYnl0ZXNTZW50ICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICcgYnl0ZXMuICBMZWF2aW5nIGNvbm5lY3Rpb24gYWxpdmUuJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5PVEU6IFdlIGRvbid0IHdhbnQgdG8gbWFyayBpdCBoZWFsdGh5LCBzaW5jZSB3ZSBoYXZlIG5vIGd1YXJhbnRlZSB0aGF0IHRoZSBieXRlcyBoYXZlIG1hZGUgaXQgdG9cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIHNlcnZlci5cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubG9nXygnQ2xvc2luZyB1bmhlYWx0aHkgY29ubmVjdGlvbiBhZnRlciB0aW1lb3V0LicpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNsb3NlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcclxuICAgICAgICAgICAgfSwgTWF0aC5mbG9vcihoZWFsdGh5VGltZW91dE1TKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgbmV4dFRyYW5zcG9ydElkXygpIHtcclxuICAgICAgICByZXR1cm4gJ2M6JyArIHRoaXMuaWQgKyAnOicgKyB0aGlzLmNvbm5lY3Rpb25Db3VudCsrO1xyXG4gICAgfVxyXG4gICAgZGlzY29ublJlY2VpdmVyXyhjb25uKSB7XHJcbiAgICAgICAgcmV0dXJuIGV2ZXJDb25uZWN0ZWQgPT4ge1xyXG4gICAgICAgICAgICBpZiAoY29ubiA9PT0gdGhpcy5jb25uXykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vbkNvbm5lY3Rpb25Mb3N0XyhldmVyQ29ubmVjdGVkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChjb25uID09PSB0aGlzLnNlY29uZGFyeUNvbm5fKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ18oJ1NlY29uZGFyeSBjb25uZWN0aW9uIGxvc3QuJyk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9uU2Vjb25kYXJ5Q29ubmVjdGlvbkxvc3RfKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ18oJ2Nsb3NpbmcgYW4gb2xkIGNvbm5lY3Rpb24nKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBjb25uUmVjZWl2ZXJfKGNvbm4pIHtcclxuICAgICAgICByZXR1cm4gKG1lc3NhZ2UpID0+IHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGVfICE9PSAyIC8qIERJU0NPTk5FQ1RFRCAqLykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGNvbm4gPT09IHRoaXMucnhfKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vblByaW1hcnlNZXNzYWdlUmVjZWl2ZWRfKG1lc3NhZ2UpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY29ubiA9PT0gdGhpcy5zZWNvbmRhcnlDb25uXykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25TZWNvbmRhcnlNZXNzYWdlUmVjZWl2ZWRfKG1lc3NhZ2UpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2dfKCdtZXNzYWdlIG9uIG9sZCBjb25uZWN0aW9uJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gZGF0YU1zZyAtIEFuIGFyYml0cmFyeSBkYXRhIG1lc3NhZ2UgdG8gYmUgc2VudCB0byB0aGUgc2VydmVyXHJcbiAgICAgKi9cclxuICAgIHNlbmRSZXF1ZXN0KGRhdGFNc2cpIHtcclxuICAgICAgICAvLyB3cmFwIGluIGEgZGF0YSBtZXNzYWdlIGVudmVsb3BlIGFuZCBzZW5kIGl0IG9uXHJcbiAgICAgICAgY29uc3QgbXNnID0geyB0OiAnZCcsIGQ6IGRhdGFNc2cgfTtcclxuICAgICAgICB0aGlzLnNlbmREYXRhXyhtc2cpO1xyXG4gICAgfVxyXG4gICAgdHJ5Q2xlYW51cENvbm5lY3Rpb24oKSB7XHJcbiAgICAgICAgaWYgKHRoaXMudHhfID09PSB0aGlzLnNlY29uZGFyeUNvbm5fICYmIHRoaXMucnhfID09PSB0aGlzLnNlY29uZGFyeUNvbm5fKSB7XHJcbiAgICAgICAgICAgIHRoaXMubG9nXygnY2xlYW5pbmcgdXAgYW5kIHByb21vdGluZyBhIGNvbm5lY3Rpb246ICcgKyB0aGlzLnNlY29uZGFyeUNvbm5fLmNvbm5JZCk7XHJcbiAgICAgICAgICAgIHRoaXMuY29ubl8gPSB0aGlzLnNlY29uZGFyeUNvbm5fO1xyXG4gICAgICAgICAgICB0aGlzLnNlY29uZGFyeUNvbm5fID0gbnVsbDtcclxuICAgICAgICAgICAgLy8gdGhlIHNlcnZlciB3aWxsIHNodXRkb3duIHRoZSBvbGQgY29ubmVjdGlvblxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIG9uU2Vjb25kYXJ5Q29udHJvbF8oY29udHJvbERhdGEpIHtcclxuICAgICAgICBpZiAoTUVTU0FHRV9UWVBFIGluIGNvbnRyb2xEYXRhKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNtZCA9IGNvbnRyb2xEYXRhW01FU1NBR0VfVFlQRV07XHJcbiAgICAgICAgICAgIGlmIChjbWQgPT09IFNXSVRDSF9BQ0spIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudXBncmFkZUlmU2Vjb25kYXJ5SGVhbHRoeV8oKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChjbWQgPT09IENPTlRST0xfUkVTRVQpIHtcclxuICAgICAgICAgICAgICAgIC8vIE1vc3QgbGlrZWx5IHRoZSBzZXNzaW9uIHdhc24ndCB2YWxpZC4gQWJhbmRvbiB0aGUgc3dpdGNoIGF0dGVtcHRcclxuICAgICAgICAgICAgICAgIHRoaXMubG9nXygnR290IGEgcmVzZXQgb24gc2Vjb25kYXJ5LCBjbG9zaW5nIGl0Jyk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNlY29uZGFyeUNvbm5fLmNsb3NlKCk7XHJcbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSB3ZXJlIGFscmVhZHkgdXNpbmcgdGhpcyBjb25uZWN0aW9uIGZvciBzb21ldGhpbmcsIHRoYW4gd2UgbmVlZCB0byBmdWxseSBjbG9zZVxyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudHhfID09PSB0aGlzLnNlY29uZGFyeUNvbm5fIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yeF8gPT09IHRoaXMuc2Vjb25kYXJ5Q29ubl8pIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNsb3NlKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoY21kID09PSBDT05UUk9MX1BPTkcpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubG9nXygnZ290IHBvbmcgb24gc2Vjb25kYXJ5LicpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZWNvbmRhcnlSZXNwb25zZXNSZXF1aXJlZF8tLTtcclxuICAgICAgICAgICAgICAgIHRoaXMudXBncmFkZUlmU2Vjb25kYXJ5SGVhbHRoeV8oKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIG9uU2Vjb25kYXJ5TWVzc2FnZVJlY2VpdmVkXyhwYXJzZWREYXRhKSB7XHJcbiAgICAgICAgY29uc3QgbGF5ZXIgPSByZXF1aXJlS2V5KCd0JywgcGFyc2VkRGF0YSk7XHJcbiAgICAgICAgY29uc3QgZGF0YSA9IHJlcXVpcmVLZXkoJ2QnLCBwYXJzZWREYXRhKTtcclxuICAgICAgICBpZiAobGF5ZXIgPT09ICdjJykge1xyXG4gICAgICAgICAgICB0aGlzLm9uU2Vjb25kYXJ5Q29udHJvbF8oZGF0YSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGxheWVyID09PSAnZCcpIHtcclxuICAgICAgICAgICAgLy8gZ290IGEgZGF0YSBtZXNzYWdlLCBidXQgd2UncmUgc3RpbGwgc2Vjb25kIGNvbm5lY3Rpb24uIE5lZWQgdG8gYnVmZmVyIGl0IHVwXHJcbiAgICAgICAgICAgIHRoaXMucGVuZGluZ0RhdGFNZXNzYWdlcy5wdXNoKGRhdGEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIHByb3RvY29sIGxheWVyOiAnICsgbGF5ZXIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHVwZ3JhZGVJZlNlY29uZGFyeUhlYWx0aHlfKCkge1xyXG4gICAgICAgIGlmICh0aGlzLnNlY29uZGFyeVJlc3BvbnNlc1JlcXVpcmVkXyA8PSAwKSB7XHJcbiAgICAgICAgICAgIHRoaXMubG9nXygnU2Vjb25kYXJ5IGNvbm5lY3Rpb24gaXMgaGVhbHRoeS4nKTtcclxuICAgICAgICAgICAgdGhpcy5pc0hlYWx0aHlfID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5zZWNvbmRhcnlDb25uXy5tYXJrQ29ubmVjdGlvbkhlYWx0aHkoKTtcclxuICAgICAgICAgICAgdGhpcy5wcm9jZWVkV2l0aFVwZ3JhZGVfKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBTZW5kIGEgcGluZyB0byBtYWtlIHN1cmUgdGhlIGNvbm5lY3Rpb24gaXMgaGVhbHRoeS5cclxuICAgICAgICAgICAgdGhpcy5sb2dfKCdzZW5kaW5nIHBpbmcgb24gc2Vjb25kYXJ5LicpO1xyXG4gICAgICAgICAgICB0aGlzLnNlY29uZGFyeUNvbm5fLnNlbmQoeyB0OiAnYycsIGQ6IHsgdDogUElORywgZDoge30gfSB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBwcm9jZWVkV2l0aFVwZ3JhZGVfKCkge1xyXG4gICAgICAgIC8vIHRlbGwgdGhpcyBjb25uZWN0aW9uIHRvIGNvbnNpZGVyIGl0c2VsZiBvcGVuXHJcbiAgICAgICAgdGhpcy5zZWNvbmRhcnlDb25uXy5zdGFydCgpO1xyXG4gICAgICAgIC8vIHNlbmQgYWNrXHJcbiAgICAgICAgdGhpcy5sb2dfKCdzZW5kaW5nIGNsaWVudCBhY2sgb24gc2Vjb25kYXJ5Jyk7XHJcbiAgICAgICAgdGhpcy5zZWNvbmRhcnlDb25uXy5zZW5kKHsgdDogJ2MnLCBkOiB7IHQ6IFNXSVRDSF9BQ0ssIGQ6IHt9IH0gfSk7XHJcbiAgICAgICAgLy8gc2VuZCBlbmQgcGFja2V0IG9uIHByaW1hcnkgdHJhbnNwb3J0LCBzd2l0Y2ggdG8gc2VuZGluZyBvbiB0aGlzIG9uZVxyXG4gICAgICAgIC8vIGNhbiByZWNlaXZlIG9uIHRoaXMgb25lLCBidWZmZXIgcmVzcG9uc2VzIHVudGlsIGVuZCByZWNlaXZlZCBvbiBwcmltYXJ5IHRyYW5zcG9ydFxyXG4gICAgICAgIHRoaXMubG9nXygnRW5kaW5nIHRyYW5zbWlzc2lvbiBvbiBwcmltYXJ5Jyk7XHJcbiAgICAgICAgdGhpcy5jb25uXy5zZW5kKHsgdDogJ2MnLCBkOiB7IHQ6IEVORF9UUkFOU01JU1NJT04sIGQ6IHt9IH0gfSk7XHJcbiAgICAgICAgdGhpcy50eF8gPSB0aGlzLnNlY29uZGFyeUNvbm5fO1xyXG4gICAgICAgIHRoaXMudHJ5Q2xlYW51cENvbm5lY3Rpb24oKTtcclxuICAgIH1cclxuICAgIG9uUHJpbWFyeU1lc3NhZ2VSZWNlaXZlZF8ocGFyc2VkRGF0YSkge1xyXG4gICAgICAgIC8vIE11c3QgcmVmZXIgdG8gcGFyc2VkRGF0YSBwcm9wZXJ0aWVzIGluIHF1b3Rlcywgc28gY2xvc3VyZSBkb2Vzbid0IHRvdWNoIHRoZW0uXHJcbiAgICAgICAgY29uc3QgbGF5ZXIgPSByZXF1aXJlS2V5KCd0JywgcGFyc2VkRGF0YSk7XHJcbiAgICAgICAgY29uc3QgZGF0YSA9IHJlcXVpcmVLZXkoJ2QnLCBwYXJzZWREYXRhKTtcclxuICAgICAgICBpZiAobGF5ZXIgPT09ICdjJykge1xyXG4gICAgICAgICAgICB0aGlzLm9uQ29udHJvbF8oZGF0YSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGxheWVyID09PSAnZCcpIHtcclxuICAgICAgICAgICAgdGhpcy5vbkRhdGFNZXNzYWdlXyhkYXRhKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBvbkRhdGFNZXNzYWdlXyhtZXNzYWdlKSB7XHJcbiAgICAgICAgdGhpcy5vblByaW1hcnlSZXNwb25zZV8oKTtcclxuICAgICAgICAvLyBXZSBkb24ndCBkbyBhbnl0aGluZyB3aXRoIGRhdGEgbWVzc2FnZXMsIGp1c3Qga2ljayB0aGVtIHVwIGEgbGV2ZWxcclxuICAgICAgICB0aGlzLm9uTWVzc2FnZV8obWVzc2FnZSk7XHJcbiAgICB9XHJcbiAgICBvblByaW1hcnlSZXNwb25zZV8oKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmlzSGVhbHRoeV8pIHtcclxuICAgICAgICAgICAgdGhpcy5wcmltYXJ5UmVzcG9uc2VzUmVxdWlyZWRfLS07XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnByaW1hcnlSZXNwb25zZXNSZXF1aXJlZF8gPD0gMCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sb2dfKCdQcmltYXJ5IGNvbm5lY3Rpb24gaXMgaGVhbHRoeS4nKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuaXNIZWFsdGh5XyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvbm5fLm1hcmtDb25uZWN0aW9uSGVhbHRoeSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgb25Db250cm9sXyhjb250cm9sRGF0YSkge1xyXG4gICAgICAgIGNvbnN0IGNtZCA9IHJlcXVpcmVLZXkoTUVTU0FHRV9UWVBFLCBjb250cm9sRGF0YSk7XHJcbiAgICAgICAgaWYgKE1FU1NBR0VfREFUQSBpbiBjb250cm9sRGF0YSkge1xyXG4gICAgICAgICAgICBjb25zdCBwYXlsb2FkID0gY29udHJvbERhdGFbTUVTU0FHRV9EQVRBXTtcclxuICAgICAgICAgICAgaWYgKGNtZCA9PT0gU0VSVkVSX0hFTExPKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9uSGFuZHNoYWtlXyhwYXlsb2FkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChjbWQgPT09IEVORF9UUkFOU01JU1NJT04pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubG9nXygncmVjdmQgZW5kIHRyYW5zbWlzc2lvbiBvbiBwcmltYXJ5Jyk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJ4XyA9IHRoaXMuc2Vjb25kYXJ5Q29ubl87XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucGVuZGluZ0RhdGFNZXNzYWdlcy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25EYXRhTWVzc2FnZV8odGhpcy5wZW5kaW5nRGF0YU1lc3NhZ2VzW2ldKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ0RhdGFNZXNzYWdlcyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgdGhpcy50cnlDbGVhbnVwQ29ubmVjdGlvbigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGNtZCA9PT0gQ09OVFJPTF9TSFVURE9XTikge1xyXG4gICAgICAgICAgICAgICAgLy8gVGhpcyB3YXMgcHJldmlvdXNseSB0aGUgJ29uS2lsbCcgY2FsbGJhY2sgcGFzc2VkIHRvIHRoZSBsb3dlci1sZXZlbCBjb25uZWN0aW9uXHJcbiAgICAgICAgICAgICAgICAvLyBwYXlsb2FkIGluIHRoaXMgY2FzZSBpcyB0aGUgcmVhc29uIGZvciB0aGUgc2h1dGRvd24uIEdlbmVyYWxseSBhIGh1bWFuLXJlYWRhYmxlIGVycm9yXHJcbiAgICAgICAgICAgICAgICB0aGlzLm9uQ29ubmVjdGlvblNodXRkb3duXyhwYXlsb2FkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChjbWQgPT09IENPTlRST0xfUkVTRVQpIHtcclxuICAgICAgICAgICAgICAgIC8vIHBheWxvYWQgaW4gdGhpcyBjYXNlIGlzIHRoZSBob3N0IHdlIHNob3VsZCBjb250YWN0XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9uUmVzZXRfKHBheWxvYWQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGNtZCA9PT0gQ09OVFJPTF9FUlJPUikge1xyXG4gICAgICAgICAgICAgICAgZXJyb3IoJ1NlcnZlciBFcnJvcjogJyArIHBheWxvYWQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGNtZCA9PT0gQ09OVFJPTF9QT05HKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ18oJ2dvdCBwb25nIG9uIHByaW1hcnkuJyk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9uUHJpbWFyeVJlc3BvbnNlXygpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZW5kUGluZ09uUHJpbWFyeUlmTmVjZXNzYXJ5XygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZXJyb3IoJ1Vua25vd24gY29udHJvbCBwYWNrZXQgY29tbWFuZDogJyArIGNtZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSBoYW5kc2hha2UgLSBUaGUgaGFuZHNoYWtlIGRhdGEgcmV0dXJuZWQgZnJvbSB0aGUgc2VydmVyXHJcbiAgICAgKi9cclxuICAgIG9uSGFuZHNoYWtlXyhoYW5kc2hha2UpIHtcclxuICAgICAgICBjb25zdCB0aW1lc3RhbXAgPSBoYW5kc2hha2UudHM7XHJcbiAgICAgICAgY29uc3QgdmVyc2lvbiA9IGhhbmRzaGFrZS52O1xyXG4gICAgICAgIGNvbnN0IGhvc3QgPSBoYW5kc2hha2UuaDtcclxuICAgICAgICB0aGlzLnNlc3Npb25JZCA9IGhhbmRzaGFrZS5zO1xyXG4gICAgICAgIHRoaXMucmVwb0luZm9fLmhvc3QgPSBob3N0O1xyXG4gICAgICAgIC8vIGlmIHdlJ3ZlIGFscmVhZHkgY2xvc2VkIHRoZSBjb25uZWN0aW9uLCB0aGVuIGRvbid0IGJvdGhlciB0cnlpbmcgdG8gcHJvZ3Jlc3MgZnVydGhlclxyXG4gICAgICAgIGlmICh0aGlzLnN0YXRlXyA9PT0gMCAvKiBDT05ORUNUSU5HICovKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY29ubl8uc3RhcnQoKTtcclxuICAgICAgICAgICAgdGhpcy5vbkNvbm5lY3Rpb25Fc3RhYmxpc2hlZF8odGhpcy5jb25uXywgdGltZXN0YW1wKTtcclxuICAgICAgICAgICAgaWYgKFBST1RPQ09MX1ZFUlNJT04gIT09IHZlcnNpb24pIHtcclxuICAgICAgICAgICAgICAgIHdhcm4oJ1Byb3RvY29sIHZlcnNpb24gbWlzbWF0Y2ggZGV0ZWN0ZWQnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBUT0RPOiBkbyB3ZSB3YW50IHRvIHVwZ3JhZGU/IHdoZW4/IG1heWJlIGEgZGVsYXk/XHJcbiAgICAgICAgICAgIHRoaXMudHJ5U3RhcnRVcGdyYWRlXygpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHRyeVN0YXJ0VXBncmFkZV8oKSB7XHJcbiAgICAgICAgY29uc3QgY29ubiA9IHRoaXMudHJhbnNwb3J0TWFuYWdlcl8udXBncmFkZVRyYW5zcG9ydCgpO1xyXG4gICAgICAgIGlmIChjb25uKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhcnRVcGdyYWRlXyhjb25uKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBzdGFydFVwZ3JhZGVfKGNvbm4pIHtcclxuICAgICAgICB0aGlzLnNlY29uZGFyeUNvbm5fID0gbmV3IGNvbm4odGhpcy5uZXh0VHJhbnNwb3J0SWRfKCksIHRoaXMucmVwb0luZm9fLCB0aGlzLmFwcGxpY2F0aW9uSWRfLCB0aGlzLmFwcENoZWNrVG9rZW5fLCB0aGlzLmF1dGhUb2tlbl8sIHRoaXMuc2Vzc2lvbklkKTtcclxuICAgICAgICAvLyBGb3IgY2VydGFpbiB0cmFuc3BvcnRzIChXZWJTb2NrZXRzKSwgd2UgbmVlZCB0byBzZW5kIGFuZCByZWNlaXZlIHNldmVyYWwgbWVzc2FnZXMgYmFjayBhbmQgZm9ydGggYmVmb3JlIHdlXHJcbiAgICAgICAgLy8gY2FuIGNvbnNpZGVyIHRoZSB0cmFuc3BvcnQgaGVhbHRoeS5cclxuICAgICAgICB0aGlzLnNlY29uZGFyeVJlc3BvbnNlc1JlcXVpcmVkXyA9XHJcbiAgICAgICAgICAgIGNvbm5bJ3Jlc3BvbnNlc1JlcXVpcmVkVG9CZUhlYWx0aHknXSB8fCAwO1xyXG4gICAgICAgIGNvbnN0IG9uTWVzc2FnZSA9IHRoaXMuY29ublJlY2VpdmVyXyh0aGlzLnNlY29uZGFyeUNvbm5fKTtcclxuICAgICAgICBjb25zdCBvbkRpc2Nvbm5lY3QgPSB0aGlzLmRpc2Nvbm5SZWNlaXZlcl8odGhpcy5zZWNvbmRhcnlDb25uXyk7XHJcbiAgICAgICAgdGhpcy5zZWNvbmRhcnlDb25uXy5vcGVuKG9uTWVzc2FnZSwgb25EaXNjb25uZWN0KTtcclxuICAgICAgICAvLyBJZiB3ZSBoYXZlbid0IHN1Y2Nlc3NmdWxseSB1cGdyYWRlZCBhZnRlciBVUEdSQURFX1RJTUVPVVQsIGdpdmUgdXAgYW5kIGtpbGwgdGhlIHNlY29uZGFyeS5cclxuICAgICAgICBzZXRUaW1lb3V0Tm9uQmxvY2tpbmcoKCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5zZWNvbmRhcnlDb25uXykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sb2dfKCdUaW1lZCBvdXQgdHJ5aW5nIHRvIHVwZ3JhZGUuJyk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNlY29uZGFyeUNvbm5fLmNsb3NlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LCBNYXRoLmZsb29yKFVQR1JBREVfVElNRU9VVCkpO1xyXG4gICAgfVxyXG4gICAgb25SZXNldF8oaG9zdCkge1xyXG4gICAgICAgIHRoaXMubG9nXygnUmVzZXQgcGFja2V0IHJlY2VpdmVkLiAgTmV3IGhvc3Q6ICcgKyBob3N0KTtcclxuICAgICAgICB0aGlzLnJlcG9JbmZvXy5ob3N0ID0gaG9zdDtcclxuICAgICAgICAvLyBUT0RPOiBpZiB3ZSdyZSBhbHJlYWR5IFwiY29ubmVjdGVkXCIsIHdlIG5lZWQgdG8gdHJpZ2dlciBhIGRpc2Nvbm5lY3QgYXQgdGhlIG5leHQgbGF5ZXIgdXAuXHJcbiAgICAgICAgLy8gV2UgZG9uJ3QgY3VycmVudGx5IHN1cHBvcnQgcmVzZXRzIGFmdGVyIHRoZSBjb25uZWN0aW9uIGhhcyBhbHJlYWR5IGJlZW4gZXN0YWJsaXNoZWRcclxuICAgICAgICBpZiAodGhpcy5zdGF0ZV8gPT09IDEgLyogQ09OTkVDVEVEICovKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY2xvc2UoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIENsb3NlIHdoYXRldmVyIGNvbm5lY3Rpb25zIHdlIGhhdmUgb3BlbiBhbmQgc3RhcnQgYWdhaW4uXHJcbiAgICAgICAgICAgIHRoaXMuY2xvc2VDb25uZWN0aW9uc18oKTtcclxuICAgICAgICAgICAgdGhpcy5zdGFydF8oKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBvbkNvbm5lY3Rpb25Fc3RhYmxpc2hlZF8oY29ubiwgdGltZXN0YW1wKSB7XHJcbiAgICAgICAgdGhpcy5sb2dfKCdSZWFsdGltZSBjb25uZWN0aW9uIGVzdGFibGlzaGVkLicpO1xyXG4gICAgICAgIHRoaXMuY29ubl8gPSBjb25uO1xyXG4gICAgICAgIHRoaXMuc3RhdGVfID0gMSAvKiBDT05ORUNURUQgKi87XHJcbiAgICAgICAgaWYgKHRoaXMub25SZWFkeV8pIHtcclxuICAgICAgICAgICAgdGhpcy5vblJlYWR5Xyh0aW1lc3RhbXAsIHRoaXMuc2Vzc2lvbklkKTtcclxuICAgICAgICAgICAgdGhpcy5vblJlYWR5XyA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIElmIGFmdGVyIDUgc2Vjb25kcyB3ZSBoYXZlbid0IHNlbnQgZW5vdWdoIHJlcXVlc3RzIHRvIHRoZSBzZXJ2ZXIgdG8gZ2V0IHRoZSBjb25uZWN0aW9uIGhlYWx0aHksXHJcbiAgICAgICAgLy8gc2VuZCBzb21lIHBpbmdzLlxyXG4gICAgICAgIGlmICh0aGlzLnByaW1hcnlSZXNwb25zZXNSZXF1aXJlZF8gPT09IDApIHtcclxuICAgICAgICAgICAgdGhpcy5sb2dfKCdQcmltYXJ5IGNvbm5lY3Rpb24gaXMgaGVhbHRoeS4nKTtcclxuICAgICAgICAgICAgdGhpcy5pc0hlYWx0aHlfID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHNldFRpbWVvdXROb25CbG9ja2luZygoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNlbmRQaW5nT25QcmltYXJ5SWZOZWNlc3NhcnlfKCk7XHJcbiAgICAgICAgICAgIH0sIE1hdGguZmxvb3IoREVMQVlfQkVGT1JFX1NFTkRJTkdfRVhUUkFfUkVRVUVTVFMpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBzZW5kUGluZ09uUHJpbWFyeUlmTmVjZXNzYXJ5XygpIHtcclxuICAgICAgICAvLyBJZiB0aGUgY29ubmVjdGlvbiBpc24ndCBjb25zaWRlcmVkIGhlYWx0aHkgeWV0LCB3ZSdsbCBzZW5kIGEgbm9vcCBwaW5nIHBhY2tldCByZXF1ZXN0LlxyXG4gICAgICAgIGlmICghdGhpcy5pc0hlYWx0aHlfICYmIHRoaXMuc3RhdGVfID09PSAxIC8qIENPTk5FQ1RFRCAqLykge1xyXG4gICAgICAgICAgICB0aGlzLmxvZ18oJ3NlbmRpbmcgcGluZyBvbiBwcmltYXJ5LicpO1xyXG4gICAgICAgICAgICB0aGlzLnNlbmREYXRhXyh7IHQ6ICdjJywgZDogeyB0OiBQSU5HLCBkOiB7fSB9IH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIG9uU2Vjb25kYXJ5Q29ubmVjdGlvbkxvc3RfKCkge1xyXG4gICAgICAgIGNvbnN0IGNvbm4gPSB0aGlzLnNlY29uZGFyeUNvbm5fO1xyXG4gICAgICAgIHRoaXMuc2Vjb25kYXJ5Q29ubl8gPSBudWxsO1xyXG4gICAgICAgIGlmICh0aGlzLnR4XyA9PT0gY29ubiB8fCB0aGlzLnJ4XyA9PT0gY29ubikge1xyXG4gICAgICAgICAgICAvLyB3ZSBhcmUgcmVseWluZyBvbiB0aGlzIGNvbm5lY3Rpb24gYWxyZWFkeSBpbiBzb21lIGNhcGFjaXR5LiBUaGVyZWZvcmUsIGEgZmFpbHVyZSBpcyByZWFsXHJcbiAgICAgICAgICAgIHRoaXMuY2xvc2UoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSBldmVyQ29ubmVjdGVkIC0gV2hldGhlciBvciBub3QgdGhlIGNvbm5lY3Rpb24gZXZlciByZWFjaGVkIGEgc2VydmVyLiBVc2VkIHRvIGRldGVybWluZSBpZlxyXG4gICAgICogd2Ugc2hvdWxkIGZsdXNoIHRoZSBob3N0IGNhY2hlXHJcbiAgICAgKi9cclxuICAgIG9uQ29ubmVjdGlvbkxvc3RfKGV2ZXJDb25uZWN0ZWQpIHtcclxuICAgICAgICB0aGlzLmNvbm5fID0gbnVsbDtcclxuICAgICAgICAvLyBOT1RFOiBJRiB5b3UncmUgc2VlaW5nIGEgRmlyZWZveCBlcnJvciBmb3IgdGhpcyBsaW5lLCBJIHRoaW5rIGl0IG1pZ2h0IGJlIGJlY2F1c2UgaXQncyBnZXR0aW5nXHJcbiAgICAgICAgLy8gY2FsbGVkIG9uIHdpbmRvdyBjbG9zZSBhbmQgUmVhbHRpbWVTdGF0ZS5DT05ORUNUSU5HIGlzIG5vIGxvbmdlciBkZWZpbmVkLiAgSnVzdCBhIGd1ZXNzLlxyXG4gICAgICAgIGlmICghZXZlckNvbm5lY3RlZCAmJiB0aGlzLnN0YXRlXyA9PT0gMCAvKiBDT05ORUNUSU5HICovKSB7XHJcbiAgICAgICAgICAgIHRoaXMubG9nXygnUmVhbHRpbWUgY29ubmVjdGlvbiBmYWlsZWQuJyk7XHJcbiAgICAgICAgICAgIC8vIFNpbmNlIHdlIGZhaWxlZCB0byBjb25uZWN0IGF0IGFsbCwgY2xlYXIgYW55IGNhY2hlZCBlbnRyeSBmb3IgdGhpcyBuYW1lc3BhY2UgaW4gY2FzZSB0aGUgbWFjaGluZSB3ZW50IGF3YXlcclxuICAgICAgICAgICAgaWYgKHRoaXMucmVwb0luZm9fLmlzQ2FjaGVhYmxlSG9zdCgpKSB7XHJcbiAgICAgICAgICAgICAgICBQZXJzaXN0ZW50U3RvcmFnZS5yZW1vdmUoJ2hvc3Q6JyArIHRoaXMucmVwb0luZm9fLmhvc3QpO1xyXG4gICAgICAgICAgICAgICAgLy8gcmVzZXQgdGhlIGludGVybmFsIGhvc3QgdG8gd2hhdCB3ZSB3b3VsZCBzaG93IHRoZSB1c2VyLCBpLmUuIDxucz4uZmlyZWJhc2Vpby5jb21cclxuICAgICAgICAgICAgICAgIHRoaXMucmVwb0luZm9fLmludGVybmFsSG9zdCA9IHRoaXMucmVwb0luZm9fLmhvc3Q7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodGhpcy5zdGF0ZV8gPT09IDEgLyogQ09OTkVDVEVEICovKSB7XHJcbiAgICAgICAgICAgIHRoaXMubG9nXygnUmVhbHRpbWUgY29ubmVjdGlvbiBsb3N0LicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmNsb3NlKCk7XHJcbiAgICB9XHJcbiAgICBvbkNvbm5lY3Rpb25TaHV0ZG93bl8ocmVhc29uKSB7XHJcbiAgICAgICAgdGhpcy5sb2dfKCdDb25uZWN0aW9uIHNodXRkb3duIGNvbW1hbmQgcmVjZWl2ZWQuIFNodXR0aW5nIGRvd24uLi4nKTtcclxuICAgICAgICBpZiAodGhpcy5vbktpbGxfKSB7XHJcbiAgICAgICAgICAgIHRoaXMub25LaWxsXyhyZWFzb24pO1xyXG4gICAgICAgICAgICB0aGlzLm9uS2lsbF8gPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBXZSBpbnRlbnRpb25hbGx5IGRvbid0IHdhbnQgdG8gZmlyZSBvbkRpc2Nvbm5lY3QgKGtpbGwgaXMgYSBkaWZmZXJlbnQgY2FzZSksXHJcbiAgICAgICAgLy8gc28gY2xlYXIgdGhlIGNhbGxiYWNrLlxyXG4gICAgICAgIHRoaXMub25EaXNjb25uZWN0XyA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5jbG9zZSgpO1xyXG4gICAgfVxyXG4gICAgc2VuZERhdGFfKGRhdGEpIHtcclxuICAgICAgICBpZiAodGhpcy5zdGF0ZV8gIT09IDEgLyogQ09OTkVDVEVEICovKSB7XHJcbiAgICAgICAgICAgIHRocm93ICdDb25uZWN0aW9uIGlzIG5vdCBjb25uZWN0ZWQnO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy50eF8uc2VuZChkYXRhKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENsZWFucyB1cCB0aGlzIGNvbm5lY3Rpb24sIGNhbGxpbmcgdGhlIGFwcHJvcHJpYXRlIGNhbGxiYWNrc1xyXG4gICAgICovXHJcbiAgICBjbG9zZSgpIHtcclxuICAgICAgICBpZiAodGhpcy5zdGF0ZV8gIT09IDIgLyogRElTQ09OTkVDVEVEICovKSB7XHJcbiAgICAgICAgICAgIHRoaXMubG9nXygnQ2xvc2luZyByZWFsdGltZSBjb25uZWN0aW9uLicpO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlXyA9IDIgLyogRElTQ09OTkVDVEVEICovO1xyXG4gICAgICAgICAgICB0aGlzLmNsb3NlQ29ubmVjdGlvbnNfKCk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLm9uRGlzY29ubmVjdF8pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMub25EaXNjb25uZWN0XygpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vbkRpc2Nvbm5lY3RfID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGNsb3NlQ29ubmVjdGlvbnNfKCkge1xyXG4gICAgICAgIHRoaXMubG9nXygnU2h1dHRpbmcgZG93biBhbGwgY29ubmVjdGlvbnMnKTtcclxuICAgICAgICBpZiAodGhpcy5jb25uXykge1xyXG4gICAgICAgICAgICB0aGlzLmNvbm5fLmNsb3NlKCk7XHJcbiAgICAgICAgICAgIHRoaXMuY29ubl8gPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5zZWNvbmRhcnlDb25uXykge1xyXG4gICAgICAgICAgICB0aGlzLnNlY29uZGFyeUNvbm5fLmNsb3NlKCk7XHJcbiAgICAgICAgICAgIHRoaXMuc2Vjb25kYXJ5Q29ubl8gPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5oZWFsdGh5VGltZW91dF8pIHtcclxuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuaGVhbHRoeVRpbWVvdXRfKTtcclxuICAgICAgICAgICAgdGhpcy5oZWFsdGh5VGltZW91dF8gPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogSW50ZXJmYWNlIGRlZmluaW5nIHRoZSBzZXQgb2YgYWN0aW9ucyB0aGF0IGNhbiBiZSBwZXJmb3JtZWQgYWdhaW5zdCB0aGUgRmlyZWJhc2Ugc2VydmVyXHJcbiAqIChiYXNpY2FsbHkgY29ycmVzcG9uZHMgdG8gb3VyIHdpcmUgcHJvdG9jb2wpLlxyXG4gKlxyXG4gKiBAaW50ZXJmYWNlXHJcbiAqL1xyXG5jbGFzcyBTZXJ2ZXJBY3Rpb25zIHtcclxuICAgIHB1dChwYXRoU3RyaW5nLCBkYXRhLCBvbkNvbXBsZXRlLCBoYXNoKSB7IH1cclxuICAgIG1lcmdlKHBhdGhTdHJpbmcsIGRhdGEsIG9uQ29tcGxldGUsIGhhc2gpIHsgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWZyZXNoZXMgdGhlIGF1dGggdG9rZW4gZm9yIHRoZSBjdXJyZW50IGNvbm5lY3Rpb24uXHJcbiAgICAgKiBAcGFyYW0gdG9rZW4gLSBUaGUgYXV0aGVudGljYXRpb24gdG9rZW5cclxuICAgICAqL1xyXG4gICAgcmVmcmVzaEF1dGhUb2tlbih0b2tlbikgeyB9XHJcbiAgICAvKipcclxuICAgICAqIFJlZnJlc2hlcyB0aGUgYXBwIGNoZWNrIHRva2VuIGZvciB0aGUgY3VycmVudCBjb25uZWN0aW9uLlxyXG4gICAgICogQHBhcmFtIHRva2VuIFRoZSBhcHAgY2hlY2sgdG9rZW5cclxuICAgICAqL1xyXG4gICAgcmVmcmVzaEFwcENoZWNrVG9rZW4odG9rZW4pIHsgfVxyXG4gICAgb25EaXNjb25uZWN0UHV0KHBhdGhTdHJpbmcsIGRhdGEsIG9uQ29tcGxldGUpIHsgfVxyXG4gICAgb25EaXNjb25uZWN0TWVyZ2UocGF0aFN0cmluZywgZGF0YSwgb25Db21wbGV0ZSkgeyB9XHJcbiAgICBvbkRpc2Nvbm5lY3RDYW5jZWwocGF0aFN0cmluZywgb25Db21wbGV0ZSkgeyB9XHJcbiAgICByZXBvcnRTdGF0cyhzdGF0cykgeyB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIEJhc2UgY2xhc3MgdG8gYmUgdXNlZCBpZiB5b3Ugd2FudCB0byBlbWl0IGV2ZW50cy4gQ2FsbCB0aGUgY29uc3RydWN0b3Igd2l0aFxyXG4gKiB0aGUgc2V0IG9mIGFsbG93ZWQgZXZlbnQgbmFtZXMuXHJcbiAqL1xyXG5jbGFzcyBFdmVudEVtaXR0ZXIge1xyXG4gICAgY29uc3RydWN0b3IoYWxsb3dlZEV2ZW50c18pIHtcclxuICAgICAgICB0aGlzLmFsbG93ZWRFdmVudHNfID0gYWxsb3dlZEV2ZW50c187XHJcbiAgICAgICAgdGhpcy5saXN0ZW5lcnNfID0ge307XHJcbiAgICAgICAgYXNzZXJ0KEFycmF5LmlzQXJyYXkoYWxsb3dlZEV2ZW50c18pICYmIGFsbG93ZWRFdmVudHNfLmxlbmd0aCA+IDAsICdSZXF1aXJlcyBhIG5vbi1lbXB0eSBhcnJheScpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUbyBiZSBjYWxsZWQgYnkgZGVyaXZlZCBjbGFzc2VzIHRvIHRyaWdnZXIgZXZlbnRzLlxyXG4gICAgICovXHJcbiAgICB0cmlnZ2VyKGV2ZW50VHlwZSwgLi4udmFyQXJncykge1xyXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRoaXMubGlzdGVuZXJzX1tldmVudFR5cGVdKSkge1xyXG4gICAgICAgICAgICAvLyBDbG9uZSB0aGUgbGlzdCwgc2luY2UgY2FsbGJhY2tzIGNvdWxkIGFkZC9yZW1vdmUgbGlzdGVuZXJzLlxyXG4gICAgICAgICAgICBjb25zdCBsaXN0ZW5lcnMgPSBbLi4udGhpcy5saXN0ZW5lcnNfW2V2ZW50VHlwZV1dO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpc3RlbmVycy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgbGlzdGVuZXJzW2ldLmNhbGxiYWNrLmFwcGx5KGxpc3RlbmVyc1tpXS5jb250ZXh0LCB2YXJBcmdzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIG9uKGV2ZW50VHlwZSwgY2FsbGJhY2ssIGNvbnRleHQpIHtcclxuICAgICAgICB0aGlzLnZhbGlkYXRlRXZlbnRUeXBlXyhldmVudFR5cGUpO1xyXG4gICAgICAgIHRoaXMubGlzdGVuZXJzX1tldmVudFR5cGVdID0gdGhpcy5saXN0ZW5lcnNfW2V2ZW50VHlwZV0gfHwgW107XHJcbiAgICAgICAgdGhpcy5saXN0ZW5lcnNfW2V2ZW50VHlwZV0ucHVzaCh7IGNhbGxiYWNrLCBjb250ZXh0IH0pO1xyXG4gICAgICAgIGNvbnN0IGV2ZW50RGF0YSA9IHRoaXMuZ2V0SW5pdGlhbEV2ZW50KGV2ZW50VHlwZSk7XHJcbiAgICAgICAgaWYgKGV2ZW50RGF0YSkge1xyXG4gICAgICAgICAgICBjYWxsYmFjay5hcHBseShjb250ZXh0LCBldmVudERhdGEpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIG9mZihldmVudFR5cGUsIGNhbGxiYWNrLCBjb250ZXh0KSB7XHJcbiAgICAgICAgdGhpcy52YWxpZGF0ZUV2ZW50VHlwZV8oZXZlbnRUeXBlKTtcclxuICAgICAgICBjb25zdCBsaXN0ZW5lcnMgPSB0aGlzLmxpc3RlbmVyc19bZXZlbnRUeXBlXSB8fCBbXTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpc3RlbmVycy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAobGlzdGVuZXJzW2ldLmNhbGxiYWNrID09PSBjYWxsYmFjayAmJlxyXG4gICAgICAgICAgICAgICAgKCFjb250ZXh0IHx8IGNvbnRleHQgPT09IGxpc3RlbmVyc1tpXS5jb250ZXh0KSkge1xyXG4gICAgICAgICAgICAgICAgbGlzdGVuZXJzLnNwbGljZShpLCAxKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHZhbGlkYXRlRXZlbnRUeXBlXyhldmVudFR5cGUpIHtcclxuICAgICAgICBhc3NlcnQodGhpcy5hbGxvd2VkRXZlbnRzXy5maW5kKGV0ID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIGV0ID09PSBldmVudFR5cGU7XHJcbiAgICAgICAgfSksICdVbmtub3duIGV2ZW50OiAnICsgZXZlbnRUeXBlKTtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogTW9uaXRvcnMgb25saW5lIHN0YXRlIChhcyByZXBvcnRlZCBieSB3aW5kb3cub25saW5lL29mZmxpbmUgZXZlbnRzKS5cclxuICpcclxuICogVGhlIGV4cGVjdGF0aW9uIGlzIHRoYXQgdGhpcyBjb3VsZCBoYXZlIG1hbnkgZmFsc2UgcG9zaXRpdmVzICh0aGlua3Mgd2UgYXJlIG9ubGluZVxyXG4gKiB3aGVuIHdlJ3JlIG5vdCksIGJ1dCBubyBmYWxzZSBuZWdhdGl2ZXMuICBTbyB3ZSBjYW4gc2FmZWx5IHVzZSBpdCB0byBkZXRlcm1pbmUgd2hlblxyXG4gKiB3ZSBkZWZpbml0ZWx5IGNhbm5vdCByZWFjaCB0aGUgaW50ZXJuZXQuXHJcbiAqL1xyXG5jbGFzcyBPbmxpbmVNb25pdG9yIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKFsnb25saW5lJ10pO1xyXG4gICAgICAgIHRoaXMub25saW5lXyA9IHRydWU7XHJcbiAgICAgICAgLy8gV2UndmUgaGFkIHJlcGVhdGVkIGNvbXBsYWludHMgdGhhdCBDb3Jkb3ZhIGFwcHMgY2FuIGdldCBzdHVjayBcIm9mZmxpbmVcIiwgZS5nLlxyXG4gICAgICAgIC8vIGh0dHBzOi8vZm9ydW0uaW9uaWNmcmFtZXdvcmsuY29tL3QvZmlyZWJhc2UtY29ubmVjdGlvbi1pcy1sb3N0LWFuZC1uZXZlci1jb21lLWJhY2svNDM4MTBcclxuICAgICAgICAvLyBJdCB3b3VsZCBzZWVtIHRoYXQgdGhlICdvbmxpbmUnIGV2ZW50IGRvZXMgbm90IGFsd2F5cyBmaXJlIGNvbnNpc3RlbnRseS4gU28gd2UgZGlzYWJsZSBpdFxyXG4gICAgICAgIC8vIGZvciBDb3Jkb3ZhLlxyXG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJlxyXG4gICAgICAgICAgICB0eXBlb2Ygd2luZG93LmFkZEV2ZW50TGlzdGVuZXIgIT09ICd1bmRlZmluZWQnICYmXHJcbiAgICAgICAgICAgICFpc01vYmlsZUNvcmRvdmEoKSkge1xyXG4gICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignb25saW5lJywgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLm9ubGluZV8pIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9ubGluZV8gPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHJpZ2dlcignb25saW5lJywgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sIGZhbHNlKTtcclxuICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ29mZmxpbmUnLCAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vbmxpbmVfKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vbmxpbmVfID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50cmlnZ2VyKCdvbmxpbmUnLCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sIGZhbHNlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgZ2V0SW5zdGFuY2UoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBPbmxpbmVNb25pdG9yKCk7XHJcbiAgICB9XHJcbiAgICBnZXRJbml0aWFsRXZlbnQoZXZlbnRUeXBlKSB7XHJcbiAgICAgICAgYXNzZXJ0KGV2ZW50VHlwZSA9PT0gJ29ubGluZScsICdVbmtub3duIGV2ZW50IHR5cGU6ICcgKyBldmVudFR5cGUpO1xyXG4gICAgICAgIHJldHVybiBbdGhpcy5vbmxpbmVfXTtcclxuICAgIH1cclxuICAgIGN1cnJlbnRseU9ubGluZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5vbmxpbmVfO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKiBNYXhpbXVtIGtleSBkZXB0aC4gKi9cclxuY29uc3QgTUFYX1BBVEhfREVQVEggPSAzMjtcclxuLyoqIE1heGltdW0gbnVtYmVyIG9mIChVVEY4KSBieXRlcyBpbiBhIEZpcmViYXNlIHBhdGguICovXHJcbmNvbnN0IE1BWF9QQVRIX0xFTkdUSF9CWVRFUyA9IDc2ODtcclxuLyoqXHJcbiAqIEFuIGltbXV0YWJsZSBvYmplY3QgcmVwcmVzZW50aW5nIGEgcGFyc2VkIHBhdGguICBJdCdzIGltbXV0YWJsZSBzbyB0aGF0IHlvdVxyXG4gKiBjYW4gcGFzcyB0aGVtIGFyb3VuZCB0byBvdGhlciBmdW5jdGlvbnMgd2l0aG91dCB3b3JyeWluZyBhYm91dCB0aGVtIGNoYW5naW5nXHJcbiAqIGl0LlxyXG4gKi9cclxuY2xhc3MgUGF0aCB7XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSBwYXRoT3JTdHJpbmcgLSBQYXRoIHN0cmluZyB0byBwYXJzZSwgb3IgYW5vdGhlciBwYXRoLCBvciB0aGUgcmF3XHJcbiAgICAgKiB0b2tlbnMgYXJyYXlcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IocGF0aE9yU3RyaW5nLCBwaWVjZU51bSkge1xyXG4gICAgICAgIGlmIChwaWVjZU51bSA9PT0gdm9pZCAwKSB7XHJcbiAgICAgICAgICAgIHRoaXMucGllY2VzXyA9IHBhdGhPclN0cmluZy5zcGxpdCgnLycpO1xyXG4gICAgICAgICAgICAvLyBSZW1vdmUgZW1wdHkgcGllY2VzLlxyXG4gICAgICAgICAgICBsZXQgY29weVRvID0gMDtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnBpZWNlc18ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnBpZWNlc19baV0ubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGllY2VzX1tjb3B5VG9dID0gdGhpcy5waWVjZXNfW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvcHlUbysrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMucGllY2VzXy5sZW5ndGggPSBjb3B5VG87XHJcbiAgICAgICAgICAgIHRoaXMucGllY2VOdW1fID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMucGllY2VzXyA9IHBhdGhPclN0cmluZztcclxuICAgICAgICAgICAgdGhpcy5waWVjZU51bV8gPSBwaWVjZU51bTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICB0b1N0cmluZygpIHtcclxuICAgICAgICBsZXQgcGF0aFN0cmluZyA9ICcnO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLnBpZWNlTnVtXzsgaSA8IHRoaXMucGllY2VzXy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5waWVjZXNfW2ldICE9PSAnJykge1xyXG4gICAgICAgICAgICAgICAgcGF0aFN0cmluZyArPSAnLycgKyB0aGlzLnBpZWNlc19baV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHBhdGhTdHJpbmcgfHwgJy8nO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIG5ld0VtcHR5UGF0aCgpIHtcclxuICAgIHJldHVybiBuZXcgUGF0aCgnJyk7XHJcbn1cclxuZnVuY3Rpb24gcGF0aEdldEZyb250KHBhdGgpIHtcclxuICAgIGlmIChwYXRoLnBpZWNlTnVtXyA+PSBwYXRoLnBpZWNlc18ubGVuZ3RoKSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcGF0aC5waWVjZXNfW3BhdGgucGllY2VOdW1fXTtcclxufVxyXG4vKipcclxuICogQHJldHVybnMgVGhlIG51bWJlciBvZiBzZWdtZW50cyBpbiB0aGlzIHBhdGhcclxuICovXHJcbmZ1bmN0aW9uIHBhdGhHZXRMZW5ndGgocGF0aCkge1xyXG4gICAgcmV0dXJuIHBhdGgucGllY2VzXy5sZW5ndGggLSBwYXRoLnBpZWNlTnVtXztcclxufVxyXG5mdW5jdGlvbiBwYXRoUG9wRnJvbnQocGF0aCkge1xyXG4gICAgbGV0IHBpZWNlTnVtID0gcGF0aC5waWVjZU51bV87XHJcbiAgICBpZiAocGllY2VOdW0gPCBwYXRoLnBpZWNlc18ubGVuZ3RoKSB7XHJcbiAgICAgICAgcGllY2VOdW0rKztcclxuICAgIH1cclxuICAgIHJldHVybiBuZXcgUGF0aChwYXRoLnBpZWNlc18sIHBpZWNlTnVtKTtcclxufVxyXG5mdW5jdGlvbiBwYXRoR2V0QmFjayhwYXRoKSB7XHJcbiAgICBpZiAocGF0aC5waWVjZU51bV8gPCBwYXRoLnBpZWNlc18ubGVuZ3RoKSB7XHJcbiAgICAgICAgcmV0dXJuIHBhdGgucGllY2VzX1twYXRoLnBpZWNlc18ubGVuZ3RoIC0gMV07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbnVsbDtcclxufVxyXG5mdW5jdGlvbiBwYXRoVG9VcmxFbmNvZGVkU3RyaW5nKHBhdGgpIHtcclxuICAgIGxldCBwYXRoU3RyaW5nID0gJyc7XHJcbiAgICBmb3IgKGxldCBpID0gcGF0aC5waWVjZU51bV87IGkgPCBwYXRoLnBpZWNlc18ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBpZiAocGF0aC5waWVjZXNfW2ldICE9PSAnJykge1xyXG4gICAgICAgICAgICBwYXRoU3RyaW5nICs9ICcvJyArIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcocGF0aC5waWVjZXNfW2ldKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHBhdGhTdHJpbmcgfHwgJy8nO1xyXG59XHJcbi8qKlxyXG4gKiBTaGFsbG93IGNvcHkgb2YgdGhlIHBhcnRzIG9mIHRoZSBwYXRoLlxyXG4gKlxyXG4gKi9cclxuZnVuY3Rpb24gcGF0aFNsaWNlKHBhdGgsIGJlZ2luID0gMCkge1xyXG4gICAgcmV0dXJuIHBhdGgucGllY2VzXy5zbGljZShwYXRoLnBpZWNlTnVtXyArIGJlZ2luKTtcclxufVxyXG5mdW5jdGlvbiBwYXRoUGFyZW50KHBhdGgpIHtcclxuICAgIGlmIChwYXRoLnBpZWNlTnVtXyA+PSBwYXRoLnBpZWNlc18ubGVuZ3RoKSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICBjb25zdCBwaWVjZXMgPSBbXTtcclxuICAgIGZvciAobGV0IGkgPSBwYXRoLnBpZWNlTnVtXzsgaSA8IHBhdGgucGllY2VzXy5sZW5ndGggLSAxOyBpKyspIHtcclxuICAgICAgICBwaWVjZXMucHVzaChwYXRoLnBpZWNlc19baV0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG5ldyBQYXRoKHBpZWNlcywgMCk7XHJcbn1cclxuZnVuY3Rpb24gcGF0aENoaWxkKHBhdGgsIGNoaWxkUGF0aE9iaikge1xyXG4gICAgY29uc3QgcGllY2VzID0gW107XHJcbiAgICBmb3IgKGxldCBpID0gcGF0aC5waWVjZU51bV87IGkgPCBwYXRoLnBpZWNlc18ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBwaWVjZXMucHVzaChwYXRoLnBpZWNlc19baV0pO1xyXG4gICAgfVxyXG4gICAgaWYgKGNoaWxkUGF0aE9iaiBpbnN0YW5jZW9mIFBhdGgpIHtcclxuICAgICAgICBmb3IgKGxldCBpID0gY2hpbGRQYXRoT2JqLnBpZWNlTnVtXzsgaSA8IGNoaWxkUGF0aE9iai5waWVjZXNfLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHBpZWNlcy5wdXNoKGNoaWxkUGF0aE9iai5waWVjZXNfW2ldKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBjb25zdCBjaGlsZFBpZWNlcyA9IGNoaWxkUGF0aE9iai5zcGxpdCgnLycpO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRQaWVjZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKGNoaWxkUGllY2VzW2ldLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgIHBpZWNlcy5wdXNoKGNoaWxkUGllY2VzW2ldKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBuZXcgUGF0aChwaWVjZXMsIDApO1xyXG59XHJcbi8qKlxyXG4gKiBAcmV0dXJucyBUcnVlIGlmIHRoZXJlIGFyZSBubyBzZWdtZW50cyBpbiB0aGlzIHBhdGhcclxuICovXHJcbmZ1bmN0aW9uIHBhdGhJc0VtcHR5KHBhdGgpIHtcclxuICAgIHJldHVybiBwYXRoLnBpZWNlTnVtXyA+PSBwYXRoLnBpZWNlc18ubGVuZ3RoO1xyXG59XHJcbi8qKlxyXG4gKiBAcmV0dXJucyBUaGUgcGF0aCBmcm9tIG91dGVyUGF0aCB0byBpbm5lclBhdGhcclxuICovXHJcbmZ1bmN0aW9uIG5ld1JlbGF0aXZlUGF0aChvdXRlclBhdGgsIGlubmVyUGF0aCkge1xyXG4gICAgY29uc3Qgb3V0ZXIgPSBwYXRoR2V0RnJvbnQob3V0ZXJQYXRoKSwgaW5uZXIgPSBwYXRoR2V0RnJvbnQoaW5uZXJQYXRoKTtcclxuICAgIGlmIChvdXRlciA9PT0gbnVsbCkge1xyXG4gICAgICAgIHJldHVybiBpbm5lclBhdGg7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChvdXRlciA9PT0gaW5uZXIpIHtcclxuICAgICAgICByZXR1cm4gbmV3UmVsYXRpdmVQYXRoKHBhdGhQb3BGcm9udChvdXRlclBhdGgpLCBwYXRoUG9wRnJvbnQoaW5uZXJQYXRoKSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lOVEVSTkFMIEVSUk9SOiBpbm5lclBhdGggKCcgK1xyXG4gICAgICAgICAgICBpbm5lclBhdGggK1xyXG4gICAgICAgICAgICAnKSBpcyBub3Qgd2l0aGluICcgK1xyXG4gICAgICAgICAgICAnb3V0ZXJQYXRoICgnICtcclxuICAgICAgICAgICAgb3V0ZXJQYXRoICtcclxuICAgICAgICAgICAgJyknKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQHJldHVybnMgLTEsIDAsIDEgaWYgbGVmdCBpcyBsZXNzLCBlcXVhbCwgb3IgZ3JlYXRlciB0aGFuIHRoZSByaWdodC5cclxuICovXHJcbmZ1bmN0aW9uIHBhdGhDb21wYXJlKGxlZnQsIHJpZ2h0KSB7XHJcbiAgICBjb25zdCBsZWZ0S2V5cyA9IHBhdGhTbGljZShsZWZ0LCAwKTtcclxuICAgIGNvbnN0IHJpZ2h0S2V5cyA9IHBhdGhTbGljZShyaWdodCwgMCk7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlZnRLZXlzLmxlbmd0aCAmJiBpIDwgcmlnaHRLZXlzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY29uc3QgY21wID0gbmFtZUNvbXBhcmUobGVmdEtleXNbaV0sIHJpZ2h0S2V5c1tpXSk7XHJcbiAgICAgICAgaWYgKGNtcCAhPT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gY21wO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChsZWZ0S2V5cy5sZW5ndGggPT09IHJpZ2h0S2V5cy5sZW5ndGgpIHtcclxuICAgICAgICByZXR1cm4gMDtcclxuICAgIH1cclxuICAgIHJldHVybiBsZWZ0S2V5cy5sZW5ndGggPCByaWdodEtleXMubGVuZ3RoID8gLTEgOiAxO1xyXG59XHJcbi8qKlxyXG4gKiBAcmV0dXJucyB0cnVlIGlmIHBhdGhzIGFyZSB0aGUgc2FtZS5cclxuICovXHJcbmZ1bmN0aW9uIHBhdGhFcXVhbHMocGF0aCwgb3RoZXIpIHtcclxuICAgIGlmIChwYXRoR2V0TGVuZ3RoKHBhdGgpICE9PSBwYXRoR2V0TGVuZ3RoKG90aGVyKSkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIGZvciAobGV0IGkgPSBwYXRoLnBpZWNlTnVtXywgaiA9IG90aGVyLnBpZWNlTnVtXzsgaSA8PSBwYXRoLnBpZWNlc18ubGVuZ3RoOyBpKyssIGorKykge1xyXG4gICAgICAgIGlmIChwYXRoLnBpZWNlc19baV0gIT09IG90aGVyLnBpZWNlc19bal0pIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB0cnVlO1xyXG59XHJcbi8qKlxyXG4gKiBAcmV0dXJucyBUcnVlIGlmIHRoaXMgcGF0aCBpcyBhIHBhcmVudCAob3IgdGhlIHNhbWUgYXMpIG90aGVyXHJcbiAqL1xyXG5mdW5jdGlvbiBwYXRoQ29udGFpbnMocGF0aCwgb3RoZXIpIHtcclxuICAgIGxldCBpID0gcGF0aC5waWVjZU51bV87XHJcbiAgICBsZXQgaiA9IG90aGVyLnBpZWNlTnVtXztcclxuICAgIGlmIChwYXRoR2V0TGVuZ3RoKHBhdGgpID4gcGF0aEdldExlbmd0aChvdGhlcikpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICB3aGlsZSAoaSA8IHBhdGgucGllY2VzXy5sZW5ndGgpIHtcclxuICAgICAgICBpZiAocGF0aC5waWVjZXNfW2ldICE9PSBvdGhlci5waWVjZXNfW2pdKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgKytpO1xyXG4gICAgICAgICsrajtcclxuICAgIH1cclxuICAgIHJldHVybiB0cnVlO1xyXG59XHJcbi8qKlxyXG4gKiBEeW5hbWljIChtdXRhYmxlKSBwYXRoIHVzZWQgdG8gY291bnQgcGF0aCBsZW5ndGhzLlxyXG4gKlxyXG4gKiBUaGlzIGNsYXNzIGlzIHVzZWQgdG8gZWZmaWNpZW50bHkgY2hlY2sgcGF0aHMgZm9yIHZhbGlkXHJcbiAqIGxlbmd0aCAoaW4gVVRGOCBieXRlcykgYW5kIGRlcHRoICh1c2VkIGluIHBhdGggdmFsaWRhdGlvbikuXHJcbiAqXHJcbiAqIFRocm93cyBFcnJvciBleGNlcHRpb24gaWYgcGF0aCBpcyBldmVyIGludmFsaWQuXHJcbiAqXHJcbiAqIFRoZSBkZWZpbml0aW9uIG9mIGEgcGF0aCBhbHdheXMgYmVnaW5zIHdpdGggJy8nLlxyXG4gKi9cclxuY2xhc3MgVmFsaWRhdGlvblBhdGgge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gcGF0aCAtIEluaXRpYWwgUGF0aC5cclxuICAgICAqIEBwYXJhbSBlcnJvclByZWZpeF8gLSBQcmVmaXggZm9yIGFueSBlcnJvciBtZXNzYWdlcy5cclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IocGF0aCwgZXJyb3JQcmVmaXhfKSB7XHJcbiAgICAgICAgdGhpcy5lcnJvclByZWZpeF8gPSBlcnJvclByZWZpeF87XHJcbiAgICAgICAgdGhpcy5wYXJ0c18gPSBwYXRoU2xpY2UocGF0aCwgMCk7XHJcbiAgICAgICAgLyoqIEluaXRpYWxpemUgdG8gbnVtYmVyIG9mICcvJyBjaGFycyBuZWVkZWQgaW4gcGF0aC4gKi9cclxuICAgICAgICB0aGlzLmJ5dGVMZW5ndGhfID0gTWF0aC5tYXgoMSwgdGhpcy5wYXJ0c18ubGVuZ3RoKTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucGFydHNfLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYnl0ZUxlbmd0aF8gKz0gc3RyaW5nTGVuZ3RoKHRoaXMucGFydHNfW2ldKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFsaWRhdGlvblBhdGhDaGVja1ZhbGlkKHRoaXMpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHZhbGlkYXRpb25QYXRoUHVzaCh2YWxpZGF0aW9uUGF0aCwgY2hpbGQpIHtcclxuICAgIC8vIENvdW50IHRoZSBuZWVkZWQgJy8nXHJcbiAgICBpZiAodmFsaWRhdGlvblBhdGgucGFydHNfLmxlbmd0aCA+IDApIHtcclxuICAgICAgICB2YWxpZGF0aW9uUGF0aC5ieXRlTGVuZ3RoXyArPSAxO1xyXG4gICAgfVxyXG4gICAgdmFsaWRhdGlvblBhdGgucGFydHNfLnB1c2goY2hpbGQpO1xyXG4gICAgdmFsaWRhdGlvblBhdGguYnl0ZUxlbmd0aF8gKz0gc3RyaW5nTGVuZ3RoKGNoaWxkKTtcclxuICAgIHZhbGlkYXRpb25QYXRoQ2hlY2tWYWxpZCh2YWxpZGF0aW9uUGF0aCk7XHJcbn1cclxuZnVuY3Rpb24gdmFsaWRhdGlvblBhdGhQb3AodmFsaWRhdGlvblBhdGgpIHtcclxuICAgIGNvbnN0IGxhc3QgPSB2YWxpZGF0aW9uUGF0aC5wYXJ0c18ucG9wKCk7XHJcbiAgICB2YWxpZGF0aW9uUGF0aC5ieXRlTGVuZ3RoXyAtPSBzdHJpbmdMZW5ndGgobGFzdCk7XHJcbiAgICAvLyBVbi1jb3VudCB0aGUgcHJldmlvdXMgJy8nXHJcbiAgICBpZiAodmFsaWRhdGlvblBhdGgucGFydHNfLmxlbmd0aCA+IDApIHtcclxuICAgICAgICB2YWxpZGF0aW9uUGF0aC5ieXRlTGVuZ3RoXyAtPSAxO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHZhbGlkYXRpb25QYXRoQ2hlY2tWYWxpZCh2YWxpZGF0aW9uUGF0aCkge1xyXG4gICAgaWYgKHZhbGlkYXRpb25QYXRoLmJ5dGVMZW5ndGhfID4gTUFYX1BBVEhfTEVOR1RIX0JZVEVTKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHZhbGlkYXRpb25QYXRoLmVycm9yUHJlZml4XyArXHJcbiAgICAgICAgICAgICdoYXMgYSBrZXkgcGF0aCBsb25nZXIgdGhhbiAnICtcclxuICAgICAgICAgICAgTUFYX1BBVEhfTEVOR1RIX0JZVEVTICtcclxuICAgICAgICAgICAgJyBieXRlcyAoJyArXHJcbiAgICAgICAgICAgIHZhbGlkYXRpb25QYXRoLmJ5dGVMZW5ndGhfICtcclxuICAgICAgICAgICAgJykuJyk7XHJcbiAgICB9XHJcbiAgICBpZiAodmFsaWRhdGlvblBhdGgucGFydHNfLmxlbmd0aCA+IE1BWF9QQVRIX0RFUFRIKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHZhbGlkYXRpb25QYXRoLmVycm9yUHJlZml4XyArXHJcbiAgICAgICAgICAgICdwYXRoIHNwZWNpZmllZCBleGNlZWRzIHRoZSBtYXhpbXVtIGRlcHRoIHRoYXQgY2FuIGJlIHdyaXR0ZW4gKCcgK1xyXG4gICAgICAgICAgICBNQVhfUEFUSF9ERVBUSCArXHJcbiAgICAgICAgICAgICcpIG9yIG9iamVjdCBjb250YWlucyBhIGN5Y2xlICcgK1xyXG4gICAgICAgICAgICB2YWxpZGF0aW9uUGF0aFRvRXJyb3JTdHJpbmcodmFsaWRhdGlvblBhdGgpKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogU3RyaW5nIGZvciB1c2UgaW4gZXJyb3IgbWVzc2FnZXMgLSB1c2VzICcuJyBub3RhdGlvbiBmb3IgcGF0aC5cclxuICovXHJcbmZ1bmN0aW9uIHZhbGlkYXRpb25QYXRoVG9FcnJvclN0cmluZyh2YWxpZGF0aW9uUGF0aCkge1xyXG4gICAgaWYgKHZhbGlkYXRpb25QYXRoLnBhcnRzXy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICByZXR1cm4gJyc7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gXCJpbiBwcm9wZXJ0eSAnXCIgKyB2YWxpZGF0aW9uUGF0aC5wYXJ0c18uam9pbignLicpICsgXCInXCI7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuY2xhc3MgVmlzaWJpbGl0eU1vbml0b3IgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoWyd2aXNpYmxlJ10pO1xyXG4gICAgICAgIGxldCBoaWRkZW47XHJcbiAgICAgICAgbGV0IHZpc2liaWxpdHlDaGFuZ2U7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiZcclxuICAgICAgICAgICAgdHlwZW9mIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZG9jdW1lbnRbJ2hpZGRlbiddICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICAgICAgLy8gT3BlcmEgMTIuMTAgYW5kIEZpcmVmb3ggMTggYW5kIGxhdGVyIHN1cHBvcnRcclxuICAgICAgICAgICAgICAgIHZpc2liaWxpdHlDaGFuZ2UgPSAndmlzaWJpbGl0eWNoYW5nZSc7XHJcbiAgICAgICAgICAgICAgICBoaWRkZW4gPSAnaGlkZGVuJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgZG9jdW1lbnRbJ21vekhpZGRlbiddICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICAgICAgdmlzaWJpbGl0eUNoYW5nZSA9ICdtb3p2aXNpYmlsaXR5Y2hhbmdlJztcclxuICAgICAgICAgICAgICAgIGhpZGRlbiA9ICdtb3pIaWRkZW4nO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBkb2N1bWVudFsnbXNIaWRkZW4nXSAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgICAgIHZpc2liaWxpdHlDaGFuZ2UgPSAnbXN2aXNpYmlsaXR5Y2hhbmdlJztcclxuICAgICAgICAgICAgICAgIGhpZGRlbiA9ICdtc0hpZGRlbic7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGRvY3VtZW50Wyd3ZWJraXRIaWRkZW4nXSAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgICAgIHZpc2liaWxpdHlDaGFuZ2UgPSAnd2Via2l0dmlzaWJpbGl0eWNoYW5nZSc7XHJcbiAgICAgICAgICAgICAgICBoaWRkZW4gPSAnd2Via2l0SGlkZGVuJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBJbml0aWFsbHksIHdlIGFsd2F5cyBhc3N1bWUgd2UgYXJlIHZpc2libGUuIFRoaXMgZW5zdXJlcyB0aGF0IGluIGJyb3dzZXJzXHJcbiAgICAgICAgLy8gd2l0aG91dCBwYWdlIHZpc2liaWxpdHkgc3VwcG9ydCBvciBpbiBjYXNlcyB3aGVyZSB3ZSBhcmUgbmV2ZXIgdmlzaWJsZVxyXG4gICAgICAgIC8vIChlLmcuIGNocm9tZSBleHRlbnNpb24pLCB3ZSBhY3QgYXMgaWYgd2UgYXJlIHZpc2libGUsIGkuZS4gZG9uJ3QgZGVsYXlcclxuICAgICAgICAvLyByZWNvbm5lY3RzXHJcbiAgICAgICAgdGhpcy52aXNpYmxlXyA9IHRydWU7XHJcbiAgICAgICAgaWYgKHZpc2liaWxpdHlDaGFuZ2UpIHtcclxuICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcih2aXNpYmlsaXR5Q2hhbmdlLCAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB2aXNpYmxlID0gIWRvY3VtZW50W2hpZGRlbl07XHJcbiAgICAgICAgICAgICAgICBpZiAodmlzaWJsZSAhPT0gdGhpcy52aXNpYmxlXykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmlzaWJsZV8gPSB2aXNpYmxlO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHJpZ2dlcigndmlzaWJsZScsIHZpc2libGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LCBmYWxzZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgc3RhdGljIGdldEluc3RhbmNlKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgVmlzaWJpbGl0eU1vbml0b3IoKTtcclxuICAgIH1cclxuICAgIGdldEluaXRpYWxFdmVudChldmVudFR5cGUpIHtcclxuICAgICAgICBhc3NlcnQoZXZlbnRUeXBlID09PSAndmlzaWJsZScsICdVbmtub3duIGV2ZW50IHR5cGU6ICcgKyBldmVudFR5cGUpO1xyXG4gICAgICAgIHJldHVybiBbdGhpcy52aXNpYmxlX107XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuY29uc3QgUkVDT05ORUNUX01JTl9ERUxBWSA9IDEwMDA7XHJcbmNvbnN0IFJFQ09OTkVDVF9NQVhfREVMQVlfREVGQVVMVCA9IDYwICogNSAqIDEwMDA7IC8vIDUgbWludXRlcyBpbiBtaWxsaXNlY29uZHMgKENhc2U6IDE4NTgpXHJcbmNvbnN0IEdFVF9DT05ORUNUX1RJTUVPVVQgPSAzICogMTAwMDtcclxuY29uc3QgUkVDT05ORUNUX01BWF9ERUxBWV9GT1JfQURNSU5TID0gMzAgKiAxMDAwOyAvLyAzMCBzZWNvbmRzIGZvciBhZG1pbiBjbGllbnRzIChsaWtlbHkgdG8gYmUgYSBiYWNrZW5kIHNlcnZlcilcclxuY29uc3QgUkVDT05ORUNUX0RFTEFZX01VTFRJUExJRVIgPSAxLjM7XHJcbmNvbnN0IFJFQ09OTkVDVF9ERUxBWV9SRVNFVF9USU1FT1VUID0gMzAwMDA7IC8vIFJlc2V0IGRlbGF5IGJhY2sgdG8gTUlOX0RFTEFZIGFmdGVyIGJlaW5nIGNvbm5lY3RlZCBmb3IgMzBzZWMuXHJcbmNvbnN0IFNFUlZFUl9LSUxMX0lOVEVSUlVQVF9SRUFTT04gPSAnc2VydmVyX2tpbGwnO1xyXG4vLyBJZiBhdXRoIGZhaWxzIHJlcGVhdGVkbHksIHdlJ2xsIGFzc3VtZSBzb21ldGhpbmcgaXMgd3JvbmcgYW5kIGxvZyBhIHdhcm5pbmcgLyBiYWNrIG9mZi5cclxuY29uc3QgSU5WQUxJRF9UT0tFTl9USFJFU0hPTEQgPSAzO1xyXG4vKipcclxuICogRmlyZWJhc2UgY29ubmVjdGlvbi4gIEFic3RyYWN0cyB3aXJlIHByb3RvY29sIGFuZCBoYW5kbGVzIHJlY29ubmVjdGluZy5cclxuICpcclxuICogTk9URTogQWxsIEpTT04gb2JqZWN0cyBzZW50IHRvIHRoZSByZWFsdGltZSBjb25uZWN0aW9uIG11c3QgaGF2ZSBwcm9wZXJ0eSBuYW1lcyBlbmNsb3NlZFxyXG4gKiBpbiBxdW90ZXMgdG8gbWFrZSBzdXJlIHRoZSBjbG9zdXJlIGNvbXBpbGVyIGRvZXMgbm90IG1pbmlmeSB0aGVtLlxyXG4gKi9cclxuY2xhc3MgUGVyc2lzdGVudENvbm5lY3Rpb24gZXh0ZW5kcyBTZXJ2ZXJBY3Rpb25zIHtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHJlcG9JbmZvXyAtIERhdGEgYWJvdXQgdGhlIG5hbWVzcGFjZSB3ZSBhcmUgY29ubmVjdGluZyB0b1xyXG4gICAgICogQHBhcmFtIGFwcGxpY2F0aW9uSWRfIC0gVGhlIEZpcmViYXNlIEFwcCBJRCBmb3IgdGhpcyBwcm9qZWN0XHJcbiAgICAgKiBAcGFyYW0gb25EYXRhVXBkYXRlXyAtIEEgY2FsbGJhY2sgZm9yIG5ldyBkYXRhIGZyb20gdGhlIHNlcnZlclxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihyZXBvSW5mb18sIGFwcGxpY2F0aW9uSWRfLCBvbkRhdGFVcGRhdGVfLCBvbkNvbm5lY3RTdGF0dXNfLCBvblNlcnZlckluZm9VcGRhdGVfLCBhdXRoVG9rZW5Qcm92aWRlcl8sIGFwcENoZWNrVG9rZW5Qcm92aWRlcl8sIGF1dGhPdmVycmlkZV8pIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMucmVwb0luZm9fID0gcmVwb0luZm9fO1xyXG4gICAgICAgIHRoaXMuYXBwbGljYXRpb25JZF8gPSBhcHBsaWNhdGlvbklkXztcclxuICAgICAgICB0aGlzLm9uRGF0YVVwZGF0ZV8gPSBvbkRhdGFVcGRhdGVfO1xyXG4gICAgICAgIHRoaXMub25Db25uZWN0U3RhdHVzXyA9IG9uQ29ubmVjdFN0YXR1c187XHJcbiAgICAgICAgdGhpcy5vblNlcnZlckluZm9VcGRhdGVfID0gb25TZXJ2ZXJJbmZvVXBkYXRlXztcclxuICAgICAgICB0aGlzLmF1dGhUb2tlblByb3ZpZGVyXyA9IGF1dGhUb2tlblByb3ZpZGVyXztcclxuICAgICAgICB0aGlzLmFwcENoZWNrVG9rZW5Qcm92aWRlcl8gPSBhcHBDaGVja1Rva2VuUHJvdmlkZXJfO1xyXG4gICAgICAgIHRoaXMuYXV0aE92ZXJyaWRlXyA9IGF1dGhPdmVycmlkZV87XHJcbiAgICAgICAgLy8gVXNlZCBmb3IgZGlhZ25vc3RpYyBsb2dnaW5nLlxyXG4gICAgICAgIHRoaXMuaWQgPSBQZXJzaXN0ZW50Q29ubmVjdGlvbi5uZXh0UGVyc2lzdGVudENvbm5lY3Rpb25JZF8rKztcclxuICAgICAgICB0aGlzLmxvZ18gPSBsb2dXcmFwcGVyKCdwOicgKyB0aGlzLmlkICsgJzonKTtcclxuICAgICAgICB0aGlzLmludGVycnVwdFJlYXNvbnNfID0ge307XHJcbiAgICAgICAgdGhpcy5saXN0ZW5zID0gbmV3IE1hcCgpO1xyXG4gICAgICAgIHRoaXMub3V0c3RhbmRpbmdQdXRzXyA9IFtdO1xyXG4gICAgICAgIHRoaXMub3V0c3RhbmRpbmdHZXRzXyA9IFtdO1xyXG4gICAgICAgIHRoaXMub3V0c3RhbmRpbmdQdXRDb3VudF8gPSAwO1xyXG4gICAgICAgIHRoaXMub3V0c3RhbmRpbmdHZXRDb3VudF8gPSAwO1xyXG4gICAgICAgIHRoaXMub25EaXNjb25uZWN0UmVxdWVzdFF1ZXVlXyA9IFtdO1xyXG4gICAgICAgIHRoaXMuY29ubmVjdGVkXyA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMucmVjb25uZWN0RGVsYXlfID0gUkVDT05ORUNUX01JTl9ERUxBWTtcclxuICAgICAgICB0aGlzLm1heFJlY29ubmVjdERlbGF5XyA9IFJFQ09OTkVDVF9NQVhfREVMQVlfREVGQVVMVDtcclxuICAgICAgICB0aGlzLnNlY3VyaXR5RGVidWdDYWxsYmFja18gPSBudWxsO1xyXG4gICAgICAgIHRoaXMubGFzdFNlc3Npb25JZCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5lc3RhYmxpc2hDb25uZWN0aW9uVGltZXJfID0gbnVsbDtcclxuICAgICAgICB0aGlzLnZpc2libGVfID0gZmFsc2U7XHJcbiAgICAgICAgLy8gQmVmb3JlIHdlIGdldCBjb25uZWN0ZWQsIHdlIGtlZXAgYSBxdWV1ZSBvZiBwZW5kaW5nIG1lc3NhZ2VzIHRvIHNlbmQuXHJcbiAgICAgICAgdGhpcy5yZXF1ZXN0Q0JIYXNoXyA9IHt9O1xyXG4gICAgICAgIHRoaXMucmVxdWVzdE51bWJlcl8gPSAwO1xyXG4gICAgICAgIHRoaXMucmVhbHRpbWVfID0gbnVsbDtcclxuICAgICAgICB0aGlzLmF1dGhUb2tlbl8gPSBudWxsO1xyXG4gICAgICAgIHRoaXMuYXBwQ2hlY2tUb2tlbl8gPSBudWxsO1xyXG4gICAgICAgIHRoaXMuZm9yY2VUb2tlblJlZnJlc2hfID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5pbnZhbGlkQXV0aFRva2VuQ291bnRfID0gMDtcclxuICAgICAgICB0aGlzLmludmFsaWRBcHBDaGVja1Rva2VuQ291bnRfID0gMDtcclxuICAgICAgICB0aGlzLmZpcnN0Q29ubmVjdGlvbl8gPSB0cnVlO1xyXG4gICAgICAgIHRoaXMubGFzdENvbm5lY3Rpb25BdHRlbXB0VGltZV8gPSBudWxsO1xyXG4gICAgICAgIHRoaXMubGFzdENvbm5lY3Rpb25Fc3RhYmxpc2hlZFRpbWVfID0gbnVsbDtcclxuICAgICAgICBpZiAoYXV0aE92ZXJyaWRlXyAmJiAhaXNOb2RlU2RrKCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBdXRoIG92ZXJyaWRlIHNwZWNpZmllZCBpbiBvcHRpb25zLCBidXQgbm90IHN1cHBvcnRlZCBvbiBub24gTm9kZS5qcyBwbGF0Zm9ybXMnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgVmlzaWJpbGl0eU1vbml0b3IuZ2V0SW5zdGFuY2UoKS5vbigndmlzaWJsZScsIHRoaXMub25WaXNpYmxlXywgdGhpcyk7XHJcbiAgICAgICAgaWYgKHJlcG9JbmZvXy5ob3N0LmluZGV4T2YoJ2ZibG9jYWwnKSA9PT0gLTEpIHtcclxuICAgICAgICAgICAgT25saW5lTW9uaXRvci5nZXRJbnN0YW5jZSgpLm9uKCdvbmxpbmUnLCB0aGlzLm9uT25saW5lXywgdGhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgc2VuZFJlcXVlc3QoYWN0aW9uLCBib2R5LCBvblJlc3BvbnNlKSB7XHJcbiAgICAgICAgY29uc3QgY3VyUmVxTnVtID0gKyt0aGlzLnJlcXVlc3ROdW1iZXJfO1xyXG4gICAgICAgIGNvbnN0IG1zZyA9IHsgcjogY3VyUmVxTnVtLCBhOiBhY3Rpb24sIGI6IGJvZHkgfTtcclxuICAgICAgICB0aGlzLmxvZ18oc3RyaW5naWZ5KG1zZykpO1xyXG4gICAgICAgIGFzc2VydCh0aGlzLmNvbm5lY3RlZF8sIFwic2VuZFJlcXVlc3QgY2FsbCB3aGVuIHdlJ3JlIG5vdCBjb25uZWN0ZWQgbm90IGFsbG93ZWQuXCIpO1xyXG4gICAgICAgIHRoaXMucmVhbHRpbWVfLnNlbmRSZXF1ZXN0KG1zZyk7XHJcbiAgICAgICAgaWYgKG9uUmVzcG9uc2UpIHtcclxuICAgICAgICAgICAgdGhpcy5yZXF1ZXN0Q0JIYXNoX1tjdXJSZXFOdW1dID0gb25SZXNwb25zZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBnZXQocXVlcnkpIHtcclxuICAgICAgICB0aGlzLmluaXRDb25uZWN0aW9uXygpO1xyXG4gICAgICAgIGNvbnN0IGRlZmVycmVkID0gbmV3IERlZmVycmVkKCk7XHJcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IHtcclxuICAgICAgICAgICAgcDogcXVlcnkuX3BhdGgudG9TdHJpbmcoKSxcclxuICAgICAgICAgICAgcTogcXVlcnkuX3F1ZXJ5T2JqZWN0XHJcbiAgICAgICAgfTtcclxuICAgICAgICBjb25zdCBvdXRzdGFuZGluZ0dldCA9IHtcclxuICAgICAgICAgICAgYWN0aW9uOiAnZycsXHJcbiAgICAgICAgICAgIHJlcXVlc3QsXHJcbiAgICAgICAgICAgIG9uQ29tcGxldGU6IChtZXNzYWdlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwYXlsb2FkID0gbWVzc2FnZVsnZCddO1xyXG4gICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2VbJ3MnXSA9PT0gJ29rJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25EYXRhVXBkYXRlXyhyZXF1ZXN0WydwJ10sIHBheWxvYWQsIFxyXG4gICAgICAgICAgICAgICAgICAgIC8qaXNNZXJnZSovIGZhbHNlLCBcclxuICAgICAgICAgICAgICAgICAgICAvKnRhZyovIG51bGwpO1xyXG4gICAgICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUocGF5bG9hZCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZWplY3QocGF5bG9hZCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMub3V0c3RhbmRpbmdHZXRzXy5wdXNoKG91dHN0YW5kaW5nR2V0KTtcclxuICAgICAgICB0aGlzLm91dHN0YW5kaW5nR2V0Q291bnRfKys7XHJcbiAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLm91dHN0YW5kaW5nR2V0c18ubGVuZ3RoIC0gMTtcclxuICAgICAgICBpZiAoIXRoaXMuY29ubmVjdGVkXykge1xyXG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGdldCA9IHRoaXMub3V0c3RhbmRpbmdHZXRzX1tpbmRleF07XHJcbiAgICAgICAgICAgICAgICBpZiAoZ2V0ID09PSB1bmRlZmluZWQgfHwgb3V0c3RhbmRpbmdHZXQgIT09IGdldCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLm91dHN0YW5kaW5nR2V0c19baW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vdXRzdGFuZGluZ0dldENvdW50Xy0tO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub3V0c3RhbmRpbmdHZXRDb3VudF8gPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm91dHN0YW5kaW5nR2V0c18gPSBbXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMubG9nXygnZ2V0ICcgKyBpbmRleCArICcgdGltZWQgb3V0IG9uIGNvbm5lY3Rpb24nKTtcclxuICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlamVjdChuZXcgRXJyb3IoJ0NsaWVudCBpcyBvZmZsaW5lLicpKTtcclxuICAgICAgICAgICAgfSwgR0VUX0NPTk5FQ1RfVElNRU9VVCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmNvbm5lY3RlZF8pIHtcclxuICAgICAgICAgICAgdGhpcy5zZW5kR2V0XyhpbmRleCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xyXG4gICAgfVxyXG4gICAgbGlzdGVuKHF1ZXJ5LCBjdXJyZW50SGFzaEZuLCB0YWcsIG9uQ29tcGxldGUpIHtcclxuICAgICAgICB0aGlzLmluaXRDb25uZWN0aW9uXygpO1xyXG4gICAgICAgIGNvbnN0IHF1ZXJ5SWQgPSBxdWVyeS5fcXVlcnlJZGVudGlmaWVyO1xyXG4gICAgICAgIGNvbnN0IHBhdGhTdHJpbmcgPSBxdWVyeS5fcGF0aC50b1N0cmluZygpO1xyXG4gICAgICAgIHRoaXMubG9nXygnTGlzdGVuIGNhbGxlZCBmb3IgJyArIHBhdGhTdHJpbmcgKyAnICcgKyBxdWVyeUlkKTtcclxuICAgICAgICBpZiAoIXRoaXMubGlzdGVucy5oYXMocGF0aFN0cmluZykpIHtcclxuICAgICAgICAgICAgdGhpcy5saXN0ZW5zLnNldChwYXRoU3RyaW5nLCBuZXcgTWFwKCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBhc3NlcnQocXVlcnkuX3F1ZXJ5UGFyYW1zLmlzRGVmYXVsdCgpIHx8ICFxdWVyeS5fcXVlcnlQYXJhbXMubG9hZHNBbGxEYXRhKCksICdsaXN0ZW4oKSBjYWxsZWQgZm9yIG5vbi1kZWZhdWx0IGJ1dCBjb21wbGV0ZSBxdWVyeScpO1xyXG4gICAgICAgIGFzc2VydCghdGhpcy5saXN0ZW5zLmdldChwYXRoU3RyaW5nKS5oYXMocXVlcnlJZCksICdsaXN0ZW4oKSBjYWxsZWQgdHdpY2UgZm9yIHNhbWUgcGF0aC9xdWVyeUlkLicpO1xyXG4gICAgICAgIGNvbnN0IGxpc3RlblNwZWMgPSB7XHJcbiAgICAgICAgICAgIG9uQ29tcGxldGUsXHJcbiAgICAgICAgICAgIGhhc2hGbjogY3VycmVudEhhc2hGbixcclxuICAgICAgICAgICAgcXVlcnksXHJcbiAgICAgICAgICAgIHRhZ1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5saXN0ZW5zLmdldChwYXRoU3RyaW5nKS5zZXQocXVlcnlJZCwgbGlzdGVuU3BlYyk7XHJcbiAgICAgICAgaWYgKHRoaXMuY29ubmVjdGVkXykge1xyXG4gICAgICAgICAgICB0aGlzLnNlbmRMaXN0ZW5fKGxpc3RlblNwZWMpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHNlbmRHZXRfKGluZGV4KSB7XHJcbiAgICAgICAgY29uc3QgZ2V0ID0gdGhpcy5vdXRzdGFuZGluZ0dldHNfW2luZGV4XTtcclxuICAgICAgICB0aGlzLnNlbmRSZXF1ZXN0KCdnJywgZ2V0LnJlcXVlc3QsIChtZXNzYWdlKSA9PiB7XHJcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLm91dHN0YW5kaW5nR2V0c19baW5kZXhdO1xyXG4gICAgICAgICAgICB0aGlzLm91dHN0YW5kaW5nR2V0Q291bnRfLS07XHJcbiAgICAgICAgICAgIGlmICh0aGlzLm91dHN0YW5kaW5nR2V0Q291bnRfID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm91dHN0YW5kaW5nR2V0c18gPSBbXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZ2V0Lm9uQ29tcGxldGUpIHtcclxuICAgICAgICAgICAgICAgIGdldC5vbkNvbXBsZXRlKG1lc3NhZ2UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBzZW5kTGlzdGVuXyhsaXN0ZW5TcGVjKSB7XHJcbiAgICAgICAgY29uc3QgcXVlcnkgPSBsaXN0ZW5TcGVjLnF1ZXJ5O1xyXG4gICAgICAgIGNvbnN0IHBhdGhTdHJpbmcgPSBxdWVyeS5fcGF0aC50b1N0cmluZygpO1xyXG4gICAgICAgIGNvbnN0IHF1ZXJ5SWQgPSBxdWVyeS5fcXVlcnlJZGVudGlmaWVyO1xyXG4gICAgICAgIHRoaXMubG9nXygnTGlzdGVuIG9uICcgKyBwYXRoU3RyaW5nICsgJyBmb3IgJyArIHF1ZXJ5SWQpO1xyXG4gICAgICAgIGNvbnN0IHJlcSA9IHsgLypwYXRoKi8gcDogcGF0aFN0cmluZyB9O1xyXG4gICAgICAgIGNvbnN0IGFjdGlvbiA9ICdxJztcclxuICAgICAgICAvLyBPbmx5IGJvdGhlciB0byBzZW5kIHF1ZXJ5IGlmIGl0J3Mgbm9uLWRlZmF1bHQuXHJcbiAgICAgICAgaWYgKGxpc3RlblNwZWMudGFnKSB7XHJcbiAgICAgICAgICAgIHJlcVsncSddID0gcXVlcnkuX3F1ZXJ5T2JqZWN0O1xyXG4gICAgICAgICAgICByZXFbJ3QnXSA9IGxpc3RlblNwZWMudGFnO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXFbIC8qaGFzaCovJ2gnXSA9IGxpc3RlblNwZWMuaGFzaEZuKCk7XHJcbiAgICAgICAgdGhpcy5zZW5kUmVxdWVzdChhY3Rpb24sIHJlcSwgKG1lc3NhZ2UpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgcGF5bG9hZCA9IG1lc3NhZ2VbIC8qZGF0YSovJ2QnXTtcclxuICAgICAgICAgICAgY29uc3Qgc3RhdHVzID0gbWVzc2FnZVsgLypzdGF0dXMqLydzJ107XHJcbiAgICAgICAgICAgIC8vIHByaW50IHdhcm5pbmdzIGluIGFueSBjYXNlLi4uXHJcbiAgICAgICAgICAgIFBlcnNpc3RlbnRDb25uZWN0aW9uLndhcm5Pbkxpc3Rlbldhcm5pbmdzXyhwYXlsb2FkLCBxdWVyeSk7XHJcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRMaXN0ZW5TcGVjID0gdGhpcy5saXN0ZW5zLmdldChwYXRoU3RyaW5nKSAmJlxyXG4gICAgICAgICAgICAgICAgdGhpcy5saXN0ZW5zLmdldChwYXRoU3RyaW5nKS5nZXQocXVlcnlJZCk7XHJcbiAgICAgICAgICAgIC8vIG9ubHkgdHJpZ2dlciBhY3Rpb25zIGlmIHRoZSBsaXN0ZW4gaGFzbid0IGJlZW4gcmVtb3ZlZCBhbmQgcmVhZGRlZFxyXG4gICAgICAgICAgICBpZiAoY3VycmVudExpc3RlblNwZWMgPT09IGxpc3RlblNwZWMpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubG9nXygnbGlzdGVuIHJlc3BvbnNlJywgbWVzc2FnZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoc3RhdHVzICE9PSAnb2snKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5fKHBhdGhTdHJpbmcsIHF1ZXJ5SWQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGxpc3RlblNwZWMub25Db21wbGV0ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxpc3RlblNwZWMub25Db21wbGV0ZShzdGF0dXMsIHBheWxvYWQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgd2Fybk9uTGlzdGVuV2FybmluZ3NfKHBheWxvYWQsIHF1ZXJ5KSB7XHJcbiAgICAgICAgaWYgKHBheWxvYWQgJiYgdHlwZW9mIHBheWxvYWQgPT09ICdvYmplY3QnICYmIGNvbnRhaW5zKHBheWxvYWQsICd3JykpIHtcclxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcclxuICAgICAgICAgICAgY29uc3Qgd2FybmluZ3MgPSBzYWZlR2V0KHBheWxvYWQsICd3Jyk7XHJcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHdhcm5pbmdzKSAmJiB+d2FybmluZ3MuaW5kZXhPZignbm9faW5kZXgnKSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgaW5kZXhTcGVjID0gJ1wiLmluZGV4T25cIjogXCInICsgcXVlcnkuX3F1ZXJ5UGFyYW1zLmdldEluZGV4KCkudG9TdHJpbmcoKSArICdcIic7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBpbmRleFBhdGggPSBxdWVyeS5fcGF0aC50b1N0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgd2FybihgVXNpbmcgYW4gdW5zcGVjaWZpZWQgaW5kZXguIFlvdXIgZGF0YSB3aWxsIGJlIGRvd25sb2FkZWQgYW5kIGAgK1xyXG4gICAgICAgICAgICAgICAgICAgIGBmaWx0ZXJlZCBvbiB0aGUgY2xpZW50LiBDb25zaWRlciBhZGRpbmcgJHtpbmRleFNwZWN9IGF0IGAgK1xyXG4gICAgICAgICAgICAgICAgICAgIGAke2luZGV4UGF0aH0gdG8geW91ciBzZWN1cml0eSBydWxlcyBmb3IgYmV0dGVyIHBlcmZvcm1hbmNlLmApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmVmcmVzaEF1dGhUb2tlbih0b2tlbikge1xyXG4gICAgICAgIHRoaXMuYXV0aFRva2VuXyA9IHRva2VuO1xyXG4gICAgICAgIHRoaXMubG9nXygnQXV0aCB0b2tlbiByZWZyZXNoZWQnKTtcclxuICAgICAgICBpZiAodGhpcy5hdXRoVG9rZW5fKSB7XHJcbiAgICAgICAgICAgIHRoaXMudHJ5QXV0aCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy9JZiB3ZSdyZSBjb25uZWN0ZWQgd2Ugd2FudCB0byBsZXQgdGhlIHNlcnZlciBrbm93IHRvIHVuYXV0aGVudGljYXRlIHVzLiBJZiB3ZSdyZSBub3QgY29ubmVjdGVkLCBzaW1wbHkgZGVsZXRlXHJcbiAgICAgICAgICAgIC8vdGhlIGNyZWRlbnRpYWwgc28gd2UgZG9udCBiZWNvbWUgYXV0aGVudGljYXRlZCBuZXh0IHRpbWUgd2UgY29ubmVjdC5cclxuICAgICAgICAgICAgaWYgKHRoaXMuY29ubmVjdGVkXykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZW5kUmVxdWVzdCgndW5hdXRoJywge30sICgpID0+IHsgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5yZWR1Y2VSZWNvbm5lY3REZWxheUlmQWRtaW5DcmVkZW50aWFsXyh0b2tlbik7XHJcbiAgICB9XHJcbiAgICByZWR1Y2VSZWNvbm5lY3REZWxheUlmQWRtaW5DcmVkZW50aWFsXyhjcmVkZW50aWFsKSB7XHJcbiAgICAgICAgLy8gTk9URTogVGhpcyBpc24ndCBpbnRlbmRlZCB0byBiZSBidWxsZXRwcm9vZiAoYSBtYWxpY2lvdXMgZGV2ZWxvcGVyIGNhbiBhbHdheXMganVzdCBtb2RpZnkgdGhlIGNsaWVudCkuXHJcbiAgICAgICAgLy8gQWRkaXRpb25hbGx5LCB3ZSBkb24ndCBib3RoZXIgcmVzZXR0aW5nIHRoZSBtYXggZGVsYXkgYmFjayB0byB0aGUgZGVmYXVsdCBpZiBhdXRoIGZhaWxzIC8gZXhwaXJlcy5cclxuICAgICAgICBjb25zdCBpc0ZpcmViYXNlU2VjcmV0ID0gY3JlZGVudGlhbCAmJiBjcmVkZW50aWFsLmxlbmd0aCA9PT0gNDA7XHJcbiAgICAgICAgaWYgKGlzRmlyZWJhc2VTZWNyZXQgfHwgaXNBZG1pbihjcmVkZW50aWFsKSkge1xyXG4gICAgICAgICAgICB0aGlzLmxvZ18oJ0FkbWluIGF1dGggY3JlZGVudGlhbCBkZXRlY3RlZC4gIFJlZHVjaW5nIG1heCByZWNvbm5lY3QgdGltZS4nKTtcclxuICAgICAgICAgICAgdGhpcy5tYXhSZWNvbm5lY3REZWxheV8gPSBSRUNPTk5FQ1RfTUFYX0RFTEFZX0ZPUl9BRE1JTlM7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmVmcmVzaEFwcENoZWNrVG9rZW4odG9rZW4pIHtcclxuICAgICAgICB0aGlzLmFwcENoZWNrVG9rZW5fID0gdG9rZW47XHJcbiAgICAgICAgdGhpcy5sb2dfKCdBcHAgY2hlY2sgdG9rZW4gcmVmcmVzaGVkJyk7XHJcbiAgICAgICAgaWYgKHRoaXMuYXBwQ2hlY2tUb2tlbl8pIHtcclxuICAgICAgICAgICAgdGhpcy50cnlBcHBDaGVjaygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy9JZiB3ZSdyZSBjb25uZWN0ZWQgd2Ugd2FudCB0byBsZXQgdGhlIHNlcnZlciBrbm93IHRvIHVuYXV0aGVudGljYXRlIHVzLlxyXG4gICAgICAgICAgICAvL0lmIHdlJ3JlIG5vdCBjb25uZWN0ZWQsIHNpbXBseSBkZWxldGUgdGhlIGNyZWRlbnRpYWwgc28gd2UgZG9udCBiZWNvbWVcclxuICAgICAgICAgICAgLy8gYXV0aGVudGljYXRlZCBuZXh0IHRpbWUgd2UgY29ubmVjdC5cclxuICAgICAgICAgICAgaWYgKHRoaXMuY29ubmVjdGVkXykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZW5kUmVxdWVzdCgndW5hcHBlY2snLCB7fSwgKCkgPT4geyB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQXR0ZW1wdHMgdG8gYXV0aGVudGljYXRlIHdpdGggdGhlIGdpdmVuIGNyZWRlbnRpYWxzLiBJZiB0aGUgYXV0aGVudGljYXRpb24gYXR0ZW1wdCBmYWlscywgaXQncyB0cmlnZ2VyZWQgbGlrZVxyXG4gICAgICogYSBhdXRoIHJldm9rZWQgKHRoZSBjb25uZWN0aW9uIGlzIGNsb3NlZCkuXHJcbiAgICAgKi9cclxuICAgIHRyeUF1dGgoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuY29ubmVjdGVkXyAmJiB0aGlzLmF1dGhUb2tlbl8pIHtcclxuICAgICAgICAgICAgY29uc3QgdG9rZW4gPSB0aGlzLmF1dGhUb2tlbl87XHJcbiAgICAgICAgICAgIGNvbnN0IGF1dGhNZXRob2QgPSBpc1ZhbGlkRm9ybWF0KHRva2VuKSA/ICdhdXRoJyA6ICdnYXV0aCc7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlcXVlc3REYXRhID0geyBjcmVkOiB0b2tlbiB9O1xyXG4gICAgICAgICAgICBpZiAodGhpcy5hdXRoT3ZlcnJpZGVfID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICByZXF1ZXN0RGF0YVsnbm9hdXRoJ10gPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB0aGlzLmF1dGhPdmVycmlkZV8gPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICAgICAgICByZXF1ZXN0RGF0YVsnYXV0aHZhciddID0gdGhpcy5hdXRoT3ZlcnJpZGVfO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuc2VuZFJlcXVlc3QoYXV0aE1ldGhvZCwgcmVxdWVzdERhdGEsIChyZXMpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHN0YXR1cyA9IHJlc1sgLypzdGF0dXMqLydzJ107XHJcbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0gcmVzWyAvKmRhdGEqLydkJ10gfHwgJ2Vycm9yJztcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmF1dGhUb2tlbl8gPT09IHRva2VuKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXR1cyA9PT0gJ29rJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmludmFsaWRBdXRoVG9rZW5Db3VudF8gPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVHJpZ2dlcnMgcmVjb25uZWN0IGFuZCBmb3JjZSByZWZyZXNoIGZvciBhdXRoIHRva2VuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub25BdXRoUmV2b2tlZF8oc3RhdHVzLCBkYXRhKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQXR0ZW1wdHMgdG8gYXV0aGVudGljYXRlIHdpdGggdGhlIGdpdmVuIHRva2VuLiBJZiB0aGUgYXV0aGVudGljYXRpb25cclxuICAgICAqIGF0dGVtcHQgZmFpbHMsIGl0J3MgdHJpZ2dlcmVkIGxpa2UgdGhlIHRva2VuIHdhcyByZXZva2VkICh0aGUgY29ubmVjdGlvbiBpc1xyXG4gICAgICogY2xvc2VkKS5cclxuICAgICAqL1xyXG4gICAgdHJ5QXBwQ2hlY2soKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuY29ubmVjdGVkXyAmJiB0aGlzLmFwcENoZWNrVG9rZW5fKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2VuZFJlcXVlc3QoJ2FwcGNoZWNrJywgeyAndG9rZW4nOiB0aGlzLmFwcENoZWNrVG9rZW5fIH0sIChyZXMpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHN0YXR1cyA9IHJlc1sgLypzdGF0dXMqLydzJ107XHJcbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0gcmVzWyAvKmRhdGEqLydkJ10gfHwgJ2Vycm9yJztcclxuICAgICAgICAgICAgICAgIGlmIChzdGF0dXMgPT09ICdvaycpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmludmFsaWRBcHBDaGVja1Rva2VuQ291bnRfID0gMDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25BcHBDaGVja1Jldm9rZWRfKHN0YXR1cywgZGF0YSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQGluaGVyaXREb2NcclxuICAgICAqL1xyXG4gICAgdW5saXN0ZW4ocXVlcnksIHRhZykge1xyXG4gICAgICAgIGNvbnN0IHBhdGhTdHJpbmcgPSBxdWVyeS5fcGF0aC50b1N0cmluZygpO1xyXG4gICAgICAgIGNvbnN0IHF1ZXJ5SWQgPSBxdWVyeS5fcXVlcnlJZGVudGlmaWVyO1xyXG4gICAgICAgIHRoaXMubG9nXygnVW5saXN0ZW4gY2FsbGVkIGZvciAnICsgcGF0aFN0cmluZyArICcgJyArIHF1ZXJ5SWQpO1xyXG4gICAgICAgIGFzc2VydChxdWVyeS5fcXVlcnlQYXJhbXMuaXNEZWZhdWx0KCkgfHwgIXF1ZXJ5Ll9xdWVyeVBhcmFtcy5sb2Fkc0FsbERhdGEoKSwgJ3VubGlzdGVuKCkgY2FsbGVkIGZvciBub24tZGVmYXVsdCBidXQgY29tcGxldGUgcXVlcnknKTtcclxuICAgICAgICBjb25zdCBsaXN0ZW4gPSB0aGlzLnJlbW92ZUxpc3Rlbl8ocGF0aFN0cmluZywgcXVlcnlJZCk7XHJcbiAgICAgICAgaWYgKGxpc3RlbiAmJiB0aGlzLmNvbm5lY3RlZF8pIHtcclxuICAgICAgICAgICAgdGhpcy5zZW5kVW5saXN0ZW5fKHBhdGhTdHJpbmcsIHF1ZXJ5SWQsIHF1ZXJ5Ll9xdWVyeU9iamVjdCwgdGFnKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBzZW5kVW5saXN0ZW5fKHBhdGhTdHJpbmcsIHF1ZXJ5SWQsIHF1ZXJ5T2JqLCB0YWcpIHtcclxuICAgICAgICB0aGlzLmxvZ18oJ1VubGlzdGVuIG9uICcgKyBwYXRoU3RyaW5nICsgJyBmb3IgJyArIHF1ZXJ5SWQpO1xyXG4gICAgICAgIGNvbnN0IHJlcSA9IHsgLypwYXRoKi8gcDogcGF0aFN0cmluZyB9O1xyXG4gICAgICAgIGNvbnN0IGFjdGlvbiA9ICduJztcclxuICAgICAgICAvLyBPbmx5IGJvdGhlciBzZW5kaW5nIHF1ZXJ5SWQgaWYgaXQncyBub24tZGVmYXVsdC5cclxuICAgICAgICBpZiAodGFnKSB7XHJcbiAgICAgICAgICAgIHJlcVsncSddID0gcXVlcnlPYmo7XHJcbiAgICAgICAgICAgIHJlcVsndCddID0gdGFnO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnNlbmRSZXF1ZXN0KGFjdGlvbiwgcmVxKTtcclxuICAgIH1cclxuICAgIG9uRGlzY29ubmVjdFB1dChwYXRoU3RyaW5nLCBkYXRhLCBvbkNvbXBsZXRlKSB7XHJcbiAgICAgICAgdGhpcy5pbml0Q29ubmVjdGlvbl8oKTtcclxuICAgICAgICBpZiAodGhpcy5jb25uZWN0ZWRfKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2VuZE9uRGlzY29ubmVjdF8oJ28nLCBwYXRoU3RyaW5nLCBkYXRhLCBvbkNvbXBsZXRlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMub25EaXNjb25uZWN0UmVxdWVzdFF1ZXVlXy5wdXNoKHtcclxuICAgICAgICAgICAgICAgIHBhdGhTdHJpbmcsXHJcbiAgICAgICAgICAgICAgICBhY3Rpb246ICdvJyxcclxuICAgICAgICAgICAgICAgIGRhdGEsXHJcbiAgICAgICAgICAgICAgICBvbkNvbXBsZXRlXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIG9uRGlzY29ubmVjdE1lcmdlKHBhdGhTdHJpbmcsIGRhdGEsIG9uQ29tcGxldGUpIHtcclxuICAgICAgICB0aGlzLmluaXRDb25uZWN0aW9uXygpO1xyXG4gICAgICAgIGlmICh0aGlzLmNvbm5lY3RlZF8pIHtcclxuICAgICAgICAgICAgdGhpcy5zZW5kT25EaXNjb25uZWN0Xygnb20nLCBwYXRoU3RyaW5nLCBkYXRhLCBvbkNvbXBsZXRlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMub25EaXNjb25uZWN0UmVxdWVzdFF1ZXVlXy5wdXNoKHtcclxuICAgICAgICAgICAgICAgIHBhdGhTdHJpbmcsXHJcbiAgICAgICAgICAgICAgICBhY3Rpb246ICdvbScsXHJcbiAgICAgICAgICAgICAgICBkYXRhLFxyXG4gICAgICAgICAgICAgICAgb25Db21wbGV0ZVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBvbkRpc2Nvbm5lY3RDYW5jZWwocGF0aFN0cmluZywgb25Db21wbGV0ZSkge1xyXG4gICAgICAgIHRoaXMuaW5pdENvbm5lY3Rpb25fKCk7XHJcbiAgICAgICAgaWYgKHRoaXMuY29ubmVjdGVkXykge1xyXG4gICAgICAgICAgICB0aGlzLnNlbmRPbkRpc2Nvbm5lY3RfKCdvYycsIHBhdGhTdHJpbmcsIG51bGwsIG9uQ29tcGxldGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5vbkRpc2Nvbm5lY3RSZXF1ZXN0UXVldWVfLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgcGF0aFN0cmluZyxcclxuICAgICAgICAgICAgICAgIGFjdGlvbjogJ29jJyxcclxuICAgICAgICAgICAgICAgIGRhdGE6IG51bGwsXHJcbiAgICAgICAgICAgICAgICBvbkNvbXBsZXRlXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHNlbmRPbkRpc2Nvbm5lY3RfKGFjdGlvbiwgcGF0aFN0cmluZywgZGF0YSwgb25Db21wbGV0ZSkge1xyXG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSB7IC8qcGF0aCovIHA6IHBhdGhTdHJpbmcsIC8qZGF0YSovIGQ6IGRhdGEgfTtcclxuICAgICAgICB0aGlzLmxvZ18oJ29uRGlzY29ubmVjdCAnICsgYWN0aW9uLCByZXF1ZXN0KTtcclxuICAgICAgICB0aGlzLnNlbmRSZXF1ZXN0KGFjdGlvbiwgcmVxdWVzdCwgKHJlc3BvbnNlKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChvbkNvbXBsZXRlKSB7XHJcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBvbkNvbXBsZXRlKHJlc3BvbnNlWyAvKnN0YXR1cyovJ3MnXSwgcmVzcG9uc2VbIC8qIGRhdGEgKi8nZCddKTtcclxuICAgICAgICAgICAgICAgIH0sIE1hdGguZmxvb3IoMCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBwdXQocGF0aFN0cmluZywgZGF0YSwgb25Db21wbGV0ZSwgaGFzaCkge1xyXG4gICAgICAgIHRoaXMucHV0SW50ZXJuYWwoJ3AnLCBwYXRoU3RyaW5nLCBkYXRhLCBvbkNvbXBsZXRlLCBoYXNoKTtcclxuICAgIH1cclxuICAgIG1lcmdlKHBhdGhTdHJpbmcsIGRhdGEsIG9uQ29tcGxldGUsIGhhc2gpIHtcclxuICAgICAgICB0aGlzLnB1dEludGVybmFsKCdtJywgcGF0aFN0cmluZywgZGF0YSwgb25Db21wbGV0ZSwgaGFzaCk7XHJcbiAgICB9XHJcbiAgICBwdXRJbnRlcm5hbChhY3Rpb24sIHBhdGhTdHJpbmcsIGRhdGEsIG9uQ29tcGxldGUsIGhhc2gpIHtcclxuICAgICAgICB0aGlzLmluaXRDb25uZWN0aW9uXygpO1xyXG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSB7XHJcbiAgICAgICAgICAgIC8qcGF0aCovIHA6IHBhdGhTdHJpbmcsXHJcbiAgICAgICAgICAgIC8qZGF0YSovIGQ6IGRhdGFcclxuICAgICAgICB9O1xyXG4gICAgICAgIGlmIChoYXNoICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgcmVxdWVzdFsgLypoYXNoKi8naCddID0gaGFzaDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gVE9ETzogT25seSBrZWVwIHRyYWNrIG9mIHRoZSBtb3N0IHJlY2VudCBwdXQgZm9yIGEgZ2l2ZW4gcGF0aD9cclxuICAgICAgICB0aGlzLm91dHN0YW5kaW5nUHV0c18ucHVzaCh7XHJcbiAgICAgICAgICAgIGFjdGlvbixcclxuICAgICAgICAgICAgcmVxdWVzdCxcclxuICAgICAgICAgICAgb25Db21wbGV0ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMub3V0c3RhbmRpbmdQdXRDb3VudF8rKztcclxuICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMub3V0c3RhbmRpbmdQdXRzXy5sZW5ndGggLSAxO1xyXG4gICAgICAgIGlmICh0aGlzLmNvbm5lY3RlZF8pIHtcclxuICAgICAgICAgICAgdGhpcy5zZW5kUHV0XyhpbmRleCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmxvZ18oJ0J1ZmZlcmluZyBwdXQ6ICcgKyBwYXRoU3RyaW5nKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBzZW5kUHV0XyhpbmRleCkge1xyXG4gICAgICAgIGNvbnN0IGFjdGlvbiA9IHRoaXMub3V0c3RhbmRpbmdQdXRzX1tpbmRleF0uYWN0aW9uO1xyXG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSB0aGlzLm91dHN0YW5kaW5nUHV0c19baW5kZXhdLnJlcXVlc3Q7XHJcbiAgICAgICAgY29uc3Qgb25Db21wbGV0ZSA9IHRoaXMub3V0c3RhbmRpbmdQdXRzX1tpbmRleF0ub25Db21wbGV0ZTtcclxuICAgICAgICB0aGlzLm91dHN0YW5kaW5nUHV0c19baW5kZXhdLnF1ZXVlZCA9IHRoaXMuY29ubmVjdGVkXztcclxuICAgICAgICB0aGlzLnNlbmRSZXF1ZXN0KGFjdGlvbiwgcmVxdWVzdCwgKG1lc3NhZ2UpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5sb2dfKGFjdGlvbiArICcgcmVzcG9uc2UnLCBtZXNzYWdlKTtcclxuICAgICAgICAgICAgZGVsZXRlIHRoaXMub3V0c3RhbmRpbmdQdXRzX1tpbmRleF07XHJcbiAgICAgICAgICAgIHRoaXMub3V0c3RhbmRpbmdQdXRDb3VudF8tLTtcclxuICAgICAgICAgICAgLy8gQ2xlYW4gdXAgYXJyYXkgb2NjYXNpb25hbGx5LlxyXG4gICAgICAgICAgICBpZiAodGhpcy5vdXRzdGFuZGluZ1B1dENvdW50XyA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vdXRzdGFuZGluZ1B1dHNfID0gW107XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKG9uQ29tcGxldGUpIHtcclxuICAgICAgICAgICAgICAgIG9uQ29tcGxldGUobWVzc2FnZVsgLypzdGF0dXMqLydzJ10sIG1lc3NhZ2VbIC8qIGRhdGEgKi8nZCddKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgcmVwb3J0U3RhdHMoc3RhdHMpIHtcclxuICAgICAgICAvLyBJZiB3ZSdyZSBub3QgY29ubmVjdGVkLCB3ZSBqdXN0IGRyb3AgdGhlIHN0YXRzLlxyXG4gICAgICAgIGlmICh0aGlzLmNvbm5lY3RlZF8pIHtcclxuICAgICAgICAgICAgY29uc3QgcmVxdWVzdCA9IHsgLypjb3VudGVycyovIGM6IHN0YXRzIH07XHJcbiAgICAgICAgICAgIHRoaXMubG9nXygncmVwb3J0U3RhdHMnLCByZXF1ZXN0KTtcclxuICAgICAgICAgICAgdGhpcy5zZW5kUmVxdWVzdCgvKnN0YXRzKi8gJ3MnLCByZXF1ZXN0LCByZXN1bHQgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc3RhdHVzID0gcmVzdWx0WyAvKnN0YXR1cyovJ3MnXTtcclxuICAgICAgICAgICAgICAgIGlmIChzdGF0dXMgIT09ICdvaycpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnJvclJlYXNvbiA9IHJlc3VsdFsgLyogZGF0YSAqLydkJ107XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2dfKCdyZXBvcnRTdGF0cycsICdFcnJvciBzZW5kaW5nIHN0YXRzOiAnICsgZXJyb3JSZWFzb24pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBvbkRhdGFNZXNzYWdlXyhtZXNzYWdlKSB7XHJcbiAgICAgICAgaWYgKCdyJyBpbiBtZXNzYWdlKSB7XHJcbiAgICAgICAgICAgIC8vIHRoaXMgaXMgYSByZXNwb25zZVxyXG4gICAgICAgICAgICB0aGlzLmxvZ18oJ2Zyb20gc2VydmVyOiAnICsgc3RyaW5naWZ5KG1lc3NhZ2UpKTtcclxuICAgICAgICAgICAgY29uc3QgcmVxTnVtID0gbWVzc2FnZVsnciddO1xyXG4gICAgICAgICAgICBjb25zdCBvblJlc3BvbnNlID0gdGhpcy5yZXF1ZXN0Q0JIYXNoX1tyZXFOdW1dO1xyXG4gICAgICAgICAgICBpZiAob25SZXNwb25zZSkge1xyXG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMucmVxdWVzdENCSGFzaF9bcmVxTnVtXTtcclxuICAgICAgICAgICAgICAgIG9uUmVzcG9uc2UobWVzc2FnZVsgLypib2R5Ki8nYiddKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICgnZXJyb3InIGluIG1lc3NhZ2UpIHtcclxuICAgICAgICAgICAgdGhyb3cgJ0Egc2VydmVyLXNpZGUgZXJyb3IgaGFzIG9jY3VycmVkOiAnICsgbWVzc2FnZVsnZXJyb3InXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoJ2EnIGluIG1lc3NhZ2UpIHtcclxuICAgICAgICAgICAgLy8gYSBhbmQgYiBhcmUgYWN0aW9uIGFuZCBib2R5LCByZXNwZWN0aXZlbHlcclxuICAgICAgICAgICAgdGhpcy5vbkRhdGFQdXNoXyhtZXNzYWdlWydhJ10sIG1lc3NhZ2VbJ2InXSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgb25EYXRhUHVzaF8oYWN0aW9uLCBib2R5KSB7XHJcbiAgICAgICAgdGhpcy5sb2dfKCdoYW5kbGVTZXJ2ZXJNZXNzYWdlJywgYWN0aW9uLCBib2R5KTtcclxuICAgICAgICBpZiAoYWN0aW9uID09PSAnZCcpIHtcclxuICAgICAgICAgICAgdGhpcy5vbkRhdGFVcGRhdGVfKGJvZHlbIC8qcGF0aCovJ3AnXSwgYm9keVsgLypkYXRhKi8nZCddLCBcclxuICAgICAgICAgICAgLyppc01lcmdlKi8gZmFsc2UsIGJvZHlbJ3QnXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGFjdGlvbiA9PT0gJ20nKSB7XHJcbiAgICAgICAgICAgIHRoaXMub25EYXRhVXBkYXRlXyhib2R5WyAvKnBhdGgqLydwJ10sIGJvZHlbIC8qZGF0YSovJ2QnXSwgXHJcbiAgICAgICAgICAgIC8qaXNNZXJnZT0qLyB0cnVlLCBib2R5Wyd0J10pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChhY3Rpb24gPT09ICdjJykge1xyXG4gICAgICAgICAgICB0aGlzLm9uTGlzdGVuUmV2b2tlZF8oYm9keVsgLypwYXRoKi8ncCddLCBib2R5WyAvKnF1ZXJ5Ki8ncSddKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoYWN0aW9uID09PSAnYWMnKSB7XHJcbiAgICAgICAgICAgIHRoaXMub25BdXRoUmV2b2tlZF8oYm9keVsgLypzdGF0dXMgY29kZSovJ3MnXSwgYm9keVsgLyogZXhwbGFuYXRpb24gKi8nZCddKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoYWN0aW9uID09PSAnYXBjJykge1xyXG4gICAgICAgICAgICB0aGlzLm9uQXBwQ2hlY2tSZXZva2VkXyhib2R5WyAvKnN0YXR1cyBjb2RlKi8ncyddLCBib2R5WyAvKiBleHBsYW5hdGlvbiAqLydkJ10pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChhY3Rpb24gPT09ICdzZCcpIHtcclxuICAgICAgICAgICAgdGhpcy5vblNlY3VyaXR5RGVidWdQYWNrZXRfKGJvZHkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZXJyb3IoJ1VucmVjb2duaXplZCBhY3Rpb24gcmVjZWl2ZWQgZnJvbSBzZXJ2ZXI6ICcgK1xyXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KGFjdGlvbikgK1xyXG4gICAgICAgICAgICAgICAgJ1xcbkFyZSB5b3UgdXNpbmcgdGhlIGxhdGVzdCBjbGllbnQ/Jyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgb25SZWFkeV8odGltZXN0YW1wLCBzZXNzaW9uSWQpIHtcclxuICAgICAgICB0aGlzLmxvZ18oJ2Nvbm5lY3Rpb24gcmVhZHknKTtcclxuICAgICAgICB0aGlzLmNvbm5lY3RlZF8gPSB0cnVlO1xyXG4gICAgICAgIHRoaXMubGFzdENvbm5lY3Rpb25Fc3RhYmxpc2hlZFRpbWVfID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XHJcbiAgICAgICAgdGhpcy5oYW5kbGVUaW1lc3RhbXBfKHRpbWVzdGFtcCk7XHJcbiAgICAgICAgdGhpcy5sYXN0U2Vzc2lvbklkID0gc2Vzc2lvbklkO1xyXG4gICAgICAgIGlmICh0aGlzLmZpcnN0Q29ubmVjdGlvbl8pIHtcclxuICAgICAgICAgICAgdGhpcy5zZW5kQ29ubmVjdFN0YXRzXygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnJlc3RvcmVTdGF0ZV8oKTtcclxuICAgICAgICB0aGlzLmZpcnN0Q29ubmVjdGlvbl8gPSBmYWxzZTtcclxuICAgICAgICB0aGlzLm9uQ29ubmVjdFN0YXR1c18odHJ1ZSk7XHJcbiAgICB9XHJcbiAgICBzY2hlZHVsZUNvbm5lY3RfKHRpbWVvdXQpIHtcclxuICAgICAgICBhc3NlcnQoIXRoaXMucmVhbHRpbWVfLCBcIlNjaGVkdWxpbmcgYSBjb25uZWN0IHdoZW4gd2UncmUgYWxyZWFkeSBjb25uZWN0ZWQvaW5nP1wiKTtcclxuICAgICAgICBpZiAodGhpcy5lc3RhYmxpc2hDb25uZWN0aW9uVGltZXJfKSB7XHJcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmVzdGFibGlzaENvbm5lY3Rpb25UaW1lcl8pO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBOT1RFOiBFdmVuIHdoZW4gdGltZW91dCBpcyAwLCBpdCdzIGltcG9ydGFudCB0byBkbyBhIHNldFRpbWVvdXQgdG8gd29yayBhcm91bmQgYW4gaW5mdXJpYXRpbmcgXCJTZWN1cml0eSBFcnJvclwiIGluXHJcbiAgICAgICAgLy8gRmlyZWZveCB3aGVuIHRyeWluZyB0byB3cml0ZSB0byBvdXIgbG9uZy1wb2xsaW5nIGlmcmFtZSBpbiBzb21lIHNjZW5hcmlvcyAoZS5nLiBGb3JnZSBvciBvdXIgdW5pdCB0ZXN0cykuXHJcbiAgICAgICAgdGhpcy5lc3RhYmxpc2hDb25uZWN0aW9uVGltZXJfID0gc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuZXN0YWJsaXNoQ29ubmVjdGlvblRpbWVyXyA9IG51bGw7XHJcbiAgICAgICAgICAgIHRoaXMuZXN0YWJsaXNoQ29ubmVjdGlvbl8oKTtcclxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcclxuICAgICAgICB9LCBNYXRoLmZsb29yKHRpbWVvdXQpKTtcclxuICAgIH1cclxuICAgIGluaXRDb25uZWN0aW9uXygpIHtcclxuICAgICAgICBpZiAoIXRoaXMucmVhbHRpbWVfICYmIHRoaXMuZmlyc3RDb25uZWN0aW9uXykge1xyXG4gICAgICAgICAgICB0aGlzLnNjaGVkdWxlQ29ubmVjdF8oMCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgb25WaXNpYmxlXyh2aXNpYmxlKSB7XHJcbiAgICAgICAgLy8gTk9URTogVGFiYmluZyBhd2F5IGFuZCBiYWNrIHRvIGEgd2luZG93IHdpbGwgZGVmZWF0IG91ciByZWNvbm5lY3QgYmFja29mZiwgYnV0IEkgdGhpbmsgdGhhdCdzIGZpbmUuXHJcbiAgICAgICAgaWYgKHZpc2libGUgJiZcclxuICAgICAgICAgICAgIXRoaXMudmlzaWJsZV8gJiZcclxuICAgICAgICAgICAgdGhpcy5yZWNvbm5lY3REZWxheV8gPT09IHRoaXMubWF4UmVjb25uZWN0RGVsYXlfKSB7XHJcbiAgICAgICAgICAgIHRoaXMubG9nXygnV2luZG93IGJlY2FtZSB2aXNpYmxlLiAgUmVkdWNpbmcgZGVsYXkuJyk7XHJcbiAgICAgICAgICAgIHRoaXMucmVjb25uZWN0RGVsYXlfID0gUkVDT05ORUNUX01JTl9ERUxBWTtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLnJlYWx0aW1lXykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zY2hlZHVsZUNvbm5lY3RfKDApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMudmlzaWJsZV8gPSB2aXNpYmxlO1xyXG4gICAgfVxyXG4gICAgb25PbmxpbmVfKG9ubGluZSkge1xyXG4gICAgICAgIGlmIChvbmxpbmUpIHtcclxuICAgICAgICAgICAgdGhpcy5sb2dfKCdCcm93c2VyIHdlbnQgb25saW5lLicpO1xyXG4gICAgICAgICAgICB0aGlzLnJlY29ubmVjdERlbGF5XyA9IFJFQ09OTkVDVF9NSU5fREVMQVk7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5yZWFsdGltZV8pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2NoZWR1bGVDb25uZWN0XygwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5sb2dfKCdCcm93c2VyIHdlbnQgb2ZmbGluZS4gIEtpbGxpbmcgY29ubmVjdGlvbi4nKTtcclxuICAgICAgICAgICAgaWYgKHRoaXMucmVhbHRpbWVfKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlYWx0aW1lXy5jbG9zZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgb25SZWFsdGltZURpc2Nvbm5lY3RfKCkge1xyXG4gICAgICAgIHRoaXMubG9nXygnZGF0YSBjbGllbnQgZGlzY29ubmVjdGVkJyk7XHJcbiAgICAgICAgdGhpcy5jb25uZWN0ZWRfID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5yZWFsdGltZV8gPSBudWxsO1xyXG4gICAgICAgIC8vIFNpbmNlIHdlIGRvbid0IGtub3cgaWYgb3VyIHNlbnQgdHJhbnNhY3Rpb25zIHN1Y2NlZWRlZCBvciBub3QsIHdlIG5lZWQgdG8gY2FuY2VsIHRoZW0uXHJcbiAgICAgICAgdGhpcy5jYW5jZWxTZW50VHJhbnNhY3Rpb25zXygpO1xyXG4gICAgICAgIC8vIENsZWFyIG91dCB0aGUgcGVuZGluZyByZXF1ZXN0cy5cclxuICAgICAgICB0aGlzLnJlcXVlc3RDQkhhc2hfID0ge307XHJcbiAgICAgICAgaWYgKHRoaXMuc2hvdWxkUmVjb25uZWN0XygpKSB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy52aXNpYmxlXykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sb2dfKFwiV2luZG93IGlzbid0IHZpc2libGUuICBEZWxheWluZyByZWNvbm5lY3QuXCIpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZWNvbm5lY3REZWxheV8gPSB0aGlzLm1heFJlY29ubmVjdERlbGF5XztcclxuICAgICAgICAgICAgICAgIHRoaXMubGFzdENvbm5lY3Rpb25BdHRlbXB0VGltZV8gPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLmxhc3RDb25uZWN0aW9uRXN0YWJsaXNoZWRUaW1lXykge1xyXG4gICAgICAgICAgICAgICAgLy8gSWYgd2UndmUgYmVlbiBjb25uZWN0ZWQgbG9uZyBlbm91Z2gsIHJlc2V0IHJlY29ubmVjdCBkZWxheSB0byBtaW5pbXVtLlxyXG4gICAgICAgICAgICAgICAgY29uc3QgdGltZVNpbmNlTGFzdENvbm5lY3RTdWNjZWVkZWQgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKSAtIHRoaXMubGFzdENvbm5lY3Rpb25Fc3RhYmxpc2hlZFRpbWVfO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRpbWVTaW5jZUxhc3RDb25uZWN0U3VjY2VlZGVkID4gUkVDT05ORUNUX0RFTEFZX1JFU0VUX1RJTUVPVVQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlY29ubmVjdERlbGF5XyA9IFJFQ09OTkVDVF9NSU5fREVMQVk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxhc3RDb25uZWN0aW9uRXN0YWJsaXNoZWRUaW1lXyA9IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgdGltZVNpbmNlTGFzdENvbm5lY3RBdHRlbXB0ID0gbmV3IERhdGUoKS5nZXRUaW1lKCkgLSB0aGlzLmxhc3RDb25uZWN0aW9uQXR0ZW1wdFRpbWVfO1xyXG4gICAgICAgICAgICBsZXQgcmVjb25uZWN0RGVsYXkgPSBNYXRoLm1heCgwLCB0aGlzLnJlY29ubmVjdERlbGF5XyAtIHRpbWVTaW5jZUxhc3RDb25uZWN0QXR0ZW1wdCk7XHJcbiAgICAgICAgICAgIHJlY29ubmVjdERlbGF5ID0gTWF0aC5yYW5kb20oKSAqIHJlY29ubmVjdERlbGF5O1xyXG4gICAgICAgICAgICB0aGlzLmxvZ18oJ1RyeWluZyB0byByZWNvbm5lY3QgaW4gJyArIHJlY29ubmVjdERlbGF5ICsgJ21zJyk7XHJcbiAgICAgICAgICAgIHRoaXMuc2NoZWR1bGVDb25uZWN0XyhyZWNvbm5lY3REZWxheSk7XHJcbiAgICAgICAgICAgIC8vIEFkanVzdCByZWNvbm5lY3QgZGVsYXkgZm9yIG5leHQgdGltZS5cclxuICAgICAgICAgICAgdGhpcy5yZWNvbm5lY3REZWxheV8gPSBNYXRoLm1pbih0aGlzLm1heFJlY29ubmVjdERlbGF5XywgdGhpcy5yZWNvbm5lY3REZWxheV8gKiBSRUNPTk5FQ1RfREVMQVlfTVVMVElQTElFUik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMub25Db25uZWN0U3RhdHVzXyhmYWxzZSk7XHJcbiAgICB9XHJcbiAgICBhc3luYyBlc3RhYmxpc2hDb25uZWN0aW9uXygpIHtcclxuICAgICAgICBpZiAodGhpcy5zaG91bGRSZWNvbm5lY3RfKCkpIHtcclxuICAgICAgICAgICAgdGhpcy5sb2dfKCdNYWtpbmcgYSBjb25uZWN0aW9uIGF0dGVtcHQnKTtcclxuICAgICAgICAgICAgdGhpcy5sYXN0Q29ubmVjdGlvbkF0dGVtcHRUaW1lXyA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xyXG4gICAgICAgICAgICB0aGlzLmxhc3RDb25uZWN0aW9uRXN0YWJsaXNoZWRUaW1lXyA9IG51bGw7XHJcbiAgICAgICAgICAgIGNvbnN0IG9uRGF0YU1lc3NhZ2UgPSB0aGlzLm9uRGF0YU1lc3NhZ2VfLmJpbmQodGhpcyk7XHJcbiAgICAgICAgICAgIGNvbnN0IG9uUmVhZHkgPSB0aGlzLm9uUmVhZHlfLmJpbmQodGhpcyk7XHJcbiAgICAgICAgICAgIGNvbnN0IG9uRGlzY29ubmVjdCA9IHRoaXMub25SZWFsdGltZURpc2Nvbm5lY3RfLmJpbmQodGhpcyk7XHJcbiAgICAgICAgICAgIGNvbnN0IGNvbm5JZCA9IHRoaXMuaWQgKyAnOicgKyBQZXJzaXN0ZW50Q29ubmVjdGlvbi5uZXh0Q29ubmVjdGlvbklkXysrO1xyXG4gICAgICAgICAgICBjb25zdCBsYXN0U2Vzc2lvbklkID0gdGhpcy5sYXN0U2Vzc2lvbklkO1xyXG4gICAgICAgICAgICBsZXQgY2FuY2VsZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgbGV0IGNvbm5lY3Rpb24gPSBudWxsO1xyXG4gICAgICAgICAgICBjb25zdCBjbG9zZUZuID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGNvbm5lY3Rpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25uZWN0aW9uLmNsb3NlKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBjYW5jZWxlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgb25EaXNjb25uZWN0KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGNvbnN0IHNlbmRSZXF1ZXN0Rm4gPSBmdW5jdGlvbiAobXNnKSB7XHJcbiAgICAgICAgICAgICAgICBhc3NlcnQoY29ubmVjdGlvbiwgXCJzZW5kUmVxdWVzdCBjYWxsIHdoZW4gd2UncmUgbm90IGNvbm5lY3RlZCBub3QgYWxsb3dlZC5cIik7XHJcbiAgICAgICAgICAgICAgICBjb25uZWN0aW9uLnNlbmRSZXF1ZXN0KG1zZyk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHRoaXMucmVhbHRpbWVfID0ge1xyXG4gICAgICAgICAgICAgICAgY2xvc2U6IGNsb3NlRm4sXHJcbiAgICAgICAgICAgICAgICBzZW5kUmVxdWVzdDogc2VuZFJlcXVlc3RGblxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBjb25zdCBmb3JjZVJlZnJlc2ggPSB0aGlzLmZvcmNlVG9rZW5SZWZyZXNoXztcclxuICAgICAgICAgICAgdGhpcy5mb3JjZVRva2VuUmVmcmVzaF8gPSBmYWxzZTtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIC8vIEZpcnN0IGZldGNoIGF1dGggYW5kIGFwcCBjaGVjayB0b2tlbiwgYW5kIGVzdGFibGlzaCBjb25uZWN0aW9uIGFmdGVyXHJcbiAgICAgICAgICAgICAgICAvLyBmZXRjaGluZyB0aGUgdG9rZW4gd2FzIHN1Y2Nlc3NmdWxcclxuICAgICAgICAgICAgICAgIGNvbnN0IFthdXRoVG9rZW4sIGFwcENoZWNrVG9rZW5dID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXV0aFRva2VuUHJvdmlkZXJfLmdldFRva2VuKGZvcmNlUmVmcmVzaCksXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hcHBDaGVja1Rva2VuUHJvdmlkZXJfLmdldFRva2VuKGZvcmNlUmVmcmVzaClcclxuICAgICAgICAgICAgICAgIF0pO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFjYW5jZWxlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxvZygnZ2V0VG9rZW4oKSBjb21wbGV0ZWQuIENyZWF0aW5nIGNvbm5lY3Rpb24uJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hdXRoVG9rZW5fID0gYXV0aFRva2VuICYmIGF1dGhUb2tlbi5hY2Nlc3NUb2tlbjtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFwcENoZWNrVG9rZW5fID0gYXBwQ2hlY2tUb2tlbiAmJiBhcHBDaGVja1Rva2VuLnRva2VuO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbm5lY3Rpb24gPSBuZXcgQ29ubmVjdGlvbihjb25uSWQsIHRoaXMucmVwb0luZm9fLCB0aGlzLmFwcGxpY2F0aW9uSWRfLCB0aGlzLmFwcENoZWNrVG9rZW5fLCB0aGlzLmF1dGhUb2tlbl8sIG9uRGF0YU1lc3NhZ2UsIG9uUmVhZHksIG9uRGlzY29ubmVjdCwgXHJcbiAgICAgICAgICAgICAgICAgICAgLyogb25LaWxsPSAqLyByZWFzb24gPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB3YXJuKHJlYXNvbiArICcgKCcgKyB0aGlzLnJlcG9JbmZvXy50b1N0cmluZygpICsgJyknKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pbnRlcnJ1cHQoU0VSVkVSX0tJTExfSU5URVJSVVBUX1JFQVNPTik7XHJcbiAgICAgICAgICAgICAgICAgICAgfSwgbGFzdFNlc3Npb25JZCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBsb2coJ2dldFRva2VuKCkgY29tcGxldGVkIGJ1dCB3YXMgY2FuY2VsZWQnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubG9nXygnRmFpbGVkIHRvIGdldCB0b2tlbjogJyArIGVycm9yKTtcclxuICAgICAgICAgICAgICAgIGlmICghY2FuY2VsZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5yZXBvSW5mb18ubm9kZUFkbWluKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgbWF5IGJlIGEgY3JpdGljYWwgZXJyb3IgZm9yIHRoZSBBZG1pbiBOb2RlLmpzIFNESywgc28gbG9nIGEgd2FybmluZy5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQnV0IGdldFRva2VuKCkgbWF5IGFsc28ganVzdCBoYXZlIHRlbXBvcmFyaWx5IGZhaWxlZCwgc28gd2Ugc3RpbGwgd2FudCB0b1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjb250aW51ZSByZXRyeWluZy5cclxuICAgICAgICAgICAgICAgICAgICAgICAgd2FybihlcnJvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNsb3NlRm4oKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGludGVycnVwdChyZWFzb24pIHtcclxuICAgICAgICBsb2coJ0ludGVycnVwdGluZyBjb25uZWN0aW9uIGZvciByZWFzb246ICcgKyByZWFzb24pO1xyXG4gICAgICAgIHRoaXMuaW50ZXJydXB0UmVhc29uc19bcmVhc29uXSA9IHRydWU7XHJcbiAgICAgICAgaWYgKHRoaXMucmVhbHRpbWVfKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVhbHRpbWVfLmNsb3NlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5lc3RhYmxpc2hDb25uZWN0aW9uVGltZXJfKSB7XHJcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5lc3RhYmxpc2hDb25uZWN0aW9uVGltZXJfKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZXN0YWJsaXNoQ29ubmVjdGlvblRpbWVyXyA9IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRoaXMuY29ubmVjdGVkXykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vblJlYWx0aW1lRGlzY29ubmVjdF8oKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJlc3VtZShyZWFzb24pIHtcclxuICAgICAgICBsb2coJ1Jlc3VtaW5nIGNvbm5lY3Rpb24gZm9yIHJlYXNvbjogJyArIHJlYXNvbik7XHJcbiAgICAgICAgZGVsZXRlIHRoaXMuaW50ZXJydXB0UmVhc29uc19bcmVhc29uXTtcclxuICAgICAgICBpZiAoaXNFbXB0eSh0aGlzLmludGVycnVwdFJlYXNvbnNfKSkge1xyXG4gICAgICAgICAgICB0aGlzLnJlY29ubmVjdERlbGF5XyA9IFJFQ09OTkVDVF9NSU5fREVMQVk7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5yZWFsdGltZV8pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2NoZWR1bGVDb25uZWN0XygwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGhhbmRsZVRpbWVzdGFtcF8odGltZXN0YW1wKSB7XHJcbiAgICAgICAgY29uc3QgZGVsdGEgPSB0aW1lc3RhbXAgLSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcclxuICAgICAgICB0aGlzLm9uU2VydmVySW5mb1VwZGF0ZV8oeyBzZXJ2ZXJUaW1lT2Zmc2V0OiBkZWx0YSB9KTtcclxuICAgIH1cclxuICAgIGNhbmNlbFNlbnRUcmFuc2FjdGlvbnNfKCkge1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5vdXRzdGFuZGluZ1B1dHNfLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHB1dCA9IHRoaXMub3V0c3RhbmRpbmdQdXRzX1tpXTtcclxuICAgICAgICAgICAgaWYgKHB1dCAmJiAvKmhhc2gqLyAnaCcgaW4gcHV0LnJlcXVlc3QgJiYgcHV0LnF1ZXVlZCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHB1dC5vbkNvbXBsZXRlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcHV0Lm9uQ29tcGxldGUoJ2Rpc2Nvbm5lY3QnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLm91dHN0YW5kaW5nUHV0c19baV07XHJcbiAgICAgICAgICAgICAgICB0aGlzLm91dHN0YW5kaW5nUHV0Q291bnRfLS07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gQ2xlYW4gdXAgYXJyYXkgb2NjYXNpb25hbGx5LlxyXG4gICAgICAgIGlmICh0aGlzLm91dHN0YW5kaW5nUHV0Q291bnRfID09PSAwKSB7XHJcbiAgICAgICAgICAgIHRoaXMub3V0c3RhbmRpbmdQdXRzXyA9IFtdO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIG9uTGlzdGVuUmV2b2tlZF8ocGF0aFN0cmluZywgcXVlcnkpIHtcclxuICAgICAgICAvLyBSZW1vdmUgdGhlIGxpc3RlbiBhbmQgbWFudWZhY3R1cmUgYSBcInBlcm1pc3Npb25fZGVuaWVkXCIgZXJyb3IgZm9yIHRoZSBmYWlsZWQgbGlzdGVuLlxyXG4gICAgICAgIGxldCBxdWVyeUlkO1xyXG4gICAgICAgIGlmICghcXVlcnkpIHtcclxuICAgICAgICAgICAgcXVlcnlJZCA9ICdkZWZhdWx0JztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHF1ZXJ5SWQgPSBxdWVyeS5tYXAocSA9PiBPYmplY3RUb1VuaXF1ZUtleShxKSkuam9pbignJCcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBsaXN0ZW4gPSB0aGlzLnJlbW92ZUxpc3Rlbl8ocGF0aFN0cmluZywgcXVlcnlJZCk7XHJcbiAgICAgICAgaWYgKGxpc3RlbiAmJiBsaXN0ZW4ub25Db21wbGV0ZSkge1xyXG4gICAgICAgICAgICBsaXN0ZW4ub25Db21wbGV0ZSgncGVybWlzc2lvbl9kZW5pZWQnKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZW1vdmVMaXN0ZW5fKHBhdGhTdHJpbmcsIHF1ZXJ5SWQpIHtcclxuICAgICAgICBjb25zdCBub3JtYWxpemVkUGF0aFN0cmluZyA9IG5ldyBQYXRoKHBhdGhTdHJpbmcpLnRvU3RyaW5nKCk7IC8vIG5vcm1hbGl6ZSBwYXRoLlxyXG4gICAgICAgIGxldCBsaXN0ZW47XHJcbiAgICAgICAgaWYgKHRoaXMubGlzdGVucy5oYXMobm9ybWFsaXplZFBhdGhTdHJpbmcpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG1hcCA9IHRoaXMubGlzdGVucy5nZXQobm9ybWFsaXplZFBhdGhTdHJpbmcpO1xyXG4gICAgICAgICAgICBsaXN0ZW4gPSBtYXAuZ2V0KHF1ZXJ5SWQpO1xyXG4gICAgICAgICAgICBtYXAuZGVsZXRlKHF1ZXJ5SWQpO1xyXG4gICAgICAgICAgICBpZiAobWFwLnNpemUgPT09IDApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubGlzdGVucy5kZWxldGUobm9ybWFsaXplZFBhdGhTdHJpbmcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBhbGwgbGlzdGVucyBmb3IgdGhpcyBwYXRoIGhhcyBhbHJlYWR5IGJlZW4gcmVtb3ZlZFxyXG4gICAgICAgICAgICBsaXN0ZW4gPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBsaXN0ZW47XHJcbiAgICB9XHJcbiAgICBvbkF1dGhSZXZva2VkXyhzdGF0dXNDb2RlLCBleHBsYW5hdGlvbikge1xyXG4gICAgICAgIGxvZygnQXV0aCB0b2tlbiByZXZva2VkOiAnICsgc3RhdHVzQ29kZSArICcvJyArIGV4cGxhbmF0aW9uKTtcclxuICAgICAgICB0aGlzLmF1dGhUb2tlbl8gPSBudWxsO1xyXG4gICAgICAgIHRoaXMuZm9yY2VUb2tlblJlZnJlc2hfID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLnJlYWx0aW1lXy5jbG9zZSgpO1xyXG4gICAgICAgIGlmIChzdGF0dXNDb2RlID09PSAnaW52YWxpZF90b2tlbicgfHwgc3RhdHVzQ29kZSA9PT0gJ3Blcm1pc3Npb25fZGVuaWVkJykge1xyXG4gICAgICAgICAgICAvLyBXZSdsbCB3YWl0IGEgY291cGxlIHRpbWVzIGJlZm9yZSBsb2dnaW5nIHRoZSB3YXJuaW5nIC8gaW5jcmVhc2luZyB0aGVcclxuICAgICAgICAgICAgLy8gcmV0cnkgcGVyaW9kIHNpbmNlIG9hdXRoIHRva2VucyB3aWxsIHJlcG9ydCBhcyBcImludmFsaWRcIiBpZiB0aGV5J3JlXHJcbiAgICAgICAgICAgIC8vIGp1c3QgZXhwaXJlZC4gUGx1cyB0aGVyZSBtYXkgYmUgdHJhbnNpZW50IGlzc3VlcyB0aGF0IHJlc29sdmUgdGhlbXNlbHZlcy5cclxuICAgICAgICAgICAgdGhpcy5pbnZhbGlkQXV0aFRva2VuQ291bnRfKys7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmludmFsaWRBdXRoVG9rZW5Db3VudF8gPj0gSU5WQUxJRF9UT0tFTl9USFJFU0hPTEQpIHtcclxuICAgICAgICAgICAgICAgIC8vIFNldCBhIGxvbmcgcmVjb25uZWN0IGRlbGF5IGJlY2F1c2UgcmVjb3ZlcnkgaXMgdW5saWtlbHlcclxuICAgICAgICAgICAgICAgIHRoaXMucmVjb25uZWN0RGVsYXlfID0gUkVDT05ORUNUX01BWF9ERUxBWV9GT1JfQURNSU5TO1xyXG4gICAgICAgICAgICAgICAgLy8gTm90aWZ5IHRoZSBhdXRoIHRva2VuIHByb3ZpZGVyIHRoYXQgdGhlIHRva2VuIGlzIGludmFsaWQsIHdoaWNoIHdpbGwgbG9nXHJcbiAgICAgICAgICAgICAgICAvLyBhIHdhcm5pbmdcclxuICAgICAgICAgICAgICAgIHRoaXMuYXV0aFRva2VuUHJvdmlkZXJfLm5vdGlmeUZvckludmFsaWRUb2tlbigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgb25BcHBDaGVja1Jldm9rZWRfKHN0YXR1c0NvZGUsIGV4cGxhbmF0aW9uKSB7XHJcbiAgICAgICAgbG9nKCdBcHAgY2hlY2sgdG9rZW4gcmV2b2tlZDogJyArIHN0YXR1c0NvZGUgKyAnLycgKyBleHBsYW5hdGlvbik7XHJcbiAgICAgICAgdGhpcy5hcHBDaGVja1Rva2VuXyA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5mb3JjZVRva2VuUmVmcmVzaF8gPSB0cnVlO1xyXG4gICAgICAgIC8vIE5vdGU6IFdlIGRvbid0IGNsb3NlIHRoZSBjb25uZWN0aW9uIGFzIHRoZSBkZXZlbG9wZXIgbWF5IG5vdCBoYXZlXHJcbiAgICAgICAgLy8gZW5mb3JjZW1lbnQgZW5hYmxlZC4gVGhlIGJhY2tlbmQgY2xvc2VzIGNvbm5lY3Rpb25zIHdpdGggZW5mb3JjZW1lbnRzLlxyXG4gICAgICAgIGlmIChzdGF0dXNDb2RlID09PSAnaW52YWxpZF90b2tlbicgfHwgc3RhdHVzQ29kZSA9PT0gJ3Blcm1pc3Npb25fZGVuaWVkJykge1xyXG4gICAgICAgICAgICAvLyBXZSdsbCB3YWl0IGEgY291cGxlIHRpbWVzIGJlZm9yZSBsb2dnaW5nIHRoZSB3YXJuaW5nIC8gaW5jcmVhc2luZyB0aGVcclxuICAgICAgICAgICAgLy8gcmV0cnkgcGVyaW9kIHNpbmNlIG9hdXRoIHRva2VucyB3aWxsIHJlcG9ydCBhcyBcImludmFsaWRcIiBpZiB0aGV5J3JlXHJcbiAgICAgICAgICAgIC8vIGp1c3QgZXhwaXJlZC4gUGx1cyB0aGVyZSBtYXkgYmUgdHJhbnNpZW50IGlzc3VlcyB0aGF0IHJlc29sdmUgdGhlbXNlbHZlcy5cclxuICAgICAgICAgICAgdGhpcy5pbnZhbGlkQXBwQ2hlY2tUb2tlbkNvdW50XysrO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5pbnZhbGlkQXBwQ2hlY2tUb2tlbkNvdW50XyA+PSBJTlZBTElEX1RPS0VOX1RIUkVTSE9MRCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hcHBDaGVja1Rva2VuUHJvdmlkZXJfLm5vdGlmeUZvckludmFsaWRUb2tlbigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgb25TZWN1cml0eURlYnVnUGFja2V0Xyhib2R5KSB7XHJcbiAgICAgICAgaWYgKHRoaXMuc2VjdXJpdHlEZWJ1Z0NhbGxiYWNrXykge1xyXG4gICAgICAgICAgICB0aGlzLnNlY3VyaXR5RGVidWdDYWxsYmFja18oYm9keSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAoJ21zZycgaW4gYm9keSkge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0ZJUkVCQVNFOiAnICsgYm9keVsnbXNnJ10ucmVwbGFjZSgnXFxuJywgJ1xcbkZJUkVCQVNFOiAnKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXN0b3JlU3RhdGVfKCkge1xyXG4gICAgICAgIC8vUmUtYXV0aGVudGljYXRlIG91cnNlbHZlcyBpZiB3ZSBoYXZlIGEgY3JlZGVudGlhbCBzdG9yZWQuXHJcbiAgICAgICAgdGhpcy50cnlBdXRoKCk7XHJcbiAgICAgICAgdGhpcy50cnlBcHBDaGVjaygpO1xyXG4gICAgICAgIC8vIFB1dHMgZGVwZW5kIG9uIGhhdmluZyByZWNlaXZlZCB0aGUgY29ycmVzcG9uZGluZyBkYXRhIHVwZGF0ZSBmcm9tIHRoZSBzZXJ2ZXIgYmVmb3JlIHRoZXkgY29tcGxldGUsIHNvIHdlIG11c3RcclxuICAgICAgICAvLyBtYWtlIHN1cmUgdG8gc2VuZCBsaXN0ZW5zIGJlZm9yZSBwdXRzLlxyXG4gICAgICAgIGZvciAoY29uc3QgcXVlcmllcyBvZiB0aGlzLmxpc3RlbnMudmFsdWVzKCkpIHtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBsaXN0ZW5TcGVjIG9mIHF1ZXJpZXMudmFsdWVzKCkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2VuZExpc3Rlbl8obGlzdGVuU3BlYyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm91dHN0YW5kaW5nUHV0c18ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMub3V0c3RhbmRpbmdQdXRzX1tpXSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZW5kUHV0XyhpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB3aGlsZSAodGhpcy5vbkRpc2Nvbm5lY3RSZXF1ZXN0UXVldWVfLmxlbmd0aCkge1xyXG4gICAgICAgICAgICBjb25zdCByZXF1ZXN0ID0gdGhpcy5vbkRpc2Nvbm5lY3RSZXF1ZXN0UXVldWVfLnNoaWZ0KCk7XHJcbiAgICAgICAgICAgIHRoaXMuc2VuZE9uRGlzY29ubmVjdF8ocmVxdWVzdC5hY3Rpb24sIHJlcXVlc3QucGF0aFN0cmluZywgcmVxdWVzdC5kYXRhLCByZXF1ZXN0Lm9uQ29tcGxldGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMub3V0c3RhbmRpbmdHZXRzXy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5vdXRzdGFuZGluZ0dldHNfW2ldKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNlbmRHZXRfKGkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTZW5kcyBjbGllbnQgc3RhdHMgZm9yIGZpcnN0IGNvbm5lY3Rpb25cclxuICAgICAqL1xyXG4gICAgc2VuZENvbm5lY3RTdGF0c18oKSB7XHJcbiAgICAgICAgY29uc3Qgc3RhdHMgPSB7fTtcclxuICAgICAgICBsZXQgY2xpZW50TmFtZSA9ICdqcyc7XHJcbiAgICAgICAgaWYgKGlzTm9kZVNkaygpKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnJlcG9JbmZvXy5ub2RlQWRtaW4pIHtcclxuICAgICAgICAgICAgICAgIGNsaWVudE5hbWUgPSAnYWRtaW5fbm9kZSc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjbGllbnROYW1lID0gJ25vZGUnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN0YXRzWydzZGsuJyArIGNsaWVudE5hbWUgKyAnLicgKyBTREtfVkVSU0lPTi5yZXBsYWNlKC9cXC4vZywgJy0nKV0gPSAxO1xyXG4gICAgICAgIGlmIChpc01vYmlsZUNvcmRvdmEoKSkge1xyXG4gICAgICAgICAgICBzdGF0c1snZnJhbWV3b3JrLmNvcmRvdmEnXSA9IDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGlzUmVhY3ROYXRpdmUoKSkge1xyXG4gICAgICAgICAgICBzdGF0c1snZnJhbWV3b3JrLnJlYWN0bmF0aXZlJ10gPSAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnJlcG9ydFN0YXRzKHN0YXRzKTtcclxuICAgIH1cclxuICAgIHNob3VsZFJlY29ubmVjdF8oKSB7XHJcbiAgICAgICAgY29uc3Qgb25saW5lID0gT25saW5lTW9uaXRvci5nZXRJbnN0YW5jZSgpLmN1cnJlbnRseU9ubGluZSgpO1xyXG4gICAgICAgIHJldHVybiBpc0VtcHR5KHRoaXMuaW50ZXJydXB0UmVhc29uc18pICYmIG9ubGluZTtcclxuICAgIH1cclxufVxyXG5QZXJzaXN0ZW50Q29ubmVjdGlvbi5uZXh0UGVyc2lzdGVudENvbm5lY3Rpb25JZF8gPSAwO1xyXG4vKipcclxuICogQ291bnRlciBmb3IgbnVtYmVyIG9mIGNvbm5lY3Rpb25zIGNyZWF0ZWQuIE1haW5seSB1c2VkIGZvciB0YWdnaW5nIGluIHRoZSBsb2dzXHJcbiAqL1xyXG5QZXJzaXN0ZW50Q29ubmVjdGlvbi5uZXh0Q29ubmVjdGlvbklkXyA9IDA7XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmNsYXNzIE5hbWVkTm9kZSB7XHJcbiAgICBjb25zdHJ1Y3RvcihuYW1lLCBub2RlKSB7XHJcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcclxuICAgICAgICB0aGlzLm5vZGUgPSBub2RlO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIFdyYXAobmFtZSwgbm9kZSkge1xyXG4gICAgICAgIHJldHVybiBuZXcgTmFtZWROb2RlKG5hbWUsIG5vZGUpO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmNsYXNzIEluZGV4IHtcclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybnMgQSBzdGFuZGFsb25lIGNvbXBhcmlzb24gZnVuY3Rpb24gZm9yXHJcbiAgICAgKiB0aGlzIGluZGV4XHJcbiAgICAgKi9cclxuICAgIGdldENvbXBhcmUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGFyZS5iaW5kKHRoaXMpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHaXZlbiBhIGJlZm9yZSBhbmQgYWZ0ZXIgdmFsdWUgZm9yIGEgbm9kZSwgZGV0ZXJtaW5lIGlmIHRoZSBpbmRleGVkIHZhbHVlIGhhcyBjaGFuZ2VkLiBFdmVuIGlmIHRoZXkgYXJlIGRpZmZlcmVudCxcclxuICAgICAqIGl0J3MgcG9zc2libGUgdGhhdCB0aGUgY2hhbmdlcyBhcmUgaXNvbGF0ZWQgdG8gcGFydHMgb2YgdGhlIHNuYXBzaG90IHRoYXQgYXJlIG5vdCBpbmRleGVkLlxyXG4gICAgICpcclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyBUcnVlIGlmIHRoZSBwb3J0aW9uIG9mIHRoZSBzbmFwc2hvdCBiZWluZyBpbmRleGVkIGNoYW5nZWQgYmV0d2VlbiBvbGROb2RlIGFuZCBuZXdOb2RlXHJcbiAgICAgKi9cclxuICAgIGluZGV4ZWRWYWx1ZUNoYW5nZWQob2xkTm9kZSwgbmV3Tm9kZSkge1xyXG4gICAgICAgIGNvbnN0IG9sZFdyYXBwZWQgPSBuZXcgTmFtZWROb2RlKE1JTl9OQU1FLCBvbGROb2RlKTtcclxuICAgICAgICBjb25zdCBuZXdXcmFwcGVkID0gbmV3IE5hbWVkTm9kZShNSU5fTkFNRSwgbmV3Tm9kZSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGFyZShvbGRXcmFwcGVkLCBuZXdXcmFwcGVkKSAhPT0gMDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybnMgYSBub2RlIHdyYXBwZXIgdGhhdCB3aWxsIHNvcnQgZXF1YWwgdG8gb3IgbGVzcyB0aGFuXHJcbiAgICAgKiBhbnkgb3RoZXIgbm9kZSB3cmFwcGVyLCB1c2luZyB0aGlzIGluZGV4XHJcbiAgICAgKi9cclxuICAgIG1pblBvc3QoKSB7XHJcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcclxuICAgICAgICByZXR1cm4gTmFtZWROb2RlLk1JTjtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5sZXQgX19FTVBUWV9OT0RFO1xyXG5jbGFzcyBLZXlJbmRleCBleHRlbmRzIEluZGV4IHtcclxuICAgIHN0YXRpYyBnZXQgX19FTVBUWV9OT0RFKCkge1xyXG4gICAgICAgIHJldHVybiBfX0VNUFRZX05PREU7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgc2V0IF9fRU1QVFlfTk9ERSh2YWwpIHtcclxuICAgICAgICBfX0VNUFRZX05PREUgPSB2YWw7XHJcbiAgICB9XHJcbiAgICBjb21wYXJlKGEsIGIpIHtcclxuICAgICAgICByZXR1cm4gbmFtZUNvbXBhcmUoYS5uYW1lLCBiLm5hbWUpO1xyXG4gICAgfVxyXG4gICAgaXNEZWZpbmVkT24obm9kZSkge1xyXG4gICAgICAgIC8vIFdlIGNvdWxkIHByb2JhYmx5IHJldHVybiB0cnVlIGhlcmUgKHNpbmNlIGV2ZXJ5IG5vZGUgaGFzIGEga2V5KSwgYnV0IGl0J3MgbmV2ZXIgY2FsbGVkXHJcbiAgICAgICAgLy8gc28ganVzdCBsZWF2aW5nIHVuaW1wbGVtZW50ZWQgZm9yIG5vdy5cclxuICAgICAgICB0aHJvdyBhc3NlcnRpb25FcnJvcignS2V5SW5kZXguaXNEZWZpbmVkT24gbm90IGV4cGVjdGVkIHRvIGJlIGNhbGxlZC4nKTtcclxuICAgIH1cclxuICAgIGluZGV4ZWRWYWx1ZUNoYW5nZWQob2xkTm9kZSwgbmV3Tm9kZSkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTsgLy8gVGhlIGtleSBmb3IgYSBub2RlIG5ldmVyIGNoYW5nZXMuXHJcbiAgICB9XHJcbiAgICBtaW5Qb3N0KCkge1xyXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XHJcbiAgICAgICAgcmV0dXJuIE5hbWVkTm9kZS5NSU47XHJcbiAgICB9XHJcbiAgICBtYXhQb3N0KCkge1xyXG4gICAgICAgIC8vIFRPRE86IFRoaXMgc2hvdWxkIHJlYWxseSBiZSBjcmVhdGVkIG9uY2UgYW5kIGNhY2hlZCBpbiBhIHN0YXRpYyBwcm9wZXJ0eSwgYnV0XHJcbiAgICAgICAgLy8gTmFtZWROb2RlIGlzbid0IGRlZmluZWQgeWV0LCBzbyBJIGNhbid0IHVzZSBpdCBpbiBhIHN0YXRpYy4gIEJsZWguXHJcbiAgICAgICAgcmV0dXJuIG5ldyBOYW1lZE5vZGUoTUFYX05BTUUsIF9fRU1QVFlfTk9ERSk7XHJcbiAgICB9XHJcbiAgICBtYWtlUG9zdChpbmRleFZhbHVlLCBuYW1lKSB7XHJcbiAgICAgICAgYXNzZXJ0KHR5cGVvZiBpbmRleFZhbHVlID09PSAnc3RyaW5nJywgJ0tleUluZGV4IGluZGV4VmFsdWUgbXVzdCBhbHdheXMgYmUgYSBzdHJpbmcuJyk7XHJcbiAgICAgICAgLy8gV2UganVzdCB1c2UgZW1wdHkgbm9kZSwgYnV0IGl0J2xsIG5ldmVyIGJlIGNvbXBhcmVkLCBzaW5jZSBvdXIgY29tcGFyYXRvciBvbmx5IGxvb2tzIGF0IG5hbWUuXHJcbiAgICAgICAgcmV0dXJuIG5ldyBOYW1lZE5vZGUoaW5kZXhWYWx1ZSwgX19FTVBUWV9OT0RFKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybnMgU3RyaW5nIHJlcHJlc2VudGF0aW9uIGZvciBpbmNsdXNpb24gaW4gYSBxdWVyeSBzcGVjXHJcbiAgICAgKi9cclxuICAgIHRvU3RyaW5nKCkge1xyXG4gICAgICAgIHJldHVybiAnLmtleSc7XHJcbiAgICB9XHJcbn1cclxuY29uc3QgS0VZX0lOREVYID0gbmV3IEtleUluZGV4KCk7XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBBbiBpdGVyYXRvciBvdmVyIGFuIExMUkJOb2RlLlxyXG4gKi9cclxuY2xhc3MgU29ydGVkTWFwSXRlcmF0b3Ige1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gbm9kZSAtIE5vZGUgdG8gaXRlcmF0ZS5cclxuICAgICAqIEBwYXJhbSBpc1JldmVyc2VfIC0gV2hldGhlciBvciBub3QgdG8gaXRlcmF0ZSBpbiByZXZlcnNlXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKG5vZGUsIHN0YXJ0S2V5LCBjb21wYXJhdG9yLCBpc1JldmVyc2VfLCByZXN1bHRHZW5lcmF0b3JfID0gbnVsbCkge1xyXG4gICAgICAgIHRoaXMuaXNSZXZlcnNlXyA9IGlzUmV2ZXJzZV87XHJcbiAgICAgICAgdGhpcy5yZXN1bHRHZW5lcmF0b3JfID0gcmVzdWx0R2VuZXJhdG9yXztcclxuICAgICAgICB0aGlzLm5vZGVTdGFja18gPSBbXTtcclxuICAgICAgICBsZXQgY21wID0gMTtcclxuICAgICAgICB3aGlsZSAoIW5vZGUuaXNFbXB0eSgpKSB7XHJcbiAgICAgICAgICAgIG5vZGUgPSBub2RlO1xyXG4gICAgICAgICAgICBjbXAgPSBzdGFydEtleSA/IGNvbXBhcmF0b3Iobm9kZS5rZXksIHN0YXJ0S2V5KSA6IDE7XHJcbiAgICAgICAgICAgIC8vIGZsaXAgdGhlIGNvbXBhcmlzb24gaWYgd2UncmUgZ29pbmcgaW4gcmV2ZXJzZVxyXG4gICAgICAgICAgICBpZiAoaXNSZXZlcnNlXykge1xyXG4gICAgICAgICAgICAgICAgY21wICo9IC0xO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChjbXAgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBUaGlzIG5vZGUgaXMgbGVzcyB0aGFuIG91ciBzdGFydCBrZXkuIGlnbm9yZSBpdFxyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNSZXZlcnNlXykge1xyXG4gICAgICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLmxlZnQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5yaWdodDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChjbXAgPT09IDApIHtcclxuICAgICAgICAgICAgICAgIC8vIFRoaXMgbm9kZSBpcyBleGFjdGx5IGVxdWFsIHRvIG91ciBzdGFydCBrZXkuIFB1c2ggaXQgb24gdGhlIHN0YWNrLCBidXQgc3RvcCBpdGVyYXRpbmc7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm5vZGVTdGFja18ucHVzaChub2RlKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBub2RlIGlzIGdyZWF0ZXIgdGhhbiBvdXIgc3RhcnQga2V5LCBhZGQgaXQgdG8gdGhlIHN0YWNrIGFuZCBtb3ZlIHRvIHRoZSBuZXh0IG9uZVxyXG4gICAgICAgICAgICAgICAgdGhpcy5ub2RlU3RhY2tfLnB1c2gobm9kZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pc1JldmVyc2VfKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUucmlnaHQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5sZWZ0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZ2V0TmV4dCgpIHtcclxuICAgICAgICBpZiAodGhpcy5ub2RlU3RhY2tfLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IG5vZGUgPSB0aGlzLm5vZGVTdGFja18ucG9wKCk7XHJcbiAgICAgICAgbGV0IHJlc3VsdDtcclxuICAgICAgICBpZiAodGhpcy5yZXN1bHRHZW5lcmF0b3JfKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMucmVzdWx0R2VuZXJhdG9yXyhub2RlLmtleSwgbm9kZS52YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXN1bHQgPSB7IGtleTogbm9kZS5rZXksIHZhbHVlOiBub2RlLnZhbHVlIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmlzUmV2ZXJzZV8pIHtcclxuICAgICAgICAgICAgbm9kZSA9IG5vZGUubGVmdDtcclxuICAgICAgICAgICAgd2hpbGUgKCFub2RlLmlzRW1wdHkoKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ub2RlU3RhY2tfLnB1c2gobm9kZSk7XHJcbiAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5yaWdodDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgbm9kZSA9IG5vZGUucmlnaHQ7XHJcbiAgICAgICAgICAgIHdoaWxlICghbm9kZS5pc0VtcHR5KCkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubm9kZVN0YWNrXy5wdXNoKG5vZGUpO1xyXG4gICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUubGVmdDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG4gICAgaGFzTmV4dCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5ub2RlU3RhY2tfLmxlbmd0aCA+IDA7XHJcbiAgICB9XHJcbiAgICBwZWVrKCkge1xyXG4gICAgICAgIGlmICh0aGlzLm5vZGVTdGFja18ubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBub2RlID0gdGhpcy5ub2RlU3RhY2tfW3RoaXMubm9kZVN0YWNrXy5sZW5ndGggLSAxXTtcclxuICAgICAgICBpZiAodGhpcy5yZXN1bHRHZW5lcmF0b3JfKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlc3VsdEdlbmVyYXRvcl8obm9kZS5rZXksIG5vZGUudmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHsga2V5OiBub2RlLmtleSwgdmFsdWU6IG5vZGUudmFsdWUgfTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFJlcHJlc2VudHMgYSBub2RlIGluIGEgTGVmdC1sZWFuaW5nIFJlZC1CbGFjayB0cmVlLlxyXG4gKi9cclxuY2xhc3MgTExSQk5vZGUge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0ga2V5IC0gS2V5IGFzc29jaWF0ZWQgd2l0aCB0aGlzIG5vZGUuXHJcbiAgICAgKiBAcGFyYW0gdmFsdWUgLSBWYWx1ZSBhc3NvY2lhdGVkIHdpdGggdGhpcyBub2RlLlxyXG4gICAgICogQHBhcmFtIGNvbG9yIC0gV2hldGhlciB0aGlzIG5vZGUgaXMgcmVkLlxyXG4gICAgICogQHBhcmFtIGxlZnQgLSBMZWZ0IGNoaWxkLlxyXG4gICAgICogQHBhcmFtIHJpZ2h0IC0gUmlnaHQgY2hpbGQuXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKGtleSwgdmFsdWUsIGNvbG9yLCBsZWZ0LCByaWdodCkge1xyXG4gICAgICAgIHRoaXMua2V5ID0ga2V5O1xyXG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcclxuICAgICAgICB0aGlzLmNvbG9yID0gY29sb3IgIT0gbnVsbCA/IGNvbG9yIDogTExSQk5vZGUuUkVEO1xyXG4gICAgICAgIHRoaXMubGVmdCA9XHJcbiAgICAgICAgICAgIGxlZnQgIT0gbnVsbCA/IGxlZnQgOiBTb3J0ZWRNYXAuRU1QVFlfTk9ERTtcclxuICAgICAgICB0aGlzLnJpZ2h0ID1cclxuICAgICAgICAgICAgcmlnaHQgIT0gbnVsbCA/IHJpZ2h0IDogU29ydGVkTWFwLkVNUFRZX05PREU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBjb3B5IG9mIHRoZSBjdXJyZW50IG5vZGUsIG9wdGlvbmFsbHkgcmVwbGFjaW5nIHBpZWNlcyBvZiBpdC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ga2V5IC0gTmV3IGtleSBmb3IgdGhlIG5vZGUsIG9yIG51bGwuXHJcbiAgICAgKiBAcGFyYW0gdmFsdWUgLSBOZXcgdmFsdWUgZm9yIHRoZSBub2RlLCBvciBudWxsLlxyXG4gICAgICogQHBhcmFtIGNvbG9yIC0gTmV3IGNvbG9yIGZvciB0aGUgbm9kZSwgb3IgbnVsbC5cclxuICAgICAqIEBwYXJhbSBsZWZ0IC0gTmV3IGxlZnQgY2hpbGQgZm9yIHRoZSBub2RlLCBvciBudWxsLlxyXG4gICAgICogQHBhcmFtIHJpZ2h0IC0gTmV3IHJpZ2h0IGNoaWxkIGZvciB0aGUgbm9kZSwgb3IgbnVsbC5cclxuICAgICAqIEByZXR1cm5zIFRoZSBub2RlIGNvcHkuXHJcbiAgICAgKi9cclxuICAgIGNvcHkoa2V5LCB2YWx1ZSwgY29sb3IsIGxlZnQsIHJpZ2h0KSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBMTFJCTm9kZShrZXkgIT0gbnVsbCA/IGtleSA6IHRoaXMua2V5LCB2YWx1ZSAhPSBudWxsID8gdmFsdWUgOiB0aGlzLnZhbHVlLCBjb2xvciAhPSBudWxsID8gY29sb3IgOiB0aGlzLmNvbG9yLCBsZWZ0ICE9IG51bGwgPyBsZWZ0IDogdGhpcy5sZWZ0LCByaWdodCAhPSBudWxsID8gcmlnaHQgOiB0aGlzLnJpZ2h0KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybnMgVGhlIHRvdGFsIG51bWJlciBvZiBub2RlcyBpbiB0aGUgdHJlZS5cclxuICAgICAqL1xyXG4gICAgY291bnQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubGVmdC5jb3VudCgpICsgMSArIHRoaXMucmlnaHQuY291bnQoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgdHJlZSBpcyBlbXB0eS5cclxuICAgICAqL1xyXG4gICAgaXNFbXB0eSgpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRyYXZlcnNlcyB0aGUgdHJlZSBpbiBrZXkgb3JkZXIgYW5kIGNhbGxzIHRoZSBzcGVjaWZpZWQgYWN0aW9uIGZ1bmN0aW9uXHJcbiAgICAgKiBmb3IgZWFjaCBub2RlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBhY3Rpb24gLSBDYWxsYmFjayBmdW5jdGlvbiB0byBiZSBjYWxsZWQgZm9yIGVhY2hcclxuICAgICAqICAgbm9kZS4gIElmIGl0IHJldHVybnMgdHJ1ZSwgdHJhdmVyc2FsIGlzIGFib3J0ZWQuXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgZmlyc3QgdHJ1dGh5IHZhbHVlIHJldHVybmVkIGJ5IGFjdGlvbiwgb3IgdGhlIGxhc3QgZmFsc2V5XHJcbiAgICAgKiAgIHZhbHVlIHJldHVybmVkIGJ5IGFjdGlvblxyXG4gICAgICovXHJcbiAgICBpbm9yZGVyVHJhdmVyc2FsKGFjdGlvbikge1xyXG4gICAgICAgIHJldHVybiAodGhpcy5sZWZ0Lmlub3JkZXJUcmF2ZXJzYWwoYWN0aW9uKSB8fFxyXG4gICAgICAgICAgICAhIWFjdGlvbih0aGlzLmtleSwgdGhpcy52YWx1ZSkgfHxcclxuICAgICAgICAgICAgdGhpcy5yaWdodC5pbm9yZGVyVHJhdmVyc2FsKGFjdGlvbikpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUcmF2ZXJzZXMgdGhlIHRyZWUgaW4gcmV2ZXJzZSBrZXkgb3JkZXIgYW5kIGNhbGxzIHRoZSBzcGVjaWZpZWQgYWN0aW9uIGZ1bmN0aW9uXHJcbiAgICAgKiBmb3IgZWFjaCBub2RlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBhY3Rpb24gLSBDYWxsYmFjayBmdW5jdGlvbiB0byBiZSBjYWxsZWQgZm9yIGVhY2hcclxuICAgICAqIG5vZGUuICBJZiBpdCByZXR1cm5zIHRydWUsIHRyYXZlcnNhbCBpcyBhYm9ydGVkLlxyXG4gICAgICogQHJldHVybnMgVHJ1ZSBpZiB0cmF2ZXJzYWwgd2FzIGFib3J0ZWQuXHJcbiAgICAgKi9cclxuICAgIHJldmVyc2VUcmF2ZXJzYWwoYWN0aW9uKSB7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLnJpZ2h0LnJldmVyc2VUcmF2ZXJzYWwoYWN0aW9uKSB8fFxyXG4gICAgICAgICAgICBhY3Rpb24odGhpcy5rZXksIHRoaXMudmFsdWUpIHx8XHJcbiAgICAgICAgICAgIHRoaXMubGVmdC5yZXZlcnNlVHJhdmVyc2FsKGFjdGlvbikpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgbWluaW11bSBub2RlIGluIHRoZSB0cmVlLlxyXG4gICAgICovXHJcbiAgICBtaW5fKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmxlZnQuaXNFbXB0eSgpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGVmdC5taW5fKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgbWF4aW11bSBrZXkgaW4gdGhlIHRyZWUuXHJcbiAgICAgKi9cclxuICAgIG1pbktleSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5taW5fKCkua2V5O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgbWF4aW11bSBrZXkgaW4gdGhlIHRyZWUuXHJcbiAgICAgKi9cclxuICAgIG1heEtleSgpIHtcclxuICAgICAgICBpZiAodGhpcy5yaWdodC5pc0VtcHR5KCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMua2V5O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmlnaHQubWF4S2V5KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0ga2V5IC0gS2V5IHRvIGluc2VydC5cclxuICAgICAqIEBwYXJhbSB2YWx1ZSAtIFZhbHVlIHRvIGluc2VydC5cclxuICAgICAqIEBwYXJhbSBjb21wYXJhdG9yIC0gQ29tcGFyYXRvci5cclxuICAgICAqIEByZXR1cm5zIE5ldyB0cmVlLCB3aXRoIHRoZSBrZXkvdmFsdWUgYWRkZWQuXHJcbiAgICAgKi9cclxuICAgIGluc2VydChrZXksIHZhbHVlLCBjb21wYXJhdG9yKSB7XHJcbiAgICAgICAgbGV0IG4gPSB0aGlzO1xyXG4gICAgICAgIGNvbnN0IGNtcCA9IGNvbXBhcmF0b3Ioa2V5LCBuLmtleSk7XHJcbiAgICAgICAgaWYgKGNtcCA8IDApIHtcclxuICAgICAgICAgICAgbiA9IG4uY29weShudWxsLCBudWxsLCBudWxsLCBuLmxlZnQuaW5zZXJ0KGtleSwgdmFsdWUsIGNvbXBhcmF0b3IpLCBudWxsKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoY21wID09PSAwKSB7XHJcbiAgICAgICAgICAgIG4gPSBuLmNvcHkobnVsbCwgdmFsdWUsIG51bGwsIG51bGwsIG51bGwpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgbiA9IG4uY29weShudWxsLCBudWxsLCBudWxsLCBudWxsLCBuLnJpZ2h0Lmluc2VydChrZXksIHZhbHVlLCBjb21wYXJhdG9yKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuLmZpeFVwXygpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJucyBOZXcgdHJlZSwgd2l0aCB0aGUgbWluaW11bSBrZXkgcmVtb3ZlZC5cclxuICAgICAqL1xyXG4gICAgcmVtb3ZlTWluXygpIHtcclxuICAgICAgICBpZiAodGhpcy5sZWZ0LmlzRW1wdHkoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gU29ydGVkTWFwLkVNUFRZX05PREU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBuID0gdGhpcztcclxuICAgICAgICBpZiAoIW4ubGVmdC5pc1JlZF8oKSAmJiAhbi5sZWZ0LmxlZnQuaXNSZWRfKCkpIHtcclxuICAgICAgICAgICAgbiA9IG4ubW92ZVJlZExlZnRfKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG4gPSBuLmNvcHkobnVsbCwgbnVsbCwgbnVsbCwgbi5sZWZ0LnJlbW92ZU1pbl8oKSwgbnVsbCk7XHJcbiAgICAgICAgcmV0dXJuIG4uZml4VXBfKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSBrZXkgLSBUaGUga2V5IG9mIHRoZSBpdGVtIHRvIHJlbW92ZS5cclxuICAgICAqIEBwYXJhbSBjb21wYXJhdG9yIC0gQ29tcGFyYXRvci5cclxuICAgICAqIEByZXR1cm5zIE5ldyB0cmVlLCB3aXRoIHRoZSBzcGVjaWZpZWQgaXRlbSByZW1vdmVkLlxyXG4gICAgICovXHJcbiAgICByZW1vdmUoa2V5LCBjb21wYXJhdG9yKSB7XHJcbiAgICAgICAgbGV0IG4sIHNtYWxsZXN0O1xyXG4gICAgICAgIG4gPSB0aGlzO1xyXG4gICAgICAgIGlmIChjb21wYXJhdG9yKGtleSwgbi5rZXkpIDwgMCkge1xyXG4gICAgICAgICAgICBpZiAoIW4ubGVmdC5pc0VtcHR5KCkgJiYgIW4ubGVmdC5pc1JlZF8oKSAmJiAhbi5sZWZ0LmxlZnQuaXNSZWRfKCkpIHtcclxuICAgICAgICAgICAgICAgIG4gPSBuLm1vdmVSZWRMZWZ0XygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG4gPSBuLmNvcHkobnVsbCwgbnVsbCwgbnVsbCwgbi5sZWZ0LnJlbW92ZShrZXksIGNvbXBhcmF0b3IpLCBudWxsKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmIChuLmxlZnQuaXNSZWRfKCkpIHtcclxuICAgICAgICAgICAgICAgIG4gPSBuLnJvdGF0ZVJpZ2h0XygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghbi5yaWdodC5pc0VtcHR5KCkgJiYgIW4ucmlnaHQuaXNSZWRfKCkgJiYgIW4ucmlnaHQubGVmdC5pc1JlZF8oKSkge1xyXG4gICAgICAgICAgICAgICAgbiA9IG4ubW92ZVJlZFJpZ2h0XygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChjb21wYXJhdG9yKGtleSwgbi5rZXkpID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobi5yaWdodC5pc0VtcHR5KCkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gU29ydGVkTWFwLkVNUFRZX05PREU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBzbWFsbGVzdCA9IG4ucmlnaHQubWluXygpO1xyXG4gICAgICAgICAgICAgICAgICAgIG4gPSBuLmNvcHkoc21hbGxlc3Qua2V5LCBzbWFsbGVzdC52YWx1ZSwgbnVsbCwgbnVsbCwgbi5yaWdodC5yZW1vdmVNaW5fKCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG4gPSBuLmNvcHkobnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbi5yaWdodC5yZW1vdmUoa2V5LCBjb21wYXJhdG9yKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuLmZpeFVwXygpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJucyBXaGV0aGVyIHRoaXMgaXMgYSBSRUQgbm9kZS5cclxuICAgICAqL1xyXG4gICAgaXNSZWRfKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNvbG9yO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJucyBOZXcgdHJlZSBhZnRlciBwZXJmb3JtaW5nIGFueSBuZWVkZWQgcm90YXRpb25zLlxyXG4gICAgICovXHJcbiAgICBmaXhVcF8oKSB7XHJcbiAgICAgICAgbGV0IG4gPSB0aGlzO1xyXG4gICAgICAgIGlmIChuLnJpZ2h0LmlzUmVkXygpICYmICFuLmxlZnQuaXNSZWRfKCkpIHtcclxuICAgICAgICAgICAgbiA9IG4ucm90YXRlTGVmdF8oKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG4ubGVmdC5pc1JlZF8oKSAmJiBuLmxlZnQubGVmdC5pc1JlZF8oKSkge1xyXG4gICAgICAgICAgICBuID0gbi5yb3RhdGVSaWdodF8oKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG4ubGVmdC5pc1JlZF8oKSAmJiBuLnJpZ2h0LmlzUmVkXygpKSB7XHJcbiAgICAgICAgICAgIG4gPSBuLmNvbG9yRmxpcF8oKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG47XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm5zIE5ldyB0cmVlLCBhZnRlciBtb3ZlUmVkTGVmdC5cclxuICAgICAqL1xyXG4gICAgbW92ZVJlZExlZnRfKCkge1xyXG4gICAgICAgIGxldCBuID0gdGhpcy5jb2xvckZsaXBfKCk7XHJcbiAgICAgICAgaWYgKG4ucmlnaHQubGVmdC5pc1JlZF8oKSkge1xyXG4gICAgICAgICAgICBuID0gbi5jb3B5KG51bGwsIG51bGwsIG51bGwsIG51bGwsIG4ucmlnaHQucm90YXRlUmlnaHRfKCkpO1xyXG4gICAgICAgICAgICBuID0gbi5yb3RhdGVMZWZ0XygpO1xyXG4gICAgICAgICAgICBuID0gbi5jb2xvckZsaXBfKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJucyBOZXcgdHJlZSwgYWZ0ZXIgbW92ZVJlZFJpZ2h0LlxyXG4gICAgICovXHJcbiAgICBtb3ZlUmVkUmlnaHRfKCkge1xyXG4gICAgICAgIGxldCBuID0gdGhpcy5jb2xvckZsaXBfKCk7XHJcbiAgICAgICAgaWYgKG4ubGVmdC5sZWZ0LmlzUmVkXygpKSB7XHJcbiAgICAgICAgICAgIG4gPSBuLnJvdGF0ZVJpZ2h0XygpO1xyXG4gICAgICAgICAgICBuID0gbi5jb2xvckZsaXBfKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJucyBOZXcgdHJlZSwgYWZ0ZXIgcm90YXRlTGVmdC5cclxuICAgICAqL1xyXG4gICAgcm90YXRlTGVmdF8oKSB7XHJcbiAgICAgICAgY29uc3QgbmwgPSB0aGlzLmNvcHkobnVsbCwgbnVsbCwgTExSQk5vZGUuUkVELCBudWxsLCB0aGlzLnJpZ2h0LmxlZnQpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJpZ2h0LmNvcHkobnVsbCwgbnVsbCwgdGhpcy5jb2xvciwgbmwsIG51bGwpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJucyBOZXcgdHJlZSwgYWZ0ZXIgcm90YXRlUmlnaHQuXHJcbiAgICAgKi9cclxuICAgIHJvdGF0ZVJpZ2h0XygpIHtcclxuICAgICAgICBjb25zdCBuciA9IHRoaXMuY29weShudWxsLCBudWxsLCBMTFJCTm9kZS5SRUQsIHRoaXMubGVmdC5yaWdodCwgbnVsbCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubGVmdC5jb3B5KG51bGwsIG51bGwsIHRoaXMuY29sb3IsIG51bGwsIG5yKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybnMgTmV3dCByZWUsIGFmdGVyIGNvbG9yRmxpcC5cclxuICAgICAqL1xyXG4gICAgY29sb3JGbGlwXygpIHtcclxuICAgICAgICBjb25zdCBsZWZ0ID0gdGhpcy5sZWZ0LmNvcHkobnVsbCwgbnVsbCwgIXRoaXMubGVmdC5jb2xvciwgbnVsbCwgbnVsbCk7XHJcbiAgICAgICAgY29uc3QgcmlnaHQgPSB0aGlzLnJpZ2h0LmNvcHkobnVsbCwgbnVsbCwgIXRoaXMucmlnaHQuY29sb3IsIG51bGwsIG51bGwpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNvcHkobnVsbCwgbnVsbCwgIXRoaXMuY29sb3IsIGxlZnQsIHJpZ2h0KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRm9yIHRlc3RpbmcuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgVHJ1ZSBpZiBhbGwgaXMgd2VsbC5cclxuICAgICAqL1xyXG4gICAgY2hlY2tNYXhEZXB0aF8oKSB7XHJcbiAgICAgICAgY29uc3QgYmxhY2tEZXB0aCA9IHRoaXMuY2hlY2tfKCk7XHJcbiAgICAgICAgcmV0dXJuIE1hdGgucG93KDIuMCwgYmxhY2tEZXB0aCkgPD0gdGhpcy5jb3VudCgpICsgMTtcclxuICAgIH1cclxuICAgIGNoZWNrXygpIHtcclxuICAgICAgICBpZiAodGhpcy5pc1JlZF8oKSAmJiB0aGlzLmxlZnQuaXNSZWRfKCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZWQgbm9kZSBoYXMgcmVkIGNoaWxkKCcgKyB0aGlzLmtleSArICcsJyArIHRoaXMudmFsdWUgKyAnKScpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5yaWdodC5pc1JlZF8oKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JpZ2h0IGNoaWxkIG9mICgnICsgdGhpcy5rZXkgKyAnLCcgKyB0aGlzLnZhbHVlICsgJykgaXMgcmVkJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGJsYWNrRGVwdGggPSB0aGlzLmxlZnQuY2hlY2tfKCk7XHJcbiAgICAgICAgaWYgKGJsYWNrRGVwdGggIT09IHRoaXMucmlnaHQuY2hlY2tfKCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdCbGFjayBkZXB0aHMgZGlmZmVyJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gYmxhY2tEZXB0aCArICh0aGlzLmlzUmVkXygpID8gMCA6IDEpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5MTFJCTm9kZS5SRUQgPSB0cnVlO1xyXG5MTFJCTm9kZS5CTEFDSyA9IGZhbHNlO1xyXG4vKipcclxuICogUmVwcmVzZW50cyBhbiBlbXB0eSBub2RlIChhIGxlYWYgbm9kZSBpbiB0aGUgUmVkLUJsYWNrIFRyZWUpLlxyXG4gKi9cclxuY2xhc3MgTExSQkVtcHR5Tm9kZSB7XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBjb3B5IG9mIHRoZSBjdXJyZW50IG5vZGUuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgVGhlIG5vZGUgY29weS5cclxuICAgICAqL1xyXG4gICAgY29weShrZXksIHZhbHVlLCBjb2xvciwgbGVmdCwgcmlnaHQpIHtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIGNvcHkgb2YgdGhlIHRyZWUsIHdpdGggdGhlIHNwZWNpZmllZCBrZXkvdmFsdWUgYWRkZWQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGtleSAtIEtleSB0byBiZSBhZGRlZC5cclxuICAgICAqIEBwYXJhbSB2YWx1ZSAtIFZhbHVlIHRvIGJlIGFkZGVkLlxyXG4gICAgICogQHBhcmFtIGNvbXBhcmF0b3IgLSBDb21wYXJhdG9yLlxyXG4gICAgICogQHJldHVybnMgTmV3IHRyZWUsIHdpdGggaXRlbSBhZGRlZC5cclxuICAgICAqL1xyXG4gICAgaW5zZXJ0KGtleSwgdmFsdWUsIGNvbXBhcmF0b3IpIHtcclxuICAgICAgICByZXR1cm4gbmV3IExMUkJOb2RlKGtleSwgdmFsdWUsIG51bGwpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgY29weSBvZiB0aGUgdHJlZSwgd2l0aCB0aGUgc3BlY2lmaWVkIGtleSByZW1vdmVkLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBrZXkgLSBUaGUga2V5IHRvIHJlbW92ZS5cclxuICAgICAqIEBwYXJhbSBjb21wYXJhdG9yIC0gQ29tcGFyYXRvci5cclxuICAgICAqIEByZXR1cm5zIE5ldyB0cmVlLCB3aXRoIGl0ZW0gcmVtb3ZlZC5cclxuICAgICAqL1xyXG4gICAgcmVtb3ZlKGtleSwgY29tcGFyYXRvcikge1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgdG90YWwgbnVtYmVyIG9mIG5vZGVzIGluIHRoZSB0cmVlLlxyXG4gICAgICovXHJcbiAgICBjb3VudCgpIHtcclxuICAgICAgICByZXR1cm4gMDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgdHJlZSBpcyBlbXB0eS5cclxuICAgICAqL1xyXG4gICAgaXNFbXB0eSgpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVHJhdmVyc2VzIHRoZSB0cmVlIGluIGtleSBvcmRlciBhbmQgY2FsbHMgdGhlIHNwZWNpZmllZCBhY3Rpb24gZnVuY3Rpb25cclxuICAgICAqIGZvciBlYWNoIG5vZGUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGFjdGlvbiAtIENhbGxiYWNrIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCBmb3IgZWFjaFxyXG4gICAgICogbm9kZS4gIElmIGl0IHJldHVybnMgdHJ1ZSwgdHJhdmVyc2FsIGlzIGFib3J0ZWQuXHJcbiAgICAgKiBAcmV0dXJucyBUcnVlIGlmIHRyYXZlcnNhbCB3YXMgYWJvcnRlZC5cclxuICAgICAqL1xyXG4gICAgaW5vcmRlclRyYXZlcnNhbChhY3Rpb24pIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRyYXZlcnNlcyB0aGUgdHJlZSBpbiByZXZlcnNlIGtleSBvcmRlciBhbmQgY2FsbHMgdGhlIHNwZWNpZmllZCBhY3Rpb24gZnVuY3Rpb25cclxuICAgICAqIGZvciBlYWNoIG5vZGUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGFjdGlvbiAtIENhbGxiYWNrIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCBmb3IgZWFjaFxyXG4gICAgICogbm9kZS4gIElmIGl0IHJldHVybnMgdHJ1ZSwgdHJhdmVyc2FsIGlzIGFib3J0ZWQuXHJcbiAgICAgKiBAcmV0dXJucyBUcnVlIGlmIHRyYXZlcnNhbCB3YXMgYWJvcnRlZC5cclxuICAgICAqL1xyXG4gICAgcmV2ZXJzZVRyYXZlcnNhbChhY3Rpb24pIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBtaW5LZXkoKSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICBtYXhLZXkoKSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICBjaGVja18oKSB7XHJcbiAgICAgICAgcmV0dXJuIDA7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm5zIFdoZXRoZXIgdGhpcyBub2RlIGlzIHJlZC5cclxuICAgICAqL1xyXG4gICAgaXNSZWRfKCkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQW4gaW1tdXRhYmxlIHNvcnRlZCBtYXAgaW1wbGVtZW50YXRpb24sIGJhc2VkIG9uIGEgTGVmdC1sZWFuaW5nIFJlZC1CbGFja1xyXG4gKiB0cmVlLlxyXG4gKi9cclxuY2xhc3MgU29ydGVkTWFwIHtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIGNvbXBhcmF0b3JfIC0gS2V5IGNvbXBhcmF0b3IuXHJcbiAgICAgKiBAcGFyYW0gcm9vdF8gLSBPcHRpb25hbCByb290IG5vZGUgZm9yIHRoZSBtYXAuXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKGNvbXBhcmF0b3JfLCByb290XyA9IFNvcnRlZE1hcC5FTVBUWV9OT0RFKSB7XHJcbiAgICAgICAgdGhpcy5jb21wYXJhdG9yXyA9IGNvbXBhcmF0b3JfO1xyXG4gICAgICAgIHRoaXMucm9vdF8gPSByb290XztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIGNvcHkgb2YgdGhlIG1hcCwgd2l0aCB0aGUgc3BlY2lmaWVkIGtleS92YWx1ZSBhZGRlZCBvciByZXBsYWNlZC5cclxuICAgICAqIChUT0RPOiBXZSBzaG91bGQgcGVyaGFwcyByZW5hbWUgdGhpcyBtZXRob2QgdG8gJ3B1dCcpXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGtleSAtIEtleSB0byBiZSBhZGRlZC5cclxuICAgICAqIEBwYXJhbSB2YWx1ZSAtIFZhbHVlIHRvIGJlIGFkZGVkLlxyXG4gICAgICogQHJldHVybnMgTmV3IG1hcCwgd2l0aCBpdGVtIGFkZGVkLlxyXG4gICAgICovXHJcbiAgICBpbnNlcnQoa2V5LCB2YWx1ZSkge1xyXG4gICAgICAgIHJldHVybiBuZXcgU29ydGVkTWFwKHRoaXMuY29tcGFyYXRvcl8sIHRoaXMucm9vdF9cclxuICAgICAgICAgICAgLmluc2VydChrZXksIHZhbHVlLCB0aGlzLmNvbXBhcmF0b3JfKVxyXG4gICAgICAgICAgICAuY29weShudWxsLCBudWxsLCBMTFJCTm9kZS5CTEFDSywgbnVsbCwgbnVsbCkpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgY29weSBvZiB0aGUgbWFwLCB3aXRoIHRoZSBzcGVjaWZpZWQga2V5IHJlbW92ZWQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGtleSAtIFRoZSBrZXkgdG8gcmVtb3ZlLlxyXG4gICAgICogQHJldHVybnMgTmV3IG1hcCwgd2l0aCBpdGVtIHJlbW92ZWQuXHJcbiAgICAgKi9cclxuICAgIHJlbW92ZShrZXkpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFNvcnRlZE1hcCh0aGlzLmNvbXBhcmF0b3JfLCB0aGlzLnJvb3RfXHJcbiAgICAgICAgICAgIC5yZW1vdmUoa2V5LCB0aGlzLmNvbXBhcmF0b3JfKVxyXG4gICAgICAgICAgICAuY29weShudWxsLCBudWxsLCBMTFJCTm9kZS5CTEFDSywgbnVsbCwgbnVsbCkpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSB2YWx1ZSBvZiB0aGUgbm9kZSB3aXRoIHRoZSBnaXZlbiBrZXksIG9yIG51bGwuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGtleSAtIFRoZSBrZXkgdG8gbG9vayB1cC5cclxuICAgICAqIEByZXR1cm5zIFRoZSB2YWx1ZSBvZiB0aGUgbm9kZSB3aXRoIHRoZSBnaXZlbiBrZXksIG9yIG51bGwgaWYgdGhlXHJcbiAgICAgKiBrZXkgZG9lc24ndCBleGlzdC5cclxuICAgICAqL1xyXG4gICAgZ2V0KGtleSkge1xyXG4gICAgICAgIGxldCBjbXA7XHJcbiAgICAgICAgbGV0IG5vZGUgPSB0aGlzLnJvb3RfO1xyXG4gICAgICAgIHdoaWxlICghbm9kZS5pc0VtcHR5KCkpIHtcclxuICAgICAgICAgICAgY21wID0gdGhpcy5jb21wYXJhdG9yXyhrZXksIG5vZGUua2V5KTtcclxuICAgICAgICAgICAgaWYgKGNtcCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGUudmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoY21wIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUubGVmdDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChjbXAgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5yaWdodDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUga2V5IG9mIHRoZSBpdGVtICpiZWZvcmUqIHRoZSBzcGVjaWZpZWQga2V5LCBvciBudWxsIGlmIGtleSBpcyB0aGUgZmlyc3QgaXRlbS5cclxuICAgICAqIEBwYXJhbSBrZXkgLSBUaGUga2V5IHRvIGZpbmQgdGhlIHByZWRlY2Vzc29yIG9mXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgcHJlZGVjZXNzb3Iga2V5LlxyXG4gICAgICovXHJcbiAgICBnZXRQcmVkZWNlc3NvcktleShrZXkpIHtcclxuICAgICAgICBsZXQgY21wLCBub2RlID0gdGhpcy5yb290XywgcmlnaHRQYXJlbnQgPSBudWxsO1xyXG4gICAgICAgIHdoaWxlICghbm9kZS5pc0VtcHR5KCkpIHtcclxuICAgICAgICAgICAgY21wID0gdGhpcy5jb21wYXJhdG9yXyhrZXksIG5vZGUua2V5KTtcclxuICAgICAgICAgICAgaWYgKGNtcCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFub2RlLmxlZnQuaXNFbXB0eSgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUubGVmdDtcclxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoIW5vZGUucmlnaHQuaXNFbXB0eSgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLnJpZ2h0O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbm9kZS5rZXk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChyaWdodFBhcmVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByaWdodFBhcmVudC5rZXk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDsgLy8gZmlyc3QgaXRlbS5cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChjbXAgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5sZWZ0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGNtcCA+IDApIHtcclxuICAgICAgICAgICAgICAgIHJpZ2h0UGFyZW50ID0gbm9kZTtcclxuICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLnJpZ2h0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQXR0ZW1wdGVkIHRvIGZpbmQgcHJlZGVjZXNzb3Iga2V5IGZvciBhIG5vbmV4aXN0ZW50IGtleS4gIFdoYXQgZ2l2ZXM/Jyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm5zIFRydWUgaWYgdGhlIG1hcCBpcyBlbXB0eS5cclxuICAgICAqL1xyXG4gICAgaXNFbXB0eSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5yb290Xy5pc0VtcHR5KCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm5zIFRoZSB0b3RhbCBudW1iZXIgb2Ygbm9kZXMgaW4gdGhlIG1hcC5cclxuICAgICAqL1xyXG4gICAgY291bnQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucm9vdF8uY291bnQoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybnMgVGhlIG1pbmltdW0ga2V5IGluIHRoZSBtYXAuXHJcbiAgICAgKi9cclxuICAgIG1pbktleSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5yb290Xy5taW5LZXkoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybnMgVGhlIG1heGltdW0ga2V5IGluIHRoZSBtYXAuXHJcbiAgICAgKi9cclxuICAgIG1heEtleSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5yb290Xy5tYXhLZXkoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVHJhdmVyc2VzIHRoZSBtYXAgaW4ga2V5IG9yZGVyIGFuZCBjYWxscyB0aGUgc3BlY2lmaWVkIGFjdGlvbiBmdW5jdGlvblxyXG4gICAgICogZm9yIGVhY2gga2V5L3ZhbHVlIHBhaXIuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGFjdGlvbiAtIENhbGxiYWNrIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZFxyXG4gICAgICogZm9yIGVhY2gga2V5L3ZhbHVlIHBhaXIuICBJZiBhY3Rpb24gcmV0dXJucyB0cnVlLCB0cmF2ZXJzYWwgaXMgYWJvcnRlZC5cclxuICAgICAqIEByZXR1cm5zIFRoZSBmaXJzdCB0cnV0aHkgdmFsdWUgcmV0dXJuZWQgYnkgYWN0aW9uLCBvciB0aGUgbGFzdCBmYWxzZXlcclxuICAgICAqICAgdmFsdWUgcmV0dXJuZWQgYnkgYWN0aW9uXHJcbiAgICAgKi9cclxuICAgIGlub3JkZXJUcmF2ZXJzYWwoYWN0aW9uKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucm9vdF8uaW5vcmRlclRyYXZlcnNhbChhY3Rpb24pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUcmF2ZXJzZXMgdGhlIG1hcCBpbiByZXZlcnNlIGtleSBvcmRlciBhbmQgY2FsbHMgdGhlIHNwZWNpZmllZCBhY3Rpb24gZnVuY3Rpb25cclxuICAgICAqIGZvciBlYWNoIGtleS92YWx1ZSBwYWlyLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBhY3Rpb24gLSBDYWxsYmFjayBmdW5jdGlvbiB0byBiZSBjYWxsZWRcclxuICAgICAqIGZvciBlYWNoIGtleS92YWx1ZSBwYWlyLiAgSWYgYWN0aW9uIHJldHVybnMgdHJ1ZSwgdHJhdmVyc2FsIGlzIGFib3J0ZWQuXHJcbiAgICAgKiBAcmV0dXJucyBUcnVlIGlmIHRoZSB0cmF2ZXJzYWwgd2FzIGFib3J0ZWQuXHJcbiAgICAgKi9cclxuICAgIHJldmVyc2VUcmF2ZXJzYWwoYWN0aW9uKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucm9vdF8ucmV2ZXJzZVRyYXZlcnNhbChhY3Rpb24pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGFuIGl0ZXJhdG9yIG92ZXIgdGhlIFNvcnRlZE1hcC5cclxuICAgICAqIEByZXR1cm5zIFRoZSBpdGVyYXRvci5cclxuICAgICAqL1xyXG4gICAgZ2V0SXRlcmF0b3IocmVzdWx0R2VuZXJhdG9yKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBTb3J0ZWRNYXBJdGVyYXRvcih0aGlzLnJvb3RfLCBudWxsLCB0aGlzLmNvbXBhcmF0b3JfLCBmYWxzZSwgcmVzdWx0R2VuZXJhdG9yKTtcclxuICAgIH1cclxuICAgIGdldEl0ZXJhdG9yRnJvbShrZXksIHJlc3VsdEdlbmVyYXRvcikge1xyXG4gICAgICAgIHJldHVybiBuZXcgU29ydGVkTWFwSXRlcmF0b3IodGhpcy5yb290Xywga2V5LCB0aGlzLmNvbXBhcmF0b3JfLCBmYWxzZSwgcmVzdWx0R2VuZXJhdG9yKTtcclxuICAgIH1cclxuICAgIGdldFJldmVyc2VJdGVyYXRvckZyb20oa2V5LCByZXN1bHRHZW5lcmF0b3IpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFNvcnRlZE1hcEl0ZXJhdG9yKHRoaXMucm9vdF8sIGtleSwgdGhpcy5jb21wYXJhdG9yXywgdHJ1ZSwgcmVzdWx0R2VuZXJhdG9yKTtcclxuICAgIH1cclxuICAgIGdldFJldmVyc2VJdGVyYXRvcihyZXN1bHRHZW5lcmF0b3IpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFNvcnRlZE1hcEl0ZXJhdG9yKHRoaXMucm9vdF8sIG51bGwsIHRoaXMuY29tcGFyYXRvcl8sIHRydWUsIHJlc3VsdEdlbmVyYXRvcik7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEFsd2F5cyB1c2UgdGhlIHNhbWUgZW1wdHkgbm9kZSwgdG8gcmVkdWNlIG1lbW9yeS5cclxuICovXHJcblNvcnRlZE1hcC5FTVBUWV9OT0RFID0gbmV3IExMUkJFbXB0eU5vZGUoKTtcblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuZnVuY3Rpb24gTkFNRV9PTkxZX0NPTVBBUkFUT1IobGVmdCwgcmlnaHQpIHtcclxuICAgIHJldHVybiBuYW1lQ29tcGFyZShsZWZ0Lm5hbWUsIHJpZ2h0Lm5hbWUpO1xyXG59XHJcbmZ1bmN0aW9uIE5BTUVfQ09NUEFSQVRPUihsZWZ0LCByaWdodCkge1xyXG4gICAgcmV0dXJuIG5hbWVDb21wYXJlKGxlZnQsIHJpZ2h0KTtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5sZXQgTUFYX05PREUkMjtcclxuZnVuY3Rpb24gc2V0TWF4Tm9kZSQxKHZhbCkge1xyXG4gICAgTUFYX05PREUkMiA9IHZhbDtcclxufVxyXG5jb25zdCBwcmlvcml0eUhhc2hUZXh0ID0gZnVuY3Rpb24gKHByaW9yaXR5KSB7XHJcbiAgICBpZiAodHlwZW9mIHByaW9yaXR5ID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgIHJldHVybiAnbnVtYmVyOicgKyBkb3VibGVUb0lFRUU3NTRTdHJpbmcocHJpb3JpdHkpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuICdzdHJpbmc6JyArIHByaW9yaXR5O1xyXG4gICAgfVxyXG59O1xyXG4vKipcclxuICogVmFsaWRhdGVzIHRoYXQgYSBwcmlvcml0eSBzbmFwc2hvdCBOb2RlIGlzIHZhbGlkLlxyXG4gKi9cclxuY29uc3QgdmFsaWRhdGVQcmlvcml0eU5vZGUgPSBmdW5jdGlvbiAocHJpb3JpdHlOb2RlKSB7XHJcbiAgICBpZiAocHJpb3JpdHlOb2RlLmlzTGVhZk5vZGUoKSkge1xyXG4gICAgICAgIGNvbnN0IHZhbCA9IHByaW9yaXR5Tm9kZS52YWwoKTtcclxuICAgICAgICBhc3NlcnQodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycgfHxcclxuICAgICAgICAgICAgdHlwZW9mIHZhbCA9PT0gJ251bWJlcicgfHxcclxuICAgICAgICAgICAgKHR5cGVvZiB2YWwgPT09ICdvYmplY3QnICYmIGNvbnRhaW5zKHZhbCwgJy5zdicpKSwgJ1ByaW9yaXR5IG11c3QgYmUgYSBzdHJpbmcgb3IgbnVtYmVyLicpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgYXNzZXJ0KHByaW9yaXR5Tm9kZSA9PT0gTUFYX05PREUkMiB8fCBwcmlvcml0eU5vZGUuaXNFbXB0eSgpLCAncHJpb3JpdHkgb2YgdW5leHBlY3RlZCB0eXBlLicpO1xyXG4gICAgfVxyXG4gICAgLy8gRG9uJ3QgY2FsbCBnZXRQcmlvcml0eSgpIG9uIE1BWF9OT0RFIHRvIGF2b2lkIGhpdHRpbmcgYXNzZXJ0aW9uLlxyXG4gICAgYXNzZXJ0KHByaW9yaXR5Tm9kZSA9PT0gTUFYX05PREUkMiB8fCBwcmlvcml0eU5vZGUuZ2V0UHJpb3JpdHkoKS5pc0VtcHR5KCksIFwiUHJpb3JpdHkgbm9kZXMgY2FuJ3QgaGF2ZSBhIHByaW9yaXR5IG9mIHRoZWlyIG93bi5cIik7XHJcbn07XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmxldCBfX2NoaWxkcmVuTm9kZUNvbnN0cnVjdG9yO1xyXG4vKipcclxuICogTGVhZk5vZGUgaXMgYSBjbGFzcyBmb3Igc3RvcmluZyBsZWFmIG5vZGVzIGluIGEgRGF0YVNuYXBzaG90LiAgSXRcclxuICogaW1wbGVtZW50cyBOb2RlIGFuZCBzdG9yZXMgdGhlIHZhbHVlIG9mIHRoZSBub2RlIChhIHN0cmluZyxcclxuICogbnVtYmVyLCBvciBib29sZWFuKSBhY2Nlc3NpYmxlIHZpYSBnZXRWYWx1ZSgpLlxyXG4gKi9cclxuY2xhc3MgTGVhZk5vZGUge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gdmFsdWVfIC0gVGhlIHZhbHVlIHRvIHN0b3JlIGluIHRoaXMgbGVhZiBub2RlLiBUaGUgb2JqZWN0IHR5cGUgaXNcclxuICAgICAqIHBvc3NpYmxlIGluIHRoZSBldmVudCBvZiBhIGRlZmVycmVkIHZhbHVlXHJcbiAgICAgKiBAcGFyYW0gcHJpb3JpdHlOb2RlXyAtIFRoZSBwcmlvcml0eSBvZiB0aGlzIG5vZGUuXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKHZhbHVlXywgcHJpb3JpdHlOb2RlXyA9IExlYWZOb2RlLl9fY2hpbGRyZW5Ob2RlQ29uc3RydWN0b3IuRU1QVFlfTk9ERSkge1xyXG4gICAgICAgIHRoaXMudmFsdWVfID0gdmFsdWVfO1xyXG4gICAgICAgIHRoaXMucHJpb3JpdHlOb2RlXyA9IHByaW9yaXR5Tm9kZV87XHJcbiAgICAgICAgdGhpcy5sYXp5SGFzaF8gPSBudWxsO1xyXG4gICAgICAgIGFzc2VydCh0aGlzLnZhbHVlXyAhPT0gdW5kZWZpbmVkICYmIHRoaXMudmFsdWVfICE9PSBudWxsLCBcIkxlYWZOb2RlIHNob3VsZG4ndCBiZSBjcmVhdGVkIHdpdGggbnVsbC91bmRlZmluZWQgdmFsdWUuXCIpO1xyXG4gICAgICAgIHZhbGlkYXRlUHJpb3JpdHlOb2RlKHRoaXMucHJpb3JpdHlOb2RlXyk7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgc2V0IF9fY2hpbGRyZW5Ob2RlQ29uc3RydWN0b3IodmFsKSB7XHJcbiAgICAgICAgX19jaGlsZHJlbk5vZGVDb25zdHJ1Y3RvciA9IHZhbDtcclxuICAgIH1cclxuICAgIHN0YXRpYyBnZXQgX19jaGlsZHJlbk5vZGVDb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICByZXR1cm4gX19jaGlsZHJlbk5vZGVDb25zdHJ1Y3RvcjtcclxuICAgIH1cclxuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xyXG4gICAgaXNMZWFmTm9kZSgpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xyXG4gICAgZ2V0UHJpb3JpdHkoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucHJpb3JpdHlOb2RlXztcclxuICAgIH1cclxuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xyXG4gICAgdXBkYXRlUHJpb3JpdHkobmV3UHJpb3JpdHlOb2RlKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBMZWFmTm9kZSh0aGlzLnZhbHVlXywgbmV3UHJpb3JpdHlOb2RlKTtcclxuICAgIH1cclxuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xyXG4gICAgZ2V0SW1tZWRpYXRlQ2hpbGQoY2hpbGROYW1lKSB7XHJcbiAgICAgICAgLy8gSGFjayB0byB0cmVhdCBwcmlvcml0eSBhcyBhIHJlZ3VsYXIgY2hpbGRcclxuICAgICAgICBpZiAoY2hpbGROYW1lID09PSAnLnByaW9yaXR5Jykge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcmlvcml0eU5vZGVfO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIExlYWZOb2RlLl9fY2hpbGRyZW5Ob2RlQ29uc3RydWN0b3IuRU1QVFlfTk9ERTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKiogQGluaGVyaXREb2MgKi9cclxuICAgIGdldENoaWxkKHBhdGgpIHtcclxuICAgICAgICBpZiAocGF0aElzRW1wdHkocGF0aCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHBhdGhHZXRGcm9udChwYXRoKSA9PT0gJy5wcmlvcml0eScpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJpb3JpdHlOb2RlXztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBMZWFmTm9kZS5fX2NoaWxkcmVuTm9kZUNvbnN0cnVjdG9yLkVNUFRZX05PREU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaGFzQ2hpbGQoKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgLyoqIEBpbmhlcml0RG9jICovXHJcbiAgICBnZXRQcmVkZWNlc3NvckNoaWxkTmFtZShjaGlsZE5hbWUsIGNoaWxkTm9kZSkge1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgLyoqIEBpbmhlcml0RG9jICovXHJcbiAgICB1cGRhdGVJbW1lZGlhdGVDaGlsZChjaGlsZE5hbWUsIG5ld0NoaWxkTm9kZSkge1xyXG4gICAgICAgIGlmIChjaGlsZE5hbWUgPT09ICcucHJpb3JpdHknKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnVwZGF0ZVByaW9yaXR5KG5ld0NoaWxkTm9kZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKG5ld0NoaWxkTm9kZS5pc0VtcHR5KCkgJiYgY2hpbGROYW1lICE9PSAnLnByaW9yaXR5Jykge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBMZWFmTm9kZS5fX2NoaWxkcmVuTm9kZUNvbnN0cnVjdG9yLkVNUFRZX05PREUudXBkYXRlSW1tZWRpYXRlQ2hpbGQoY2hpbGROYW1lLCBuZXdDaGlsZE5vZGUpLnVwZGF0ZVByaW9yaXR5KHRoaXMucHJpb3JpdHlOb2RlXyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqIEBpbmhlcml0RG9jICovXHJcbiAgICB1cGRhdGVDaGlsZChwYXRoLCBuZXdDaGlsZE5vZGUpIHtcclxuICAgICAgICBjb25zdCBmcm9udCA9IHBhdGhHZXRGcm9udChwYXRoKTtcclxuICAgICAgICBpZiAoZnJvbnQgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ld0NoaWxkTm9kZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAobmV3Q2hpbGROb2RlLmlzRW1wdHkoKSAmJiBmcm9udCAhPT0gJy5wcmlvcml0eScpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBhc3NlcnQoZnJvbnQgIT09ICcucHJpb3JpdHknIHx8IHBhdGhHZXRMZW5ndGgocGF0aCkgPT09IDEsICcucHJpb3JpdHkgbXVzdCBiZSB0aGUgbGFzdCB0b2tlbiBpbiBhIHBhdGgnKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudXBkYXRlSW1tZWRpYXRlQ2hpbGQoZnJvbnQsIExlYWZOb2RlLl9fY2hpbGRyZW5Ob2RlQ29uc3RydWN0b3IuRU1QVFlfTk9ERS51cGRhdGVDaGlsZChwYXRoUG9wRnJvbnQocGF0aCksIG5ld0NoaWxkTm9kZSkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xyXG4gICAgaXNFbXB0eSgpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICAvKiogQGluaGVyaXREb2MgKi9cclxuICAgIG51bUNoaWxkcmVuKCkge1xyXG4gICAgICAgIHJldHVybiAwO1xyXG4gICAgfVxyXG4gICAgLyoqIEBpbmhlcml0RG9jICovXHJcbiAgICBmb3JFYWNoQ2hpbGQoaW5kZXgsIGFjdGlvbikge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIHZhbChleHBvcnRGb3JtYXQpIHtcclxuICAgICAgICBpZiAoZXhwb3J0Rm9ybWF0ICYmICF0aGlzLmdldFByaW9yaXR5KCkuaXNFbXB0eSgpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAnLnZhbHVlJzogdGhpcy5nZXRWYWx1ZSgpLFxyXG4gICAgICAgICAgICAgICAgJy5wcmlvcml0eSc6IHRoaXMuZ2V0UHJpb3JpdHkoKS52YWwoKVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VmFsdWUoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKiogQGluaGVyaXREb2MgKi9cclxuICAgIGhhc2goKSB7XHJcbiAgICAgICAgaWYgKHRoaXMubGF6eUhhc2hfID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGxldCB0b0hhc2ggPSAnJztcclxuICAgICAgICAgICAgaWYgKCF0aGlzLnByaW9yaXR5Tm9kZV8uaXNFbXB0eSgpKSB7XHJcbiAgICAgICAgICAgICAgICB0b0hhc2ggKz1cclxuICAgICAgICAgICAgICAgICAgICAncHJpb3JpdHk6JyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHByaW9yaXR5SGFzaFRleHQodGhpcy5wcmlvcml0eU5vZGVfLnZhbCgpKSArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICc6JztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCB0eXBlID0gdHlwZW9mIHRoaXMudmFsdWVfO1xyXG4gICAgICAgICAgICB0b0hhc2ggKz0gdHlwZSArICc6JztcclxuICAgICAgICAgICAgaWYgKHR5cGUgPT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgICAgICAgICB0b0hhc2ggKz0gZG91YmxlVG9JRUVFNzU0U3RyaW5nKHRoaXMudmFsdWVfKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRvSGFzaCArPSB0aGlzLnZhbHVlXztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmxhenlIYXNoXyA9IHNoYTEodG9IYXNoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubGF6eUhhc2hfO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSB2YWx1ZSBvZiB0aGUgbGVhZiBub2RlLlxyXG4gICAgICogQHJldHVybnMgVGhlIHZhbHVlIG9mIHRoZSBub2RlLlxyXG4gICAgICovXHJcbiAgICBnZXRWYWx1ZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZV87XHJcbiAgICB9XHJcbiAgICBjb21wYXJlVG8ob3RoZXIpIHtcclxuICAgICAgICBpZiAob3RoZXIgPT09IExlYWZOb2RlLl9fY2hpbGRyZW5Ob2RlQ29uc3RydWN0b3IuRU1QVFlfTk9ERSkge1xyXG4gICAgICAgICAgICByZXR1cm4gMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAob3RoZXIgaW5zdGFuY2VvZiBMZWFmTm9kZS5fX2NoaWxkcmVuTm9kZUNvbnN0cnVjdG9yKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAtMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGFzc2VydChvdGhlci5pc0xlYWZOb2RlKCksICdVbmtub3duIG5vZGUgdHlwZScpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb21wYXJlVG9MZWFmTm9kZV8ob3RoZXIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ29tcGFyaXNvbiBzcGVjaWZpY2FsbHkgZm9yIHR3byBsZWFmIG5vZGVzXHJcbiAgICAgKi9cclxuICAgIGNvbXBhcmVUb0xlYWZOb2RlXyhvdGhlckxlYWYpIHtcclxuICAgICAgICBjb25zdCBvdGhlckxlYWZUeXBlID0gdHlwZW9mIG90aGVyTGVhZi52YWx1ZV87XHJcbiAgICAgICAgY29uc3QgdGhpc0xlYWZUeXBlID0gdHlwZW9mIHRoaXMudmFsdWVfO1xyXG4gICAgICAgIGNvbnN0IG90aGVySW5kZXggPSBMZWFmTm9kZS5WQUxVRV9UWVBFX09SREVSLmluZGV4T2Yob3RoZXJMZWFmVHlwZSk7XHJcbiAgICAgICAgY29uc3QgdGhpc0luZGV4ID0gTGVhZk5vZGUuVkFMVUVfVFlQRV9PUkRFUi5pbmRleE9mKHRoaXNMZWFmVHlwZSk7XHJcbiAgICAgICAgYXNzZXJ0KG90aGVySW5kZXggPj0gMCwgJ1Vua25vd24gbGVhZiB0eXBlOiAnICsgb3RoZXJMZWFmVHlwZSk7XHJcbiAgICAgICAgYXNzZXJ0KHRoaXNJbmRleCA+PSAwLCAnVW5rbm93biBsZWFmIHR5cGU6ICcgKyB0aGlzTGVhZlR5cGUpO1xyXG4gICAgICAgIGlmIChvdGhlckluZGV4ID09PSB0aGlzSW5kZXgpIHtcclxuICAgICAgICAgICAgLy8gU2FtZSB0eXBlLCBjb21wYXJlIHZhbHVlc1xyXG4gICAgICAgICAgICBpZiAodGhpc0xlYWZUeXBlID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgICAgICAgICAgLy8gRGVmZXJyZWQgdmFsdWUgbm9kZXMgYXJlIGFsbCBlcXVhbCwgYnV0IHdlIHNob3VsZCBhbHNvIG5ldmVyIGdldCB0byB0aGlzIHBvaW50Li4uXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIE5vdGUgdGhhdCB0aGlzIHdvcmtzIGJlY2F1c2UgdHJ1ZSA+IGZhbHNlLCBhbGwgb3RoZXJzIGFyZSBudW1iZXIgb3Igc3RyaW5nIGNvbXBhcmlzb25zXHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy52YWx1ZV8gPCBvdGhlckxlYWYudmFsdWVfKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy52YWx1ZV8gPT09IG90aGVyTGVhZi52YWx1ZV8pIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAxO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpc0luZGV4IC0gb3RoZXJJbmRleDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICB3aXRoSW5kZXgoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICBpc0luZGV4ZWQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICBlcXVhbHMob3RoZXIpIHtcclxuICAgICAgICBpZiAob3RoZXIgPT09IHRoaXMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKG90aGVyLmlzTGVhZk5vZGUoKSkge1xyXG4gICAgICAgICAgICBjb25zdCBvdGhlckxlYWYgPSBvdGhlcjtcclxuICAgICAgICAgICAgcmV0dXJuICh0aGlzLnZhbHVlXyA9PT0gb3RoZXJMZWFmLnZhbHVlXyAmJlxyXG4gICAgICAgICAgICAgICAgdGhpcy5wcmlvcml0eU5vZGVfLmVxdWFscyhvdGhlckxlYWYucHJpb3JpdHlOb2RlXykpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4vKipcclxuICogVGhlIHNvcnQgb3JkZXIgZm9yIGNvbXBhcmluZyBsZWFmIG5vZGVzIG9mIGRpZmZlcmVudCB0eXBlcy4gSWYgdHdvIGxlYWYgbm9kZXMgaGF2ZVxyXG4gKiB0aGUgc2FtZSB0eXBlLCB0aGUgY29tcGFyaXNvbiBmYWxscyBiYWNrIHRvIHRoZWlyIHZhbHVlXHJcbiAqL1xyXG5MZWFmTm9kZS5WQUxVRV9UWVBFX09SREVSID0gWydvYmplY3QnLCAnYm9vbGVhbicsICdudW1iZXInLCAnc3RyaW5nJ107XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmxldCBub2RlRnJvbUpTT04kMTtcclxubGV0IE1BWF9OT0RFJDE7XHJcbmZ1bmN0aW9uIHNldE5vZGVGcm9tSlNPTih2YWwpIHtcclxuICAgIG5vZGVGcm9tSlNPTiQxID0gdmFsO1xyXG59XHJcbmZ1bmN0aW9uIHNldE1heE5vZGUodmFsKSB7XHJcbiAgICBNQVhfTk9ERSQxID0gdmFsO1xyXG59XHJcbmNsYXNzIFByaW9yaXR5SW5kZXggZXh0ZW5kcyBJbmRleCB7XHJcbiAgICBjb21wYXJlKGEsIGIpIHtcclxuICAgICAgICBjb25zdCBhUHJpb3JpdHkgPSBhLm5vZGUuZ2V0UHJpb3JpdHkoKTtcclxuICAgICAgICBjb25zdCBiUHJpb3JpdHkgPSBiLm5vZGUuZ2V0UHJpb3JpdHkoKTtcclxuICAgICAgICBjb25zdCBpbmRleENtcCA9IGFQcmlvcml0eS5jb21wYXJlVG8oYlByaW9yaXR5KTtcclxuICAgICAgICBpZiAoaW5kZXhDbXAgPT09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5hbWVDb21wYXJlKGEubmFtZSwgYi5uYW1lKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpbmRleENtcDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpc0RlZmluZWRPbihub2RlKSB7XHJcbiAgICAgICAgcmV0dXJuICFub2RlLmdldFByaW9yaXR5KCkuaXNFbXB0eSgpO1xyXG4gICAgfVxyXG4gICAgaW5kZXhlZFZhbHVlQ2hhbmdlZChvbGROb2RlLCBuZXdOb2RlKSB7XHJcbiAgICAgICAgcmV0dXJuICFvbGROb2RlLmdldFByaW9yaXR5KCkuZXF1YWxzKG5ld05vZGUuZ2V0UHJpb3JpdHkoKSk7XHJcbiAgICB9XHJcbiAgICBtaW5Qb3N0KCkge1xyXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XHJcbiAgICAgICAgcmV0dXJuIE5hbWVkTm9kZS5NSU47XHJcbiAgICB9XHJcbiAgICBtYXhQb3N0KCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgTmFtZWROb2RlKE1BWF9OQU1FLCBuZXcgTGVhZk5vZGUoJ1tQUklPUklUWS1QT1NUXScsIE1BWF9OT0RFJDEpKTtcclxuICAgIH1cclxuICAgIG1ha2VQb3N0KGluZGV4VmFsdWUsIG5hbWUpIHtcclxuICAgICAgICBjb25zdCBwcmlvcml0eU5vZGUgPSBub2RlRnJvbUpTT04kMShpbmRleFZhbHVlKTtcclxuICAgICAgICByZXR1cm4gbmV3IE5hbWVkTm9kZShuYW1lLCBuZXcgTGVhZk5vZGUoJ1tQUklPUklUWS1QT1NUXScsIHByaW9yaXR5Tm9kZSkpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJucyBTdHJpbmcgcmVwcmVzZW50YXRpb24gZm9yIGluY2x1c2lvbiBpbiBhIHF1ZXJ5IHNwZWNcclxuICAgICAqL1xyXG4gICAgdG9TdHJpbmcoKSB7XHJcbiAgICAgICAgcmV0dXJuICcucHJpb3JpdHknO1xyXG4gICAgfVxyXG59XHJcbmNvbnN0IFBSSU9SSVRZX0lOREVYID0gbmV3IFByaW9yaXR5SW5kZXgoKTtcblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuY29uc3QgTE9HXzIgPSBNYXRoLmxvZygyKTtcclxuY2xhc3MgQmFzZTEyTnVtIHtcclxuICAgIGNvbnN0cnVjdG9yKGxlbmd0aCkge1xyXG4gICAgICAgIGNvbnN0IGxvZ0Jhc2UyID0gKG51bSkgPT4gXHJcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcclxuICAgICAgICBwYXJzZUludCgoTWF0aC5sb2cobnVtKSAvIExPR18yKSwgMTApO1xyXG4gICAgICAgIGNvbnN0IGJpdE1hc2sgPSAoYml0cykgPT4gcGFyc2VJbnQoQXJyYXkoYml0cyArIDEpLmpvaW4oJzEnKSwgMik7XHJcbiAgICAgICAgdGhpcy5jb3VudCA9IGxvZ0Jhc2UyKGxlbmd0aCArIDEpO1xyXG4gICAgICAgIHRoaXMuY3VycmVudF8gPSB0aGlzLmNvdW50IC0gMTtcclxuICAgICAgICBjb25zdCBtYXNrID0gYml0TWFzayh0aGlzLmNvdW50KTtcclxuICAgICAgICB0aGlzLmJpdHNfID0gKGxlbmd0aCArIDEpICYgbWFzaztcclxuICAgIH1cclxuICAgIG5leHRCaXRJc09uZSgpIHtcclxuICAgICAgICAvL25vaW5zcGVjdGlvbiBKU0JpdHdpc2VPcGVyYXRvclVzYWdlXHJcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gISh0aGlzLmJpdHNfICYgKDB4MSA8PCB0aGlzLmN1cnJlbnRfKSk7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50Xy0tO1xyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFRha2VzIGEgbGlzdCBvZiBjaGlsZCBub2RlcyBhbmQgY29uc3RydWN0cyBhIFNvcnRlZFNldCB1c2luZyB0aGUgZ2l2ZW4gY29tcGFyaXNvblxyXG4gKiBmdW5jdGlvblxyXG4gKlxyXG4gKiBVc2VzIHRoZSBhbGdvcml0aG0gZGVzY3JpYmVkIGluIHRoZSBwYXBlciBsaW5rZWQgaGVyZTpcclxuICogaHR0cDovL2NpdGVzZWVyeC5pc3QucHN1LmVkdS92aWV3ZG9jL3N1bW1hcnk/ZG9pPTEwLjEuMS40Ni4xNDU4XHJcbiAqXHJcbiAqIEBwYXJhbSBjaGlsZExpc3QgLSBVbnNvcnRlZCBsaXN0IG9mIGNoaWxkcmVuXHJcbiAqIEBwYXJhbSBjbXAgLSBUaGUgY29tcGFyaXNvbiBtZXRob2QgdG8gYmUgdXNlZFxyXG4gKiBAcGFyYW0ga2V5Rm4gLSBBbiBvcHRpb25hbCBmdW5jdGlvbiB0byBleHRyYWN0IEsgZnJvbSBhIG5vZGUgd3JhcHBlciwgaWYgSydzXHJcbiAqIHR5cGUgaXMgbm90IE5hbWVkTm9kZVxyXG4gKiBAcGFyYW0gbWFwU29ydEZuIC0gQW4gb3B0aW9uYWwgb3ZlcnJpZGUgZm9yIGNvbXBhcmF0b3IgdXNlZCBieSB0aGUgZ2VuZXJhdGVkIHNvcnRlZCBtYXBcclxuICovXHJcbmNvbnN0IGJ1aWxkQ2hpbGRTZXQgPSBmdW5jdGlvbiAoY2hpbGRMaXN0LCBjbXAsIGtleUZuLCBtYXBTb3J0Rm4pIHtcclxuICAgIGNoaWxkTGlzdC5zb3J0KGNtcCk7XHJcbiAgICBjb25zdCBidWlsZEJhbGFuY2VkVHJlZSA9IGZ1bmN0aW9uIChsb3csIGhpZ2gpIHtcclxuICAgICAgICBjb25zdCBsZW5ndGggPSBoaWdoIC0gbG93O1xyXG4gICAgICAgIGxldCBuYW1lZE5vZGU7XHJcbiAgICAgICAgbGV0IGtleTtcclxuICAgICAgICBpZiAobGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChsZW5ndGggPT09IDEpIHtcclxuICAgICAgICAgICAgbmFtZWROb2RlID0gY2hpbGRMaXN0W2xvd107XHJcbiAgICAgICAgICAgIGtleSA9IGtleUZuID8ga2V5Rm4obmFtZWROb2RlKSA6IG5hbWVkTm9kZTtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBMTFJCTm9kZShrZXksIG5hbWVkTm9kZS5ub2RlLCBMTFJCTm9kZS5CTEFDSywgbnVsbCwgbnVsbCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxyXG4gICAgICAgICAgICBjb25zdCBtaWRkbGUgPSBwYXJzZUludCgobGVuZ3RoIC8gMiksIDEwKSArIGxvdztcclxuICAgICAgICAgICAgY29uc3QgbGVmdCA9IGJ1aWxkQmFsYW5jZWRUcmVlKGxvdywgbWlkZGxlKTtcclxuICAgICAgICAgICAgY29uc3QgcmlnaHQgPSBidWlsZEJhbGFuY2VkVHJlZShtaWRkbGUgKyAxLCBoaWdoKTtcclxuICAgICAgICAgICAgbmFtZWROb2RlID0gY2hpbGRMaXN0W21pZGRsZV07XHJcbiAgICAgICAgICAgIGtleSA9IGtleUZuID8ga2V5Rm4obmFtZWROb2RlKSA6IG5hbWVkTm9kZTtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBMTFJCTm9kZShrZXksIG5hbWVkTm9kZS5ub2RlLCBMTFJCTm9kZS5CTEFDSywgbGVmdCwgcmlnaHQpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBjb25zdCBidWlsZEZyb20xMkFycmF5ID0gZnVuY3Rpb24gKGJhc2UxMikge1xyXG4gICAgICAgIGxldCBub2RlID0gbnVsbDtcclxuICAgICAgICBsZXQgcm9vdCA9IG51bGw7XHJcbiAgICAgICAgbGV0IGluZGV4ID0gY2hpbGRMaXN0Lmxlbmd0aDtcclxuICAgICAgICBjb25zdCBidWlsZFBlbm5hbnQgPSBmdW5jdGlvbiAoY2h1bmtTaXplLCBjb2xvcikge1xyXG4gICAgICAgICAgICBjb25zdCBsb3cgPSBpbmRleCAtIGNodW5rU2l6ZTtcclxuICAgICAgICAgICAgY29uc3QgaGlnaCA9IGluZGV4O1xyXG4gICAgICAgICAgICBpbmRleCAtPSBjaHVua1NpemU7XHJcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkVHJlZSA9IGJ1aWxkQmFsYW5jZWRUcmVlKGxvdyArIDEsIGhpZ2gpO1xyXG4gICAgICAgICAgICBjb25zdCBuYW1lZE5vZGUgPSBjaGlsZExpc3RbbG93XTtcclxuICAgICAgICAgICAgY29uc3Qga2V5ID0ga2V5Rm4gPyBrZXlGbihuYW1lZE5vZGUpIDogbmFtZWROb2RlO1xyXG4gICAgICAgICAgICBhdHRhY2hQZW5uYW50KG5ldyBMTFJCTm9kZShrZXksIG5hbWVkTm9kZS5ub2RlLCBjb2xvciwgbnVsbCwgY2hpbGRUcmVlKSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBjb25zdCBhdHRhY2hQZW5uYW50ID0gZnVuY3Rpb24gKHBlbm5hbnQpIHtcclxuICAgICAgICAgICAgaWYgKG5vZGUpIHtcclxuICAgICAgICAgICAgICAgIG5vZGUubGVmdCA9IHBlbm5hbnQ7XHJcbiAgICAgICAgICAgICAgICBub2RlID0gcGVubmFudDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJvb3QgPSBwZW5uYW50O1xyXG4gICAgICAgICAgICAgICAgbm9kZSA9IHBlbm5hbnQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmFzZTEyLmNvdW50OyArK2kpIHtcclxuICAgICAgICAgICAgY29uc3QgaXNPbmUgPSBiYXNlMTIubmV4dEJpdElzT25lKCk7XHJcbiAgICAgICAgICAgIC8vIFRoZSBudW1iZXIgb2Ygbm9kZXMgdGFrZW4gaW4gZWFjaCBzbGljZSBpcyAyXihhcnIubGVuZ3RoIC0gKGkgKyAxKSlcclxuICAgICAgICAgICAgY29uc3QgY2h1bmtTaXplID0gTWF0aC5wb3coMiwgYmFzZTEyLmNvdW50IC0gKGkgKyAxKSk7XHJcbiAgICAgICAgICAgIGlmIChpc09uZSkge1xyXG4gICAgICAgICAgICAgICAgYnVpbGRQZW5uYW50KGNodW5rU2l6ZSwgTExSQk5vZGUuQkxBQ0spO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gY3VycmVudCA9PSAyXHJcbiAgICAgICAgICAgICAgICBidWlsZFBlbm5hbnQoY2h1bmtTaXplLCBMTFJCTm9kZS5CTEFDSyk7XHJcbiAgICAgICAgICAgICAgICBidWlsZFBlbm5hbnQoY2h1bmtTaXplLCBMTFJCTm9kZS5SRUQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByb290O1xyXG4gICAgfTtcclxuICAgIGNvbnN0IGJhc2UxMiA9IG5ldyBCYXNlMTJOdW0oY2hpbGRMaXN0Lmxlbmd0aCk7XHJcbiAgICBjb25zdCByb290ID0gYnVpbGRGcm9tMTJBcnJheShiYXNlMTIpO1xyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcclxuICAgIHJldHVybiBuZXcgU29ydGVkTWFwKG1hcFNvcnRGbiB8fCBjbXAsIHJvb3QpO1xyXG59O1xuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5sZXQgX2RlZmF1bHRJbmRleE1hcDtcclxuY29uc3QgZmFsbGJhY2tPYmplY3QgPSB7fTtcclxuY2xhc3MgSW5kZXhNYXAge1xyXG4gICAgY29uc3RydWN0b3IoaW5kZXhlc18sIGluZGV4U2V0Xykge1xyXG4gICAgICAgIHRoaXMuaW5kZXhlc18gPSBpbmRleGVzXztcclxuICAgICAgICB0aGlzLmluZGV4U2V0XyA9IGluZGV4U2V0XztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGRlZmF1bHQgSW5kZXhNYXAgZm9yIG5vZGVzIHdpdGhvdXQgYSBwcmlvcml0eVxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZ2V0IERlZmF1bHQoKSB7XHJcbiAgICAgICAgYXNzZXJ0KGZhbGxiYWNrT2JqZWN0ICYmIFBSSU9SSVRZX0lOREVYLCAnQ2hpbGRyZW5Ob2RlLnRzIGhhcyBub3QgYmVlbiBsb2FkZWQnKTtcclxuICAgICAgICBfZGVmYXVsdEluZGV4TWFwID1cclxuICAgICAgICAgICAgX2RlZmF1bHRJbmRleE1hcCB8fFxyXG4gICAgICAgICAgICAgICAgbmV3IEluZGV4TWFwKHsgJy5wcmlvcml0eSc6IGZhbGxiYWNrT2JqZWN0IH0sIHsgJy5wcmlvcml0eSc6IFBSSU9SSVRZX0lOREVYIH0pO1xyXG4gICAgICAgIHJldHVybiBfZGVmYXVsdEluZGV4TWFwO1xyXG4gICAgfVxyXG4gICAgZ2V0KGluZGV4S2V5KSB7XHJcbiAgICAgICAgY29uc3Qgc29ydGVkTWFwID0gc2FmZUdldCh0aGlzLmluZGV4ZXNfLCBpbmRleEtleSk7XHJcbiAgICAgICAgaWYgKCFzb3J0ZWRNYXApIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBpbmRleCBkZWZpbmVkIGZvciAnICsgaW5kZXhLZXkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc29ydGVkTWFwIGluc3RhbmNlb2YgU29ydGVkTWFwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzb3J0ZWRNYXA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBUaGUgaW5kZXggZXhpc3RzLCBidXQgaXQgZmFsbHMgYmFjayB0byBqdXN0IG5hbWUgY29tcGFyaXNvbi4gUmV0dXJuIG51bGwgc28gdGhhdCB0aGUgY2FsbGluZyBjb2RlIHVzZXMgdGhlXHJcbiAgICAgICAgICAgIC8vIHJlZ3VsYXIgY2hpbGQgbWFwXHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGhhc0luZGV4KGluZGV4RGVmaW5pdGlvbikge1xyXG4gICAgICAgIHJldHVybiBjb250YWlucyh0aGlzLmluZGV4U2V0XywgaW5kZXhEZWZpbml0aW9uLnRvU3RyaW5nKCkpO1xyXG4gICAgfVxyXG4gICAgYWRkSW5kZXgoaW5kZXhEZWZpbml0aW9uLCBleGlzdGluZ0NoaWxkcmVuKSB7XHJcbiAgICAgICAgYXNzZXJ0KGluZGV4RGVmaW5pdGlvbiAhPT0gS0VZX0lOREVYLCBcIktleUluZGV4IGFsd2F5cyBleGlzdHMgYW5kIGlzbid0IG1lYW50IHRvIGJlIGFkZGVkIHRvIHRoZSBJbmRleE1hcC5cIik7XHJcbiAgICAgICAgY29uc3QgY2hpbGRMaXN0ID0gW107XHJcbiAgICAgICAgbGV0IHNhd0luZGV4ZWRWYWx1ZSA9IGZhbHNlO1xyXG4gICAgICAgIGNvbnN0IGl0ZXIgPSBleGlzdGluZ0NoaWxkcmVuLmdldEl0ZXJhdG9yKE5hbWVkTm9kZS5XcmFwKTtcclxuICAgICAgICBsZXQgbmV4dCA9IGl0ZXIuZ2V0TmV4dCgpO1xyXG4gICAgICAgIHdoaWxlIChuZXh0KSB7XHJcbiAgICAgICAgICAgIHNhd0luZGV4ZWRWYWx1ZSA9XHJcbiAgICAgICAgICAgICAgICBzYXdJbmRleGVkVmFsdWUgfHwgaW5kZXhEZWZpbml0aW9uLmlzRGVmaW5lZE9uKG5leHQubm9kZSk7XHJcbiAgICAgICAgICAgIGNoaWxkTGlzdC5wdXNoKG5leHQpO1xyXG4gICAgICAgICAgICBuZXh0ID0gaXRlci5nZXROZXh0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBuZXdJbmRleDtcclxuICAgICAgICBpZiAoc2F3SW5kZXhlZFZhbHVlKSB7XHJcbiAgICAgICAgICAgIG5ld0luZGV4ID0gYnVpbGRDaGlsZFNldChjaGlsZExpc3QsIGluZGV4RGVmaW5pdGlvbi5nZXRDb21wYXJlKCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgbmV3SW5kZXggPSBmYWxsYmFja09iamVjdDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgaW5kZXhOYW1lID0gaW5kZXhEZWZpbml0aW9uLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgY29uc3QgbmV3SW5kZXhTZXQgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLmluZGV4U2V0Xyk7XHJcbiAgICAgICAgbmV3SW5kZXhTZXRbaW5kZXhOYW1lXSA9IGluZGV4RGVmaW5pdGlvbjtcclxuICAgICAgICBjb25zdCBuZXdJbmRleGVzID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5pbmRleGVzXyk7XHJcbiAgICAgICAgbmV3SW5kZXhlc1tpbmRleE5hbWVdID0gbmV3SW5kZXg7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBJbmRleE1hcChuZXdJbmRleGVzLCBuZXdJbmRleFNldCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEVuc3VyZSB0aGF0IHRoaXMgbm9kZSBpcyBwcm9wZXJseSB0cmFja2VkIGluIGFueSBpbmRleGVzIHRoYXQgd2UncmUgbWFpbnRhaW5pbmdcclxuICAgICAqL1xyXG4gICAgYWRkVG9JbmRleGVzKG5hbWVkTm9kZSwgZXhpc3RpbmdDaGlsZHJlbikge1xyXG4gICAgICAgIGNvbnN0IG5ld0luZGV4ZXMgPSBtYXAodGhpcy5pbmRleGVzXywgKGluZGV4ZWRDaGlsZHJlbiwgaW5kZXhOYW1lKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gc2FmZUdldCh0aGlzLmluZGV4U2V0XywgaW5kZXhOYW1lKTtcclxuICAgICAgICAgICAgYXNzZXJ0KGluZGV4LCAnTWlzc2luZyBpbmRleCBpbXBsZW1lbnRhdGlvbiBmb3IgJyArIGluZGV4TmFtZSk7XHJcbiAgICAgICAgICAgIGlmIChpbmRleGVkQ2hpbGRyZW4gPT09IGZhbGxiYWNrT2JqZWN0KSB7XHJcbiAgICAgICAgICAgICAgICAvLyBDaGVjayB0byBzZWUgaWYgd2UgbmVlZCB0byBpbmRleCBldmVyeXRoaW5nXHJcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXguaXNEZWZpbmVkT24obmFtZWROb2RlLm5vZGUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgbmVlZCB0byBidWlsZCB0aGlzIGluZGV4XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2hpbGRMaXN0ID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaXRlciA9IGV4aXN0aW5nQ2hpbGRyZW4uZ2V0SXRlcmF0b3IoTmFtZWROb2RlLldyYXApO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBuZXh0ID0gaXRlci5nZXROZXh0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKG5leHQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5leHQubmFtZSAhPT0gbmFtZWROb2RlLm5hbWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkTGlzdC5wdXNoKG5leHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHQgPSBpdGVyLmdldE5leHQoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRMaXN0LnB1c2gobmFtZWROb2RlKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYnVpbGRDaGlsZFNldChjaGlsZExpc3QsIGluZGV4LmdldENvbXBhcmUoKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBObyBjaGFuZ2UsIHRoaXMgcmVtYWlucyBhIGZhbGxiYWNrXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbGxiYWNrT2JqZWN0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZXhpc3RpbmdTbmFwID0gZXhpc3RpbmdDaGlsZHJlbi5nZXQobmFtZWROb2RlLm5hbWUpO1xyXG4gICAgICAgICAgICAgICAgbGV0IG5ld0NoaWxkcmVuID0gaW5kZXhlZENoaWxkcmVuO1xyXG4gICAgICAgICAgICAgICAgaWYgKGV4aXN0aW5nU25hcCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG5ld0NoaWxkcmVuID0gbmV3Q2hpbGRyZW4ucmVtb3ZlKG5ldyBOYW1lZE5vZGUobmFtZWROb2RlLm5hbWUsIGV4aXN0aW5nU25hcCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ld0NoaWxkcmVuLmluc2VydChuYW1lZE5vZGUsIG5hbWVkTm9kZS5ub2RlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBuZXcgSW5kZXhNYXAobmV3SW5kZXhlcywgdGhpcy5pbmRleFNldF8pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGUgYSBuZXcgSW5kZXhNYXAgaW5zdGFuY2Ugd2l0aCB0aGUgZ2l2ZW4gdmFsdWUgcmVtb3ZlZFxyXG4gICAgICovXHJcbiAgICByZW1vdmVGcm9tSW5kZXhlcyhuYW1lZE5vZGUsIGV4aXN0aW5nQ2hpbGRyZW4pIHtcclxuICAgICAgICBjb25zdCBuZXdJbmRleGVzID0gbWFwKHRoaXMuaW5kZXhlc18sIChpbmRleGVkQ2hpbGRyZW4pID0+IHtcclxuICAgICAgICAgICAgaWYgKGluZGV4ZWRDaGlsZHJlbiA9PT0gZmFsbGJhY2tPYmplY3QpIHtcclxuICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgdGhlIGZhbGxiYWNrLiBKdXN0IHJldHVybiBpdCwgbm90aGluZyB0byBkbyBpbiB0aGlzIGNhc2VcclxuICAgICAgICAgICAgICAgIHJldHVybiBpbmRleGVkQ2hpbGRyZW47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBleGlzdGluZ1NuYXAgPSBleGlzdGluZ0NoaWxkcmVuLmdldChuYW1lZE5vZGUubmFtZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoZXhpc3RpbmdTbmFwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGluZGV4ZWRDaGlsZHJlbi5yZW1vdmUobmV3IE5hbWVkTm9kZShuYW1lZE5vZGUubmFtZSwgZXhpc3RpbmdTbmFwKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBObyByZWNvcmQgb2YgdGhpcyBjaGlsZFxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpbmRleGVkQ2hpbGRyZW47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gbmV3IEluZGV4TWFwKG5ld0luZGV4ZXMsIHRoaXMuaW5kZXhTZXRfKTtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vLyBUT0RPOiBGb3IgbWVtb3J5IHNhdmluZ3MsIGRvbid0IHN0b3JlIHByaW9yaXR5Tm9kZV8gaWYgaXQncyBlbXB0eS5cclxubGV0IEVNUFRZX05PREU7XHJcbi8qKlxyXG4gKiBDaGlsZHJlbk5vZGUgaXMgYSBjbGFzcyBmb3Igc3RvcmluZyBpbnRlcm5hbCBub2RlcyBpbiBhIERhdGFTbmFwc2hvdFxyXG4gKiAoaS5lLiBub2RlcyB3aXRoIGNoaWxkcmVuKS4gIEl0IGltcGxlbWVudHMgTm9kZSBhbmQgc3RvcmVzIHRoZVxyXG4gKiBsaXN0IG9mIGNoaWxkcmVuIGluIHRoZSBjaGlsZHJlbiBwcm9wZXJ0eSwgc29ydGVkIGJ5IGNoaWxkIG5hbWUuXHJcbiAqL1xyXG5jbGFzcyBDaGlsZHJlbk5vZGUge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gY2hpbGRyZW5fIC0gTGlzdCBvZiBjaGlsZHJlbiBvZiB0aGlzIG5vZGUuLlxyXG4gICAgICogQHBhcmFtIHByaW9yaXR5Tm9kZV8gLSBUaGUgcHJpb3JpdHkgb2YgdGhpcyBub2RlIChhcyBhIHNuYXBzaG90IG5vZGUpLlxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihjaGlsZHJlbl8sIHByaW9yaXR5Tm9kZV8sIGluZGV4TWFwXykge1xyXG4gICAgICAgIHRoaXMuY2hpbGRyZW5fID0gY2hpbGRyZW5fO1xyXG4gICAgICAgIHRoaXMucHJpb3JpdHlOb2RlXyA9IHByaW9yaXR5Tm9kZV87XHJcbiAgICAgICAgdGhpcy5pbmRleE1hcF8gPSBpbmRleE1hcF87XHJcbiAgICAgICAgdGhpcy5sYXp5SGFzaF8gPSBudWxsO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIE5vdGU6IFRoZSBvbmx5IHJlYXNvbiB3ZSBhbGxvdyBudWxsIHByaW9yaXR5IGlzIGZvciBFTVBUWV9OT0RFLCBzaW5jZSB3ZSBjYW4ndCB1c2VcclxuICAgICAgICAgKiBFTVBUWV9OT0RFIGFzIHRoZSBwcmlvcml0eSBvZiBFTVBUWV9OT0RFLiAgV2UgbWlnaHQgd2FudCB0byBjb25zaWRlciBtYWtpbmcgRU1QVFlfTk9ERSBpdHMgb3duXHJcbiAgICAgICAgICogY2xhc3MgaW5zdGVhZCBvZiBhbiBlbXB0eSBDaGlsZHJlbk5vZGUuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgaWYgKHRoaXMucHJpb3JpdHlOb2RlXykge1xyXG4gICAgICAgICAgICB2YWxpZGF0ZVByaW9yaXR5Tm9kZSh0aGlzLnByaW9yaXR5Tm9kZV8pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5jaGlsZHJlbl8uaXNFbXB0eSgpKSB7XHJcbiAgICAgICAgICAgIGFzc2VydCghdGhpcy5wcmlvcml0eU5vZGVfIHx8IHRoaXMucHJpb3JpdHlOb2RlXy5pc0VtcHR5KCksICdBbiBlbXB0eSBub2RlIGNhbm5vdCBoYXZlIGEgcHJpb3JpdHknKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgZ2V0IEVNUFRZX05PREUoKSB7XHJcbiAgICAgICAgcmV0dXJuIChFTVBUWV9OT0RFIHx8XHJcbiAgICAgICAgICAgIChFTVBUWV9OT0RFID0gbmV3IENoaWxkcmVuTm9kZShuZXcgU29ydGVkTWFwKE5BTUVfQ09NUEFSQVRPUiksIG51bGwsIEluZGV4TWFwLkRlZmF1bHQpKSk7XHJcbiAgICB9XHJcbiAgICAvKiogQGluaGVyaXREb2MgKi9cclxuICAgIGlzTGVhZk5vZGUoKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgLyoqIEBpbmhlcml0RG9jICovXHJcbiAgICBnZXRQcmlvcml0eSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5wcmlvcml0eU5vZGVfIHx8IEVNUFRZX05PREU7XHJcbiAgICB9XHJcbiAgICAvKiogQGluaGVyaXREb2MgKi9cclxuICAgIHVwZGF0ZVByaW9yaXR5KG5ld1ByaW9yaXR5Tm9kZSkge1xyXG4gICAgICAgIGlmICh0aGlzLmNoaWxkcmVuXy5pc0VtcHR5KCkpIHtcclxuICAgICAgICAgICAgLy8gRG9uJ3QgYWxsb3cgcHJpb3JpdGllcyBvbiBlbXB0eSBub2Rlc1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ2hpbGRyZW5Ob2RlKHRoaXMuY2hpbGRyZW5fLCBuZXdQcmlvcml0eU5vZGUsIHRoaXMuaW5kZXhNYXBfKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKiogQGluaGVyaXREb2MgKi9cclxuICAgIGdldEltbWVkaWF0ZUNoaWxkKGNoaWxkTmFtZSkge1xyXG4gICAgICAgIC8vIEhhY2sgdG8gdHJlYXQgcHJpb3JpdHkgYXMgYSByZWd1bGFyIGNoaWxkXHJcbiAgICAgICAgaWYgKGNoaWxkTmFtZSA9PT0gJy5wcmlvcml0eScpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0UHJpb3JpdHkoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkID0gdGhpcy5jaGlsZHJlbl8uZ2V0KGNoaWxkTmFtZSk7XHJcbiAgICAgICAgICAgIHJldHVybiBjaGlsZCA9PT0gbnVsbCA/IEVNUFRZX05PREUgOiBjaGlsZDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKiogQGluaGVyaXREb2MgKi9cclxuICAgIGdldENoaWxkKHBhdGgpIHtcclxuICAgICAgICBjb25zdCBmcm9udCA9IHBhdGhHZXRGcm9udChwYXRoKTtcclxuICAgICAgICBpZiAoZnJvbnQgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLmdldEltbWVkaWF0ZUNoaWxkKGZyb250KS5nZXRDaGlsZChwYXRoUG9wRnJvbnQocGF0aCkpO1xyXG4gICAgfVxyXG4gICAgLyoqIEBpbmhlcml0RG9jICovXHJcbiAgICBoYXNDaGlsZChjaGlsZE5hbWUpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jaGlsZHJlbl8uZ2V0KGNoaWxkTmFtZSkgIT09IG51bGw7XHJcbiAgICB9XHJcbiAgICAvKiogQGluaGVyaXREb2MgKi9cclxuICAgIHVwZGF0ZUltbWVkaWF0ZUNoaWxkKGNoaWxkTmFtZSwgbmV3Q2hpbGROb2RlKSB7XHJcbiAgICAgICAgYXNzZXJ0KG5ld0NoaWxkTm9kZSwgJ1dlIHNob3VsZCBhbHdheXMgYmUgcGFzc2luZyBzbmFwc2hvdCBub2RlcycpO1xyXG4gICAgICAgIGlmIChjaGlsZE5hbWUgPT09ICcucHJpb3JpdHknKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnVwZGF0ZVByaW9yaXR5KG5ld0NoaWxkTm9kZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCBuYW1lZE5vZGUgPSBuZXcgTmFtZWROb2RlKGNoaWxkTmFtZSwgbmV3Q2hpbGROb2RlKTtcclxuICAgICAgICAgICAgbGV0IG5ld0NoaWxkcmVuLCBuZXdJbmRleE1hcDtcclxuICAgICAgICAgICAgaWYgKG5ld0NoaWxkTm9kZS5pc0VtcHR5KCkpIHtcclxuICAgICAgICAgICAgICAgIG5ld0NoaWxkcmVuID0gdGhpcy5jaGlsZHJlbl8ucmVtb3ZlKGNoaWxkTmFtZSk7XHJcbiAgICAgICAgICAgICAgICBuZXdJbmRleE1hcCA9IHRoaXMuaW5kZXhNYXBfLnJlbW92ZUZyb21JbmRleGVzKG5hbWVkTm9kZSwgdGhpcy5jaGlsZHJlbl8pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbmV3Q2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuXy5pbnNlcnQoY2hpbGROYW1lLCBuZXdDaGlsZE5vZGUpO1xyXG4gICAgICAgICAgICAgICAgbmV3SW5kZXhNYXAgPSB0aGlzLmluZGV4TWFwXy5hZGRUb0luZGV4ZXMobmFtZWROb2RlLCB0aGlzLmNoaWxkcmVuXyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgbmV3UHJpb3JpdHkgPSBuZXdDaGlsZHJlbi5pc0VtcHR5KClcclxuICAgICAgICAgICAgICAgID8gRU1QVFlfTk9ERVxyXG4gICAgICAgICAgICAgICAgOiB0aGlzLnByaW9yaXR5Tm9kZV87XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ2hpbGRyZW5Ob2RlKG5ld0NoaWxkcmVuLCBuZXdQcmlvcml0eSwgbmV3SW5kZXhNYXApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xyXG4gICAgdXBkYXRlQ2hpbGQocGF0aCwgbmV3Q2hpbGROb2RlKSB7XHJcbiAgICAgICAgY29uc3QgZnJvbnQgPSBwYXRoR2V0RnJvbnQocGF0aCk7XHJcbiAgICAgICAgaWYgKGZyb250ID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXdDaGlsZE5vZGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBhc3NlcnQocGF0aEdldEZyb250KHBhdGgpICE9PSAnLnByaW9yaXR5JyB8fCBwYXRoR2V0TGVuZ3RoKHBhdGgpID09PSAxLCAnLnByaW9yaXR5IG11c3QgYmUgdGhlIGxhc3QgdG9rZW4gaW4gYSBwYXRoJyk7XHJcbiAgICAgICAgICAgIGNvbnN0IG5ld0ltbWVkaWF0ZUNoaWxkID0gdGhpcy5nZXRJbW1lZGlhdGVDaGlsZChmcm9udCkudXBkYXRlQ2hpbGQocGF0aFBvcEZyb250KHBhdGgpLCBuZXdDaGlsZE5vZGUpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy51cGRhdGVJbW1lZGlhdGVDaGlsZChmcm9udCwgbmV3SW1tZWRpYXRlQ2hpbGQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xyXG4gICAgaXNFbXB0eSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jaGlsZHJlbl8uaXNFbXB0eSgpO1xyXG4gICAgfVxyXG4gICAgLyoqIEBpbmhlcml0RG9jICovXHJcbiAgICBudW1DaGlsZHJlbigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jaGlsZHJlbl8uY291bnQoKTtcclxuICAgIH1cclxuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xyXG4gICAgdmFsKGV4cG9ydEZvcm1hdCkge1xyXG4gICAgICAgIGlmICh0aGlzLmlzRW1wdHkoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3Qgb2JqID0ge307XHJcbiAgICAgICAgbGV0IG51bUtleXMgPSAwLCBtYXhLZXkgPSAwLCBhbGxJbnRlZ2VyS2V5cyA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5mb3JFYWNoQ2hpbGQoUFJJT1JJVFlfSU5ERVgsIChrZXksIGNoaWxkTm9kZSkgPT4ge1xyXG4gICAgICAgICAgICBvYmpba2V5XSA9IGNoaWxkTm9kZS52YWwoZXhwb3J0Rm9ybWF0KTtcclxuICAgICAgICAgICAgbnVtS2V5cysrO1xyXG4gICAgICAgICAgICBpZiAoYWxsSW50ZWdlcktleXMgJiYgQ2hpbGRyZW5Ob2RlLklOVEVHRVJfUkVHRVhQXy50ZXN0KGtleSkpIHtcclxuICAgICAgICAgICAgICAgIG1heEtleSA9IE1hdGgubWF4KG1heEtleSwgTnVtYmVyKGtleSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgYWxsSW50ZWdlcktleXMgPSBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmICghZXhwb3J0Rm9ybWF0ICYmIGFsbEludGVnZXJLZXlzICYmIG1heEtleSA8IDIgKiBudW1LZXlzKSB7XHJcbiAgICAgICAgICAgIC8vIGNvbnZlcnQgdG8gYXJyYXkuXHJcbiAgICAgICAgICAgIGNvbnN0IGFycmF5ID0gW107XHJcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBndWFyZC1mb3ItaW5cclxuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gb2JqKSB7XHJcbiAgICAgICAgICAgICAgICBhcnJheVtrZXldID0gb2JqW2tleV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGFycmF5O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKGV4cG9ydEZvcm1hdCAmJiAhdGhpcy5nZXRQcmlvcml0eSgpLmlzRW1wdHkoKSkge1xyXG4gICAgICAgICAgICAgICAgb2JqWycucHJpb3JpdHknXSA9IHRoaXMuZ2V0UHJpb3JpdHkoKS52YWwoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gb2JqO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xyXG4gICAgaGFzaCgpIHtcclxuICAgICAgICBpZiAodGhpcy5sYXp5SGFzaF8gPT09IG51bGwpIHtcclxuICAgICAgICAgICAgbGV0IHRvSGFzaCA9ICcnO1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuZ2V0UHJpb3JpdHkoKS5pc0VtcHR5KCkpIHtcclxuICAgICAgICAgICAgICAgIHRvSGFzaCArPVxyXG4gICAgICAgICAgICAgICAgICAgICdwcmlvcml0eTonICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcHJpb3JpdHlIYXNoVGV4dCh0aGlzLmdldFByaW9yaXR5KCkudmFsKCkpICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgJzonO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuZm9yRWFjaENoaWxkKFBSSU9SSVRZX0lOREVYLCAoa2V5LCBjaGlsZE5vZGUpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkSGFzaCA9IGNoaWxkTm9kZS5oYXNoKCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGRIYXNoICE9PSAnJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRvSGFzaCArPSAnOicgKyBrZXkgKyAnOicgKyBjaGlsZEhhc2g7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB0aGlzLmxhenlIYXNoXyA9IHRvSGFzaCA9PT0gJycgPyAnJyA6IHNoYTEodG9IYXNoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubGF6eUhhc2hfO1xyXG4gICAgfVxyXG4gICAgLyoqIEBpbmhlcml0RG9jICovXHJcbiAgICBnZXRQcmVkZWNlc3NvckNoaWxkTmFtZShjaGlsZE5hbWUsIGNoaWxkTm9kZSwgaW5kZXgpIHtcclxuICAgICAgICBjb25zdCBpZHggPSB0aGlzLnJlc29sdmVJbmRleF8oaW5kZXgpO1xyXG4gICAgICAgIGlmIChpZHgpIHtcclxuICAgICAgICAgICAgY29uc3QgcHJlZGVjZXNzb3IgPSBpZHguZ2V0UHJlZGVjZXNzb3JLZXkobmV3IE5hbWVkTm9kZShjaGlsZE5hbWUsIGNoaWxkTm9kZSkpO1xyXG4gICAgICAgICAgICByZXR1cm4gcHJlZGVjZXNzb3IgPyBwcmVkZWNlc3Nvci5uYW1lIDogbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNoaWxkcmVuXy5nZXRQcmVkZWNlc3NvcktleShjaGlsZE5hbWUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGdldEZpcnN0Q2hpbGROYW1lKGluZGV4RGVmaW5pdGlvbikge1xyXG4gICAgICAgIGNvbnN0IGlkeCA9IHRoaXMucmVzb2x2ZUluZGV4XyhpbmRleERlZmluaXRpb24pO1xyXG4gICAgICAgIGlmIChpZHgpIHtcclxuICAgICAgICAgICAgY29uc3QgbWluS2V5ID0gaWR4Lm1pbktleSgpO1xyXG4gICAgICAgICAgICByZXR1cm4gbWluS2V5ICYmIG1pbktleS5uYW1lO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGRyZW5fLm1pbktleSgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGdldEZpcnN0Q2hpbGQoaW5kZXhEZWZpbml0aW9uKSB7XHJcbiAgICAgICAgY29uc3QgbWluS2V5ID0gdGhpcy5nZXRGaXJzdENoaWxkTmFtZShpbmRleERlZmluaXRpb24pO1xyXG4gICAgICAgIGlmIChtaW5LZXkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBOYW1lZE5vZGUobWluS2V5LCB0aGlzLmNoaWxkcmVuXy5nZXQobWluS2V5KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdpdmVuIGFuIGluZGV4LCByZXR1cm4gdGhlIGtleSBuYW1lIG9mIHRoZSBsYXJnZXN0IHZhbHVlIHdlIGhhdmUsIGFjY29yZGluZyB0byB0aGF0IGluZGV4XHJcbiAgICAgKi9cclxuICAgIGdldExhc3RDaGlsZE5hbWUoaW5kZXhEZWZpbml0aW9uKSB7XHJcbiAgICAgICAgY29uc3QgaWR4ID0gdGhpcy5yZXNvbHZlSW5kZXhfKGluZGV4RGVmaW5pdGlvbik7XHJcbiAgICAgICAgaWYgKGlkeCkge1xyXG4gICAgICAgICAgICBjb25zdCBtYXhLZXkgPSBpZHgubWF4S2V5KCk7XHJcbiAgICAgICAgICAgIHJldHVybiBtYXhLZXkgJiYgbWF4S2V5Lm5hbWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jaGlsZHJlbl8ubWF4S2V5KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZ2V0TGFzdENoaWxkKGluZGV4RGVmaW5pdGlvbikge1xyXG4gICAgICAgIGNvbnN0IG1heEtleSA9IHRoaXMuZ2V0TGFzdENoaWxkTmFtZShpbmRleERlZmluaXRpb24pO1xyXG4gICAgICAgIGlmIChtYXhLZXkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBOYW1lZE5vZGUobWF4S2V5LCB0aGlzLmNoaWxkcmVuXy5nZXQobWF4S2V5KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmb3JFYWNoQ2hpbGQoaW5kZXgsIGFjdGlvbikge1xyXG4gICAgICAgIGNvbnN0IGlkeCA9IHRoaXMucmVzb2x2ZUluZGV4XyhpbmRleCk7XHJcbiAgICAgICAgaWYgKGlkeCkge1xyXG4gICAgICAgICAgICByZXR1cm4gaWR4Lmlub3JkZXJUcmF2ZXJzYWwod3JhcHBlZE5vZGUgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFjdGlvbih3cmFwcGVkTm9kZS5uYW1lLCB3cmFwcGVkTm9kZS5ub2RlKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jaGlsZHJlbl8uaW5vcmRlclRyYXZlcnNhbChhY3Rpb24pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGdldEl0ZXJhdG9yKGluZGV4RGVmaW5pdGlvbikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdldEl0ZXJhdG9yRnJvbShpbmRleERlZmluaXRpb24ubWluUG9zdCgpLCBpbmRleERlZmluaXRpb24pO1xyXG4gICAgfVxyXG4gICAgZ2V0SXRlcmF0b3JGcm9tKHN0YXJ0UG9zdCwgaW5kZXhEZWZpbml0aW9uKSB7XHJcbiAgICAgICAgY29uc3QgaWR4ID0gdGhpcy5yZXNvbHZlSW5kZXhfKGluZGV4RGVmaW5pdGlvbik7XHJcbiAgICAgICAgaWYgKGlkeCkge1xyXG4gICAgICAgICAgICByZXR1cm4gaWR4LmdldEl0ZXJhdG9yRnJvbShzdGFydFBvc3QsIGtleSA9PiBrZXkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3QgaXRlcmF0b3IgPSB0aGlzLmNoaWxkcmVuXy5nZXRJdGVyYXRvckZyb20oc3RhcnRQb3N0Lm5hbWUsIE5hbWVkTm9kZS5XcmFwKTtcclxuICAgICAgICAgICAgbGV0IG5leHQgPSBpdGVyYXRvci5wZWVrKCk7XHJcbiAgICAgICAgICAgIHdoaWxlIChuZXh0ICE9IG51bGwgJiYgaW5kZXhEZWZpbml0aW9uLmNvbXBhcmUobmV4dCwgc3RhcnRQb3N0KSA8IDApIHtcclxuICAgICAgICAgICAgICAgIGl0ZXJhdG9yLmdldE5leHQoKTtcclxuICAgICAgICAgICAgICAgIG5leHQgPSBpdGVyYXRvci5wZWVrKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGl0ZXJhdG9yO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGdldFJldmVyc2VJdGVyYXRvcihpbmRleERlZmluaXRpb24pIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5nZXRSZXZlcnNlSXRlcmF0b3JGcm9tKGluZGV4RGVmaW5pdGlvbi5tYXhQb3N0KCksIGluZGV4RGVmaW5pdGlvbik7XHJcbiAgICB9XHJcbiAgICBnZXRSZXZlcnNlSXRlcmF0b3JGcm9tKGVuZFBvc3QsIGluZGV4RGVmaW5pdGlvbikge1xyXG4gICAgICAgIGNvbnN0IGlkeCA9IHRoaXMucmVzb2x2ZUluZGV4XyhpbmRleERlZmluaXRpb24pO1xyXG4gICAgICAgIGlmIChpZHgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGlkeC5nZXRSZXZlcnNlSXRlcmF0b3JGcm9tKGVuZFBvc3QsIGtleSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ga2V5O1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGl0ZXJhdG9yID0gdGhpcy5jaGlsZHJlbl8uZ2V0UmV2ZXJzZUl0ZXJhdG9yRnJvbShlbmRQb3N0Lm5hbWUsIE5hbWVkTm9kZS5XcmFwKTtcclxuICAgICAgICAgICAgbGV0IG5leHQgPSBpdGVyYXRvci5wZWVrKCk7XHJcbiAgICAgICAgICAgIHdoaWxlIChuZXh0ICE9IG51bGwgJiYgaW5kZXhEZWZpbml0aW9uLmNvbXBhcmUobmV4dCwgZW5kUG9zdCkgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICBpdGVyYXRvci5nZXROZXh0KCk7XHJcbiAgICAgICAgICAgICAgICBuZXh0ID0gaXRlcmF0b3IucGVlaygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBpdGVyYXRvcjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjb21wYXJlVG8ob3RoZXIpIHtcclxuICAgICAgICBpZiAodGhpcy5pc0VtcHR5KCkpIHtcclxuICAgICAgICAgICAgaWYgKG90aGVyLmlzRW1wdHkoKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAob3RoZXIuaXNMZWFmTm9kZSgpIHx8IG90aGVyLmlzRW1wdHkoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAob3RoZXIgPT09IE1BWF9OT0RFKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAtMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIE11c3QgYmUgYW5vdGhlciBub2RlIHdpdGggY2hpbGRyZW4uXHJcbiAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHdpdGhJbmRleChpbmRleERlZmluaXRpb24pIHtcclxuICAgICAgICBpZiAoaW5kZXhEZWZpbml0aW9uID09PSBLRVlfSU5ERVggfHxcclxuICAgICAgICAgICAgdGhpcy5pbmRleE1hcF8uaGFzSW5kZXgoaW5kZXhEZWZpbml0aW9uKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG5ld0luZGV4TWFwID0gdGhpcy5pbmRleE1hcF8uYWRkSW5kZXgoaW5kZXhEZWZpbml0aW9uLCB0aGlzLmNoaWxkcmVuXyk7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ2hpbGRyZW5Ob2RlKHRoaXMuY2hpbGRyZW5fLCB0aGlzLnByaW9yaXR5Tm9kZV8sIG5ld0luZGV4TWFwKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpc0luZGV4ZWQoaW5kZXgpIHtcclxuICAgICAgICByZXR1cm4gaW5kZXggPT09IEtFWV9JTkRFWCB8fCB0aGlzLmluZGV4TWFwXy5oYXNJbmRleChpbmRleCk7XHJcbiAgICB9XHJcbiAgICBlcXVhbHMob3RoZXIpIHtcclxuICAgICAgICBpZiAob3RoZXIgPT09IHRoaXMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKG90aGVyLmlzTGVhZk5vZGUoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCBvdGhlckNoaWxkcmVuTm9kZSA9IG90aGVyO1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuZ2V0UHJpb3JpdHkoKS5lcXVhbHMob3RoZXJDaGlsZHJlbk5vZGUuZ2V0UHJpb3JpdHkoKSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLmNoaWxkcmVuXy5jb3VudCgpID09PSBvdGhlckNoaWxkcmVuTm9kZS5jaGlsZHJlbl8uY291bnQoKSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdGhpc0l0ZXIgPSB0aGlzLmdldEl0ZXJhdG9yKFBSSU9SSVRZX0lOREVYKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG90aGVySXRlciA9IG90aGVyQ2hpbGRyZW5Ob2RlLmdldEl0ZXJhdG9yKFBSSU9SSVRZX0lOREVYKTtcclxuICAgICAgICAgICAgICAgIGxldCB0aGlzQ3VycmVudCA9IHRoaXNJdGVyLmdldE5leHQoKTtcclxuICAgICAgICAgICAgICAgIGxldCBvdGhlckN1cnJlbnQgPSBvdGhlckl0ZXIuZ2V0TmV4dCgpO1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKHRoaXNDdXJyZW50ICYmIG90aGVyQ3VycmVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzQ3VycmVudC5uYW1lICE9PSBvdGhlckN1cnJlbnQubmFtZSB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAhdGhpc0N1cnJlbnQubm9kZS5lcXVhbHMob3RoZXJDdXJyZW50Lm5vZGUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpc0N1cnJlbnQgPSB0aGlzSXRlci5nZXROZXh0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgb3RoZXJDdXJyZW50ID0gb3RoZXJJdGVyLmdldE5leHQoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzQ3VycmVudCA9PT0gbnVsbCAmJiBvdGhlckN1cnJlbnQgPT09IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBTb3J0ZWRNYXAgb3JkZXJlZCBieSBpbmRleCwgb3IgbnVsbCBpZiB0aGUgZGVmYXVsdCAoYnkta2V5KSBvcmRlcmluZyBjYW4gYmUgdXNlZFxyXG4gICAgICogaW5zdGVhZC5cclxuICAgICAqXHJcbiAgICAgKi9cclxuICAgIHJlc29sdmVJbmRleF8oaW5kZXhEZWZpbml0aW9uKSB7XHJcbiAgICAgICAgaWYgKGluZGV4RGVmaW5pdGlvbiA9PT0gS0VZX0lOREVYKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW5kZXhNYXBfLmdldChpbmRleERlZmluaXRpb24udG9TdHJpbmcoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbkNoaWxkcmVuTm9kZS5JTlRFR0VSX1JFR0VYUF8gPSAvXigwfFsxLTldXFxkKikkLztcclxuY2xhc3MgTWF4Tm9kZSBleHRlbmRzIENoaWxkcmVuTm9kZSB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlcihuZXcgU29ydGVkTWFwKE5BTUVfQ09NUEFSQVRPUiksIENoaWxkcmVuTm9kZS5FTVBUWV9OT0RFLCBJbmRleE1hcC5EZWZhdWx0KTtcclxuICAgIH1cclxuICAgIGNvbXBhcmVUbyhvdGhlcikge1xyXG4gICAgICAgIGlmIChvdGhlciA9PT0gdGhpcykge1xyXG4gICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiAxO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVxdWFscyhvdGhlcikge1xyXG4gICAgICAgIC8vIE5vdCB0aGF0IHdlIGV2ZXJ5IGNvbXBhcmUgaXQsIGJ1dCBNQVhfTk9ERSBpcyBvbmx5IGV2ZXIgZXF1YWwgdG8gaXRzZWxmXHJcbiAgICAgICAgcmV0dXJuIG90aGVyID09PSB0aGlzO1xyXG4gICAgfVxyXG4gICAgZ2V0UHJpb3JpdHkoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICBnZXRJbW1lZGlhdGVDaGlsZChjaGlsZE5hbWUpIHtcclxuICAgICAgICByZXR1cm4gQ2hpbGRyZW5Ob2RlLkVNUFRZX05PREU7XHJcbiAgICB9XHJcbiAgICBpc0VtcHR5KCkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogTWFya2VyIHRoYXQgd2lsbCBzb3J0IGhpZ2hlciB0aGFuIGFueSBvdGhlciBzbmFwc2hvdC5cclxuICovXHJcbmNvbnN0IE1BWF9OT0RFID0gbmV3IE1heE5vZGUoKTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoTmFtZWROb2RlLCB7XHJcbiAgICBNSU46IHtcclxuICAgICAgICB2YWx1ZTogbmV3IE5hbWVkTm9kZShNSU5fTkFNRSwgQ2hpbGRyZW5Ob2RlLkVNUFRZX05PREUpXHJcbiAgICB9LFxyXG4gICAgTUFYOiB7XHJcbiAgICAgICAgdmFsdWU6IG5ldyBOYW1lZE5vZGUoTUFYX05BTUUsIE1BWF9OT0RFKVxyXG4gICAgfVxyXG59KTtcclxuLyoqXHJcbiAqIFJlZmVyZW5jZSBFeHRlbnNpb25zXHJcbiAqL1xyXG5LZXlJbmRleC5fX0VNUFRZX05PREUgPSBDaGlsZHJlbk5vZGUuRU1QVFlfTk9ERTtcclxuTGVhZk5vZGUuX19jaGlsZHJlbk5vZGVDb25zdHJ1Y3RvciA9IENoaWxkcmVuTm9kZTtcclxuc2V0TWF4Tm9kZSQxKE1BWF9OT0RFKTtcclxuc2V0TWF4Tm9kZShNQVhfTk9ERSk7XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmNvbnN0IFVTRV9ISU5aRSA9IHRydWU7XHJcbi8qKlxyXG4gKiBDb25zdHJ1Y3RzIGEgc25hcHNob3Qgbm9kZSByZXByZXNlbnRpbmcgdGhlIHBhc3NlZCBKU09OIGFuZCByZXR1cm5zIGl0LlxyXG4gKiBAcGFyYW0ganNvbiAtIEpTT04gdG8gY3JlYXRlIGEgbm9kZSBmb3IuXHJcbiAqIEBwYXJhbSBwcmlvcml0eSAtIE9wdGlvbmFsIHByaW9yaXR5IHRvIHVzZS4gIFRoaXMgd2lsbCBiZSBpZ25vcmVkIGlmIHRoZVxyXG4gKiBwYXNzZWQgSlNPTiBjb250YWlucyBhIC5wcmlvcml0eSBwcm9wZXJ0eS5cclxuICovXHJcbmZ1bmN0aW9uIG5vZGVGcm9tSlNPTihqc29uLCBwcmlvcml0eSA9IG51bGwpIHtcclxuICAgIGlmIChqc29uID09PSBudWxsKSB7XHJcbiAgICAgICAgcmV0dXJuIENoaWxkcmVuTm9kZS5FTVBUWV9OT0RFO1xyXG4gICAgfVxyXG4gICAgaWYgKHR5cGVvZiBqc29uID09PSAnb2JqZWN0JyAmJiAnLnByaW9yaXR5JyBpbiBqc29uKSB7XHJcbiAgICAgICAgcHJpb3JpdHkgPSBqc29uWycucHJpb3JpdHknXTtcclxuICAgIH1cclxuICAgIGFzc2VydChwcmlvcml0eSA9PT0gbnVsbCB8fFxyXG4gICAgICAgIHR5cGVvZiBwcmlvcml0eSA9PT0gJ3N0cmluZycgfHxcclxuICAgICAgICB0eXBlb2YgcHJpb3JpdHkgPT09ICdudW1iZXInIHx8XHJcbiAgICAgICAgKHR5cGVvZiBwcmlvcml0eSA9PT0gJ29iamVjdCcgJiYgJy5zdicgaW4gcHJpb3JpdHkpLCAnSW52YWxpZCBwcmlvcml0eSB0eXBlIGZvdW5kOiAnICsgdHlwZW9mIHByaW9yaXR5KTtcclxuICAgIGlmICh0eXBlb2YganNvbiA9PT0gJ29iamVjdCcgJiYgJy52YWx1ZScgaW4ganNvbiAmJiBqc29uWycudmFsdWUnXSAhPT0gbnVsbCkge1xyXG4gICAgICAgIGpzb24gPSBqc29uWycudmFsdWUnXTtcclxuICAgIH1cclxuICAgIC8vIFZhbGlkIGxlYWYgbm9kZXMgaW5jbHVkZSBub24tb2JqZWN0cyBvciBzZXJ2ZXItdmFsdWUgd3JhcHBlciBvYmplY3RzXHJcbiAgICBpZiAodHlwZW9mIGpzb24gIT09ICdvYmplY3QnIHx8ICcuc3YnIGluIGpzb24pIHtcclxuICAgICAgICBjb25zdCBqc29uTGVhZiA9IGpzb247XHJcbiAgICAgICAgcmV0dXJuIG5ldyBMZWFmTm9kZShqc29uTGVhZiwgbm9kZUZyb21KU09OKHByaW9yaXR5KSk7XHJcbiAgICB9XHJcbiAgICBpZiAoIShqc29uIGluc3RhbmNlb2YgQXJyYXkpICYmIFVTRV9ISU5aRSkge1xyXG4gICAgICAgIGNvbnN0IGNoaWxkcmVuID0gW107XHJcbiAgICAgICAgbGV0IGNoaWxkcmVuSGF2ZVByaW9yaXR5ID0gZmFsc2U7XHJcbiAgICAgICAgY29uc3QgaGluemVKc29uT2JqID0ganNvbjtcclxuICAgICAgICBlYWNoKGhpbnplSnNvbk9iaiwgKGtleSwgY2hpbGQpID0+IHtcclxuICAgICAgICAgICAgaWYgKGtleS5zdWJzdHJpbmcoMCwgMSkgIT09ICcuJykge1xyXG4gICAgICAgICAgICAgICAgLy8gSWdub3JlIG1ldGFkYXRhIG5vZGVzXHJcbiAgICAgICAgICAgICAgICBjb25zdCBjaGlsZE5vZGUgPSBub2RlRnJvbUpTT04oY2hpbGQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFjaGlsZE5vZGUuaXNFbXB0eSgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW5IYXZlUHJpb3JpdHkgPVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbkhhdmVQcmlvcml0eSB8fCAhY2hpbGROb2RlLmdldFByaW9yaXR5KCkuaXNFbXB0eSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuLnB1c2gobmV3IE5hbWVkTm9kZShrZXksIGNoaWxkTm9kZSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKGNoaWxkcmVuLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gQ2hpbGRyZW5Ob2RlLkVNUFRZX05PREU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGNoaWxkU2V0ID0gYnVpbGRDaGlsZFNldChjaGlsZHJlbiwgTkFNRV9PTkxZX0NPTVBBUkFUT1IsIG5hbWVkTm9kZSA9PiBuYW1lZE5vZGUubmFtZSwgTkFNRV9DT01QQVJBVE9SKTtcclxuICAgICAgICBpZiAoY2hpbGRyZW5IYXZlUHJpb3JpdHkpIHtcclxuICAgICAgICAgICAgY29uc3Qgc29ydGVkQ2hpbGRTZXQgPSBidWlsZENoaWxkU2V0KGNoaWxkcmVuLCBQUklPUklUWV9JTkRFWC5nZXRDb21wYXJlKCkpO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IENoaWxkcmVuTm9kZShjaGlsZFNldCwgbm9kZUZyb21KU09OKHByaW9yaXR5KSwgbmV3IEluZGV4TWFwKHsgJy5wcmlvcml0eSc6IHNvcnRlZENoaWxkU2V0IH0sIHsgJy5wcmlvcml0eSc6IFBSSU9SSVRZX0lOREVYIH0pKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ2hpbGRyZW5Ob2RlKGNoaWxkU2V0LCBub2RlRnJvbUpTT04ocHJpb3JpdHkpLCBJbmRleE1hcC5EZWZhdWx0KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBsZXQgbm9kZSA9IENoaWxkcmVuTm9kZS5FTVBUWV9OT0RFO1xyXG4gICAgICAgIGVhY2goanNvbiwgKGtleSwgY2hpbGREYXRhKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChjb250YWlucyhqc29uLCBrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoa2V5LnN1YnN0cmluZygwLCAxKSAhPT0gJy4nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaWdub3JlIG1ldGFkYXRhIG5vZGVzLlxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkTm9kZSA9IG5vZGVGcm9tSlNPTihjaGlsZERhdGEpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZE5vZGUuaXNMZWFmTm9kZSgpIHx8ICFjaGlsZE5vZGUuaXNFbXB0eSgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLnVwZGF0ZUltbWVkaWF0ZUNoaWxkKGtleSwgY2hpbGROb2RlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gbm9kZS51cGRhdGVQcmlvcml0eShub2RlRnJvbUpTT04ocHJpb3JpdHkpKTtcclxuICAgIH1cclxufVxyXG5zZXROb2RlRnJvbUpTT04obm9kZUZyb21KU09OKTtcblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuY2xhc3MgUGF0aEluZGV4IGV4dGVuZHMgSW5kZXgge1xyXG4gICAgY29uc3RydWN0b3IoaW5kZXhQYXRoXykge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5pbmRleFBhdGhfID0gaW5kZXhQYXRoXztcclxuICAgICAgICBhc3NlcnQoIXBhdGhJc0VtcHR5KGluZGV4UGF0aF8pICYmIHBhdGhHZXRGcm9udChpbmRleFBhdGhfKSAhPT0gJy5wcmlvcml0eScsIFwiQ2FuJ3QgY3JlYXRlIFBhdGhJbmRleCB3aXRoIGVtcHR5IHBhdGggb3IgLnByaW9yaXR5IGtleVwiKTtcclxuICAgIH1cclxuICAgIGV4dHJhY3RDaGlsZChzbmFwKSB7XHJcbiAgICAgICAgcmV0dXJuIHNuYXAuZ2V0Q2hpbGQodGhpcy5pbmRleFBhdGhfKTtcclxuICAgIH1cclxuICAgIGlzRGVmaW5lZE9uKG5vZGUpIHtcclxuICAgICAgICByZXR1cm4gIW5vZGUuZ2V0Q2hpbGQodGhpcy5pbmRleFBhdGhfKS5pc0VtcHR5KCk7XHJcbiAgICB9XHJcbiAgICBjb21wYXJlKGEsIGIpIHtcclxuICAgICAgICBjb25zdCBhQ2hpbGQgPSB0aGlzLmV4dHJhY3RDaGlsZChhLm5vZGUpO1xyXG4gICAgICAgIGNvbnN0IGJDaGlsZCA9IHRoaXMuZXh0cmFjdENoaWxkKGIubm9kZSk7XHJcbiAgICAgICAgY29uc3QgaW5kZXhDbXAgPSBhQ2hpbGQuY29tcGFyZVRvKGJDaGlsZCk7XHJcbiAgICAgICAgaWYgKGluZGV4Q21wID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuYW1lQ29tcGFyZShhLm5hbWUsIGIubmFtZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gaW5kZXhDbXA7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgbWFrZVBvc3QoaW5kZXhWYWx1ZSwgbmFtZSkge1xyXG4gICAgICAgIGNvbnN0IHZhbHVlTm9kZSA9IG5vZGVGcm9tSlNPTihpbmRleFZhbHVlKTtcclxuICAgICAgICBjb25zdCBub2RlID0gQ2hpbGRyZW5Ob2RlLkVNUFRZX05PREUudXBkYXRlQ2hpbGQodGhpcy5pbmRleFBhdGhfLCB2YWx1ZU5vZGUpO1xyXG4gICAgICAgIHJldHVybiBuZXcgTmFtZWROb2RlKG5hbWUsIG5vZGUpO1xyXG4gICAgfVxyXG4gICAgbWF4UG9zdCgpIHtcclxuICAgICAgICBjb25zdCBub2RlID0gQ2hpbGRyZW5Ob2RlLkVNUFRZX05PREUudXBkYXRlQ2hpbGQodGhpcy5pbmRleFBhdGhfLCBNQVhfTk9ERSk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBOYW1lZE5vZGUoTUFYX05BTUUsIG5vZGUpO1xyXG4gICAgfVxyXG4gICAgdG9TdHJpbmcoKSB7XHJcbiAgICAgICAgcmV0dXJuIHBhdGhTbGljZSh0aGlzLmluZGV4UGF0aF8sIDApLmpvaW4oJy8nKTtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5jbGFzcyBWYWx1ZUluZGV4IGV4dGVuZHMgSW5kZXgge1xyXG4gICAgY29tcGFyZShhLCBiKSB7XHJcbiAgICAgICAgY29uc3QgaW5kZXhDbXAgPSBhLm5vZGUuY29tcGFyZVRvKGIubm9kZSk7XHJcbiAgICAgICAgaWYgKGluZGV4Q21wID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuYW1lQ29tcGFyZShhLm5hbWUsIGIubmFtZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gaW5kZXhDbXA7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaXNEZWZpbmVkT24obm9kZSkge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgaW5kZXhlZFZhbHVlQ2hhbmdlZChvbGROb2RlLCBuZXdOb2RlKSB7XHJcbiAgICAgICAgcmV0dXJuICFvbGROb2RlLmVxdWFscyhuZXdOb2RlKTtcclxuICAgIH1cclxuICAgIG1pblBvc3QoKSB7XHJcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcclxuICAgICAgICByZXR1cm4gTmFtZWROb2RlLk1JTjtcclxuICAgIH1cclxuICAgIG1heFBvc3QoKSB7XHJcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcclxuICAgICAgICByZXR1cm4gTmFtZWROb2RlLk1BWDtcclxuICAgIH1cclxuICAgIG1ha2VQb3N0KGluZGV4VmFsdWUsIG5hbWUpIHtcclxuICAgICAgICBjb25zdCB2YWx1ZU5vZGUgPSBub2RlRnJvbUpTT04oaW5kZXhWYWx1ZSk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBOYW1lZE5vZGUobmFtZSwgdmFsdWVOb2RlKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybnMgU3RyaW5nIHJlcHJlc2VudGF0aW9uIGZvciBpbmNsdXNpb24gaW4gYSBxdWVyeSBzcGVjXHJcbiAgICAgKi9cclxuICAgIHRvU3RyaW5nKCkge1xyXG4gICAgICAgIHJldHVybiAnLnZhbHVlJztcclxuICAgIH1cclxufVxyXG5jb25zdCBWQUxVRV9JTkRFWCA9IG5ldyBWYWx1ZUluZGV4KCk7XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8vIE1vZGVsZWQgYWZ0ZXIgYmFzZTY0IHdlYi1zYWZlIGNoYXJzLCBidXQgb3JkZXJlZCBieSBBU0NJSS5cclxuY29uc3QgUFVTSF9DSEFSUyA9ICctMDEyMzQ1Njc4OUFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaX2FiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6JztcclxuY29uc3QgTUlOX1BVU0hfQ0hBUiA9ICctJztcclxuY29uc3QgTUFYX1BVU0hfQ0hBUiA9ICd6JztcclxuY29uc3QgTUFYX0tFWV9MRU4gPSA3ODY7XHJcbi8qKlxyXG4gKiBGYW5jeSBJRCBnZW5lcmF0b3IgdGhhdCBjcmVhdGVzIDIwLWNoYXJhY3RlciBzdHJpbmcgaWRlbnRpZmllcnMgd2l0aCB0aGVcclxuICogZm9sbG93aW5nIHByb3BlcnRpZXM6XHJcbiAqXHJcbiAqIDEuIFRoZXkncmUgYmFzZWQgb24gdGltZXN0YW1wIHNvIHRoYXQgdGhleSBzb3J0ICphZnRlciogYW55IGV4aXN0aW5nIGlkcy5cclxuICogMi4gVGhleSBjb250YWluIDcyLWJpdHMgb2YgcmFuZG9tIGRhdGEgYWZ0ZXIgdGhlIHRpbWVzdGFtcCBzbyB0aGF0IElEcyB3b24ndFxyXG4gKiAgICBjb2xsaWRlIHdpdGggb3RoZXIgY2xpZW50cycgSURzLlxyXG4gKiAzLiBUaGV5IHNvcnQgKmxleGljb2dyYXBoaWNhbGx5KiAoc28gdGhlIHRpbWVzdGFtcCBpcyBjb252ZXJ0ZWQgdG8gY2hhcmFjdGVyc1xyXG4gKiAgICB0aGF0IHdpbGwgc29ydCBwcm9wZXJseSkuXHJcbiAqIDQuIFRoZXkncmUgbW9ub3RvbmljYWxseSBpbmNyZWFzaW5nLiBFdmVuIGlmIHlvdSBnZW5lcmF0ZSBtb3JlIHRoYW4gb25lIGluXHJcbiAqICAgIHRoZSBzYW1lIHRpbWVzdGFtcCwgdGhlIGxhdHRlciBvbmVzIHdpbGwgc29ydCBhZnRlciB0aGUgZm9ybWVyIG9uZXMuIFdlIGRvXHJcbiAqICAgIHRoaXMgYnkgdXNpbmcgdGhlIHByZXZpb3VzIHJhbmRvbSBiaXRzIGJ1dCBcImluY3JlbWVudGluZ1wiIHRoZW0gYnkgMSAob25seVxyXG4gKiAgICBpbiB0aGUgY2FzZSBvZiBhIHRpbWVzdGFtcCBjb2xsaXNpb24pLlxyXG4gKi9cclxuY29uc3QgbmV4dFB1c2hJZCA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAvLyBUaW1lc3RhbXAgb2YgbGFzdCBwdXNoLCB1c2VkIHRvIHByZXZlbnQgbG9jYWwgY29sbGlzaW9ucyBpZiB5b3UgcHVzaCB0d2ljZVxyXG4gICAgLy8gaW4gb25lIG1zLlxyXG4gICAgbGV0IGxhc3RQdXNoVGltZSA9IDA7XHJcbiAgICAvLyBXZSBnZW5lcmF0ZSA3Mi1iaXRzIG9mIHJhbmRvbW5lc3Mgd2hpY2ggZ2V0IHR1cm5lZCBpbnRvIDEyIGNoYXJhY3RlcnMgYW5kXHJcbiAgICAvLyBhcHBlbmRlZCB0byB0aGUgdGltZXN0YW1wIHRvIHByZXZlbnQgY29sbGlzaW9ucyB3aXRoIG90aGVyIGNsaWVudHMuIFdlXHJcbiAgICAvLyBzdG9yZSB0aGUgbGFzdCBjaGFyYWN0ZXJzIHdlIGdlbmVyYXRlZCBiZWNhdXNlIGluIHRoZSBldmVudCBvZiBhIGNvbGxpc2lvbixcclxuICAgIC8vIHdlJ2xsIHVzZSB0aG9zZSBzYW1lIGNoYXJhY3RlcnMgZXhjZXB0IFwiaW5jcmVtZW50ZWRcIiBieSBvbmUuXHJcbiAgICBjb25zdCBsYXN0UmFuZENoYXJzID0gW107XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKG5vdykge1xyXG4gICAgICAgIGNvbnN0IGR1cGxpY2F0ZVRpbWUgPSBub3cgPT09IGxhc3RQdXNoVGltZTtcclxuICAgICAgICBsYXN0UHVzaFRpbWUgPSBub3c7XHJcbiAgICAgICAgbGV0IGk7XHJcbiAgICAgICAgY29uc3QgdGltZVN0YW1wQ2hhcnMgPSBuZXcgQXJyYXkoOCk7XHJcbiAgICAgICAgZm9yIChpID0gNzsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgICAgICAgdGltZVN0YW1wQ2hhcnNbaV0gPSBQVVNIX0NIQVJTLmNoYXJBdChub3cgJSA2NCk7XHJcbiAgICAgICAgICAgIC8vIE5PVEU6IENhbid0IHVzZSA8PCBoZXJlIGJlY2F1c2UgamF2YXNjcmlwdCB3aWxsIGNvbnZlcnQgdG8gaW50IGFuZCBsb3NlXHJcbiAgICAgICAgICAgIC8vIHRoZSB1cHBlciBiaXRzLlxyXG4gICAgICAgICAgICBub3cgPSBNYXRoLmZsb29yKG5vdyAvIDY0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYXNzZXJ0KG5vdyA9PT0gMCwgJ0Nhbm5vdCBwdXNoIGF0IHRpbWUgPT0gMCcpO1xyXG4gICAgICAgIGxldCBpZCA9IHRpbWVTdGFtcENoYXJzLmpvaW4oJycpO1xyXG4gICAgICAgIGlmICghZHVwbGljYXRlVGltZSkge1xyXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMTI7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgbGFzdFJhbmRDaGFyc1tpXSA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDY0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gSWYgdGhlIHRpbWVzdGFtcCBoYXNuJ3QgY2hhbmdlZCBzaW5jZSBsYXN0IHB1c2gsIHVzZSB0aGUgc2FtZSByYW5kb21cclxuICAgICAgICAgICAgLy8gbnVtYmVyLCBleGNlcHQgaW5jcmVtZW50ZWQgYnkgMS5cclxuICAgICAgICAgICAgZm9yIChpID0gMTE7IGkgPj0gMCAmJiBsYXN0UmFuZENoYXJzW2ldID09PSA2MzsgaS0tKSB7XHJcbiAgICAgICAgICAgICAgICBsYXN0UmFuZENoYXJzW2ldID0gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsYXN0UmFuZENoYXJzW2ldKys7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCAxMjsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlkICs9IFBVU0hfQ0hBUlMuY2hhckF0KGxhc3RSYW5kQ2hhcnNbaV0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBhc3NlcnQoaWQubGVuZ3RoID09PSAyMCwgJ25leHRQdXNoSWQ6IExlbmd0aCBzaG91bGQgYmUgMjAuJyk7XHJcbiAgICAgICAgcmV0dXJuIGlkO1xyXG4gICAgfTtcclxufSkoKTtcclxuY29uc3Qgc3VjY2Vzc29yID0gZnVuY3Rpb24gKGtleSkge1xyXG4gICAgaWYgKGtleSA9PT0gJycgKyBJTlRFR0VSXzMyX01BWCkge1xyXG4gICAgICAgIC8vIFNlZSBodHRwczovL2ZpcmViYXNlLmdvb2dsZS5jb20vZG9jcy9kYXRhYmFzZS93ZWIvbGlzdHMtb2YtZGF0YSNkYXRhLW9yZGVyXHJcbiAgICAgICAgcmV0dXJuIE1JTl9QVVNIX0NIQVI7XHJcbiAgICB9XHJcbiAgICBjb25zdCBrZXlBc0ludCA9IHRyeVBhcnNlSW50KGtleSk7XHJcbiAgICBpZiAoa2V5QXNJbnQgIT0gbnVsbCkge1xyXG4gICAgICAgIHJldHVybiAnJyArIChrZXlBc0ludCArIDEpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgbmV4dCA9IG5ldyBBcnJheShrZXkubGVuZ3RoKTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmV4dC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIG5leHRbaV0gPSBrZXkuY2hhckF0KGkpO1xyXG4gICAgfVxyXG4gICAgaWYgKG5leHQubGVuZ3RoIDwgTUFYX0tFWV9MRU4pIHtcclxuICAgICAgICBuZXh0LnB1c2goTUlOX1BVU0hfQ0hBUik7XHJcbiAgICAgICAgcmV0dXJuIG5leHQuam9pbignJyk7XHJcbiAgICB9XHJcbiAgICBsZXQgaSA9IG5leHQubGVuZ3RoIC0gMTtcclxuICAgIHdoaWxlIChpID49IDAgJiYgbmV4dFtpXSA9PT0gTUFYX1BVU0hfQ0hBUikge1xyXG4gICAgICAgIGktLTtcclxuICAgIH1cclxuICAgIC8vIGBzdWNjZXNzb3JgIHdhcyBjYWxsZWQgb24gdGhlIGxhcmdlc3QgcG9zc2libGUga2V5LCBzbyByZXR1cm4gdGhlXHJcbiAgICAvLyBNQVhfTkFNRSwgd2hpY2ggc29ydHMgbGFyZ2VyIHRoYW4gYWxsIGtleXMuXHJcbiAgICBpZiAoaSA9PT0gLTEpIHtcclxuICAgICAgICByZXR1cm4gTUFYX05BTUU7XHJcbiAgICB9XHJcbiAgICBjb25zdCBzb3VyY2UgPSBuZXh0W2ldO1xyXG4gICAgY29uc3Qgc291cmNlUGx1c09uZSA9IFBVU0hfQ0hBUlMuY2hhckF0KFBVU0hfQ0hBUlMuaW5kZXhPZihzb3VyY2UpICsgMSk7XHJcbiAgICBuZXh0W2ldID0gc291cmNlUGx1c09uZTtcclxuICAgIHJldHVybiBuZXh0LnNsaWNlKDAsIGkgKyAxKS5qb2luKCcnKTtcclxufTtcclxuLy8gYGtleWAgaXMgYXNzdW1lZCB0byBiZSBub24tZW1wdHkuXHJcbmNvbnN0IHByZWRlY2Vzc29yID0gZnVuY3Rpb24gKGtleSkge1xyXG4gICAgaWYgKGtleSA9PT0gJycgKyBJTlRFR0VSXzMyX01JTikge1xyXG4gICAgICAgIHJldHVybiBNSU5fTkFNRTtcclxuICAgIH1cclxuICAgIGNvbnN0IGtleUFzSW50ID0gdHJ5UGFyc2VJbnQoa2V5KTtcclxuICAgIGlmIChrZXlBc0ludCAhPSBudWxsKSB7XHJcbiAgICAgICAgcmV0dXJuICcnICsgKGtleUFzSW50IC0gMSk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBuZXh0ID0gbmV3IEFycmF5KGtleS5sZW5ndGgpO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuZXh0Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgbmV4dFtpXSA9IGtleS5jaGFyQXQoaSk7XHJcbiAgICB9XHJcbiAgICAvLyBJZiBga2V5YCBlbmRzIGluIGBNSU5fUFVTSF9DSEFSYCwgdGhlIGxhcmdlc3Qga2V5IGxleGljb2dyYXBoaWNhbGx5XHJcbiAgICAvLyBzbWFsbGVyIHRoYW4gYGtleWAsIGlzIGBrZXlbMDprZXkubGVuZ3RoIC0gMV1gLiBUaGUgbmV4dCBrZXkgc21hbGxlclxyXG4gICAgLy8gdGhhbiB0aGF0LCBgcHJlZGVjZXNzb3IocHJlZGVjZXNzb3Ioa2V5KSlgLCBpc1xyXG4gICAgLy9cclxuICAgIC8vIGBrZXlbMDprZXkubGVuZ3RoIC0gMl0gKyAoa2V5W2tleS5sZW5ndGggLSAxXSAtIDEpICsgXFxcclxuICAgIC8vICAgeyBNQVhfUFVTSF9DSEFSIHJlcGVhdGVkIE1BWF9LRVlfTEVOIC0gKGtleS5sZW5ndGggLSAxKSB0aW1lcyB9XHJcbiAgICAvL1xyXG4gICAgLy8gYW5hbG9nb3VzIHRvIGluY3JlbWVudC9kZWNyZW1lbnQgZm9yIGJhc2UtMTAgaW50ZWdlcnMuXHJcbiAgICAvL1xyXG4gICAgLy8gVGhpcyB3b3JrcyBiZWNhdXNlIGxleGlnb2dyYXBoaWMgY29tcGFyaXNvbiB3b3JrcyBjaGFyYWN0ZXItYnktY2hhcmFjdGVyLFxyXG4gICAgLy8gdXNpbmcgbGVuZ3RoIGFzIGEgdGllLWJyZWFrZXIgaWYgb25lIGtleSBpcyBhIHByZWZpeCBvZiB0aGUgb3RoZXIuXHJcbiAgICBpZiAobmV4dFtuZXh0Lmxlbmd0aCAtIDFdID09PSBNSU5fUFVTSF9DSEFSKSB7XHJcbiAgICAgICAgaWYgKG5leHQubGVuZ3RoID09PSAxKSB7XHJcbiAgICAgICAgICAgIC8vIFNlZSBodHRwczovL2ZpcmViYXNlLmdvb2dsZS5jb20vZG9jcy9kYXRhYmFzZS93ZWIvbGlzdHMtb2YtZGF0YSNvcmRlcmJ5a2V5XHJcbiAgICAgICAgICAgIHJldHVybiAnJyArIElOVEVHRVJfMzJfTUFYO1xyXG4gICAgICAgIH1cclxuICAgICAgICBkZWxldGUgbmV4dFtuZXh0Lmxlbmd0aCAtIDFdO1xyXG4gICAgICAgIHJldHVybiBuZXh0LmpvaW4oJycpO1xyXG4gICAgfVxyXG4gICAgLy8gUmVwbGFjZSB0aGUgbGFzdCBjaGFyYWN0ZXIgd2l0aCBpdCdzIGltbWVkaWF0ZSBwcmVkZWNlc3NvciwgYW5kXHJcbiAgICAvLyBmaWxsIHRoZSBzdWZmaXggb2YgdGhlIGtleSB3aXRoIE1BWF9QVVNIX0NIQVIuIFRoaXMgaXMgdGhlXHJcbiAgICAvLyBsZXhpY29ncmFwaGljYWxseSBsYXJnZXN0IHBvc3NpYmxlIGtleSBzbWFsbGVyIHRoYW4gYGtleWAuXHJcbiAgICBuZXh0W25leHQubGVuZ3RoIC0gMV0gPSBQVVNIX0NIQVJTLmNoYXJBdChQVVNIX0NIQVJTLmluZGV4T2YobmV4dFtuZXh0Lmxlbmd0aCAtIDFdKSAtIDEpO1xyXG4gICAgcmV0dXJuIG5leHQuam9pbignJykgKyBNQVhfUFVTSF9DSEFSLnJlcGVhdChNQVhfS0VZX0xFTiAtIG5leHQubGVuZ3RoKTtcclxufTtcblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuZnVuY3Rpb24gY2hhbmdlVmFsdWUoc25hcHNob3ROb2RlKSB7XHJcbiAgICByZXR1cm4geyB0eXBlOiBcInZhbHVlXCIgLyogVkFMVUUgKi8sIHNuYXBzaG90Tm9kZSB9O1xyXG59XHJcbmZ1bmN0aW9uIGNoYW5nZUNoaWxkQWRkZWQoY2hpbGROYW1lLCBzbmFwc2hvdE5vZGUpIHtcclxuICAgIHJldHVybiB7IHR5cGU6IFwiY2hpbGRfYWRkZWRcIiAvKiBDSElMRF9BRERFRCAqLywgc25hcHNob3ROb2RlLCBjaGlsZE5hbWUgfTtcclxufVxyXG5mdW5jdGlvbiBjaGFuZ2VDaGlsZFJlbW92ZWQoY2hpbGROYW1lLCBzbmFwc2hvdE5vZGUpIHtcclxuICAgIHJldHVybiB7IHR5cGU6IFwiY2hpbGRfcmVtb3ZlZFwiIC8qIENISUxEX1JFTU9WRUQgKi8sIHNuYXBzaG90Tm9kZSwgY2hpbGROYW1lIH07XHJcbn1cclxuZnVuY3Rpb24gY2hhbmdlQ2hpbGRDaGFuZ2VkKGNoaWxkTmFtZSwgc25hcHNob3ROb2RlLCBvbGRTbmFwKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHR5cGU6IFwiY2hpbGRfY2hhbmdlZFwiIC8qIENISUxEX0NIQU5HRUQgKi8sXHJcbiAgICAgICAgc25hcHNob3ROb2RlLFxyXG4gICAgICAgIGNoaWxkTmFtZSxcclxuICAgICAgICBvbGRTbmFwXHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGNoYW5nZUNoaWxkTW92ZWQoY2hpbGROYW1lLCBzbmFwc2hvdE5vZGUpIHtcclxuICAgIHJldHVybiB7IHR5cGU6IFwiY2hpbGRfbW92ZWRcIiAvKiBDSElMRF9NT1ZFRCAqLywgc25hcHNob3ROb2RlLCBjaGlsZE5hbWUgfTtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogRG9lc24ndCByZWFsbHkgZmlsdGVyIG5vZGVzIGJ1dCBhcHBsaWVzIGFuIGluZGV4IHRvIHRoZSBub2RlIGFuZCBrZWVwcyB0cmFjayBvZiBhbnkgY2hhbmdlc1xyXG4gKi9cclxuY2xhc3MgSW5kZXhlZEZpbHRlciB7XHJcbiAgICBjb25zdHJ1Y3RvcihpbmRleF8pIHtcclxuICAgICAgICB0aGlzLmluZGV4XyA9IGluZGV4XztcclxuICAgIH1cclxuICAgIHVwZGF0ZUNoaWxkKHNuYXAsIGtleSwgbmV3Q2hpbGQsIGFmZmVjdGVkUGF0aCwgc291cmNlLCBvcHRDaGFuZ2VBY2N1bXVsYXRvcikge1xyXG4gICAgICAgIGFzc2VydChzbmFwLmlzSW5kZXhlZCh0aGlzLmluZGV4XyksICdBIG5vZGUgbXVzdCBiZSBpbmRleGVkIGlmIG9ubHkgYSBjaGlsZCBpcyB1cGRhdGVkJyk7XHJcbiAgICAgICAgY29uc3Qgb2xkQ2hpbGQgPSBzbmFwLmdldEltbWVkaWF0ZUNoaWxkKGtleSk7XHJcbiAgICAgICAgLy8gQ2hlY2sgaWYgYW55dGhpbmcgYWN0dWFsbHkgY2hhbmdlZC5cclxuICAgICAgICBpZiAob2xkQ2hpbGQuZ2V0Q2hpbGQoYWZmZWN0ZWRQYXRoKS5lcXVhbHMobmV3Q2hpbGQuZ2V0Q2hpbGQoYWZmZWN0ZWRQYXRoKSkpIHtcclxuICAgICAgICAgICAgLy8gVGhlcmUncyBhbiBlZGdlIGNhc2Ugd2hlcmUgYSBjaGlsZCBjYW4gZW50ZXIgb3IgbGVhdmUgdGhlIHZpZXcgYmVjYXVzZSBhZmZlY3RlZFBhdGggd2FzIHNldCB0byBudWxsLlxyXG4gICAgICAgICAgICAvLyBJbiB0aGlzIGNhc2UsIGFmZmVjdGVkUGF0aCB3aWxsIGFwcGVhciBudWxsIGluIGJvdGggdGhlIG9sZCBhbmQgbmV3IHNuYXBzaG90cy4gIFNvIHdlIG5lZWRcclxuICAgICAgICAgICAgLy8gdG8gYXZvaWQgdHJlYXRpbmcgdGhlc2UgY2FzZXMgYXMgXCJub3RoaW5nIGNoYW5nZWQuXCJcclxuICAgICAgICAgICAgaWYgKG9sZENoaWxkLmlzRW1wdHkoKSA9PT0gbmV3Q2hpbGQuaXNFbXB0eSgpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBOb3RoaW5nIGNoYW5nZWQuXHJcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGFzc2VydCBzaG91bGQgYmUgdmFsaWQsIGJ1dCBpdCdzIGV4cGVuc2l2ZSAoY2FuIGRvbWluYXRlIHBlcmYgdGVzdGluZykgc28gZG9uJ3QgYWN0dWFsbHkgZG8gaXQuXHJcbiAgICAgICAgICAgICAgICAvL2Fzc2VydChvbGRDaGlsZC5lcXVhbHMobmV3Q2hpbGQpLCAnT2xkIGFuZCBuZXcgc25hcHNob3RzIHNob3VsZCBiZSBlcXVhbC4nKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBzbmFwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChvcHRDaGFuZ2VBY2N1bXVsYXRvciAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIGlmIChuZXdDaGlsZC5pc0VtcHR5KCkpIHtcclxuICAgICAgICAgICAgICAgIGlmIChzbmFwLmhhc0NoaWxkKGtleSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBvcHRDaGFuZ2VBY2N1bXVsYXRvci50cmFja0NoaWxkQ2hhbmdlKGNoYW5nZUNoaWxkUmVtb3ZlZChrZXksIG9sZENoaWxkKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBhc3NlcnQoc25hcC5pc0xlYWZOb2RlKCksICdBIGNoaWxkIHJlbW92ZSB3aXRob3V0IGFuIG9sZCBjaGlsZCBvbmx5IG1ha2VzIHNlbnNlIG9uIGEgbGVhZiBub2RlJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAob2xkQ2hpbGQuaXNFbXB0eSgpKSB7XHJcbiAgICAgICAgICAgICAgICBvcHRDaGFuZ2VBY2N1bXVsYXRvci50cmFja0NoaWxkQ2hhbmdlKGNoYW5nZUNoaWxkQWRkZWQoa2V5LCBuZXdDaGlsZCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgb3B0Q2hhbmdlQWNjdW11bGF0b3IudHJhY2tDaGlsZENoYW5nZShjaGFuZ2VDaGlsZENoYW5nZWQoa2V5LCBuZXdDaGlsZCwgb2xkQ2hpbGQpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc25hcC5pc0xlYWZOb2RlKCkgJiYgbmV3Q2hpbGQuaXNFbXB0eSgpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzbmFwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHRoZSBub2RlIGlzIGluZGV4ZWRcclxuICAgICAgICAgICAgcmV0dXJuIHNuYXAudXBkYXRlSW1tZWRpYXRlQ2hpbGQoa2V5LCBuZXdDaGlsZCkud2l0aEluZGV4KHRoaXMuaW5kZXhfKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICB1cGRhdGVGdWxsTm9kZShvbGRTbmFwLCBuZXdTbmFwLCBvcHRDaGFuZ2VBY2N1bXVsYXRvcikge1xyXG4gICAgICAgIGlmIChvcHRDaGFuZ2VBY2N1bXVsYXRvciAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIGlmICghb2xkU25hcC5pc0xlYWZOb2RlKCkpIHtcclxuICAgICAgICAgICAgICAgIG9sZFNuYXAuZm9yRWFjaENoaWxkKFBSSU9SSVRZX0lOREVYLCAoa2V5LCBjaGlsZE5vZGUpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIW5ld1NuYXAuaGFzQ2hpbGQoa2V5KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRDaGFuZ2VBY2N1bXVsYXRvci50cmFja0NoaWxkQ2hhbmdlKGNoYW5nZUNoaWxkUmVtb3ZlZChrZXksIGNoaWxkTm9kZSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghbmV3U25hcC5pc0xlYWZOb2RlKCkpIHtcclxuICAgICAgICAgICAgICAgIG5ld1NuYXAuZm9yRWFjaENoaWxkKFBSSU9SSVRZX0lOREVYLCAoa2V5LCBjaGlsZE5vZGUpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAob2xkU25hcC5oYXNDaGlsZChrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG9sZENoaWxkID0gb2xkU25hcC5nZXRJbW1lZGlhdGVDaGlsZChrZXkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW9sZENoaWxkLmVxdWFscyhjaGlsZE5vZGUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRDaGFuZ2VBY2N1bXVsYXRvci50cmFja0NoaWxkQ2hhbmdlKGNoYW5nZUNoaWxkQ2hhbmdlZChrZXksIGNoaWxkTm9kZSwgb2xkQ2hpbGQpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3B0Q2hhbmdlQWNjdW11bGF0b3IudHJhY2tDaGlsZENoYW5nZShjaGFuZ2VDaGlsZEFkZGVkKGtleSwgY2hpbGROb2RlKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ld1NuYXAud2l0aEluZGV4KHRoaXMuaW5kZXhfKTtcclxuICAgIH1cclxuICAgIHVwZGF0ZVByaW9yaXR5KG9sZFNuYXAsIG5ld1ByaW9yaXR5KSB7XHJcbiAgICAgICAgaWYgKG9sZFNuYXAuaXNFbXB0eSgpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBDaGlsZHJlbk5vZGUuRU1QVFlfTk9ERTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBvbGRTbmFwLnVwZGF0ZVByaW9yaXR5KG5ld1ByaW9yaXR5KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmaWx0ZXJzTm9kZXMoKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgZ2V0SW5kZXhlZEZpbHRlcigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIGdldEluZGV4KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmluZGV4XztcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogRmlsdGVycyBub2RlcyBieSByYW5nZSBhbmQgdXNlcyBhbiBJbmRleEZpbHRlciB0byB0cmFjayBhbnkgY2hhbmdlcyBhZnRlciBmaWx0ZXJpbmcgdGhlIG5vZGVcclxuICovXHJcbmNsYXNzIFJhbmdlZEZpbHRlciB7XHJcbiAgICBjb25zdHJ1Y3RvcihwYXJhbXMpIHtcclxuICAgICAgICB0aGlzLmluZGV4ZWRGaWx0ZXJfID0gbmV3IEluZGV4ZWRGaWx0ZXIocGFyYW1zLmdldEluZGV4KCkpO1xyXG4gICAgICAgIHRoaXMuaW5kZXhfID0gcGFyYW1zLmdldEluZGV4KCk7XHJcbiAgICAgICAgdGhpcy5zdGFydFBvc3RfID0gUmFuZ2VkRmlsdGVyLmdldFN0YXJ0UG9zdF8ocGFyYW1zKTtcclxuICAgICAgICB0aGlzLmVuZFBvc3RfID0gUmFuZ2VkRmlsdGVyLmdldEVuZFBvc3RfKHBhcmFtcyk7XHJcbiAgICB9XHJcbiAgICBnZXRTdGFydFBvc3QoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhcnRQb3N0XztcclxuICAgIH1cclxuICAgIGdldEVuZFBvc3QoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZW5kUG9zdF87XHJcbiAgICB9XHJcbiAgICBtYXRjaGVzKG5vZGUpIHtcclxuICAgICAgICByZXR1cm4gKHRoaXMuaW5kZXhfLmNvbXBhcmUodGhpcy5nZXRTdGFydFBvc3QoKSwgbm9kZSkgPD0gMCAmJlxyXG4gICAgICAgICAgICB0aGlzLmluZGV4Xy5jb21wYXJlKG5vZGUsIHRoaXMuZ2V0RW5kUG9zdCgpKSA8PSAwKTtcclxuICAgIH1cclxuICAgIHVwZGF0ZUNoaWxkKHNuYXAsIGtleSwgbmV3Q2hpbGQsIGFmZmVjdGVkUGF0aCwgc291cmNlLCBvcHRDaGFuZ2VBY2N1bXVsYXRvcikge1xyXG4gICAgICAgIGlmICghdGhpcy5tYXRjaGVzKG5ldyBOYW1lZE5vZGUoa2V5LCBuZXdDaGlsZCkpKSB7XHJcbiAgICAgICAgICAgIG5ld0NoaWxkID0gQ2hpbGRyZW5Ob2RlLkVNUFRZX05PREU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLmluZGV4ZWRGaWx0ZXJfLnVwZGF0ZUNoaWxkKHNuYXAsIGtleSwgbmV3Q2hpbGQsIGFmZmVjdGVkUGF0aCwgc291cmNlLCBvcHRDaGFuZ2VBY2N1bXVsYXRvcik7XHJcbiAgICB9XHJcbiAgICB1cGRhdGVGdWxsTm9kZShvbGRTbmFwLCBuZXdTbmFwLCBvcHRDaGFuZ2VBY2N1bXVsYXRvcikge1xyXG4gICAgICAgIGlmIChuZXdTbmFwLmlzTGVhZk5vZGUoKSkge1xyXG4gICAgICAgICAgICAvLyBNYWtlIHN1cmUgd2UgaGF2ZSBhIGNoaWxkcmVuIG5vZGUgd2l0aCB0aGUgY29ycmVjdCBpbmRleCwgbm90IGEgbGVhZiBub2RlO1xyXG4gICAgICAgICAgICBuZXdTbmFwID0gQ2hpbGRyZW5Ob2RlLkVNUFRZX05PREU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBmaWx0ZXJlZCA9IG5ld1NuYXAud2l0aEluZGV4KHRoaXMuaW5kZXhfKTtcclxuICAgICAgICAvLyBEb24ndCBzdXBwb3J0IHByaW9yaXRpZXMgb24gcXVlcmllc1xyXG4gICAgICAgIGZpbHRlcmVkID0gZmlsdGVyZWQudXBkYXRlUHJpb3JpdHkoQ2hpbGRyZW5Ob2RlLkVNUFRZX05PREUpO1xyXG4gICAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xyXG4gICAgICAgIG5ld1NuYXAuZm9yRWFjaENoaWxkKFBSSU9SSVRZX0lOREVYLCAoa2V5LCBjaGlsZE5vZGUpID0+IHtcclxuICAgICAgICAgICAgaWYgKCFzZWxmLm1hdGNoZXMobmV3IE5hbWVkTm9kZShrZXksIGNoaWxkTm9kZSkpKSB7XHJcbiAgICAgICAgICAgICAgICBmaWx0ZXJlZCA9IGZpbHRlcmVkLnVwZGF0ZUltbWVkaWF0ZUNoaWxkKGtleSwgQ2hpbGRyZW5Ob2RlLkVNUFRZX05PREUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5kZXhlZEZpbHRlcl8udXBkYXRlRnVsbE5vZGUob2xkU25hcCwgZmlsdGVyZWQsIG9wdENoYW5nZUFjY3VtdWxhdG9yKTtcclxuICAgIH1cclxuICAgIHVwZGF0ZVByaW9yaXR5KG9sZFNuYXAsIG5ld1ByaW9yaXR5KSB7XHJcbiAgICAgICAgLy8gRG9uJ3Qgc3VwcG9ydCBwcmlvcml0aWVzIG9uIHF1ZXJpZXNcclxuICAgICAgICByZXR1cm4gb2xkU25hcDtcclxuICAgIH1cclxuICAgIGZpbHRlcnNOb2RlcygpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIGdldEluZGV4ZWRGaWx0ZXIoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5kZXhlZEZpbHRlcl87XHJcbiAgICB9XHJcbiAgICBnZXRJbmRleCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5pbmRleF87XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgZ2V0U3RhcnRQb3N0XyhwYXJhbXMpIHtcclxuICAgICAgICBpZiAocGFyYW1zLmhhc1N0YXJ0KCkpIHtcclxuICAgICAgICAgICAgY29uc3Qgc3RhcnROYW1lID0gcGFyYW1zLmdldEluZGV4U3RhcnROYW1lKCk7XHJcbiAgICAgICAgICAgIHJldHVybiBwYXJhbXMuZ2V0SW5kZXgoKS5tYWtlUG9zdChwYXJhbXMuZ2V0SW5kZXhTdGFydFZhbHVlKCksIHN0YXJ0TmFtZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gcGFyYW1zLmdldEluZGV4KCkubWluUG9zdCgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHN0YXRpYyBnZXRFbmRQb3N0XyhwYXJhbXMpIHtcclxuICAgICAgICBpZiAocGFyYW1zLmhhc0VuZCgpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGVuZE5hbWUgPSBwYXJhbXMuZ2V0SW5kZXhFbmROYW1lKCk7XHJcbiAgICAgICAgICAgIHJldHVybiBwYXJhbXMuZ2V0SW5kZXgoKS5tYWtlUG9zdChwYXJhbXMuZ2V0SW5kZXhFbmRWYWx1ZSgpLCBlbmROYW1lKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBwYXJhbXMuZ2V0SW5kZXgoKS5tYXhQb3N0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBBcHBsaWVzIGEgbGltaXQgYW5kIGEgcmFuZ2UgdG8gYSBub2RlIGFuZCB1c2VzIFJhbmdlZEZpbHRlciB0byBkbyB0aGUgaGVhdnkgbGlmdGluZyB3aGVyZSBwb3NzaWJsZVxyXG4gKi9cclxuY2xhc3MgTGltaXRlZEZpbHRlciB7XHJcbiAgICBjb25zdHJ1Y3RvcihwYXJhbXMpIHtcclxuICAgICAgICB0aGlzLnJhbmdlZEZpbHRlcl8gPSBuZXcgUmFuZ2VkRmlsdGVyKHBhcmFtcyk7XHJcbiAgICAgICAgdGhpcy5pbmRleF8gPSBwYXJhbXMuZ2V0SW5kZXgoKTtcclxuICAgICAgICB0aGlzLmxpbWl0XyA9IHBhcmFtcy5nZXRMaW1pdCgpO1xyXG4gICAgICAgIHRoaXMucmV2ZXJzZV8gPSAhcGFyYW1zLmlzVmlld0Zyb21MZWZ0KCk7XHJcbiAgICB9XHJcbiAgICB1cGRhdGVDaGlsZChzbmFwLCBrZXksIG5ld0NoaWxkLCBhZmZlY3RlZFBhdGgsIHNvdXJjZSwgb3B0Q2hhbmdlQWNjdW11bGF0b3IpIHtcclxuICAgICAgICBpZiAoIXRoaXMucmFuZ2VkRmlsdGVyXy5tYXRjaGVzKG5ldyBOYW1lZE5vZGUoa2V5LCBuZXdDaGlsZCkpKSB7XHJcbiAgICAgICAgICAgIG5ld0NoaWxkID0gQ2hpbGRyZW5Ob2RlLkVNUFRZX05PREU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzbmFwLmdldEltbWVkaWF0ZUNoaWxkKGtleSkuZXF1YWxzKG5ld0NoaWxkKSkge1xyXG4gICAgICAgICAgICAvLyBObyBjaGFuZ2VcclxuICAgICAgICAgICAgcmV0dXJuIHNuYXA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHNuYXAubnVtQ2hpbGRyZW4oKSA8IHRoaXMubGltaXRfKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJhbmdlZEZpbHRlcl9cclxuICAgICAgICAgICAgICAgIC5nZXRJbmRleGVkRmlsdGVyKClcclxuICAgICAgICAgICAgICAgIC51cGRhdGVDaGlsZChzbmFwLCBrZXksIG5ld0NoaWxkLCBhZmZlY3RlZFBhdGgsIHNvdXJjZSwgb3B0Q2hhbmdlQWNjdW11bGF0b3IpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZnVsbExpbWl0VXBkYXRlQ2hpbGRfKHNuYXAsIGtleSwgbmV3Q2hpbGQsIHNvdXJjZSwgb3B0Q2hhbmdlQWNjdW11bGF0b3IpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHVwZGF0ZUZ1bGxOb2RlKG9sZFNuYXAsIG5ld1NuYXAsIG9wdENoYW5nZUFjY3VtdWxhdG9yKSB7XHJcbiAgICAgICAgbGV0IGZpbHRlcmVkO1xyXG4gICAgICAgIGlmIChuZXdTbmFwLmlzTGVhZk5vZGUoKSB8fCBuZXdTbmFwLmlzRW1wdHkoKSkge1xyXG4gICAgICAgICAgICAvLyBNYWtlIHN1cmUgd2UgaGF2ZSBhIGNoaWxkcmVuIG5vZGUgd2l0aCB0aGUgY29ycmVjdCBpbmRleCwgbm90IGEgbGVhZiBub2RlO1xyXG4gICAgICAgICAgICBmaWx0ZXJlZCA9IENoaWxkcmVuTm9kZS5FTVBUWV9OT0RFLndpdGhJbmRleCh0aGlzLmluZGV4Xyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5saW1pdF8gKiAyIDwgbmV3U25hcC5udW1DaGlsZHJlbigpICYmXHJcbiAgICAgICAgICAgICAgICBuZXdTbmFwLmlzSW5kZXhlZCh0aGlzLmluZGV4XykpIHtcclxuICAgICAgICAgICAgICAgIC8vIEVhc2llciB0byBidWlsZCB1cCBhIHNuYXBzaG90LCBzaW5jZSB3aGF0IHdlJ3JlIGdpdmVuIGhhcyBtb3JlIHRoYW4gdHdpY2UgdGhlIGVsZW1lbnRzIHdlIHdhbnRcclxuICAgICAgICAgICAgICAgIGZpbHRlcmVkID0gQ2hpbGRyZW5Ob2RlLkVNUFRZX05PREUud2l0aEluZGV4KHRoaXMuaW5kZXhfKTtcclxuICAgICAgICAgICAgICAgIC8vIGFuY2hvciB0byB0aGUgc3RhcnRQb3N0LCBlbmRQb3N0LCBvciBsYXN0IGVsZW1lbnQgYXMgYXBwcm9wcmlhdGVcclxuICAgICAgICAgICAgICAgIGxldCBpdGVyYXRvcjtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnJldmVyc2VfKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaXRlcmF0b3IgPSBuZXdTbmFwLmdldFJldmVyc2VJdGVyYXRvckZyb20odGhpcy5yYW5nZWRGaWx0ZXJfLmdldEVuZFBvc3QoKSwgdGhpcy5pbmRleF8pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaXRlcmF0b3IgPSBuZXdTbmFwLmdldEl0ZXJhdG9yRnJvbSh0aGlzLnJhbmdlZEZpbHRlcl8uZ2V0U3RhcnRQb3N0KCksIHRoaXMuaW5kZXhfKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGxldCBjb3VudCA9IDA7XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAoaXRlcmF0b3IuaGFzTmV4dCgpICYmIGNvdW50IDwgdGhpcy5saW1pdF8pIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXh0ID0gaXRlcmF0b3IuZ2V0TmV4dCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBpblJhbmdlO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnJldmVyc2VfKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGluUmFuZ2UgPVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmRleF8uY29tcGFyZSh0aGlzLnJhbmdlZEZpbHRlcl8uZ2V0U3RhcnRQb3N0KCksIG5leHQpIDw9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpblJhbmdlID1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaW5kZXhfLmNvbXBhcmUobmV4dCwgdGhpcy5yYW5nZWRGaWx0ZXJfLmdldEVuZFBvc3QoKSkgPD0gMDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluUmFuZ2UpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmlsdGVyZWQgPSBmaWx0ZXJlZC51cGRhdGVJbW1lZGlhdGVDaGlsZChuZXh0Lm5hbWUsIG5leHQubm9kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50Kys7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiB3ZSBoYXZlIHJlYWNoZWQgdGhlIGVuZCBwb3N0LCB3ZSBjYW5ub3Qga2VlcCBhZGRpbmcgZWxlbW1lbnRzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIFRoZSBzbmFwIGNvbnRhaW5zIGxlc3MgdGhhbiB0d2ljZSB0aGUgbGltaXQuIEZhc3RlciB0byBkZWxldGUgZnJvbSB0aGUgc25hcCB0aGFuIGJ1aWxkIHVwIGEgbmV3IG9uZVxyXG4gICAgICAgICAgICAgICAgZmlsdGVyZWQgPSBuZXdTbmFwLndpdGhJbmRleCh0aGlzLmluZGV4Xyk7XHJcbiAgICAgICAgICAgICAgICAvLyBEb24ndCBzdXBwb3J0IHByaW9yaXRpZXMgb24gcXVlcmllc1xyXG4gICAgICAgICAgICAgICAgZmlsdGVyZWQgPSBmaWx0ZXJlZC51cGRhdGVQcmlvcml0eShDaGlsZHJlbk5vZGUuRU1QVFlfTk9ERSk7XHJcbiAgICAgICAgICAgICAgICBsZXQgc3RhcnRQb3N0O1xyXG4gICAgICAgICAgICAgICAgbGV0IGVuZFBvc3Q7XHJcbiAgICAgICAgICAgICAgICBsZXQgY21wO1xyXG4gICAgICAgICAgICAgICAgbGV0IGl0ZXJhdG9yO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucmV2ZXJzZV8pIHtcclxuICAgICAgICAgICAgICAgICAgICBpdGVyYXRvciA9IGZpbHRlcmVkLmdldFJldmVyc2VJdGVyYXRvcih0aGlzLmluZGV4Xyk7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRQb3N0ID0gdGhpcy5yYW5nZWRGaWx0ZXJfLmdldEVuZFBvc3QoKTtcclxuICAgICAgICAgICAgICAgICAgICBlbmRQb3N0ID0gdGhpcy5yYW5nZWRGaWx0ZXJfLmdldFN0YXJ0UG9zdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGluZGV4Q29tcGFyZSA9IHRoaXMuaW5kZXhfLmdldENvbXBhcmUoKTtcclxuICAgICAgICAgICAgICAgICAgICBjbXAgPSAoYSwgYikgPT4gaW5kZXhDb21wYXJlKGIsIGEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaXRlcmF0b3IgPSBmaWx0ZXJlZC5nZXRJdGVyYXRvcih0aGlzLmluZGV4Xyk7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRQb3N0ID0gdGhpcy5yYW5nZWRGaWx0ZXJfLmdldFN0YXJ0UG9zdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGVuZFBvc3QgPSB0aGlzLnJhbmdlZEZpbHRlcl8uZ2V0RW5kUG9zdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNtcCA9IHRoaXMuaW5kZXhfLmdldENvbXBhcmUoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGxldCBjb3VudCA9IDA7XHJcbiAgICAgICAgICAgICAgICBsZXQgZm91bmRTdGFydFBvc3QgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIHdoaWxlIChpdGVyYXRvci5oYXNOZXh0KCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXh0ID0gaXRlcmF0b3IuZ2V0TmV4dCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghZm91bmRTdGFydFBvc3QgJiYgY21wKHN0YXJ0UG9zdCwgbmV4dCkgPD0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzdGFydCBhZGRpbmdcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm91bmRTdGFydFBvc3QgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBpblJhbmdlID0gZm91bmRTdGFydFBvc3QgJiYgY291bnQgPCB0aGlzLmxpbWl0XyAmJiBjbXAobmV4dCwgZW5kUG9zdCkgPD0gMDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaW5SYW5nZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudCsrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmlsdGVyZWQgPSBmaWx0ZXJlZC51cGRhdGVJbW1lZGlhdGVDaGlsZChuZXh0Lm5hbWUsIENoaWxkcmVuTm9kZS5FTVBUWV9OT0RFKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucmFuZ2VkRmlsdGVyX1xyXG4gICAgICAgICAgICAuZ2V0SW5kZXhlZEZpbHRlcigpXHJcbiAgICAgICAgICAgIC51cGRhdGVGdWxsTm9kZShvbGRTbmFwLCBmaWx0ZXJlZCwgb3B0Q2hhbmdlQWNjdW11bGF0b3IpO1xyXG4gICAgfVxyXG4gICAgdXBkYXRlUHJpb3JpdHkob2xkU25hcCwgbmV3UHJpb3JpdHkpIHtcclxuICAgICAgICAvLyBEb24ndCBzdXBwb3J0IHByaW9yaXRpZXMgb24gcXVlcmllc1xyXG4gICAgICAgIHJldHVybiBvbGRTbmFwO1xyXG4gICAgfVxyXG4gICAgZmlsdGVyc05vZGVzKCkge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgZ2V0SW5kZXhlZEZpbHRlcigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5yYW5nZWRGaWx0ZXJfLmdldEluZGV4ZWRGaWx0ZXIoKTtcclxuICAgIH1cclxuICAgIGdldEluZGV4KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmluZGV4XztcclxuICAgIH1cclxuICAgIGZ1bGxMaW1pdFVwZGF0ZUNoaWxkXyhzbmFwLCBjaGlsZEtleSwgY2hpbGRTbmFwLCBzb3VyY2UsIGNoYW5nZUFjY3VtdWxhdG9yKSB7XHJcbiAgICAgICAgLy8gVE9ETzogcmVuYW1lIGFsbCBjYWNoZSBzdHVmZiBldGMgdG8gZ2VuZXJhbCBzbmFwIHRlcm1pbm9sb2d5XHJcbiAgICAgICAgbGV0IGNtcDtcclxuICAgICAgICBpZiAodGhpcy5yZXZlcnNlXykge1xyXG4gICAgICAgICAgICBjb25zdCBpbmRleENtcCA9IHRoaXMuaW5kZXhfLmdldENvbXBhcmUoKTtcclxuICAgICAgICAgICAgY21wID0gKGEsIGIpID0+IGluZGV4Q21wKGIsIGEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY21wID0gdGhpcy5pbmRleF8uZ2V0Q29tcGFyZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBvbGRFdmVudENhY2hlID0gc25hcDtcclxuICAgICAgICBhc3NlcnQob2xkRXZlbnRDYWNoZS5udW1DaGlsZHJlbigpID09PSB0aGlzLmxpbWl0XywgJycpO1xyXG4gICAgICAgIGNvbnN0IG5ld0NoaWxkTmFtZWROb2RlID0gbmV3IE5hbWVkTm9kZShjaGlsZEtleSwgY2hpbGRTbmFwKTtcclxuICAgICAgICBjb25zdCB3aW5kb3dCb3VuZGFyeSA9IHRoaXMucmV2ZXJzZV9cclxuICAgICAgICAgICAgPyBvbGRFdmVudENhY2hlLmdldEZpcnN0Q2hpbGQodGhpcy5pbmRleF8pXHJcbiAgICAgICAgICAgIDogb2xkRXZlbnRDYWNoZS5nZXRMYXN0Q2hpbGQodGhpcy5pbmRleF8pO1xyXG4gICAgICAgIGNvbnN0IGluUmFuZ2UgPSB0aGlzLnJhbmdlZEZpbHRlcl8ubWF0Y2hlcyhuZXdDaGlsZE5hbWVkTm9kZSk7XHJcbiAgICAgICAgaWYgKG9sZEV2ZW50Q2FjaGUuaGFzQ2hpbGQoY2hpbGRLZXkpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG9sZENoaWxkU25hcCA9IG9sZEV2ZW50Q2FjaGUuZ2V0SW1tZWRpYXRlQ2hpbGQoY2hpbGRLZXkpO1xyXG4gICAgICAgICAgICBsZXQgbmV4dENoaWxkID0gc291cmNlLmdldENoaWxkQWZ0ZXJDaGlsZCh0aGlzLmluZGV4Xywgd2luZG93Qm91bmRhcnksIHRoaXMucmV2ZXJzZV8pO1xyXG4gICAgICAgICAgICB3aGlsZSAobmV4dENoaWxkICE9IG51bGwgJiZcclxuICAgICAgICAgICAgICAgIChuZXh0Q2hpbGQubmFtZSA9PT0gY2hpbGRLZXkgfHwgb2xkRXZlbnRDYWNoZS5oYXNDaGlsZChuZXh0Q2hpbGQubmFtZSkpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBUaGVyZSBpcyBhIHdlaXJkIGVkZ2UgY2FzZSB3aGVyZSBhIG5vZGUgaXMgdXBkYXRlZCBhcyBwYXJ0IG9mIGEgbWVyZ2UgaW4gdGhlIHdyaXRlIHRyZWUsIGJ1dCBoYXNuJ3RcclxuICAgICAgICAgICAgICAgIC8vIGJlZW4gYXBwbGllZCB0byB0aGUgbGltaXRlZCBmaWx0ZXIgeWV0LiBJZ25vcmUgdGhpcyBuZXh0IGNoaWxkIHdoaWNoIHdpbGwgYmUgdXBkYXRlZCBsYXRlciBpblxyXG4gICAgICAgICAgICAgICAgLy8gdGhlIGxpbWl0ZWQgZmlsdGVyLi4uXHJcbiAgICAgICAgICAgICAgICBuZXh0Q2hpbGQgPSBzb3VyY2UuZ2V0Q2hpbGRBZnRlckNoaWxkKHRoaXMuaW5kZXhfLCBuZXh0Q2hpbGQsIHRoaXMucmV2ZXJzZV8pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IGNvbXBhcmVOZXh0ID0gbmV4dENoaWxkID09IG51bGwgPyAxIDogY21wKG5leHRDaGlsZCwgbmV3Q2hpbGROYW1lZE5vZGUpO1xyXG4gICAgICAgICAgICBjb25zdCByZW1haW5zSW5XaW5kb3cgPSBpblJhbmdlICYmICFjaGlsZFNuYXAuaXNFbXB0eSgpICYmIGNvbXBhcmVOZXh0ID49IDA7XHJcbiAgICAgICAgICAgIGlmIChyZW1haW5zSW5XaW5kb3cpIHtcclxuICAgICAgICAgICAgICAgIGlmIChjaGFuZ2VBY2N1bXVsYXRvciAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlQWNjdW11bGF0b3IudHJhY2tDaGlsZENoYW5nZShjaGFuZ2VDaGlsZENoYW5nZWQoY2hpbGRLZXksIGNoaWxkU25hcCwgb2xkQ2hpbGRTbmFwKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gb2xkRXZlbnRDYWNoZS51cGRhdGVJbW1lZGlhdGVDaGlsZChjaGlsZEtleSwgY2hpbGRTbmFwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmIChjaGFuZ2VBY2N1bXVsYXRvciAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlQWNjdW11bGF0b3IudHJhY2tDaGlsZENoYW5nZShjaGFuZ2VDaGlsZFJlbW92ZWQoY2hpbGRLZXksIG9sZENoaWxkU25hcCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29uc3QgbmV3RXZlbnRDYWNoZSA9IG9sZEV2ZW50Q2FjaGUudXBkYXRlSW1tZWRpYXRlQ2hpbGQoY2hpbGRLZXksIENoaWxkcmVuTm9kZS5FTVBUWV9OT0RFKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG5leHRDaGlsZEluUmFuZ2UgPSBuZXh0Q2hpbGQgIT0gbnVsbCAmJiB0aGlzLnJhbmdlZEZpbHRlcl8ubWF0Y2hlcyhuZXh0Q2hpbGQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKG5leHRDaGlsZEluUmFuZ2UpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY2hhbmdlQWNjdW11bGF0b3IgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFuZ2VBY2N1bXVsYXRvci50cmFja0NoaWxkQ2hhbmdlKGNoYW5nZUNoaWxkQWRkZWQobmV4dENoaWxkLm5hbWUsIG5leHRDaGlsZC5ub2RlKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXdFdmVudENhY2hlLnVwZGF0ZUltbWVkaWF0ZUNoaWxkKG5leHRDaGlsZC5uYW1lLCBuZXh0Q2hpbGQubm9kZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3RXZlbnRDYWNoZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChjaGlsZFNuYXAuaXNFbXB0eSgpKSB7XHJcbiAgICAgICAgICAgIC8vIHdlJ3JlIGRlbGV0aW5nIGEgbm9kZSwgYnV0IGl0IHdhcyBub3QgaW4gdGhlIHdpbmRvdywgc28gaWdub3JlIGl0XHJcbiAgICAgICAgICAgIHJldHVybiBzbmFwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChpblJhbmdlKSB7XHJcbiAgICAgICAgICAgIGlmIChjbXAod2luZG93Qm91bmRhcnksIG5ld0NoaWxkTmFtZWROb2RlKSA+PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY2hhbmdlQWNjdW11bGF0b3IgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZUFjY3VtdWxhdG9yLnRyYWNrQ2hpbGRDaGFuZ2UoY2hhbmdlQ2hpbGRSZW1vdmVkKHdpbmRvd0JvdW5kYXJ5Lm5hbWUsIHdpbmRvd0JvdW5kYXJ5Lm5vZGUpKTtcclxuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VBY2N1bXVsYXRvci50cmFja0NoaWxkQ2hhbmdlKGNoYW5nZUNoaWxkQWRkZWQoY2hpbGRLZXksIGNoaWxkU25hcCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG9sZEV2ZW50Q2FjaGVcclxuICAgICAgICAgICAgICAgICAgICAudXBkYXRlSW1tZWRpYXRlQ2hpbGQoY2hpbGRLZXksIGNoaWxkU25hcClcclxuICAgICAgICAgICAgICAgICAgICAudXBkYXRlSW1tZWRpYXRlQ2hpbGQod2luZG93Qm91bmRhcnkubmFtZSwgQ2hpbGRyZW5Ob2RlLkVNUFRZX05PREUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNuYXA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzbmFwO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogVGhpcyBjbGFzcyBpcyBhbiBpbW11dGFibGUtZnJvbS10aGUtcHVibGljLWFwaSBzdHJ1Y3QgY29udGFpbmluZyBhIHNldCBvZiBxdWVyeSBwYXJhbWV0ZXJzIGRlZmluaW5nIGFcclxuICogcmFuZ2UgdG8gYmUgcmV0dXJuZWQgZm9yIGEgcGFydGljdWxhciBsb2NhdGlvbi4gSXQgaXMgYXNzdW1lZCB0aGF0IHZhbGlkYXRpb24gb2YgcGFyYW1ldGVycyBpcyBkb25lIGF0IHRoZVxyXG4gKiB1c2VyLWZhY2luZyBBUEkgbGV2ZWwsIHNvIGl0IGlzIG5vdCBkb25lIGhlcmUuXHJcbiAqXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cclxuY2xhc3MgUXVlcnlQYXJhbXMge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5saW1pdFNldF8gPSBmYWxzZTtcclxuICAgICAgICB0aGlzLnN0YXJ0U2V0XyA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuc3RhcnROYW1lU2V0XyA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuc3RhcnRBZnRlclNldF8gPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmVuZFNldF8gPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmVuZE5hbWVTZXRfID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5lbmRCZWZvcmVTZXRfID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5saW1pdF8gPSAwO1xyXG4gICAgICAgIHRoaXMudmlld0Zyb21fID0gJyc7XHJcbiAgICAgICAgdGhpcy5pbmRleFN0YXJ0VmFsdWVfID0gbnVsbDtcclxuICAgICAgICB0aGlzLmluZGV4U3RhcnROYW1lXyA9ICcnO1xyXG4gICAgICAgIHRoaXMuaW5kZXhFbmRWYWx1ZV8gPSBudWxsO1xyXG4gICAgICAgIHRoaXMuaW5kZXhFbmROYW1lXyA9ICcnO1xyXG4gICAgICAgIHRoaXMuaW5kZXhfID0gUFJJT1JJVFlfSU5ERVg7XHJcbiAgICB9XHJcbiAgICBoYXNTdGFydCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zdGFydFNldF87XHJcbiAgICB9XHJcbiAgICBoYXNTdGFydEFmdGVyKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnN0YXJ0QWZ0ZXJTZXRfO1xyXG4gICAgfVxyXG4gICAgaGFzRW5kQmVmb3JlKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmVuZEJlZm9yZVNldF87XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm5zIFRydWUgaWYgaXQgd291bGQgcmV0dXJuIGZyb20gbGVmdC5cclxuICAgICAqL1xyXG4gICAgaXNWaWV3RnJvbUxlZnQoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMudmlld0Zyb21fID09PSAnJykge1xyXG4gICAgICAgICAgICAvLyBsaW1pdCgpLCByYXRoZXIgdGhhbiBsaW1pdFRvRmlyc3Qgb3IgbGltaXRUb0xhc3Qgd2FzIGNhbGxlZC5cclxuICAgICAgICAgICAgLy8gVGhpcyBtZWFucyB0aGF0IG9ubHkgb25lIG9mIHN0YXJ0U2V0XyBhbmQgZW5kU2V0XyBpcyB0cnVlLiBVc2UgdGhlbVxyXG4gICAgICAgICAgICAvLyB0byBjYWxjdWxhdGUgd2hpY2ggc2lkZSBvZiB0aGUgdmlldyB0byBhbmNob3IgdG8uIElmIG5laXRoZXIgaXMgc2V0LFxyXG4gICAgICAgICAgICAvLyBhbmNob3IgdG8gdGhlIGVuZC5cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RhcnRTZXRfO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmlld0Zyb21fID09PSBcImxcIiAvKiBWSUVXX0ZST01fTEVGVCAqLztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIE9ubHkgdmFsaWQgdG8gY2FsbCBpZiBoYXNTdGFydCgpIHJldHVybnMgdHJ1ZVxyXG4gICAgICovXHJcbiAgICBnZXRJbmRleFN0YXJ0VmFsdWUoKSB7XHJcbiAgICAgICAgYXNzZXJ0KHRoaXMuc3RhcnRTZXRfLCAnT25seSB2YWxpZCBpZiBzdGFydCBoYXMgYmVlbiBzZXQnKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5pbmRleFN0YXJ0VmFsdWVfO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBPbmx5IHZhbGlkIHRvIGNhbGwgaWYgaGFzU3RhcnQoKSByZXR1cm5zIHRydWUuXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBzdGFydGluZyBrZXkgbmFtZSBmb3IgdGhlIHJhbmdlIGRlZmluZWQgYnkgdGhlc2UgcXVlcnkgcGFyYW1ldGVyc1xyXG4gICAgICovXHJcbiAgICBnZXRJbmRleFN0YXJ0TmFtZSgpIHtcclxuICAgICAgICBhc3NlcnQodGhpcy5zdGFydFNldF8sICdPbmx5IHZhbGlkIGlmIHN0YXJ0IGhhcyBiZWVuIHNldCcpO1xyXG4gICAgICAgIGlmICh0aGlzLnN0YXJ0TmFtZVNldF8pIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW5kZXhTdGFydE5hbWVfO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIE1JTl9OQU1FO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGhhc0VuZCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5lbmRTZXRfO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBPbmx5IHZhbGlkIHRvIGNhbGwgaWYgaGFzRW5kKCkgcmV0dXJucyB0cnVlLlxyXG4gICAgICovXHJcbiAgICBnZXRJbmRleEVuZFZhbHVlKCkge1xyXG4gICAgICAgIGFzc2VydCh0aGlzLmVuZFNldF8sICdPbmx5IHZhbGlkIGlmIGVuZCBoYXMgYmVlbiBzZXQnKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5pbmRleEVuZFZhbHVlXztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogT25seSB2YWxpZCB0byBjYWxsIGlmIGhhc0VuZCgpIHJldHVybnMgdHJ1ZS5cclxuICAgICAqIFJldHVybnMgdGhlIGVuZCBrZXkgbmFtZSBmb3IgdGhlIHJhbmdlIGRlZmluZWQgYnkgdGhlc2UgcXVlcnkgcGFyYW1ldGVyc1xyXG4gICAgICovXHJcbiAgICBnZXRJbmRleEVuZE5hbWUoKSB7XHJcbiAgICAgICAgYXNzZXJ0KHRoaXMuZW5kU2V0XywgJ09ubHkgdmFsaWQgaWYgZW5kIGhhcyBiZWVuIHNldCcpO1xyXG4gICAgICAgIGlmICh0aGlzLmVuZE5hbWVTZXRfKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmluZGV4RW5kTmFtZV87XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gTUFYX05BTUU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaGFzTGltaXQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubGltaXRTZXRfO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJucyBUcnVlIGlmIGEgbGltaXQgaGFzIGJlZW4gc2V0IGFuZCBpdCBoYXMgYmVlbiBleHBsaWNpdGx5IGFuY2hvcmVkXHJcbiAgICAgKi9cclxuICAgIGhhc0FuY2hvcmVkTGltaXQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubGltaXRTZXRfICYmIHRoaXMudmlld0Zyb21fICE9PSAnJztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogT25seSB2YWxpZCB0byBjYWxsIGlmIGhhc0xpbWl0KCkgcmV0dXJucyB0cnVlXHJcbiAgICAgKi9cclxuICAgIGdldExpbWl0KCkge1xyXG4gICAgICAgIGFzc2VydCh0aGlzLmxpbWl0U2V0XywgJ09ubHkgdmFsaWQgaWYgbGltaXQgaGFzIGJlZW4gc2V0Jyk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubGltaXRfO1xyXG4gICAgfVxyXG4gICAgZ2V0SW5kZXgoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5kZXhfO1xyXG4gICAgfVxyXG4gICAgbG9hZHNBbGxEYXRhKCkge1xyXG4gICAgICAgIHJldHVybiAhKHRoaXMuc3RhcnRTZXRfIHx8IHRoaXMuZW5kU2V0XyB8fCB0aGlzLmxpbWl0U2V0Xyk7XHJcbiAgICB9XHJcbiAgICBpc0RlZmF1bHQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubG9hZHNBbGxEYXRhKCkgJiYgdGhpcy5pbmRleF8gPT09IFBSSU9SSVRZX0lOREVYO1xyXG4gICAgfVxyXG4gICAgY29weSgpIHtcclxuICAgICAgICBjb25zdCBjb3B5ID0gbmV3IFF1ZXJ5UGFyYW1zKCk7XHJcbiAgICAgICAgY29weS5saW1pdFNldF8gPSB0aGlzLmxpbWl0U2V0XztcclxuICAgICAgICBjb3B5LmxpbWl0XyA9IHRoaXMubGltaXRfO1xyXG4gICAgICAgIGNvcHkuc3RhcnRTZXRfID0gdGhpcy5zdGFydFNldF87XHJcbiAgICAgICAgY29weS5pbmRleFN0YXJ0VmFsdWVfID0gdGhpcy5pbmRleFN0YXJ0VmFsdWVfO1xyXG4gICAgICAgIGNvcHkuc3RhcnROYW1lU2V0XyA9IHRoaXMuc3RhcnROYW1lU2V0XztcclxuICAgICAgICBjb3B5LmluZGV4U3RhcnROYW1lXyA9IHRoaXMuaW5kZXhTdGFydE5hbWVfO1xyXG4gICAgICAgIGNvcHkuZW5kU2V0XyA9IHRoaXMuZW5kU2V0XztcclxuICAgICAgICBjb3B5LmluZGV4RW5kVmFsdWVfID0gdGhpcy5pbmRleEVuZFZhbHVlXztcclxuICAgICAgICBjb3B5LmVuZE5hbWVTZXRfID0gdGhpcy5lbmROYW1lU2V0XztcclxuICAgICAgICBjb3B5LmluZGV4RW5kTmFtZV8gPSB0aGlzLmluZGV4RW5kTmFtZV87XHJcbiAgICAgICAgY29weS5pbmRleF8gPSB0aGlzLmluZGV4XztcclxuICAgICAgICBjb3B5LnZpZXdGcm9tXyA9IHRoaXMudmlld0Zyb21fO1xyXG4gICAgICAgIHJldHVybiBjb3B5O1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHF1ZXJ5UGFyYW1zR2V0Tm9kZUZpbHRlcihxdWVyeVBhcmFtcykge1xyXG4gICAgaWYgKHF1ZXJ5UGFyYW1zLmxvYWRzQWxsRGF0YSgpKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBJbmRleGVkRmlsdGVyKHF1ZXJ5UGFyYW1zLmdldEluZGV4KCkpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAocXVlcnlQYXJhbXMuaGFzTGltaXQoKSkge1xyXG4gICAgICAgIHJldHVybiBuZXcgTGltaXRlZEZpbHRlcihxdWVyeVBhcmFtcyk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gbmV3IFJhbmdlZEZpbHRlcihxdWVyeVBhcmFtcyk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gcXVlcnlQYXJhbXNMaW1pdFRvRmlyc3QocXVlcnlQYXJhbXMsIG5ld0xpbWl0KSB7XHJcbiAgICBjb25zdCBuZXdQYXJhbXMgPSBxdWVyeVBhcmFtcy5jb3B5KCk7XHJcbiAgICBuZXdQYXJhbXMubGltaXRTZXRfID0gdHJ1ZTtcclxuICAgIG5ld1BhcmFtcy5saW1pdF8gPSBuZXdMaW1pdDtcclxuICAgIG5ld1BhcmFtcy52aWV3RnJvbV8gPSBcImxcIiAvKiBWSUVXX0ZST01fTEVGVCAqLztcclxuICAgIHJldHVybiBuZXdQYXJhbXM7XHJcbn1cclxuZnVuY3Rpb24gcXVlcnlQYXJhbXNMaW1pdFRvTGFzdChxdWVyeVBhcmFtcywgbmV3TGltaXQpIHtcclxuICAgIGNvbnN0IG5ld1BhcmFtcyA9IHF1ZXJ5UGFyYW1zLmNvcHkoKTtcclxuICAgIG5ld1BhcmFtcy5saW1pdFNldF8gPSB0cnVlO1xyXG4gICAgbmV3UGFyYW1zLmxpbWl0XyA9IG5ld0xpbWl0O1xyXG4gICAgbmV3UGFyYW1zLnZpZXdGcm9tXyA9IFwiclwiIC8qIFZJRVdfRlJPTV9SSUdIVCAqLztcclxuICAgIHJldHVybiBuZXdQYXJhbXM7XHJcbn1cclxuZnVuY3Rpb24gcXVlcnlQYXJhbXNTdGFydEF0KHF1ZXJ5UGFyYW1zLCBpbmRleFZhbHVlLCBrZXkpIHtcclxuICAgIGNvbnN0IG5ld1BhcmFtcyA9IHF1ZXJ5UGFyYW1zLmNvcHkoKTtcclxuICAgIG5ld1BhcmFtcy5zdGFydFNldF8gPSB0cnVlO1xyXG4gICAgaWYgKGluZGV4VmFsdWUgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIGluZGV4VmFsdWUgPSBudWxsO1xyXG4gICAgfVxyXG4gICAgbmV3UGFyYW1zLmluZGV4U3RhcnRWYWx1ZV8gPSBpbmRleFZhbHVlO1xyXG4gICAgaWYgKGtleSAhPSBudWxsKSB7XHJcbiAgICAgICAgbmV3UGFyYW1zLnN0YXJ0TmFtZVNldF8gPSB0cnVlO1xyXG4gICAgICAgIG5ld1BhcmFtcy5pbmRleFN0YXJ0TmFtZV8gPSBrZXk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBuZXdQYXJhbXMuc3RhcnROYW1lU2V0XyA9IGZhbHNlO1xyXG4gICAgICAgIG5ld1BhcmFtcy5pbmRleFN0YXJ0TmFtZV8gPSAnJztcclxuICAgIH1cclxuICAgIHJldHVybiBuZXdQYXJhbXM7XHJcbn1cclxuZnVuY3Rpb24gcXVlcnlQYXJhbXNTdGFydEFmdGVyKHF1ZXJ5UGFyYW1zLCBpbmRleFZhbHVlLCBrZXkpIHtcclxuICAgIGxldCBwYXJhbXM7XHJcbiAgICBpZiAocXVlcnlQYXJhbXMuaW5kZXhfID09PSBLRVlfSU5ERVgpIHtcclxuICAgICAgICBpZiAodHlwZW9mIGluZGV4VmFsdWUgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgIGluZGV4VmFsdWUgPSBzdWNjZXNzb3IoaW5kZXhWYWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHBhcmFtcyA9IHF1ZXJ5UGFyYW1zU3RhcnRBdChxdWVyeVBhcmFtcywgaW5kZXhWYWx1ZSwga2V5KTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGxldCBjaGlsZEtleTtcclxuICAgICAgICBpZiAoa2V5ID09IG51bGwpIHtcclxuICAgICAgICAgICAgY2hpbGRLZXkgPSBNQVhfTkFNRTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNoaWxkS2V5ID0gc3VjY2Vzc29yKGtleSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHBhcmFtcyA9IHF1ZXJ5UGFyYW1zU3RhcnRBdChxdWVyeVBhcmFtcywgaW5kZXhWYWx1ZSwgY2hpbGRLZXkpO1xyXG4gICAgfVxyXG4gICAgcGFyYW1zLnN0YXJ0QWZ0ZXJTZXRfID0gdHJ1ZTtcclxuICAgIHJldHVybiBwYXJhbXM7XHJcbn1cclxuZnVuY3Rpb24gcXVlcnlQYXJhbXNFbmRBdChxdWVyeVBhcmFtcywgaW5kZXhWYWx1ZSwga2V5KSB7XHJcbiAgICBjb25zdCBuZXdQYXJhbXMgPSBxdWVyeVBhcmFtcy5jb3B5KCk7XHJcbiAgICBuZXdQYXJhbXMuZW5kU2V0XyA9IHRydWU7XHJcbiAgICBpZiAoaW5kZXhWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgaW5kZXhWYWx1ZSA9IG51bGw7XHJcbiAgICB9XHJcbiAgICBuZXdQYXJhbXMuaW5kZXhFbmRWYWx1ZV8gPSBpbmRleFZhbHVlO1xyXG4gICAgaWYgKGtleSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgbmV3UGFyYW1zLmVuZE5hbWVTZXRfID0gdHJ1ZTtcclxuICAgICAgICBuZXdQYXJhbXMuaW5kZXhFbmROYW1lXyA9IGtleTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIG5ld1BhcmFtcy5lbmROYW1lU2V0XyA9IGZhbHNlO1xyXG4gICAgICAgIG5ld1BhcmFtcy5pbmRleEVuZE5hbWVfID0gJyc7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbmV3UGFyYW1zO1xyXG59XHJcbmZ1bmN0aW9uIHF1ZXJ5UGFyYW1zRW5kQmVmb3JlKHF1ZXJ5UGFyYW1zLCBpbmRleFZhbHVlLCBrZXkpIHtcclxuICAgIGxldCBjaGlsZEtleTtcclxuICAgIGxldCBwYXJhbXM7XHJcbiAgICBpZiAocXVlcnlQYXJhbXMuaW5kZXhfID09PSBLRVlfSU5ERVgpIHtcclxuICAgICAgICBpZiAodHlwZW9mIGluZGV4VmFsdWUgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgIGluZGV4VmFsdWUgPSBwcmVkZWNlc3NvcihpbmRleFZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcGFyYW1zID0gcXVlcnlQYXJhbXNFbmRBdChxdWVyeVBhcmFtcywgaW5kZXhWYWx1ZSwga2V5KTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGlmIChrZXkgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBjaGlsZEtleSA9IE1JTl9OQU1FO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY2hpbGRLZXkgPSBwcmVkZWNlc3NvcihrZXkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBwYXJhbXMgPSBxdWVyeVBhcmFtc0VuZEF0KHF1ZXJ5UGFyYW1zLCBpbmRleFZhbHVlLCBjaGlsZEtleSk7XHJcbiAgICB9XHJcbiAgICBwYXJhbXMuZW5kQmVmb3JlU2V0XyA9IHRydWU7XHJcbiAgICByZXR1cm4gcGFyYW1zO1xyXG59XHJcbmZ1bmN0aW9uIHF1ZXJ5UGFyYW1zT3JkZXJCeShxdWVyeVBhcmFtcywgaW5kZXgpIHtcclxuICAgIGNvbnN0IG5ld1BhcmFtcyA9IHF1ZXJ5UGFyYW1zLmNvcHkoKTtcclxuICAgIG5ld1BhcmFtcy5pbmRleF8gPSBpbmRleDtcclxuICAgIHJldHVybiBuZXdQYXJhbXM7XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybnMgYSBzZXQgb2YgUkVTVCBxdWVyeSBzdHJpbmcgcGFyYW1ldGVycyByZXByZXNlbnRpbmcgdGhpcyBxdWVyeS5cclxuICpcclxuICogQHJldHVybnMgcXVlcnkgc3RyaW5nIHBhcmFtZXRlcnNcclxuICovXHJcbmZ1bmN0aW9uIHF1ZXJ5UGFyYW1zVG9SZXN0UXVlcnlTdHJpbmdQYXJhbWV0ZXJzKHF1ZXJ5UGFyYW1zKSB7XHJcbiAgICBjb25zdCBxcyA9IHt9O1xyXG4gICAgaWYgKHF1ZXJ5UGFyYW1zLmlzRGVmYXVsdCgpKSB7XHJcbiAgICAgICAgcmV0dXJuIHFzO1xyXG4gICAgfVxyXG4gICAgbGV0IG9yZGVyQnk7XHJcbiAgICBpZiAocXVlcnlQYXJhbXMuaW5kZXhfID09PSBQUklPUklUWV9JTkRFWCkge1xyXG4gICAgICAgIG9yZGVyQnkgPSBcIiRwcmlvcml0eVwiIC8qIFBSSU9SSVRZX0lOREVYICovO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAocXVlcnlQYXJhbXMuaW5kZXhfID09PSBWQUxVRV9JTkRFWCkge1xyXG4gICAgICAgIG9yZGVyQnkgPSBcIiR2YWx1ZVwiIC8qIFZBTFVFX0lOREVYICovO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAocXVlcnlQYXJhbXMuaW5kZXhfID09PSBLRVlfSU5ERVgpIHtcclxuICAgICAgICBvcmRlckJ5ID0gXCIka2V5XCIgLyogS0VZX0lOREVYICovO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgYXNzZXJ0KHF1ZXJ5UGFyYW1zLmluZGV4XyBpbnN0YW5jZW9mIFBhdGhJbmRleCwgJ1VucmVjb2duaXplZCBpbmRleCB0eXBlIScpO1xyXG4gICAgICAgIG9yZGVyQnkgPSBxdWVyeVBhcmFtcy5pbmRleF8udG9TdHJpbmcoKTtcclxuICAgIH1cclxuICAgIHFzW1wib3JkZXJCeVwiIC8qIE9SREVSX0JZICovXSA9IHN0cmluZ2lmeShvcmRlckJ5KTtcclxuICAgIGlmIChxdWVyeVBhcmFtcy5zdGFydFNldF8pIHtcclxuICAgICAgICBxc1tcInN0YXJ0QXRcIiAvKiBTVEFSVF9BVCAqL10gPSBzdHJpbmdpZnkocXVlcnlQYXJhbXMuaW5kZXhTdGFydFZhbHVlXyk7XHJcbiAgICAgICAgaWYgKHF1ZXJ5UGFyYW1zLnN0YXJ0TmFtZVNldF8pIHtcclxuICAgICAgICAgICAgcXNbXCJzdGFydEF0XCIgLyogU1RBUlRfQVQgKi9dICs9XHJcbiAgICAgICAgICAgICAgICAnLCcgKyBzdHJpbmdpZnkocXVlcnlQYXJhbXMuaW5kZXhTdGFydE5hbWVfKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAocXVlcnlQYXJhbXMuZW5kU2V0Xykge1xyXG4gICAgICAgIHFzW1wiZW5kQXRcIiAvKiBFTkRfQVQgKi9dID0gc3RyaW5naWZ5KHF1ZXJ5UGFyYW1zLmluZGV4RW5kVmFsdWVfKTtcclxuICAgICAgICBpZiAocXVlcnlQYXJhbXMuZW5kTmFtZVNldF8pIHtcclxuICAgICAgICAgICAgcXNbXCJlbmRBdFwiIC8qIEVORF9BVCAqL10gKz1cclxuICAgICAgICAgICAgICAgICcsJyArIHN0cmluZ2lmeShxdWVyeVBhcmFtcy5pbmRleEVuZE5hbWVfKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAocXVlcnlQYXJhbXMubGltaXRTZXRfKSB7XHJcbiAgICAgICAgaWYgKHF1ZXJ5UGFyYW1zLmlzVmlld0Zyb21MZWZ0KCkpIHtcclxuICAgICAgICAgICAgcXNbXCJsaW1pdFRvRmlyc3RcIiAvKiBMSU1JVF9UT19GSVJTVCAqL10gPSBxdWVyeVBhcmFtcy5saW1pdF87XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBxc1tcImxpbWl0VG9MYXN0XCIgLyogTElNSVRfVE9fTEFTVCAqL10gPSBxdWVyeVBhcmFtcy5saW1pdF87XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHFzO1xyXG59XHJcbmZ1bmN0aW9uIHF1ZXJ5UGFyYW1zR2V0UXVlcnlPYmplY3QocXVlcnlQYXJhbXMpIHtcclxuICAgIGNvbnN0IG9iaiA9IHt9O1xyXG4gICAgaWYgKHF1ZXJ5UGFyYW1zLnN0YXJ0U2V0Xykge1xyXG4gICAgICAgIG9ialtcInNwXCIgLyogSU5ERVhfU1RBUlRfVkFMVUUgKi9dID1cclxuICAgICAgICAgICAgcXVlcnlQYXJhbXMuaW5kZXhTdGFydFZhbHVlXztcclxuICAgICAgICBpZiAocXVlcnlQYXJhbXMuc3RhcnROYW1lU2V0Xykge1xyXG4gICAgICAgICAgICBvYmpbXCJzblwiIC8qIElOREVYX1NUQVJUX05BTUUgKi9dID1cclxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zLmluZGV4U3RhcnROYW1lXztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAocXVlcnlQYXJhbXMuZW5kU2V0Xykge1xyXG4gICAgICAgIG9ialtcImVwXCIgLyogSU5ERVhfRU5EX1ZBTFVFICovXSA9IHF1ZXJ5UGFyYW1zLmluZGV4RW5kVmFsdWVfO1xyXG4gICAgICAgIGlmIChxdWVyeVBhcmFtcy5lbmROYW1lU2V0Xykge1xyXG4gICAgICAgICAgICBvYmpbXCJlblwiIC8qIElOREVYX0VORF9OQU1FICovXSA9IHF1ZXJ5UGFyYW1zLmluZGV4RW5kTmFtZV87XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKHF1ZXJ5UGFyYW1zLmxpbWl0U2V0Xykge1xyXG4gICAgICAgIG9ialtcImxcIiAvKiBMSU1JVCAqL10gPSBxdWVyeVBhcmFtcy5saW1pdF87XHJcbiAgICAgICAgbGV0IHZpZXdGcm9tID0gcXVlcnlQYXJhbXMudmlld0Zyb21fO1xyXG4gICAgICAgIGlmICh2aWV3RnJvbSA9PT0gJycpIHtcclxuICAgICAgICAgICAgaWYgKHF1ZXJ5UGFyYW1zLmlzVmlld0Zyb21MZWZ0KCkpIHtcclxuICAgICAgICAgICAgICAgIHZpZXdGcm9tID0gXCJsXCIgLyogVklFV19GUk9NX0xFRlQgKi87XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB2aWV3RnJvbSA9IFwiclwiIC8qIFZJRVdfRlJPTV9SSUdIVCAqLztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBvYmpbXCJ2ZlwiIC8qIFZJRVdfRlJPTSAqL10gPSB2aWV3RnJvbTtcclxuICAgIH1cclxuICAgIC8vIEZvciBub3csIHByaW9yaXR5IGluZGV4IGlzIHRoZSBkZWZhdWx0LCBzbyB3ZSBvbmx5IHNwZWNpZnkgaWYgaXQncyBzb21lIG90aGVyIGluZGV4XHJcbiAgICBpZiAocXVlcnlQYXJhbXMuaW5kZXhfICE9PSBQUklPUklUWV9JTkRFWCkge1xyXG4gICAgICAgIG9ialtcImlcIiAvKiBJTkRFWCAqL10gPSBxdWVyeVBhcmFtcy5pbmRleF8udG9TdHJpbmcoKTtcclxuICAgIH1cclxuICAgIHJldHVybiBvYmo7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIEFuIGltcGxlbWVudGF0aW9uIG9mIFNlcnZlckFjdGlvbnMgdGhhdCBjb21tdW5pY2F0ZXMgd2l0aCB0aGUgc2VydmVyIHZpYSBSRVNUIHJlcXVlc3RzLlxyXG4gKiBUaGlzIGlzIG1vc3RseSB1c2VmdWwgZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBjcmF3bGVycywgd2hlcmUgd2UgZG9uJ3Qgd2FudCB0byBzcGluIHVwIGEgZnVsbFxyXG4gKiBwZXJzaXN0ZW50IGNvbm5lY3Rpb24gKHVzaW5nIFdlYlNvY2tldHMgb3IgbG9uZy1wb2xsaW5nKVxyXG4gKi9cclxuY2xhc3MgUmVhZG9ubHlSZXN0Q2xpZW50IGV4dGVuZHMgU2VydmVyQWN0aW9ucyB7XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSByZXBvSW5mb18gLSBEYXRhIGFib3V0IHRoZSBuYW1lc3BhY2Ugd2UgYXJlIGNvbm5lY3RpbmcgdG9cclxuICAgICAqIEBwYXJhbSBvbkRhdGFVcGRhdGVfIC0gQSBjYWxsYmFjayBmb3IgbmV3IGRhdGEgZnJvbSB0aGUgc2VydmVyXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKHJlcG9JbmZvXywgb25EYXRhVXBkYXRlXywgYXV0aFRva2VuUHJvdmlkZXJfLCBhcHBDaGVja1Rva2VuUHJvdmlkZXJfKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLnJlcG9JbmZvXyA9IHJlcG9JbmZvXztcclxuICAgICAgICB0aGlzLm9uRGF0YVVwZGF0ZV8gPSBvbkRhdGFVcGRhdGVfO1xyXG4gICAgICAgIHRoaXMuYXV0aFRva2VuUHJvdmlkZXJfID0gYXV0aFRva2VuUHJvdmlkZXJfO1xyXG4gICAgICAgIHRoaXMuYXBwQ2hlY2tUb2tlblByb3ZpZGVyXyA9IGFwcENoZWNrVG9rZW5Qcm92aWRlcl87XHJcbiAgICAgICAgLyoqIEBwcml2YXRlIHtmdW5jdGlvbiguLi5bKl0pfSAqL1xyXG4gICAgICAgIHRoaXMubG9nXyA9IGxvZ1dyYXBwZXIoJ3A6cmVzdDonKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBXZSBkb24ndCBhY3R1YWxseSBuZWVkIHRvIHRyYWNrIGxpc3RlbnMsIGV4Y2VwdCB0byBwcmV2ZW50IHVzIGNhbGxpbmcgYW4gb25Db21wbGV0ZSBmb3IgYSBsaXN0ZW5cclxuICAgICAgICAgKiB0aGF0J3MgYmVlbiByZW1vdmVkLiA6LS9cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmxpc3RlbnNfID0ge307XHJcbiAgICB9XHJcbiAgICByZXBvcnRTdGF0cyhzdGF0cykge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTWV0aG9kIG5vdCBpbXBsZW1lbnRlZC4nKTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBnZXRMaXN0ZW5JZF8ocXVlcnksIHRhZykge1xyXG4gICAgICAgIGlmICh0YWcgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gJ3RhZyQnICsgdGFnO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgYXNzZXJ0KHF1ZXJ5Ll9xdWVyeVBhcmFtcy5pc0RlZmF1bHQoKSwgXCJzaG91bGQgaGF2ZSBhIHRhZyBpZiBpdCdzIG5vdCBhIGRlZmF1bHQgcXVlcnkuXCIpO1xyXG4gICAgICAgICAgICByZXR1cm4gcXVlcnkuX3BhdGgudG9TdHJpbmcoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKiogQGluaGVyaXREb2MgKi9cclxuICAgIGxpc3RlbihxdWVyeSwgY3VycmVudEhhc2hGbiwgdGFnLCBvbkNvbXBsZXRlKSB7XHJcbiAgICAgICAgY29uc3QgcGF0aFN0cmluZyA9IHF1ZXJ5Ll9wYXRoLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgdGhpcy5sb2dfKCdMaXN0ZW4gY2FsbGVkIGZvciAnICsgcGF0aFN0cmluZyArICcgJyArIHF1ZXJ5Ll9xdWVyeUlkZW50aWZpZXIpO1xyXG4gICAgICAgIC8vIE1hcmsgdGhpcyBsaXN0ZW5lciBzbyB3ZSBjYW4gdGVsbCBpZiBpdCdzIHJlbW92ZWQuXHJcbiAgICAgICAgY29uc3QgbGlzdGVuSWQgPSBSZWFkb25seVJlc3RDbGllbnQuZ2V0TGlzdGVuSWRfKHF1ZXJ5LCB0YWcpO1xyXG4gICAgICAgIGNvbnN0IHRoaXNMaXN0ZW4gPSB7fTtcclxuICAgICAgICB0aGlzLmxpc3RlbnNfW2xpc3RlbklkXSA9IHRoaXNMaXN0ZW47XHJcbiAgICAgICAgY29uc3QgcXVlcnlTdHJpbmdQYXJhbWV0ZXJzID0gcXVlcnlQYXJhbXNUb1Jlc3RRdWVyeVN0cmluZ1BhcmFtZXRlcnMocXVlcnkuX3F1ZXJ5UGFyYW1zKTtcclxuICAgICAgICB0aGlzLnJlc3RSZXF1ZXN0XyhwYXRoU3RyaW5nICsgJy5qc29uJywgcXVlcnlTdHJpbmdQYXJhbWV0ZXJzLCAoZXJyb3IsIHJlc3VsdCkgPT4ge1xyXG4gICAgICAgICAgICBsZXQgZGF0YSA9IHJlc3VsdDtcclxuICAgICAgICAgICAgaWYgKGVycm9yID09PSA0MDQpIHtcclxuICAgICAgICAgICAgICAgIGRhdGEgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgZXJyb3IgPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChlcnJvciA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vbkRhdGFVcGRhdGVfKHBhdGhTdHJpbmcsIGRhdGEsIC8qaXNNZXJnZT0qLyBmYWxzZSwgdGFnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoc2FmZUdldCh0aGlzLmxpc3RlbnNfLCBsaXN0ZW5JZCkgPT09IHRoaXNMaXN0ZW4pIHtcclxuICAgICAgICAgICAgICAgIGxldCBzdGF0dXM7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzID0gJ29rJztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGVycm9yID09PSA0MDEpIHtcclxuICAgICAgICAgICAgICAgICAgICBzdGF0dXMgPSAncGVybWlzc2lvbl9kZW5pZWQnO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzID0gJ3Jlc3RfZXJyb3I6JyArIGVycm9yO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgb25Db21wbGV0ZShzdGF0dXMsIG51bGwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKiogQGluaGVyaXREb2MgKi9cclxuICAgIHVubGlzdGVuKHF1ZXJ5LCB0YWcpIHtcclxuICAgICAgICBjb25zdCBsaXN0ZW5JZCA9IFJlYWRvbmx5UmVzdENsaWVudC5nZXRMaXN0ZW5JZF8ocXVlcnksIHRhZyk7XHJcbiAgICAgICAgZGVsZXRlIHRoaXMubGlzdGVuc19bbGlzdGVuSWRdO1xyXG4gICAgfVxyXG4gICAgZ2V0KHF1ZXJ5KSB7XHJcbiAgICAgICAgY29uc3QgcXVlcnlTdHJpbmdQYXJhbWV0ZXJzID0gcXVlcnlQYXJhbXNUb1Jlc3RRdWVyeVN0cmluZ1BhcmFtZXRlcnMocXVlcnkuX3F1ZXJ5UGFyYW1zKTtcclxuICAgICAgICBjb25zdCBwYXRoU3RyaW5nID0gcXVlcnkuX3BhdGgudG9TdHJpbmcoKTtcclxuICAgICAgICBjb25zdCBkZWZlcnJlZCA9IG5ldyBEZWZlcnJlZCgpO1xyXG4gICAgICAgIHRoaXMucmVzdFJlcXVlc3RfKHBhdGhTdHJpbmcgKyAnLmpzb24nLCBxdWVyeVN0cmluZ1BhcmFtZXRlcnMsIChlcnJvciwgcmVzdWx0KSA9PiB7XHJcbiAgICAgICAgICAgIGxldCBkYXRhID0gcmVzdWx0O1xyXG4gICAgICAgICAgICBpZiAoZXJyb3IgPT09IDQwNCkge1xyXG4gICAgICAgICAgICAgICAgZGF0YSA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICBlcnJvciA9IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGVycm9yID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9uRGF0YVVwZGF0ZV8ocGF0aFN0cmluZywgZGF0YSwgXHJcbiAgICAgICAgICAgICAgICAvKmlzTWVyZ2U9Ki8gZmFsc2UsIFxyXG4gICAgICAgICAgICAgICAgLyp0YWc9Ki8gbnVsbCk7XHJcbiAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKGRhdGEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZGVmZXJyZWQucmVqZWN0KG5ldyBFcnJvcihkYXRhKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcclxuICAgIH1cclxuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xyXG4gICAgcmVmcmVzaEF1dGhUb2tlbih0b2tlbikge1xyXG4gICAgICAgIC8vIG5vLW9wIHNpbmNlIHdlIGp1c3QgYWx3YXlzIGNhbGwgZ2V0VG9rZW4uXHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFBlcmZvcm1zIGEgUkVTVCByZXF1ZXN0IHRvIHRoZSBnaXZlbiBwYXRoLCB3aXRoIHRoZSBwcm92aWRlZCBxdWVyeSBzdHJpbmcgcGFyYW1ldGVycyxcclxuICAgICAqIGFuZCBhbnkgYXV0aCBjcmVkZW50aWFscyB3ZSBoYXZlLlxyXG4gICAgICovXHJcbiAgICByZXN0UmVxdWVzdF8ocGF0aFN0cmluZywgcXVlcnlTdHJpbmdQYXJhbWV0ZXJzID0ge30sIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgcXVlcnlTdHJpbmdQYXJhbWV0ZXJzWydmb3JtYXQnXSA9ICdleHBvcnQnO1xyXG4gICAgICAgIHJldHVybiBQcm9taXNlLmFsbChbXHJcbiAgICAgICAgICAgIHRoaXMuYXV0aFRva2VuUHJvdmlkZXJfLmdldFRva2VuKC8qZm9yY2VSZWZyZXNoPSovIGZhbHNlKSxcclxuICAgICAgICAgICAgdGhpcy5hcHBDaGVja1Rva2VuUHJvdmlkZXJfLmdldFRva2VuKC8qZm9yY2VSZWZyZXNoPSovIGZhbHNlKVxyXG4gICAgICAgIF0pLnRoZW4oKFthdXRoVG9rZW4sIGFwcENoZWNrVG9rZW5dKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChhdXRoVG9rZW4gJiYgYXV0aFRva2VuLmFjY2Vzc1Rva2VuKSB7XHJcbiAgICAgICAgICAgICAgICBxdWVyeVN0cmluZ1BhcmFtZXRlcnNbJ2F1dGgnXSA9IGF1dGhUb2tlbi5hY2Nlc3NUb2tlbjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoYXBwQ2hlY2tUb2tlbiAmJiBhcHBDaGVja1Rva2VuLnRva2VuKSB7XHJcbiAgICAgICAgICAgICAgICBxdWVyeVN0cmluZ1BhcmFtZXRlcnNbJ2FjJ10gPSBhcHBDaGVja1Rva2VuLnRva2VuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IHVybCA9ICh0aGlzLnJlcG9JbmZvXy5zZWN1cmUgPyAnaHR0cHM6Ly8nIDogJ2h0dHA6Ly8nKSArXHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlcG9JbmZvXy5ob3N0ICtcclxuICAgICAgICAgICAgICAgIHBhdGhTdHJpbmcgK1xyXG4gICAgICAgICAgICAgICAgJz8nICtcclxuICAgICAgICAgICAgICAgICducz0nICtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVwb0luZm9fLm5hbWVzcGFjZSArXHJcbiAgICAgICAgICAgICAgICBxdWVyeXN0cmluZyhxdWVyeVN0cmluZ1BhcmFtZXRlcnMpO1xyXG4gICAgICAgICAgICB0aGlzLmxvZ18oJ1NlbmRpbmcgUkVTVCByZXF1ZXN0IGZvciAnICsgdXJsKTtcclxuICAgICAgICAgICAgY29uc3QgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XHJcbiAgICAgICAgICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2sgJiYgeGhyLnJlYWR5U3RhdGUgPT09IDQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmxvZ18oJ1JFU1QgUmVzcG9uc2UgZm9yICcgKyB1cmwgKyAnIHJlY2VpdmVkLiBzdGF0dXM6JywgeGhyLnN0YXR1cywgJ3Jlc3BvbnNlOicsIHhoci5yZXNwb25zZVRleHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCByZXMgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh4aHIuc3RhdHVzID49IDIwMCAmJiB4aHIuc3RhdHVzIDwgMzAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXMgPSBqc29uRXZhbCh4aHIucmVzcG9uc2VUZXh0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2FybignRmFpbGVkIHRvIHBhcnNlIEpTT04gcmVzcG9uc2UgZm9yICcgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybCArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJzogJyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeGhyLnJlc3BvbnNlVGV4dCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgcmVzKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIDQwMSBhbmQgNDA0IGFyZSBleHBlY3RlZC5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHhoci5zdGF0dXMgIT09IDQwMSAmJiB4aHIuc3RhdHVzICE9PSA0MDQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdhcm4oJ0dvdCB1bnN1Y2Nlc3NmdWwgUkVTVCByZXNwb25zZSBmb3IgJyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnIFN0YXR1czogJyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeGhyLnN0YXR1cyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soeGhyLnN0YXR1cyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgeGhyLm9wZW4oJ0dFVCcsIHVybCwgLyphc3luY2hyb25vdXM9Ki8gdHJ1ZSk7XHJcbiAgICAgICAgICAgIHhoci5zZW5kKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIE11dGFibGUgb2JqZWN0IHdoaWNoIGJhc2ljYWxseSBqdXN0IHN0b3JlcyBhIHJlZmVyZW5jZSB0byB0aGUgXCJsYXRlc3RcIiBpbW11dGFibGUgc25hcHNob3QuXHJcbiAqL1xyXG5jbGFzcyBTbmFwc2hvdEhvbGRlciB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLnJvb3ROb2RlXyA9IENoaWxkcmVuTm9kZS5FTVBUWV9OT0RFO1xyXG4gICAgfVxyXG4gICAgZ2V0Tm9kZShwYXRoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucm9vdE5vZGVfLmdldENoaWxkKHBhdGgpO1xyXG4gICAgfVxyXG4gICAgdXBkYXRlU25hcHNob3QocGF0aCwgbmV3U25hcHNob3ROb2RlKSB7XHJcbiAgICAgICAgdGhpcy5yb290Tm9kZV8gPSB0aGlzLnJvb3ROb2RlXy51cGRhdGVDaGlsZChwYXRoLCBuZXdTbmFwc2hvdE5vZGUpO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmZ1bmN0aW9uIG5ld1NwYXJzZVNuYXBzaG90VHJlZSgpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdmFsdWU6IG51bGwsXHJcbiAgICAgICAgY2hpbGRyZW46IG5ldyBNYXAoKVxyXG4gICAgfTtcclxufVxyXG4vKipcclxuICogU3RvcmVzIHRoZSBnaXZlbiBub2RlIGF0IHRoZSBzcGVjaWZpZWQgcGF0aC4gSWYgdGhlcmUgaXMgYWxyZWFkeSBhIG5vZGVcclxuICogYXQgYSBzaGFsbG93ZXIgcGF0aCwgaXQgbWVyZ2VzIHRoZSBuZXcgZGF0YSBpbnRvIHRoYXQgc25hcHNob3Qgbm9kZS5cclxuICpcclxuICogQHBhcmFtIHBhdGggLSBQYXRoIHRvIGxvb2sgdXAgc25hcHNob3QgZm9yLlxyXG4gKiBAcGFyYW0gZGF0YSAtIFRoZSBuZXcgZGF0YSwgb3IgbnVsbC5cclxuICovXHJcbmZ1bmN0aW9uIHNwYXJzZVNuYXBzaG90VHJlZVJlbWVtYmVyKHNwYXJzZVNuYXBzaG90VHJlZSwgcGF0aCwgZGF0YSkge1xyXG4gICAgaWYgKHBhdGhJc0VtcHR5KHBhdGgpKSB7XHJcbiAgICAgICAgc3BhcnNlU25hcHNob3RUcmVlLnZhbHVlID0gZGF0YTtcclxuICAgICAgICBzcGFyc2VTbmFwc2hvdFRyZWUuY2hpbGRyZW4uY2xlYXIoKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHNwYXJzZVNuYXBzaG90VHJlZS52YWx1ZSAhPT0gbnVsbCkge1xyXG4gICAgICAgIHNwYXJzZVNuYXBzaG90VHJlZS52YWx1ZSA9IHNwYXJzZVNuYXBzaG90VHJlZS52YWx1ZS51cGRhdGVDaGlsZChwYXRoLCBkYXRhKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGNvbnN0IGNoaWxkS2V5ID0gcGF0aEdldEZyb250KHBhdGgpO1xyXG4gICAgICAgIGlmICghc3BhcnNlU25hcHNob3RUcmVlLmNoaWxkcmVuLmhhcyhjaGlsZEtleSkpIHtcclxuICAgICAgICAgICAgc3BhcnNlU25hcHNob3RUcmVlLmNoaWxkcmVuLnNldChjaGlsZEtleSwgbmV3U3BhcnNlU25hcHNob3RUcmVlKCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBjaGlsZCA9IHNwYXJzZVNuYXBzaG90VHJlZS5jaGlsZHJlbi5nZXQoY2hpbGRLZXkpO1xyXG4gICAgICAgIHBhdGggPSBwYXRoUG9wRnJvbnQocGF0aCk7XHJcbiAgICAgICAgc3BhcnNlU25hcHNob3RUcmVlUmVtZW1iZXIoY2hpbGQsIHBhdGgsIGRhdGEpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBQdXJnZSB0aGUgZGF0YSBhdCBwYXRoIGZyb20gdGhlIGNhY2hlLlxyXG4gKlxyXG4gKiBAcGFyYW0gcGF0aCAtIFBhdGggdG8gbG9vayB1cCBzbmFwc2hvdCBmb3IuXHJcbiAqIEByZXR1cm5zIFRydWUgaWYgdGhpcyBub2RlIHNob3VsZCBub3cgYmUgcmVtb3ZlZC5cclxuICovXHJcbmZ1bmN0aW9uIHNwYXJzZVNuYXBzaG90VHJlZUZvcmdldChzcGFyc2VTbmFwc2hvdFRyZWUsIHBhdGgpIHtcclxuICAgIGlmIChwYXRoSXNFbXB0eShwYXRoKSkge1xyXG4gICAgICAgIHNwYXJzZVNuYXBzaG90VHJlZS52YWx1ZSA9IG51bGw7XHJcbiAgICAgICAgc3BhcnNlU25hcHNob3RUcmVlLmNoaWxkcmVuLmNsZWFyKCk7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBpZiAoc3BhcnNlU25hcHNob3RUcmVlLnZhbHVlICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGlmIChzcGFyc2VTbmFwc2hvdFRyZWUudmFsdWUuaXNMZWFmTm9kZSgpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBXZSdyZSB0cnlpbmcgdG8gZm9yZ2V0IGEgbm9kZSB0aGF0IGRvZXNuJ3QgZXhpc3RcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gc3BhcnNlU25hcHNob3RUcmVlLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgc3BhcnNlU25hcHNob3RUcmVlLnZhbHVlID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIHZhbHVlLmZvckVhY2hDaGlsZChQUklPUklUWV9JTkRFWCwgKGtleSwgdHJlZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHNwYXJzZVNuYXBzaG90VHJlZVJlbWVtYmVyKHNwYXJzZVNuYXBzaG90VHJlZSwgbmV3IFBhdGgoa2V5KSwgdHJlZSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBzcGFyc2VTbmFwc2hvdFRyZWVGb3JnZXQoc3BhcnNlU25hcHNob3RUcmVlLCBwYXRoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChzcGFyc2VTbmFwc2hvdFRyZWUuY2hpbGRyZW4uc2l6ZSA+IDApIHtcclxuICAgICAgICAgICAgY29uc3QgY2hpbGRLZXkgPSBwYXRoR2V0RnJvbnQocGF0aCk7XHJcbiAgICAgICAgICAgIHBhdGggPSBwYXRoUG9wRnJvbnQocGF0aCk7XHJcbiAgICAgICAgICAgIGlmIChzcGFyc2VTbmFwc2hvdFRyZWUuY2hpbGRyZW4uaGFzKGNoaWxkS2V5KSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc2FmZVRvUmVtb3ZlID0gc3BhcnNlU25hcHNob3RUcmVlRm9yZ2V0KHNwYXJzZVNuYXBzaG90VHJlZS5jaGlsZHJlbi5nZXQoY2hpbGRLZXkpLCBwYXRoKTtcclxuICAgICAgICAgICAgICAgIGlmIChzYWZlVG9SZW1vdmUpIHtcclxuICAgICAgICAgICAgICAgICAgICBzcGFyc2VTbmFwc2hvdFRyZWUuY2hpbGRyZW4uZGVsZXRlKGNoaWxkS2V5KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gc3BhcnNlU25hcHNob3RUcmVlLmNoaWxkcmVuLnNpemUgPT09IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFJlY3Vyc2l2ZWx5IGl0ZXJhdGVzIHRocm91Z2ggYWxsIG9mIHRoZSBzdG9yZWQgdHJlZSBhbmQgY2FsbHMgdGhlXHJcbiAqIGNhbGxiYWNrIG9uIGVhY2ggb25lLlxyXG4gKlxyXG4gKiBAcGFyYW0gcHJlZml4UGF0aCAtIFBhdGggdG8gbG9vayB1cCBub2RlIGZvci5cclxuICogQHBhcmFtIGZ1bmMgLSBUaGUgZnVuY3Rpb24gdG8gaW52b2tlIGZvciBlYWNoIHRyZWUuXHJcbiAqL1xyXG5mdW5jdGlvbiBzcGFyc2VTbmFwc2hvdFRyZWVGb3JFYWNoVHJlZShzcGFyc2VTbmFwc2hvdFRyZWUsIHByZWZpeFBhdGgsIGZ1bmMpIHtcclxuICAgIGlmIChzcGFyc2VTbmFwc2hvdFRyZWUudmFsdWUgIT09IG51bGwpIHtcclxuICAgICAgICBmdW5jKHByZWZpeFBhdGgsIHNwYXJzZVNuYXBzaG90VHJlZS52YWx1ZSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBzcGFyc2VTbmFwc2hvdFRyZWVGb3JFYWNoQ2hpbGQoc3BhcnNlU25hcHNob3RUcmVlLCAoa2V5LCB0cmVlKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHBhdGggPSBuZXcgUGF0aChwcmVmaXhQYXRoLnRvU3RyaW5nKCkgKyAnLycgKyBrZXkpO1xyXG4gICAgICAgICAgICBzcGFyc2VTbmFwc2hvdFRyZWVGb3JFYWNoVHJlZSh0cmVlLCBwYXRoLCBmdW5jKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogSXRlcmF0ZXMgdGhyb3VnaCBlYWNoIGltbWVkaWF0ZSBjaGlsZCBhbmQgdHJpZ2dlcnMgdGhlIGNhbGxiYWNrLlxyXG4gKiBPbmx5IHNlZW1zIHRvIGJlIHVzZWQgaW4gdGVzdHMuXHJcbiAqXHJcbiAqIEBwYXJhbSBmdW5jIC0gVGhlIGZ1bmN0aW9uIHRvIGludm9rZSBmb3IgZWFjaCBjaGlsZC5cclxuICovXHJcbmZ1bmN0aW9uIHNwYXJzZVNuYXBzaG90VHJlZUZvckVhY2hDaGlsZChzcGFyc2VTbmFwc2hvdFRyZWUsIGZ1bmMpIHtcclxuICAgIHNwYXJzZVNuYXBzaG90VHJlZS5jaGlsZHJlbi5mb3JFYWNoKCh0cmVlLCBrZXkpID0+IHtcclxuICAgICAgICBmdW5jKGtleSwgdHJlZSk7XHJcbiAgICB9KTtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogUmV0dXJucyB0aGUgZGVsdGEgZnJvbSB0aGUgcHJldmlvdXMgY2FsbCB0byBnZXQgc3RhdHMuXHJcbiAqXHJcbiAqIEBwYXJhbSBjb2xsZWN0aW9uXyAtIFRoZSBjb2xsZWN0aW9uIHRvIFwibGlzdGVuXCIgdG8uXHJcbiAqL1xyXG5jbGFzcyBTdGF0c0xpc3RlbmVyIHtcclxuICAgIGNvbnN0cnVjdG9yKGNvbGxlY3Rpb25fKSB7XHJcbiAgICAgICAgdGhpcy5jb2xsZWN0aW9uXyA9IGNvbGxlY3Rpb25fO1xyXG4gICAgICAgIHRoaXMubGFzdF8gPSBudWxsO1xyXG4gICAgfVxyXG4gICAgZ2V0KCkge1xyXG4gICAgICAgIGNvbnN0IG5ld1N0YXRzID0gdGhpcy5jb2xsZWN0aW9uXy5nZXQoKTtcclxuICAgICAgICBjb25zdCBkZWx0YSA9IE9iamVjdC5hc3NpZ24oe30sIG5ld1N0YXRzKTtcclxuICAgICAgICBpZiAodGhpcy5sYXN0Xykge1xyXG4gICAgICAgICAgICBlYWNoKHRoaXMubGFzdF8sIChzdGF0LCB2YWx1ZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgZGVsdGFbc3RhdF0gPSBkZWx0YVtzdGF0XSAtIHZhbHVlO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5sYXN0XyA9IG5ld1N0YXRzO1xyXG4gICAgICAgIHJldHVybiBkZWx0YTtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vLyBBc3N1bWluZyBzb21lIGFwcHMgbWF5IGhhdmUgYSBzaG9ydCBhbW91bnQgb2YgdGltZSBvbiBwYWdlLCBhbmQgYSBidWxrIG9mIGZpcmViYXNlIG9wZXJhdGlvbnMgcHJvYmFibHlcclxuLy8gaGFwcGVuIG9uIHBhZ2UgbG9hZCwgd2UgdHJ5IHRvIHJlcG9ydCBvdXIgZmlyc3Qgc2V0IG9mIHN0YXRzIHByZXR0eSBxdWlja2x5LCBidXQgd2Ugd2FpdCBhdCBsZWFzdCAxMFxyXG4vLyBzZWNvbmRzIHRvIHRyeSB0byBlbnN1cmUgdGhlIEZpcmViYXNlIGNvbm5lY3Rpb24gaXMgZXN0YWJsaXNoZWQgLyBzZXR0bGVkLlxyXG5jb25zdCBGSVJTVF9TVEFUU19NSU5fVElNRSA9IDEwICogMTAwMDtcclxuY29uc3QgRklSU1RfU1RBVFNfTUFYX1RJTUUgPSAzMCAqIDEwMDA7XHJcbi8vIFdlJ2xsIGNvbnRpbnVlIHRvIHJlcG9ydCBzdGF0cyBvbiBhdmVyYWdlIGV2ZXJ5IDUgbWludXRlcy5cclxuY29uc3QgUkVQT1JUX1NUQVRTX0lOVEVSVkFMID0gNSAqIDYwICogMTAwMDtcclxuY2xhc3MgU3RhdHNSZXBvcnRlciB7XHJcbiAgICBjb25zdHJ1Y3Rvcihjb2xsZWN0aW9uLCBzZXJ2ZXJfKSB7XHJcbiAgICAgICAgdGhpcy5zZXJ2ZXJfID0gc2VydmVyXztcclxuICAgICAgICB0aGlzLnN0YXRzVG9SZXBvcnRfID0ge307XHJcbiAgICAgICAgdGhpcy5zdGF0c0xpc3RlbmVyXyA9IG5ldyBTdGF0c0xpc3RlbmVyKGNvbGxlY3Rpb24pO1xyXG4gICAgICAgIGNvbnN0IHRpbWVvdXQgPSBGSVJTVF9TVEFUU19NSU5fVElNRSArXHJcbiAgICAgICAgICAgIChGSVJTVF9TVEFUU19NQVhfVElNRSAtIEZJUlNUX1NUQVRTX01JTl9USU1FKSAqIE1hdGgucmFuZG9tKCk7XHJcbiAgICAgICAgc2V0VGltZW91dE5vbkJsb2NraW5nKHRoaXMucmVwb3J0U3RhdHNfLmJpbmQodGhpcyksIE1hdGguZmxvb3IodGltZW91dCkpO1xyXG4gICAgfVxyXG4gICAgcmVwb3J0U3RhdHNfKCkge1xyXG4gICAgICAgIGNvbnN0IHN0YXRzID0gdGhpcy5zdGF0c0xpc3RlbmVyXy5nZXQoKTtcclxuICAgICAgICBjb25zdCByZXBvcnRlZFN0YXRzID0ge307XHJcbiAgICAgICAgbGV0IGhhdmVTdGF0c1RvUmVwb3J0ID0gZmFsc2U7XHJcbiAgICAgICAgZWFjaChzdGF0cywgKHN0YXQsIHZhbHVlKSA9PiB7XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZSA+IDAgJiYgY29udGFpbnModGhpcy5zdGF0c1RvUmVwb3J0Xywgc3RhdCkpIHtcclxuICAgICAgICAgICAgICAgIHJlcG9ydGVkU3RhdHNbc3RhdF0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgIGhhdmVTdGF0c1RvUmVwb3J0ID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmIChoYXZlU3RhdHNUb1JlcG9ydCkge1xyXG4gICAgICAgICAgICB0aGlzLnNlcnZlcl8ucmVwb3J0U3RhdHMocmVwb3J0ZWRTdGF0cyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHF1ZXVlIG91ciBuZXh0IHJ1bi5cclxuICAgICAgICBzZXRUaW1lb3V0Tm9uQmxvY2tpbmcodGhpcy5yZXBvcnRTdGF0c18uYmluZCh0aGlzKSwgTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMiAqIFJFUE9SVF9TVEFUU19JTlRFUlZBTCkpO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKlxyXG4gKiBAZW51bVxyXG4gKi9cclxudmFyIE9wZXJhdGlvblR5cGU7XHJcbihmdW5jdGlvbiAoT3BlcmF0aW9uVHlwZSkge1xyXG4gICAgT3BlcmF0aW9uVHlwZVtPcGVyYXRpb25UeXBlW1wiT1ZFUldSSVRFXCJdID0gMF0gPSBcIk9WRVJXUklURVwiO1xyXG4gICAgT3BlcmF0aW9uVHlwZVtPcGVyYXRpb25UeXBlW1wiTUVSR0VcIl0gPSAxXSA9IFwiTUVSR0VcIjtcclxuICAgIE9wZXJhdGlvblR5cGVbT3BlcmF0aW9uVHlwZVtcIkFDS19VU0VSX1dSSVRFXCJdID0gMl0gPSBcIkFDS19VU0VSX1dSSVRFXCI7XHJcbiAgICBPcGVyYXRpb25UeXBlW09wZXJhdGlvblR5cGVbXCJMSVNURU5fQ09NUExFVEVcIl0gPSAzXSA9IFwiTElTVEVOX0NPTVBMRVRFXCI7XHJcbn0pKE9wZXJhdGlvblR5cGUgfHwgKE9wZXJhdGlvblR5cGUgPSB7fSkpO1xyXG5mdW5jdGlvbiBuZXdPcGVyYXRpb25Tb3VyY2VVc2VyKCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBmcm9tVXNlcjogdHJ1ZSxcclxuICAgICAgICBmcm9tU2VydmVyOiBmYWxzZSxcclxuICAgICAgICBxdWVyeUlkOiBudWxsLFxyXG4gICAgICAgIHRhZ2dlZDogZmFsc2VcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gbmV3T3BlcmF0aW9uU291cmNlU2VydmVyKCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBmcm9tVXNlcjogZmFsc2UsXHJcbiAgICAgICAgZnJvbVNlcnZlcjogdHJ1ZSxcclxuICAgICAgICBxdWVyeUlkOiBudWxsLFxyXG4gICAgICAgIHRhZ2dlZDogZmFsc2VcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gbmV3T3BlcmF0aW9uU291cmNlU2VydmVyVGFnZ2VkUXVlcnkocXVlcnlJZCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBmcm9tVXNlcjogZmFsc2UsXHJcbiAgICAgICAgZnJvbVNlcnZlcjogdHJ1ZSxcclxuICAgICAgICBxdWVyeUlkLFxyXG4gICAgICAgIHRhZ2dlZDogdHJ1ZVxyXG4gICAgfTtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5jbGFzcyBBY2tVc2VyV3JpdGUge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gYWZmZWN0ZWRUcmVlIC0gQSB0cmVlIGNvbnRhaW5pbmcgdHJ1ZSBmb3IgZWFjaCBhZmZlY3RlZCBwYXRoLiBBZmZlY3RlZCBwYXRocyBjYW4ndCBvdmVybGFwLlxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihcclxuICAgIC8qKiBAaW5oZXJpdERvYyAqLyBwYXRoLCBcclxuICAgIC8qKiBAaW5oZXJpdERvYyAqLyBhZmZlY3RlZFRyZWUsIFxyXG4gICAgLyoqIEBpbmhlcml0RG9jICovIHJldmVydCkge1xyXG4gICAgICAgIHRoaXMucGF0aCA9IHBhdGg7XHJcbiAgICAgICAgdGhpcy5hZmZlY3RlZFRyZWUgPSBhZmZlY3RlZFRyZWU7XHJcbiAgICAgICAgdGhpcy5yZXZlcnQgPSByZXZlcnQ7XHJcbiAgICAgICAgLyoqIEBpbmhlcml0RG9jICovXHJcbiAgICAgICAgdGhpcy50eXBlID0gT3BlcmF0aW9uVHlwZS5BQ0tfVVNFUl9XUklURTtcclxuICAgICAgICAvKiogQGluaGVyaXREb2MgKi9cclxuICAgICAgICB0aGlzLnNvdXJjZSA9IG5ld09wZXJhdGlvblNvdXJjZVVzZXIoKTtcclxuICAgIH1cclxuICAgIG9wZXJhdGlvbkZvckNoaWxkKGNoaWxkTmFtZSkge1xyXG4gICAgICAgIGlmICghcGF0aElzRW1wdHkodGhpcy5wYXRoKSkge1xyXG4gICAgICAgICAgICBhc3NlcnQocGF0aEdldEZyb250KHRoaXMucGF0aCkgPT09IGNoaWxkTmFtZSwgJ29wZXJhdGlvbkZvckNoaWxkIGNhbGxlZCBmb3IgdW5yZWxhdGVkIGNoaWxkLicpO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEFja1VzZXJXcml0ZShwYXRoUG9wRnJvbnQodGhpcy5wYXRoKSwgdGhpcy5hZmZlY3RlZFRyZWUsIHRoaXMucmV2ZXJ0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodGhpcy5hZmZlY3RlZFRyZWUudmFsdWUgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICBhc3NlcnQodGhpcy5hZmZlY3RlZFRyZWUuY2hpbGRyZW4uaXNFbXB0eSgpLCAnYWZmZWN0ZWRUcmVlIHNob3VsZCBub3QgaGF2ZSBvdmVybGFwcGluZyBhZmZlY3RlZCBwYXRocy4nKTtcclxuICAgICAgICAgICAgLy8gQWxsIGNoaWxkIGxvY2F0aW9ucyBhcmUgYWZmZWN0ZWQgYXMgd2VsbDsganVzdCByZXR1cm4gc2FtZSBvcGVyYXRpb24uXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3QgY2hpbGRUcmVlID0gdGhpcy5hZmZlY3RlZFRyZWUuc3VidHJlZShuZXcgUGF0aChjaGlsZE5hbWUpKTtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBBY2tVc2VyV3JpdGUobmV3RW1wdHlQYXRoKCksIGNoaWxkVHJlZSwgdGhpcy5yZXZlcnQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5jbGFzcyBMaXN0ZW5Db21wbGV0ZSB7XHJcbiAgICBjb25zdHJ1Y3Rvcihzb3VyY2UsIHBhdGgpIHtcclxuICAgICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcclxuICAgICAgICB0aGlzLnBhdGggPSBwYXRoO1xyXG4gICAgICAgIC8qKiBAaW5oZXJpdERvYyAqL1xyXG4gICAgICAgIHRoaXMudHlwZSA9IE9wZXJhdGlvblR5cGUuTElTVEVOX0NPTVBMRVRFO1xyXG4gICAgfVxyXG4gICAgb3BlcmF0aW9uRm9yQ2hpbGQoY2hpbGROYW1lKSB7XHJcbiAgICAgICAgaWYgKHBhdGhJc0VtcHR5KHRoaXMucGF0aCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBMaXN0ZW5Db21wbGV0ZSh0aGlzLnNvdXJjZSwgbmV3RW1wdHlQYXRoKCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBMaXN0ZW5Db21wbGV0ZSh0aGlzLnNvdXJjZSwgcGF0aFBvcEZyb250KHRoaXMucGF0aCkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5jbGFzcyBPdmVyd3JpdGUge1xyXG4gICAgY29uc3RydWN0b3Ioc291cmNlLCBwYXRoLCBzbmFwKSB7XHJcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XHJcbiAgICAgICAgdGhpcy5wYXRoID0gcGF0aDtcclxuICAgICAgICB0aGlzLnNuYXAgPSBzbmFwO1xyXG4gICAgICAgIC8qKiBAaW5oZXJpdERvYyAqL1xyXG4gICAgICAgIHRoaXMudHlwZSA9IE9wZXJhdGlvblR5cGUuT1ZFUldSSVRFO1xyXG4gICAgfVxyXG4gICAgb3BlcmF0aW9uRm9yQ2hpbGQoY2hpbGROYW1lKSB7XHJcbiAgICAgICAgaWYgKHBhdGhJc0VtcHR5KHRoaXMucGF0aCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBPdmVyd3JpdGUodGhpcy5zb3VyY2UsIG5ld0VtcHR5UGF0aCgpLCB0aGlzLnNuYXAuZ2V0SW1tZWRpYXRlQ2hpbGQoY2hpbGROYW1lKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IE92ZXJ3cml0ZSh0aGlzLnNvdXJjZSwgcGF0aFBvcEZyb250KHRoaXMucGF0aCksIHRoaXMuc25hcCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmNsYXNzIE1lcmdlIHtcclxuICAgIGNvbnN0cnVjdG9yKFxyXG4gICAgLyoqIEBpbmhlcml0RG9jICovIHNvdXJjZSwgXHJcbiAgICAvKiogQGluaGVyaXREb2MgKi8gcGF0aCwgXHJcbiAgICAvKiogQGluaGVyaXREb2MgKi8gY2hpbGRyZW4pIHtcclxuICAgICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcclxuICAgICAgICB0aGlzLnBhdGggPSBwYXRoO1xyXG4gICAgICAgIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcclxuICAgICAgICAvKiogQGluaGVyaXREb2MgKi9cclxuICAgICAgICB0aGlzLnR5cGUgPSBPcGVyYXRpb25UeXBlLk1FUkdFO1xyXG4gICAgfVxyXG4gICAgb3BlcmF0aW9uRm9yQ2hpbGQoY2hpbGROYW1lKSB7XHJcbiAgICAgICAgaWYgKHBhdGhJc0VtcHR5KHRoaXMucGF0aCkpIHtcclxuICAgICAgICAgICAgY29uc3QgY2hpbGRUcmVlID0gdGhpcy5jaGlsZHJlbi5zdWJ0cmVlKG5ldyBQYXRoKGNoaWxkTmFtZSkpO1xyXG4gICAgICAgICAgICBpZiAoY2hpbGRUcmVlLmlzRW1wdHkoKSkge1xyXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBjaGlsZCBpcyB1bmFmZmVjdGVkXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChjaGlsZFRyZWUudmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIC8vIFdlIGhhdmUgYSBzbmFwc2hvdCBmb3IgdGhlIGNoaWxkIGluIHF1ZXN0aW9uLiAgVGhpcyBiZWNvbWVzIGFuIG92ZXJ3cml0ZSBvZiB0aGUgY2hpbGQuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IE92ZXJ3cml0ZSh0aGlzLnNvdXJjZSwgbmV3RW1wdHlQYXRoKCksIGNoaWxkVHJlZS52YWx1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIGEgbWVyZ2UgYXQgYSBkZWVwZXIgbGV2ZWxcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgTWVyZ2UodGhpcy5zb3VyY2UsIG5ld0VtcHR5UGF0aCgpLCBjaGlsZFRyZWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBhc3NlcnQocGF0aEdldEZyb250KHRoaXMucGF0aCkgPT09IGNoaWxkTmFtZSwgXCJDYW4ndCBnZXQgYSBtZXJnZSBmb3IgYSBjaGlsZCBub3Qgb24gdGhlIHBhdGggb2YgdGhlIG9wZXJhdGlvblwiKTtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBNZXJnZSh0aGlzLnNvdXJjZSwgcGF0aFBvcEZyb250KHRoaXMucGF0aCksIHRoaXMuY2hpbGRyZW4pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHRvU3RyaW5nKCkge1xyXG4gICAgICAgIHJldHVybiAoJ09wZXJhdGlvbignICtcclxuICAgICAgICAgICAgdGhpcy5wYXRoICtcclxuICAgICAgICAgICAgJzogJyArXHJcbiAgICAgICAgICAgIHRoaXMuc291cmNlLnRvU3RyaW5nKCkgK1xyXG4gICAgICAgICAgICAnIG1lcmdlOiAnICtcclxuICAgICAgICAgICAgdGhpcy5jaGlsZHJlbi50b1N0cmluZygpICtcclxuICAgICAgICAgICAgJyknKTtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogQSBjYWNoZSBub2RlIG9ubHkgc3RvcmVzIGNvbXBsZXRlIGNoaWxkcmVuLiBBZGRpdGlvbmFsbHkgaXQgaG9sZHMgYSBmbGFnIHdoZXRoZXIgdGhlIG5vZGUgY2FuIGJlIGNvbnNpZGVyZWQgZnVsbHlcclxuICogaW5pdGlhbGl6ZWQgaW4gdGhlIHNlbnNlIHRoYXQgd2Uga25vdyBhdCBvbmUgcG9pbnQgaW4gdGltZSB0aGlzIHJlcHJlc2VudGVkIGEgdmFsaWQgc3RhdGUgb2YgdGhlIHdvcmxkLCBlLmcuXHJcbiAqIGluaXRpYWxpemVkIHdpdGggZGF0YSBmcm9tIHRoZSBzZXJ2ZXIsIG9yIGEgY29tcGxldGUgb3ZlcndyaXRlIGJ5IHRoZSBjbGllbnQuIFRoZSBmaWx0ZXJlZCBmbGFnIGFsc28gdHJhY2tzXHJcbiAqIHdoZXRoZXIgYSBub2RlIHBvdGVudGlhbGx5IGhhZCBjaGlsZHJlbiByZW1vdmVkIGR1ZSB0byBhIGZpbHRlci5cclxuICovXHJcbmNsYXNzIENhY2hlTm9kZSB7XHJcbiAgICBjb25zdHJ1Y3Rvcihub2RlXywgZnVsbHlJbml0aWFsaXplZF8sIGZpbHRlcmVkXykge1xyXG4gICAgICAgIHRoaXMubm9kZV8gPSBub2RlXztcclxuICAgICAgICB0aGlzLmZ1bGx5SW5pdGlhbGl6ZWRfID0gZnVsbHlJbml0aWFsaXplZF87XHJcbiAgICAgICAgdGhpcy5maWx0ZXJlZF8gPSBmaWx0ZXJlZF87XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGlzIG5vZGUgd2FzIGZ1bGx5IGluaXRpYWxpemVkIHdpdGggZWl0aGVyIHNlcnZlciBkYXRhIG9yIGEgY29tcGxldGUgb3ZlcndyaXRlIGJ5IHRoZSBjbGllbnRcclxuICAgICAqL1xyXG4gICAgaXNGdWxseUluaXRpYWxpemVkKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmZ1bGx5SW5pdGlhbGl6ZWRfO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhpcyBub2RlIGlzIHBvdGVudGlhbGx5IG1pc3NpbmcgY2hpbGRyZW4gZHVlIHRvIGEgZmlsdGVyIGFwcGxpZWQgdG8gdGhlIG5vZGVcclxuICAgICAqL1xyXG4gICAgaXNGaWx0ZXJlZCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5maWx0ZXJlZF87XHJcbiAgICB9XHJcbiAgICBpc0NvbXBsZXRlRm9yUGF0aChwYXRoKSB7XHJcbiAgICAgICAgaWYgKHBhdGhJc0VtcHR5KHBhdGgpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmlzRnVsbHlJbml0aWFsaXplZCgpICYmICF0aGlzLmZpbHRlcmVkXztcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgY2hpbGRLZXkgPSBwYXRoR2V0RnJvbnQocGF0aCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNDb21wbGV0ZUZvckNoaWxkKGNoaWxkS2V5KTtcclxuICAgIH1cclxuICAgIGlzQ29tcGxldGVGb3JDaGlsZChrZXkpIHtcclxuICAgICAgICByZXR1cm4gKCh0aGlzLmlzRnVsbHlJbml0aWFsaXplZCgpICYmICF0aGlzLmZpbHRlcmVkXykgfHwgdGhpcy5ub2RlXy5oYXNDaGlsZChrZXkpKTtcclxuICAgIH1cclxuICAgIGdldE5vZGUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubm9kZV87XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIEFuIEV2ZW50R2VuZXJhdG9yIGlzIHVzZWQgdG8gY29udmVydCBcInJhd1wiIGNoYW5nZXMgKENoYW5nZSkgYXMgY29tcHV0ZWQgYnkgdGhlXHJcbiAqIENhY2hlRGlmZmVyIGludG8gYWN0dWFsIGV2ZW50cyAoRXZlbnQpIHRoYXQgY2FuIGJlIHJhaXNlZC4gIFNlZSBnZW5lcmF0ZUV2ZW50c0ZvckNoYW5nZXMoKVxyXG4gKiBmb3IgZGV0YWlscy5cclxuICpcclxuICovXHJcbmNsYXNzIEV2ZW50R2VuZXJhdG9yIHtcclxuICAgIGNvbnN0cnVjdG9yKHF1ZXJ5Xykge1xyXG4gICAgICAgIHRoaXMucXVlcnlfID0gcXVlcnlfO1xyXG4gICAgICAgIHRoaXMuaW5kZXhfID0gdGhpcy5xdWVyeV8uX3F1ZXJ5UGFyYW1zLmdldEluZGV4KCk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEdpdmVuIGEgc2V0IG9mIHJhdyBjaGFuZ2VzIChubyBtb3ZlZCBldmVudHMgYW5kIHByZXZOYW1lIG5vdCBzcGVjaWZpZWQgeWV0KSwgYW5kIGEgc2V0IG9mXHJcbiAqIEV2ZW50UmVnaXN0cmF0aW9ucyB0aGF0IHNob3VsZCBiZSBub3RpZmllZCBvZiB0aGVzZSBjaGFuZ2VzLCBnZW5lcmF0ZSB0aGUgYWN0dWFsIGV2ZW50cyB0byBiZSByYWlzZWQuXHJcbiAqXHJcbiAqIE5vdGVzOlxyXG4gKiAgLSBjaGlsZF9tb3ZlZCBldmVudHMgd2lsbCBiZSBzeW50aGVzaXplZCBhdCB0aGlzIHRpbWUgZm9yIGFueSBjaGlsZF9jaGFuZ2VkIGV2ZW50cyB0aGF0IGFmZmVjdFxyXG4gKiAgICBvdXIgaW5kZXguXHJcbiAqICAtIHByZXZOYW1lIHdpbGwgYmUgY2FsY3VsYXRlZCBiYXNlZCBvbiB0aGUgaW5kZXggb3JkZXJpbmcuXHJcbiAqL1xyXG5mdW5jdGlvbiBldmVudEdlbmVyYXRvckdlbmVyYXRlRXZlbnRzRm9yQ2hhbmdlcyhldmVudEdlbmVyYXRvciwgY2hhbmdlcywgZXZlbnRDYWNoZSwgZXZlbnRSZWdpc3RyYXRpb25zKSB7XHJcbiAgICBjb25zdCBldmVudHMgPSBbXTtcclxuICAgIGNvbnN0IG1vdmVzID0gW107XHJcbiAgICBjaGFuZ2VzLmZvckVhY2goY2hhbmdlID0+IHtcclxuICAgICAgICBpZiAoY2hhbmdlLnR5cGUgPT09IFwiY2hpbGRfY2hhbmdlZFwiIC8qIENISUxEX0NIQU5HRUQgKi8gJiZcclxuICAgICAgICAgICAgZXZlbnRHZW5lcmF0b3IuaW5kZXhfLmluZGV4ZWRWYWx1ZUNoYW5nZWQoY2hhbmdlLm9sZFNuYXAsIGNoYW5nZS5zbmFwc2hvdE5vZGUpKSB7XHJcbiAgICAgICAgICAgIG1vdmVzLnB1c2goY2hhbmdlQ2hpbGRNb3ZlZChjaGFuZ2UuY2hpbGROYW1lLCBjaGFuZ2Uuc25hcHNob3ROb2RlKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICBldmVudEdlbmVyYXRvckdlbmVyYXRlRXZlbnRzRm9yVHlwZShldmVudEdlbmVyYXRvciwgZXZlbnRzLCBcImNoaWxkX3JlbW92ZWRcIiAvKiBDSElMRF9SRU1PVkVEICovLCBjaGFuZ2VzLCBldmVudFJlZ2lzdHJhdGlvbnMsIGV2ZW50Q2FjaGUpO1xyXG4gICAgZXZlbnRHZW5lcmF0b3JHZW5lcmF0ZUV2ZW50c0ZvclR5cGUoZXZlbnRHZW5lcmF0b3IsIGV2ZW50cywgXCJjaGlsZF9hZGRlZFwiIC8qIENISUxEX0FEREVEICovLCBjaGFuZ2VzLCBldmVudFJlZ2lzdHJhdGlvbnMsIGV2ZW50Q2FjaGUpO1xyXG4gICAgZXZlbnRHZW5lcmF0b3JHZW5lcmF0ZUV2ZW50c0ZvclR5cGUoZXZlbnRHZW5lcmF0b3IsIGV2ZW50cywgXCJjaGlsZF9tb3ZlZFwiIC8qIENISUxEX01PVkVEICovLCBtb3ZlcywgZXZlbnRSZWdpc3RyYXRpb25zLCBldmVudENhY2hlKTtcclxuICAgIGV2ZW50R2VuZXJhdG9yR2VuZXJhdGVFdmVudHNGb3JUeXBlKGV2ZW50R2VuZXJhdG9yLCBldmVudHMsIFwiY2hpbGRfY2hhbmdlZFwiIC8qIENISUxEX0NIQU5HRUQgKi8sIGNoYW5nZXMsIGV2ZW50UmVnaXN0cmF0aW9ucywgZXZlbnRDYWNoZSk7XHJcbiAgICBldmVudEdlbmVyYXRvckdlbmVyYXRlRXZlbnRzRm9yVHlwZShldmVudEdlbmVyYXRvciwgZXZlbnRzLCBcInZhbHVlXCIgLyogVkFMVUUgKi8sIGNoYW5nZXMsIGV2ZW50UmVnaXN0cmF0aW9ucywgZXZlbnRDYWNoZSk7XHJcbiAgICByZXR1cm4gZXZlbnRzO1xyXG59XHJcbi8qKlxyXG4gKiBHaXZlbiBjaGFuZ2VzIG9mIGEgc2luZ2xlIGNoYW5nZSB0eXBlLCBnZW5lcmF0ZSB0aGUgY29ycmVzcG9uZGluZyBldmVudHMuXHJcbiAqL1xyXG5mdW5jdGlvbiBldmVudEdlbmVyYXRvckdlbmVyYXRlRXZlbnRzRm9yVHlwZShldmVudEdlbmVyYXRvciwgZXZlbnRzLCBldmVudFR5cGUsIGNoYW5nZXMsIHJlZ2lzdHJhdGlvbnMsIGV2ZW50Q2FjaGUpIHtcclxuICAgIGNvbnN0IGZpbHRlcmVkQ2hhbmdlcyA9IGNoYW5nZXMuZmlsdGVyKGNoYW5nZSA9PiBjaGFuZ2UudHlwZSA9PT0gZXZlbnRUeXBlKTtcclxuICAgIGZpbHRlcmVkQ2hhbmdlcy5zb3J0KChhLCBiKSA9PiBldmVudEdlbmVyYXRvckNvbXBhcmVDaGFuZ2VzKGV2ZW50R2VuZXJhdG9yLCBhLCBiKSk7XHJcbiAgICBmaWx0ZXJlZENoYW5nZXMuZm9yRWFjaChjaGFuZ2UgPT4ge1xyXG4gICAgICAgIGNvbnN0IG1hdGVyaWFsaXplZENoYW5nZSA9IGV2ZW50R2VuZXJhdG9yTWF0ZXJpYWxpemVTaW5nbGVDaGFuZ2UoZXZlbnRHZW5lcmF0b3IsIGNoYW5nZSwgZXZlbnRDYWNoZSk7XHJcbiAgICAgICAgcmVnaXN0cmF0aW9ucy5mb3JFYWNoKHJlZ2lzdHJhdGlvbiA9PiB7XHJcbiAgICAgICAgICAgIGlmIChyZWdpc3RyYXRpb24ucmVzcG9uZHNUbyhjaGFuZ2UudHlwZSkpIHtcclxuICAgICAgICAgICAgICAgIGV2ZW50cy5wdXNoKHJlZ2lzdHJhdGlvbi5jcmVhdGVFdmVudChtYXRlcmlhbGl6ZWRDaGFuZ2UsIGV2ZW50R2VuZXJhdG9yLnF1ZXJ5XykpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTtcclxufVxyXG5mdW5jdGlvbiBldmVudEdlbmVyYXRvck1hdGVyaWFsaXplU2luZ2xlQ2hhbmdlKGV2ZW50R2VuZXJhdG9yLCBjaGFuZ2UsIGV2ZW50Q2FjaGUpIHtcclxuICAgIGlmIChjaGFuZ2UudHlwZSA9PT0gJ3ZhbHVlJyB8fCBjaGFuZ2UudHlwZSA9PT0gJ2NoaWxkX3JlbW92ZWQnKSB7XHJcbiAgICAgICAgcmV0dXJuIGNoYW5nZTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGNoYW5nZS5wcmV2TmFtZSA9IGV2ZW50Q2FjaGUuZ2V0UHJlZGVjZXNzb3JDaGlsZE5hbWUoY2hhbmdlLmNoaWxkTmFtZSwgY2hhbmdlLnNuYXBzaG90Tm9kZSwgZXZlbnRHZW5lcmF0b3IuaW5kZXhfKTtcclxuICAgICAgICByZXR1cm4gY2hhbmdlO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGV2ZW50R2VuZXJhdG9yQ29tcGFyZUNoYW5nZXMoZXZlbnRHZW5lcmF0b3IsIGEsIGIpIHtcclxuICAgIGlmIChhLmNoaWxkTmFtZSA9PSBudWxsIHx8IGIuY2hpbGROYW1lID09IG51bGwpIHtcclxuICAgICAgICB0aHJvdyBhc3NlcnRpb25FcnJvcignU2hvdWxkIG9ubHkgY29tcGFyZSBjaGlsZF8gZXZlbnRzLicpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgYVdyYXBwZWQgPSBuZXcgTmFtZWROb2RlKGEuY2hpbGROYW1lLCBhLnNuYXBzaG90Tm9kZSk7XHJcbiAgICBjb25zdCBiV3JhcHBlZCA9IG5ldyBOYW1lZE5vZGUoYi5jaGlsZE5hbWUsIGIuc25hcHNob3ROb2RlKTtcclxuICAgIHJldHVybiBldmVudEdlbmVyYXRvci5pbmRleF8uY29tcGFyZShhV3JhcHBlZCwgYldyYXBwZWQpO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmZ1bmN0aW9uIG5ld1ZpZXdDYWNoZShldmVudENhY2hlLCBzZXJ2ZXJDYWNoZSkge1xyXG4gICAgcmV0dXJuIHsgZXZlbnRDYWNoZSwgc2VydmVyQ2FjaGUgfTtcclxufVxyXG5mdW5jdGlvbiB2aWV3Q2FjaGVVcGRhdGVFdmVudFNuYXAodmlld0NhY2hlLCBldmVudFNuYXAsIGNvbXBsZXRlLCBmaWx0ZXJlZCkge1xyXG4gICAgcmV0dXJuIG5ld1ZpZXdDYWNoZShuZXcgQ2FjaGVOb2RlKGV2ZW50U25hcCwgY29tcGxldGUsIGZpbHRlcmVkKSwgdmlld0NhY2hlLnNlcnZlckNhY2hlKTtcclxufVxyXG5mdW5jdGlvbiB2aWV3Q2FjaGVVcGRhdGVTZXJ2ZXJTbmFwKHZpZXdDYWNoZSwgc2VydmVyU25hcCwgY29tcGxldGUsIGZpbHRlcmVkKSB7XHJcbiAgICByZXR1cm4gbmV3Vmlld0NhY2hlKHZpZXdDYWNoZS5ldmVudENhY2hlLCBuZXcgQ2FjaGVOb2RlKHNlcnZlclNuYXAsIGNvbXBsZXRlLCBmaWx0ZXJlZCkpO1xyXG59XHJcbmZ1bmN0aW9uIHZpZXdDYWNoZUdldENvbXBsZXRlRXZlbnRTbmFwKHZpZXdDYWNoZSkge1xyXG4gICAgcmV0dXJuIHZpZXdDYWNoZS5ldmVudENhY2hlLmlzRnVsbHlJbml0aWFsaXplZCgpXHJcbiAgICAgICAgPyB2aWV3Q2FjaGUuZXZlbnRDYWNoZS5nZXROb2RlKClcclxuICAgICAgICA6IG51bGw7XHJcbn1cclxuZnVuY3Rpb24gdmlld0NhY2hlR2V0Q29tcGxldGVTZXJ2ZXJTbmFwKHZpZXdDYWNoZSkge1xyXG4gICAgcmV0dXJuIHZpZXdDYWNoZS5zZXJ2ZXJDYWNoZS5pc0Z1bGx5SW5pdGlhbGl6ZWQoKVxyXG4gICAgICAgID8gdmlld0NhY2hlLnNlcnZlckNhY2hlLmdldE5vZGUoKVxyXG4gICAgICAgIDogbnVsbDtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5sZXQgZW1wdHlDaGlsZHJlblNpbmdsZXRvbjtcclxuLyoqXHJcbiAqIFNpbmdsZXRvbiBlbXB0eSBjaGlsZHJlbiBjb2xsZWN0aW9uLlxyXG4gKlxyXG4gKi9cclxuY29uc3QgRW1wdHlDaGlsZHJlbiA9ICgpID0+IHtcclxuICAgIGlmICghZW1wdHlDaGlsZHJlblNpbmdsZXRvbikge1xyXG4gICAgICAgIGVtcHR5Q2hpbGRyZW5TaW5nbGV0b24gPSBuZXcgU29ydGVkTWFwKHN0cmluZ0NvbXBhcmUpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGVtcHR5Q2hpbGRyZW5TaW5nbGV0b247XHJcbn07XHJcbi8qKlxyXG4gKiBBIHRyZWUgd2l0aCBpbW11dGFibGUgZWxlbWVudHMuXHJcbiAqL1xyXG5jbGFzcyBJbW11dGFibGVUcmVlIHtcclxuICAgIGNvbnN0cnVjdG9yKHZhbHVlLCBjaGlsZHJlbiA9IEVtcHR5Q2hpbGRyZW4oKSkge1xyXG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcclxuICAgICAgICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW47XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgZnJvbU9iamVjdChvYmopIHtcclxuICAgICAgICBsZXQgdHJlZSA9IG5ldyBJbW11dGFibGVUcmVlKG51bGwpO1xyXG4gICAgICAgIGVhY2gob2JqLCAoY2hpbGRQYXRoLCBjaGlsZFNuYXApID0+IHtcclxuICAgICAgICAgICAgdHJlZSA9IHRyZWUuc2V0KG5ldyBQYXRoKGNoaWxkUGF0aCksIGNoaWxkU25hcCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHRyZWU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRydWUgaWYgdGhlIHZhbHVlIGlzIGVtcHR5IGFuZCB0aGVyZSBhcmUgbm8gY2hpbGRyZW5cclxuICAgICAqL1xyXG4gICAgaXNFbXB0eSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZSA9PT0gbnVsbCAmJiB0aGlzLmNoaWxkcmVuLmlzRW1wdHkoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2l2ZW4gYSBwYXRoIGFuZCBwcmVkaWNhdGUsIHJldHVybiB0aGUgZmlyc3Qgbm9kZSBhbmQgdGhlIHBhdGggdG8gdGhhdCBub2RlXHJcbiAgICAgKiB3aGVyZSB0aGUgcHJlZGljYXRlIHJldHVybnMgdHJ1ZS5cclxuICAgICAqXHJcbiAgICAgKiBUT0RPIERvIGEgcGVyZiB0ZXN0IC0tIElmIHdlJ3JlIGNyZWF0aW5nIGEgYnVuY2ggb2YgYHtwYXRoOiB2YWx1ZTp9YFxyXG4gICAgICogb2JqZWN0cyBvbiB0aGUgd2F5IGJhY2sgb3V0LCBpdCBtYXkgYmUgYmV0dGVyIHRvIHBhc3MgZG93biBhIHBhdGhTb0ZhciBvYmouXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHJlbGF0aXZlUGF0aCAtIFRoZSByZW1haW5kZXIgb2YgdGhlIHBhdGhcclxuICAgICAqIEBwYXJhbSBwcmVkaWNhdGUgLSBUaGUgcHJlZGljYXRlIHRvIHNhdGlzZnkgdG8gcmV0dXJuIGEgbm9kZVxyXG4gICAgICovXHJcbiAgICBmaW5kUm9vdE1vc3RNYXRjaGluZ1BhdGhBbmRWYWx1ZShyZWxhdGl2ZVBhdGgsIHByZWRpY2F0ZSkge1xyXG4gICAgICAgIGlmICh0aGlzLnZhbHVlICE9IG51bGwgJiYgcHJlZGljYXRlKHRoaXMudmFsdWUpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7IHBhdGg6IG5ld0VtcHR5UGF0aCgpLCB2YWx1ZTogdGhpcy52YWx1ZSB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKHBhdGhJc0VtcHR5KHJlbGF0aXZlUGF0aCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZnJvbnQgPSBwYXRoR2V0RnJvbnQocmVsYXRpdmVQYXRoKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkID0gdGhpcy5jaGlsZHJlbi5nZXQoZnJvbnQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2hpbGRFeGlzdGluZ1BhdGhBbmRWYWx1ZSA9IGNoaWxkLmZpbmRSb290TW9zdE1hdGNoaW5nUGF0aEFuZFZhbHVlKHBhdGhQb3BGcm9udChyZWxhdGl2ZVBhdGgpLCBwcmVkaWNhdGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZEV4aXN0aW5nUGF0aEFuZFZhbHVlICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZnVsbFBhdGggPSBwYXRoQ2hpbGQobmV3IFBhdGgoZnJvbnQpLCBjaGlsZEV4aXN0aW5nUGF0aEFuZFZhbHVlLnBhdGgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBwYXRoOiBmdWxsUGF0aCwgdmFsdWU6IGNoaWxkRXhpc3RpbmdQYXRoQW5kVmFsdWUudmFsdWUgfTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBGaW5kLCBpZiBpdCBleGlzdHMsIHRoZSBzaG9ydGVzdCBzdWJwYXRoIG9mIHRoZSBnaXZlbiBwYXRoIHRoYXQgcG9pbnRzIGEgZGVmaW5lZFxyXG4gICAgICogdmFsdWUgaW4gdGhlIHRyZWVcclxuICAgICAqL1xyXG4gICAgZmluZFJvb3RNb3N0VmFsdWVBbmRQYXRoKHJlbGF0aXZlUGF0aCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmZpbmRSb290TW9zdE1hdGNoaW5nUGF0aEFuZFZhbHVlKHJlbGF0aXZlUGF0aCwgKCkgPT4gdHJ1ZSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm5zIFRoZSBzdWJ0cmVlIGF0IHRoZSBnaXZlbiBwYXRoXHJcbiAgICAgKi9cclxuICAgIHN1YnRyZWUocmVsYXRpdmVQYXRoKSB7XHJcbiAgICAgICAgaWYgKHBhdGhJc0VtcHR5KHJlbGF0aXZlUGF0aCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCBmcm9udCA9IHBhdGhHZXRGcm9udChyZWxhdGl2ZVBhdGgpO1xyXG4gICAgICAgICAgICBjb25zdCBjaGlsZFRyZWUgPSB0aGlzLmNoaWxkcmVuLmdldChmcm9udCk7XHJcbiAgICAgICAgICAgIGlmIChjaGlsZFRyZWUgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjaGlsZFRyZWUuc3VidHJlZShwYXRoUG9wRnJvbnQocmVsYXRpdmVQYXRoKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEltbXV0YWJsZVRyZWUobnVsbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNldHMgYSB2YWx1ZSBhdCB0aGUgc3BlY2lmaWVkIHBhdGguXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHJlbGF0aXZlUGF0aCAtIFBhdGggdG8gc2V0IHZhbHVlIGF0LlxyXG4gICAgICogQHBhcmFtIHRvU2V0IC0gVmFsdWUgdG8gc2V0LlxyXG4gICAgICogQHJldHVybnMgUmVzdWx0aW5nIHRyZWUuXHJcbiAgICAgKi9cclxuICAgIHNldChyZWxhdGl2ZVBhdGgsIHRvU2V0KSB7XHJcbiAgICAgICAgaWYgKHBhdGhJc0VtcHR5KHJlbGF0aXZlUGF0aCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBJbW11dGFibGVUcmVlKHRvU2V0LCB0aGlzLmNoaWxkcmVuKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGZyb250ID0gcGF0aEdldEZyb250KHJlbGF0aXZlUGF0aCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkID0gdGhpcy5jaGlsZHJlbi5nZXQoZnJvbnQpIHx8IG5ldyBJbW11dGFibGVUcmVlKG51bGwpO1xyXG4gICAgICAgICAgICBjb25zdCBuZXdDaGlsZCA9IGNoaWxkLnNldChwYXRoUG9wRnJvbnQocmVsYXRpdmVQYXRoKSwgdG9TZXQpO1xyXG4gICAgICAgICAgICBjb25zdCBuZXdDaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW4uaW5zZXJ0KGZyb250LCBuZXdDaGlsZCk7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgSW1tdXRhYmxlVHJlZSh0aGlzLnZhbHVlLCBuZXdDaGlsZHJlbik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmVzIHRoZSB2YWx1ZSBhdCB0aGUgc3BlY2lmaWVkIHBhdGguXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHJlbGF0aXZlUGF0aCAtIFBhdGggdG8gdmFsdWUgdG8gcmVtb3ZlLlxyXG4gICAgICogQHJldHVybnMgUmVzdWx0aW5nIHRyZWUuXHJcbiAgICAgKi9cclxuICAgIHJlbW92ZShyZWxhdGl2ZVBhdGgpIHtcclxuICAgICAgICBpZiAocGF0aElzRW1wdHkocmVsYXRpdmVQYXRoKSkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5jaGlsZHJlbi5pc0VtcHR5KCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgSW1tdXRhYmxlVHJlZShudWxsKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgSW1tdXRhYmxlVHJlZShudWxsLCB0aGlzLmNoaWxkcmVuKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3QgZnJvbnQgPSBwYXRoR2V0RnJvbnQocmVsYXRpdmVQYXRoKTtcclxuICAgICAgICAgICAgY29uc3QgY2hpbGQgPSB0aGlzLmNoaWxkcmVuLmdldChmcm9udCk7XHJcbiAgICAgICAgICAgIGlmIChjaGlsZCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbmV3Q2hpbGQgPSBjaGlsZC5yZW1vdmUocGF0aFBvcEZyb250KHJlbGF0aXZlUGF0aCkpO1xyXG4gICAgICAgICAgICAgICAgbGV0IG5ld0NoaWxkcmVuO1xyXG4gICAgICAgICAgICAgICAgaWYgKG5ld0NoaWxkLmlzRW1wdHkoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG5ld0NoaWxkcmVuID0gdGhpcy5jaGlsZHJlbi5yZW1vdmUoZnJvbnQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3Q2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuLmluc2VydChmcm9udCwgbmV3Q2hpbGQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudmFsdWUgPT09IG51bGwgJiYgbmV3Q2hpbGRyZW4uaXNFbXB0eSgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBJbW11dGFibGVUcmVlKG51bGwpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBJbW11dGFibGVUcmVlKHRoaXMudmFsdWUsIG5ld0NoaWxkcmVuKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIGEgdmFsdWUgZnJvbSB0aGUgdHJlZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gcmVsYXRpdmVQYXRoIC0gUGF0aCB0byBnZXQgdmFsdWUgZm9yLlxyXG4gICAgICogQHJldHVybnMgVmFsdWUgYXQgcGF0aCwgb3IgbnVsbC5cclxuICAgICAqL1xyXG4gICAgZ2V0KHJlbGF0aXZlUGF0aCkge1xyXG4gICAgICAgIGlmIChwYXRoSXNFbXB0eShyZWxhdGl2ZVBhdGgpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3QgZnJvbnQgPSBwYXRoR2V0RnJvbnQocmVsYXRpdmVQYXRoKTtcclxuICAgICAgICAgICAgY29uc3QgY2hpbGQgPSB0aGlzLmNoaWxkcmVuLmdldChmcm9udCk7XHJcbiAgICAgICAgICAgIGlmIChjaGlsZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkLmdldChwYXRoUG9wRnJvbnQocmVsYXRpdmVQYXRoKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmVwbGFjZSB0aGUgc3VidHJlZSBhdCB0aGUgc3BlY2lmaWVkIHBhdGggd2l0aCB0aGUgZ2l2ZW4gbmV3IHRyZWUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHJlbGF0aXZlUGF0aCAtIFBhdGggdG8gcmVwbGFjZSBzdWJ0cmVlIGZvci5cclxuICAgICAqIEBwYXJhbSBuZXdUcmVlIC0gTmV3IHRyZWUuXHJcbiAgICAgKiBAcmV0dXJucyBSZXN1bHRpbmcgdHJlZS5cclxuICAgICAqL1xyXG4gICAgc2V0VHJlZShyZWxhdGl2ZVBhdGgsIG5ld1RyZWUpIHtcclxuICAgICAgICBpZiAocGF0aElzRW1wdHkocmVsYXRpdmVQYXRoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3VHJlZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGZyb250ID0gcGF0aEdldEZyb250KHJlbGF0aXZlUGF0aCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkID0gdGhpcy5jaGlsZHJlbi5nZXQoZnJvbnQpIHx8IG5ldyBJbW11dGFibGVUcmVlKG51bGwpO1xyXG4gICAgICAgICAgICBjb25zdCBuZXdDaGlsZCA9IGNoaWxkLnNldFRyZWUocGF0aFBvcEZyb250KHJlbGF0aXZlUGF0aCksIG5ld1RyZWUpO1xyXG4gICAgICAgICAgICBsZXQgbmV3Q2hpbGRyZW47XHJcbiAgICAgICAgICAgIGlmIChuZXdDaGlsZC5pc0VtcHR5KCkpIHtcclxuICAgICAgICAgICAgICAgIG5ld0NoaWxkcmVuID0gdGhpcy5jaGlsZHJlbi5yZW1vdmUoZnJvbnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbmV3Q2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuLmluc2VydChmcm9udCwgbmV3Q2hpbGQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgSW1tdXRhYmxlVHJlZSh0aGlzLnZhbHVlLCBuZXdDaGlsZHJlbik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBQZXJmb3JtcyBhIGRlcHRoIGZpcnN0IGZvbGQgb24gdGhpcyB0cmVlLiBUcmFuc2Zvcm1zIGEgdHJlZSBpbnRvIGEgc2luZ2xlXHJcbiAgICAgKiB2YWx1ZSwgZ2l2ZW4gYSBmdW5jdGlvbiB0aGF0IG9wZXJhdGVzIG9uIHRoZSBwYXRoIHRvIGEgbm9kZSwgYW4gb3B0aW9uYWxcclxuICAgICAqIGN1cnJlbnQgdmFsdWUsIGFuZCBhIG1hcCBvZiBjaGlsZCBuYW1lcyB0byBmb2xkZWQgc3VidHJlZXNcclxuICAgICAqL1xyXG4gICAgZm9sZChmbikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmZvbGRfKG5ld0VtcHR5UGF0aCgpLCBmbik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlY3Vyc2l2ZSBoZWxwZXIgZm9yIHB1YmxpYy1mYWNpbmcgZm9sZCgpIG1ldGhvZFxyXG4gICAgICovXHJcbiAgICBmb2xkXyhwYXRoU29GYXIsIGZuKSB7XHJcbiAgICAgICAgY29uc3QgYWNjdW0gPSB7fTtcclxuICAgICAgICB0aGlzLmNoaWxkcmVuLmlub3JkZXJUcmF2ZXJzYWwoKGNoaWxkS2V5LCBjaGlsZFRyZWUpID0+IHtcclxuICAgICAgICAgICAgYWNjdW1bY2hpbGRLZXldID0gY2hpbGRUcmVlLmZvbGRfKHBhdGhDaGlsZChwYXRoU29GYXIsIGNoaWxkS2V5KSwgZm4pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBmbihwYXRoU29GYXIsIHRoaXMudmFsdWUsIGFjY3VtKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRmluZCB0aGUgZmlyc3QgbWF0Y2hpbmcgdmFsdWUgb24gdGhlIGdpdmVuIHBhdGguIFJldHVybiB0aGUgcmVzdWx0IG9mIGFwcGx5aW5nIGYgdG8gaXQuXHJcbiAgICAgKi9cclxuICAgIGZpbmRPblBhdGgocGF0aCwgZikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmZpbmRPblBhdGhfKHBhdGgsIG5ld0VtcHR5UGF0aCgpLCBmKTtcclxuICAgIH1cclxuICAgIGZpbmRPblBhdGhfKHBhdGhUb0ZvbGxvdywgcGF0aFNvRmFyLCBmKSB7XHJcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy52YWx1ZSA/IGYocGF0aFNvRmFyLCB0aGlzLnZhbHVlKSA6IGZhbHNlO1xyXG4gICAgICAgIGlmIChyZXN1bHQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmIChwYXRoSXNFbXB0eShwYXRoVG9Gb2xsb3cpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGZyb250ID0gcGF0aEdldEZyb250KHBhdGhUb0ZvbGxvdyk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBuZXh0Q2hpbGQgPSB0aGlzLmNoaWxkcmVuLmdldChmcm9udCk7XHJcbiAgICAgICAgICAgICAgICBpZiAobmV4dENoaWxkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5leHRDaGlsZC5maW5kT25QYXRoXyhwYXRoUG9wRnJvbnQocGF0aFRvRm9sbG93KSwgcGF0aENoaWxkKHBhdGhTb0ZhciwgZnJvbnQpLCBmKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZm9yZWFjaE9uUGF0aChwYXRoLCBmKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZm9yZWFjaE9uUGF0aF8ocGF0aCwgbmV3RW1wdHlQYXRoKCksIGYpO1xyXG4gICAgfVxyXG4gICAgZm9yZWFjaE9uUGF0aF8ocGF0aFRvRm9sbG93LCBjdXJyZW50UmVsYXRpdmVQYXRoLCBmKSB7XHJcbiAgICAgICAgaWYgKHBhdGhJc0VtcHR5KHBhdGhUb0ZvbGxvdykpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAodGhpcy52YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgZihjdXJyZW50UmVsYXRpdmVQYXRoLCB0aGlzLnZhbHVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBmcm9udCA9IHBhdGhHZXRGcm9udChwYXRoVG9Gb2xsb3cpO1xyXG4gICAgICAgICAgICBjb25zdCBuZXh0Q2hpbGQgPSB0aGlzLmNoaWxkcmVuLmdldChmcm9udCk7XHJcbiAgICAgICAgICAgIGlmIChuZXh0Q2hpbGQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXh0Q2hpbGQuZm9yZWFjaE9uUGF0aF8ocGF0aFBvcEZyb250KHBhdGhUb0ZvbGxvdyksIHBhdGhDaGlsZChjdXJyZW50UmVsYXRpdmVQYXRoLCBmcm9udCksIGYpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBJbW11dGFibGVUcmVlKG51bGwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxscyB0aGUgZ2l2ZW4gZnVuY3Rpb24gZm9yIGVhY2ggbm9kZSBpbiB0aGUgdHJlZSB0aGF0IGhhcyBhIHZhbHVlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBmIC0gQSBmdW5jdGlvbiB0byBiZSBjYWxsZWQgd2l0aCB0aGUgcGF0aCBmcm9tIHRoZSByb290IG9mIHRoZSB0cmVlIHRvXHJcbiAgICAgKiBhIG5vZGUsIGFuZCB0aGUgdmFsdWUgYXQgdGhhdCBub2RlLiBDYWxsZWQgaW4gZGVwdGgtZmlyc3Qgb3JkZXIuXHJcbiAgICAgKi9cclxuICAgIGZvcmVhY2goZikge1xyXG4gICAgICAgIHRoaXMuZm9yZWFjaF8obmV3RW1wdHlQYXRoKCksIGYpO1xyXG4gICAgfVxyXG4gICAgZm9yZWFjaF8oY3VycmVudFJlbGF0aXZlUGF0aCwgZikge1xyXG4gICAgICAgIHRoaXMuY2hpbGRyZW4uaW5vcmRlclRyYXZlcnNhbCgoY2hpbGROYW1lLCBjaGlsZFRyZWUpID0+IHtcclxuICAgICAgICAgICAgY2hpbGRUcmVlLmZvcmVhY2hfKHBhdGhDaGlsZChjdXJyZW50UmVsYXRpdmVQYXRoLCBjaGlsZE5hbWUpLCBmKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAodGhpcy52YWx1ZSkge1xyXG4gICAgICAgICAgICBmKGN1cnJlbnRSZWxhdGl2ZVBhdGgsIHRoaXMudmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZvcmVhY2hDaGlsZChmKSB7XHJcbiAgICAgICAgdGhpcy5jaGlsZHJlbi5pbm9yZGVyVHJhdmVyc2FsKChjaGlsZE5hbWUsIGNoaWxkVHJlZSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoY2hpbGRUcmVlLnZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICBmKGNoaWxkTmFtZSwgY2hpbGRUcmVlLnZhbHVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBUaGlzIGNsYXNzIGhvbGRzIGEgY29sbGVjdGlvbiBvZiB3cml0ZXMgdGhhdCBjYW4gYmUgYXBwbGllZCB0byBub2RlcyBpbiB1bmlzb24uIEl0IGFic3RyYWN0cyBhd2F5IHRoZSBsb2dpYyB3aXRoXHJcbiAqIGRlYWxpbmcgd2l0aCBwcmlvcml0eSB3cml0ZXMgYW5kIG11bHRpcGxlIG5lc3RlZCB3cml0ZXMuIEF0IGFueSBnaXZlbiBwYXRoIHRoZXJlIGlzIG9ubHkgYWxsb3dlZCB0byBiZSBvbmUgd3JpdGVcclxuICogbW9kaWZ5aW5nIHRoYXQgcGF0aC4gQW55IHdyaXRlIHRvIGFuIGV4aXN0aW5nIHBhdGggb3Igc2hhZG93aW5nIGFuIGV4aXN0aW5nIHBhdGggd2lsbCBtb2RpZnkgdGhhdCBleGlzdGluZyB3cml0ZVxyXG4gKiB0byByZWZsZWN0IHRoZSB3cml0ZSBhZGRlZC5cclxuICovXHJcbmNsYXNzIENvbXBvdW5kV3JpdGUge1xyXG4gICAgY29uc3RydWN0b3Iod3JpdGVUcmVlXykge1xyXG4gICAgICAgIHRoaXMud3JpdGVUcmVlXyA9IHdyaXRlVHJlZV87XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgZW1wdHkoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBDb21wb3VuZFdyaXRlKG5ldyBJbW11dGFibGVUcmVlKG51bGwpKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBjb21wb3VuZFdyaXRlQWRkV3JpdGUoY29tcG91bmRXcml0ZSwgcGF0aCwgbm9kZSkge1xyXG4gICAgaWYgKHBhdGhJc0VtcHR5KHBhdGgpKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBDb21wb3VuZFdyaXRlKG5ldyBJbW11dGFibGVUcmVlKG5vZGUpKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGNvbnN0IHJvb3Rtb3N0ID0gY29tcG91bmRXcml0ZS53cml0ZVRyZWVfLmZpbmRSb290TW9zdFZhbHVlQW5kUGF0aChwYXRoKTtcclxuICAgICAgICBpZiAocm9vdG1vc3QgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICBjb25zdCByb290TW9zdFBhdGggPSByb290bW9zdC5wYXRoO1xyXG4gICAgICAgICAgICBsZXQgdmFsdWUgPSByb290bW9zdC52YWx1ZTtcclxuICAgICAgICAgICAgY29uc3QgcmVsYXRpdmVQYXRoID0gbmV3UmVsYXRpdmVQYXRoKHJvb3RNb3N0UGF0aCwgcGF0aCk7XHJcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUudXBkYXRlQ2hpbGQocmVsYXRpdmVQYXRoLCBub2RlKTtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBDb21wb3VuZFdyaXRlKGNvbXBvdW5kV3JpdGUud3JpdGVUcmVlXy5zZXQocm9vdE1vc3RQYXRoLCB2YWx1ZSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3Qgc3VidHJlZSA9IG5ldyBJbW11dGFibGVUcmVlKG5vZGUpO1xyXG4gICAgICAgICAgICBjb25zdCBuZXdXcml0ZVRyZWUgPSBjb21wb3VuZFdyaXRlLndyaXRlVHJlZV8uc2V0VHJlZShwYXRoLCBzdWJ0cmVlKTtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBDb21wb3VuZFdyaXRlKG5ld1dyaXRlVHJlZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGNvbXBvdW5kV3JpdGVBZGRXcml0ZXMoY29tcG91bmRXcml0ZSwgcGF0aCwgdXBkYXRlcykge1xyXG4gICAgbGV0IG5ld1dyaXRlID0gY29tcG91bmRXcml0ZTtcclxuICAgIGVhY2godXBkYXRlcywgKGNoaWxkS2V5LCBub2RlKSA9PiB7XHJcbiAgICAgICAgbmV3V3JpdGUgPSBjb21wb3VuZFdyaXRlQWRkV3JpdGUobmV3V3JpdGUsIHBhdGhDaGlsZChwYXRoLCBjaGlsZEtleSksIG5vZGUpO1xyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gbmV3V3JpdGU7XHJcbn1cclxuLyoqXHJcbiAqIFdpbGwgcmVtb3ZlIGEgd3JpdGUgYXQgdGhlIGdpdmVuIHBhdGggYW5kIGRlZXBlciBwYXRocy4gVGhpcyB3aWxsIDxlbT5ub3Q8L2VtPiBtb2RpZnkgYSB3cml0ZSBhdCBhIGhpZ2hlclxyXG4gKiBsb2NhdGlvbiwgd2hpY2ggbXVzdCBiZSByZW1vdmVkIGJ5IGNhbGxpbmcgdGhpcyBtZXRob2Qgd2l0aCB0aGF0IHBhdGguXHJcbiAqXHJcbiAqIEBwYXJhbSBjb21wb3VuZFdyaXRlIC0gVGhlIENvbXBvdW5kV3JpdGUgdG8gcmVtb3ZlLlxyXG4gKiBAcGFyYW0gcGF0aCAtIFRoZSBwYXRoIGF0IHdoaWNoIGEgd3JpdGUgYW5kIGFsbCBkZWVwZXIgd3JpdGVzIHNob3VsZCBiZSByZW1vdmVkXHJcbiAqIEByZXR1cm5zIFRoZSBuZXcgQ29tcG91bmRXcml0ZSB3aXRoIHRoZSByZW1vdmVkIHBhdGhcclxuICovXHJcbmZ1bmN0aW9uIGNvbXBvdW5kV3JpdGVSZW1vdmVXcml0ZShjb21wb3VuZFdyaXRlLCBwYXRoKSB7XHJcbiAgICBpZiAocGF0aElzRW1wdHkocGF0aCkpIHtcclxuICAgICAgICByZXR1cm4gQ29tcG91bmRXcml0ZS5lbXB0eSgpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgY29uc3QgbmV3V3JpdGVUcmVlID0gY29tcG91bmRXcml0ZS53cml0ZVRyZWVfLnNldFRyZWUocGF0aCwgbmV3IEltbXV0YWJsZVRyZWUobnVsbCkpO1xyXG4gICAgICAgIHJldHVybiBuZXcgQ29tcG91bmRXcml0ZShuZXdXcml0ZVRyZWUpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm5zIHdoZXRoZXIgdGhpcyBDb21wb3VuZFdyaXRlIHdpbGwgZnVsbHkgb3ZlcndyaXRlIGEgbm9kZSBhdCBhIGdpdmVuIGxvY2F0aW9uIGFuZCBjYW4gdGhlcmVmb3JlIGJlXHJcbiAqIGNvbnNpZGVyZWQgXCJjb21wbGV0ZVwiLlxyXG4gKlxyXG4gKiBAcGFyYW0gY29tcG91bmRXcml0ZSAtIFRoZSBDb21wb3VuZFdyaXRlIHRvIGNoZWNrLlxyXG4gKiBAcGFyYW0gcGF0aCAtIFRoZSBwYXRoIHRvIGNoZWNrIGZvclxyXG4gKiBAcmV0dXJucyBXaGV0aGVyIHRoZXJlIGlzIGEgY29tcGxldGUgd3JpdGUgYXQgdGhhdCBwYXRoXHJcbiAqL1xyXG5mdW5jdGlvbiBjb21wb3VuZFdyaXRlSGFzQ29tcGxldGVXcml0ZShjb21wb3VuZFdyaXRlLCBwYXRoKSB7XHJcbiAgICByZXR1cm4gY29tcG91bmRXcml0ZUdldENvbXBsZXRlTm9kZShjb21wb3VuZFdyaXRlLCBwYXRoKSAhPSBudWxsO1xyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm5zIGEgbm9kZSBmb3IgYSBwYXRoIGlmIGFuZCBvbmx5IGlmIHRoZSBub2RlIGlzIGEgXCJjb21wbGV0ZVwiIG92ZXJ3cml0ZSBhdCB0aGF0IHBhdGguIFRoaXMgd2lsbCBub3QgYWdncmVnYXRlXHJcbiAqIHdyaXRlcyBmcm9tIGRlZXBlciBwYXRocywgYnV0IHdpbGwgcmV0dXJuIGNoaWxkIG5vZGVzIGZyb20gYSBtb3JlIHNoYWxsb3cgcGF0aC5cclxuICpcclxuICogQHBhcmFtIGNvbXBvdW5kV3JpdGUgLSBUaGUgQ29tcG91bmRXcml0ZSB0byBnZXQgdGhlIG5vZGUgZnJvbS5cclxuICogQHBhcmFtIHBhdGggLSBUaGUgcGF0aCB0byBnZXQgYSBjb21wbGV0ZSB3cml0ZVxyXG4gKiBAcmV0dXJucyBUaGUgbm9kZSBpZiBjb21wbGV0ZSBhdCB0aGF0IHBhdGgsIG9yIG51bGwgb3RoZXJ3aXNlLlxyXG4gKi9cclxuZnVuY3Rpb24gY29tcG91bmRXcml0ZUdldENvbXBsZXRlTm9kZShjb21wb3VuZFdyaXRlLCBwYXRoKSB7XHJcbiAgICBjb25zdCByb290bW9zdCA9IGNvbXBvdW5kV3JpdGUud3JpdGVUcmVlXy5maW5kUm9vdE1vc3RWYWx1ZUFuZFBhdGgocGF0aCk7XHJcbiAgICBpZiAocm9vdG1vc3QgIT0gbnVsbCkge1xyXG4gICAgICAgIHJldHVybiBjb21wb3VuZFdyaXRlLndyaXRlVHJlZV9cclxuICAgICAgICAgICAgLmdldChyb290bW9zdC5wYXRoKVxyXG4gICAgICAgICAgICAuZ2V0Q2hpbGQobmV3UmVsYXRpdmVQYXRoKHJvb3Rtb3N0LnBhdGgsIHBhdGgpKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm5zIGFsbCBjaGlsZHJlbiB0aGF0IGFyZSBndWFyYW50ZWVkIHRvIGJlIGEgY29tcGxldGUgb3ZlcndyaXRlLlxyXG4gKlxyXG4gKiBAcGFyYW0gY29tcG91bmRXcml0ZSAtIFRoZSBDb21wb3VuZFdyaXRlIHRvIGdldCBjaGlsZHJlbiBmcm9tLlxyXG4gKiBAcmV0dXJucyBBIGxpc3Qgb2YgYWxsIGNvbXBsZXRlIGNoaWxkcmVuLlxyXG4gKi9cclxuZnVuY3Rpb24gY29tcG91bmRXcml0ZUdldENvbXBsZXRlQ2hpbGRyZW4oY29tcG91bmRXcml0ZSkge1xyXG4gICAgY29uc3QgY2hpbGRyZW4gPSBbXTtcclxuICAgIGNvbnN0IG5vZGUgPSBjb21wb3VuZFdyaXRlLndyaXRlVHJlZV8udmFsdWU7XHJcbiAgICBpZiAobm9kZSAhPSBudWxsKSB7XHJcbiAgICAgICAgLy8gSWYgaXQncyBhIGxlYWYgbm9kZSwgaXQgaGFzIG5vIGNoaWxkcmVuOyBzbyBub3RoaW5nIHRvIGRvLlxyXG4gICAgICAgIGlmICghbm9kZS5pc0xlYWZOb2RlKCkpIHtcclxuICAgICAgICAgICAgbm9kZS5mb3JFYWNoQ2hpbGQoUFJJT1JJVFlfSU5ERVgsIChjaGlsZE5hbWUsIGNoaWxkTm9kZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY2hpbGRyZW4ucHVzaChuZXcgTmFtZWROb2RlKGNoaWxkTmFtZSwgY2hpbGROb2RlKSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGNvbXBvdW5kV3JpdGUud3JpdGVUcmVlXy5jaGlsZHJlbi5pbm9yZGVyVHJhdmVyc2FsKChjaGlsZE5hbWUsIGNoaWxkVHJlZSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoY2hpbGRUcmVlLnZhbHVlICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIGNoaWxkcmVuLnB1c2gobmV3IE5hbWVkTm9kZShjaGlsZE5hbWUsIGNoaWxkVHJlZS52YWx1ZSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gY2hpbGRyZW47XHJcbn1cclxuZnVuY3Rpb24gY29tcG91bmRXcml0ZUNoaWxkQ29tcG91bmRXcml0ZShjb21wb3VuZFdyaXRlLCBwYXRoKSB7XHJcbiAgICBpZiAocGF0aElzRW1wdHkocGF0aCkpIHtcclxuICAgICAgICByZXR1cm4gY29tcG91bmRXcml0ZTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGNvbnN0IHNoYWRvd2luZ05vZGUgPSBjb21wb3VuZFdyaXRlR2V0Q29tcGxldGVOb2RlKGNvbXBvdW5kV3JpdGUsIHBhdGgpO1xyXG4gICAgICAgIGlmIChzaGFkb3dpbmdOb2RlICE9IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBDb21wb3VuZFdyaXRlKG5ldyBJbW11dGFibGVUcmVlKHNoYWRvd2luZ05vZGUpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ29tcG91bmRXcml0ZShjb21wb3VuZFdyaXRlLndyaXRlVHJlZV8uc3VidHJlZShwYXRoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhpcyBDb21wb3VuZFdyaXRlIGlzIGVtcHR5IGFuZCB0aGVyZWZvcmUgZG9lcyBub3QgbW9kaWZ5IGFueSBub2Rlcy5cclxuICogQHJldHVybnMgV2hldGhlciB0aGlzIENvbXBvdW5kV3JpdGUgaXMgZW1wdHlcclxuICovXHJcbmZ1bmN0aW9uIGNvbXBvdW5kV3JpdGVJc0VtcHR5KGNvbXBvdW5kV3JpdGUpIHtcclxuICAgIHJldHVybiBjb21wb3VuZFdyaXRlLndyaXRlVHJlZV8uaXNFbXB0eSgpO1xyXG59XHJcbi8qKlxyXG4gKiBBcHBsaWVzIHRoaXMgQ29tcG91bmRXcml0ZSB0byBhIG5vZGUuIFRoZSBub2RlIGlzIHJldHVybmVkIHdpdGggYWxsIHdyaXRlcyBmcm9tIHRoaXMgQ29tcG91bmRXcml0ZSBhcHBsaWVkIHRvIHRoZVxyXG4gKiBub2RlXHJcbiAqIEBwYXJhbSBub2RlIC0gVGhlIG5vZGUgdG8gYXBwbHkgdGhpcyBDb21wb3VuZFdyaXRlIHRvXHJcbiAqIEByZXR1cm5zIFRoZSBub2RlIHdpdGggYWxsIHdyaXRlcyBhcHBsaWVkXHJcbiAqL1xyXG5mdW5jdGlvbiBjb21wb3VuZFdyaXRlQXBwbHkoY29tcG91bmRXcml0ZSwgbm9kZSkge1xyXG4gICAgcmV0dXJuIGFwcGx5U3VidHJlZVdyaXRlKG5ld0VtcHR5UGF0aCgpLCBjb21wb3VuZFdyaXRlLndyaXRlVHJlZV8sIG5vZGUpO1xyXG59XHJcbmZ1bmN0aW9uIGFwcGx5U3VidHJlZVdyaXRlKHJlbGF0aXZlUGF0aCwgd3JpdGVUcmVlLCBub2RlKSB7XHJcbiAgICBpZiAod3JpdGVUcmVlLnZhbHVlICE9IG51bGwpIHtcclxuICAgICAgICAvLyBTaW5jZSB0aGVyZSBhIHdyaXRlIGlzIGFsd2F5cyBhIGxlYWYsIHdlJ3JlIGRvbmUgaGVyZVxyXG4gICAgICAgIHJldHVybiBub2RlLnVwZGF0ZUNoaWxkKHJlbGF0aXZlUGF0aCwgd3JpdGVUcmVlLnZhbHVlKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGxldCBwcmlvcml0eVdyaXRlID0gbnVsbDtcclxuICAgICAgICB3cml0ZVRyZWUuY2hpbGRyZW4uaW5vcmRlclRyYXZlcnNhbCgoY2hpbGRLZXksIGNoaWxkVHJlZSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoY2hpbGRLZXkgPT09ICcucHJpb3JpdHknKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBBcHBseSBwcmlvcml0aWVzIGF0IHRoZSBlbmQgc28gd2UgZG9uJ3QgdXBkYXRlIHByaW9yaXRpZXMgZm9yIGVpdGhlciBlbXB0eSBub2RlcyBvciBmb3JnZXRcclxuICAgICAgICAgICAgICAgIC8vIHRvIGFwcGx5IHByaW9yaXRpZXMgdG8gZW1wdHkgbm9kZXMgdGhhdCBhcmUgbGF0ZXIgZmlsbGVkXHJcbiAgICAgICAgICAgICAgICBhc3NlcnQoY2hpbGRUcmVlLnZhbHVlICE9PSBudWxsLCAnUHJpb3JpdHkgd3JpdGVzIG11c3QgYWx3YXlzIGJlIGxlYWYgbm9kZXMnKTtcclxuICAgICAgICAgICAgICAgIHByaW9yaXR5V3JpdGUgPSBjaGlsZFRyZWUudmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBub2RlID0gYXBwbHlTdWJ0cmVlV3JpdGUocGF0aENoaWxkKHJlbGF0aXZlUGF0aCwgY2hpbGRLZXkpLCBjaGlsZFRyZWUsIG5vZGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLy8gSWYgdGhlcmUgd2FzIGEgcHJpb3JpdHkgd3JpdGUsIHdlIG9ubHkgYXBwbHkgaXQgaWYgdGhlIG5vZGUgaXMgbm90IGVtcHR5XHJcbiAgICAgICAgaWYgKCFub2RlLmdldENoaWxkKHJlbGF0aXZlUGF0aCkuaXNFbXB0eSgpICYmIHByaW9yaXR5V3JpdGUgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgbm9kZSA9IG5vZGUudXBkYXRlQ2hpbGQocGF0aENoaWxkKHJlbGF0aXZlUGF0aCwgJy5wcmlvcml0eScpLCBwcmlvcml0eVdyaXRlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5vZGU7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIENyZWF0ZSBhIG5ldyBXcml0ZVRyZWVSZWYgZm9yIHRoZSBnaXZlbiBwYXRoLiBGb3IgdXNlIHdpdGggYSBuZXcgc3luYyBwb2ludCBhdCB0aGUgZ2l2ZW4gcGF0aC5cclxuICpcclxuICovXHJcbmZ1bmN0aW9uIHdyaXRlVHJlZUNoaWxkV3JpdGVzKHdyaXRlVHJlZSwgcGF0aCkge1xyXG4gICAgcmV0dXJuIG5ld1dyaXRlVHJlZVJlZihwYXRoLCB3cml0ZVRyZWUpO1xyXG59XHJcbi8qKlxyXG4gKiBSZWNvcmQgYSBuZXcgb3ZlcndyaXRlIGZyb20gdXNlciBjb2RlLlxyXG4gKlxyXG4gKiBAcGFyYW0gdmlzaWJsZSAtIFRoaXMgaXMgc2V0IHRvIGZhbHNlIGJ5IHNvbWUgdHJhbnNhY3Rpb25zLiBJdCBzaG91bGQgYmUgZXhjbHVkZWQgZnJvbSBldmVudCBjYWNoZXNcclxuICovXHJcbmZ1bmN0aW9uIHdyaXRlVHJlZUFkZE92ZXJ3cml0ZSh3cml0ZVRyZWUsIHBhdGgsIHNuYXAsIHdyaXRlSWQsIHZpc2libGUpIHtcclxuICAgIGFzc2VydCh3cml0ZUlkID4gd3JpdGVUcmVlLmxhc3RXcml0ZUlkLCAnU3RhY2tpbmcgYW4gb2xkZXIgd3JpdGUgb24gdG9wIG9mIG5ld2VyIG9uZXMnKTtcclxuICAgIGlmICh2aXNpYmxlID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICB2aXNpYmxlID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIHdyaXRlVHJlZS5hbGxXcml0ZXMucHVzaCh7XHJcbiAgICAgICAgcGF0aCxcclxuICAgICAgICBzbmFwLFxyXG4gICAgICAgIHdyaXRlSWQsXHJcbiAgICAgICAgdmlzaWJsZVxyXG4gICAgfSk7XHJcbiAgICBpZiAodmlzaWJsZSkge1xyXG4gICAgICAgIHdyaXRlVHJlZS52aXNpYmxlV3JpdGVzID0gY29tcG91bmRXcml0ZUFkZFdyaXRlKHdyaXRlVHJlZS52aXNpYmxlV3JpdGVzLCBwYXRoLCBzbmFwKTtcclxuICAgIH1cclxuICAgIHdyaXRlVHJlZS5sYXN0V3JpdGVJZCA9IHdyaXRlSWQ7XHJcbn1cclxuLyoqXHJcbiAqIFJlY29yZCBhIG5ldyBtZXJnZSBmcm9tIHVzZXIgY29kZS5cclxuICovXHJcbmZ1bmN0aW9uIHdyaXRlVHJlZUFkZE1lcmdlKHdyaXRlVHJlZSwgcGF0aCwgY2hhbmdlZENoaWxkcmVuLCB3cml0ZUlkKSB7XHJcbiAgICBhc3NlcnQod3JpdGVJZCA+IHdyaXRlVHJlZS5sYXN0V3JpdGVJZCwgJ1N0YWNraW5nIGFuIG9sZGVyIG1lcmdlIG9uIHRvcCBvZiBuZXdlciBvbmVzJyk7XHJcbiAgICB3cml0ZVRyZWUuYWxsV3JpdGVzLnB1c2goe1xyXG4gICAgICAgIHBhdGgsXHJcbiAgICAgICAgY2hpbGRyZW46IGNoYW5nZWRDaGlsZHJlbixcclxuICAgICAgICB3cml0ZUlkLFxyXG4gICAgICAgIHZpc2libGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgd3JpdGVUcmVlLnZpc2libGVXcml0ZXMgPSBjb21wb3VuZFdyaXRlQWRkV3JpdGVzKHdyaXRlVHJlZS52aXNpYmxlV3JpdGVzLCBwYXRoLCBjaGFuZ2VkQ2hpbGRyZW4pO1xyXG4gICAgd3JpdGVUcmVlLmxhc3RXcml0ZUlkID0gd3JpdGVJZDtcclxufVxyXG5mdW5jdGlvbiB3cml0ZVRyZWVHZXRXcml0ZSh3cml0ZVRyZWUsIHdyaXRlSWQpIHtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgd3JpdGVUcmVlLmFsbFdyaXRlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IHJlY29yZCA9IHdyaXRlVHJlZS5hbGxXcml0ZXNbaV07XHJcbiAgICAgICAgaWYgKHJlY29yZC53cml0ZUlkID09PSB3cml0ZUlkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiByZWNvcmQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIG51bGw7XHJcbn1cclxuLyoqXHJcbiAqIFJlbW92ZSBhIHdyaXRlIChlaXRoZXIgYW4gb3ZlcndyaXRlIG9yIG1lcmdlKSB0aGF0IGhhcyBiZWVuIHN1Y2Nlc3NmdWxseSBhY2tub3dsZWRnZSBieSB0aGUgc2VydmVyLiBSZWNhbGN1bGF0ZXNcclxuICogdGhlIHRyZWUgaWYgbmVjZXNzYXJ5LiAgV2UgcmV0dXJuIHRydWUgaWYgaXQgbWF5IGhhdmUgYmVlbiB2aXNpYmxlLCBtZWFuaW5nIHZpZXdzIG5lZWQgdG8gcmVldmFsdWF0ZS5cclxuICpcclxuICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgd3JpdGUgbWF5IGhhdmUgYmVlbiB2aXNpYmxlIChtZWFuaW5nIHdlJ2xsIG5lZWQgdG8gcmVldmFsdWF0ZSAvIHJhaXNlXHJcbiAqIGV2ZW50cyBhcyBhIHJlc3VsdCkuXHJcbiAqL1xyXG5mdW5jdGlvbiB3cml0ZVRyZWVSZW1vdmVXcml0ZSh3cml0ZVRyZWUsIHdyaXRlSWQpIHtcclxuICAgIC8vIE5vdGU6IGRpc2FibGluZyB0aGlzIGNoZWNrLiBJdCBjb3VsZCBiZSBhIHRyYW5zYWN0aW9uIHRoYXQgcHJlZW1wdGVkIGFub3RoZXIgdHJhbnNhY3Rpb24sIGFuZCB0aHVzIHdhcyBhcHBsaWVkXHJcbiAgICAvLyBvdXQgb2Ygb3JkZXIuXHJcbiAgICAvL2NvbnN0IHZhbGlkQ2xlYXIgPSByZXZlcnQgfHwgdGhpcy5hbGxXcml0ZXNfLmxlbmd0aCA9PT0gMCB8fCB3cml0ZUlkIDw9IHRoaXMuYWxsV3JpdGVzX1swXS53cml0ZUlkO1xyXG4gICAgLy9hc3NlcnQodmFsaWRDbGVhciwgXCJFaXRoZXIgd2UgZG9uJ3QgaGF2ZSB0aGlzIHdyaXRlLCBvciBpdCdzIHRoZSBmaXJzdCBvbmUgaW4gdGhlIHF1ZXVlXCIpO1xyXG4gICAgY29uc3QgaWR4ID0gd3JpdGVUcmVlLmFsbFdyaXRlcy5maW5kSW5kZXgocyA9PiB7XHJcbiAgICAgICAgcmV0dXJuIHMud3JpdGVJZCA9PT0gd3JpdGVJZDtcclxuICAgIH0pO1xyXG4gICAgYXNzZXJ0KGlkeCA+PSAwLCAncmVtb3ZlV3JpdGUgY2FsbGVkIHdpdGggbm9uZXhpc3RlbnQgd3JpdGVJZC4nKTtcclxuICAgIGNvbnN0IHdyaXRlVG9SZW1vdmUgPSB3cml0ZVRyZWUuYWxsV3JpdGVzW2lkeF07XHJcbiAgICB3cml0ZVRyZWUuYWxsV3JpdGVzLnNwbGljZShpZHgsIDEpO1xyXG4gICAgbGV0IHJlbW92ZWRXcml0ZVdhc1Zpc2libGUgPSB3cml0ZVRvUmVtb3ZlLnZpc2libGU7XHJcbiAgICBsZXQgcmVtb3ZlZFdyaXRlT3ZlcmxhcHNXaXRoT3RoZXJXcml0ZXMgPSBmYWxzZTtcclxuICAgIGxldCBpID0gd3JpdGVUcmVlLmFsbFdyaXRlcy5sZW5ndGggLSAxO1xyXG4gICAgd2hpbGUgKHJlbW92ZWRXcml0ZVdhc1Zpc2libGUgJiYgaSA+PSAwKSB7XHJcbiAgICAgICAgY29uc3QgY3VycmVudFdyaXRlID0gd3JpdGVUcmVlLmFsbFdyaXRlc1tpXTtcclxuICAgICAgICBpZiAoY3VycmVudFdyaXRlLnZpc2libGUpIHtcclxuICAgICAgICAgICAgaWYgKGkgPj0gaWR4ICYmXHJcbiAgICAgICAgICAgICAgICB3cml0ZVRyZWVSZWNvcmRDb250YWluc1BhdGhfKGN1cnJlbnRXcml0ZSwgd3JpdGVUb1JlbW92ZS5wYXRoKSkge1xyXG4gICAgICAgICAgICAgICAgLy8gVGhlIHJlbW92ZWQgd3JpdGUgd2FzIGNvbXBsZXRlbHkgc2hhZG93ZWQgYnkgYSBzdWJzZXF1ZW50IHdyaXRlLlxyXG4gICAgICAgICAgICAgICAgcmVtb3ZlZFdyaXRlV2FzVmlzaWJsZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHBhdGhDb250YWlucyh3cml0ZVRvUmVtb3ZlLnBhdGgsIGN1cnJlbnRXcml0ZS5wYXRoKSkge1xyXG4gICAgICAgICAgICAgICAgLy8gRWl0aGVyIHdlJ3JlIGNvdmVyaW5nIHNvbWUgd3JpdGVzIG9yIHRoZXkncmUgY292ZXJpbmcgcGFydCBvZiB1cyAoZGVwZW5kaW5nIG9uIHdoaWNoIGNhbWUgZmlyc3QpLlxyXG4gICAgICAgICAgICAgICAgcmVtb3ZlZFdyaXRlT3ZlcmxhcHNXaXRoT3RoZXJXcml0ZXMgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGktLTtcclxuICAgIH1cclxuICAgIGlmICghcmVtb3ZlZFdyaXRlV2FzVmlzaWJsZSkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHJlbW92ZWRXcml0ZU92ZXJsYXBzV2l0aE90aGVyV3JpdGVzKSB7XHJcbiAgICAgICAgLy8gVGhlcmUncyBzb21lIHNoYWRvd2luZyBnb2luZyBvbi4gSnVzdCByZWJ1aWxkIHRoZSB2aXNpYmxlIHdyaXRlcyBmcm9tIHNjcmF0Y2guXHJcbiAgICAgICAgd3JpdGVUcmVlUmVzZXRUcmVlXyh3cml0ZVRyZWUpO1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgLy8gVGhlcmUncyBubyBzaGFkb3dpbmcuICBXZSBjYW4gc2FmZWx5IGp1c3QgcmVtb3ZlIHRoZSB3cml0ZShzKSBmcm9tIHZpc2libGVXcml0ZXMuXHJcbiAgICAgICAgaWYgKHdyaXRlVG9SZW1vdmUuc25hcCkge1xyXG4gICAgICAgICAgICB3cml0ZVRyZWUudmlzaWJsZVdyaXRlcyA9IGNvbXBvdW5kV3JpdGVSZW1vdmVXcml0ZSh3cml0ZVRyZWUudmlzaWJsZVdyaXRlcywgd3JpdGVUb1JlbW92ZS5wYXRoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkcmVuID0gd3JpdGVUb1JlbW92ZS5jaGlsZHJlbjtcclxuICAgICAgICAgICAgZWFjaChjaGlsZHJlbiwgKGNoaWxkTmFtZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgd3JpdGVUcmVlLnZpc2libGVXcml0ZXMgPSBjb21wb3VuZFdyaXRlUmVtb3ZlV3JpdGUod3JpdGVUcmVlLnZpc2libGVXcml0ZXMsIHBhdGhDaGlsZCh3cml0ZVRvUmVtb3ZlLnBhdGgsIGNoaWxkTmFtZSkpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gd3JpdGVUcmVlUmVjb3JkQ29udGFpbnNQYXRoXyh3cml0ZVJlY29yZCwgcGF0aCkge1xyXG4gICAgaWYgKHdyaXRlUmVjb3JkLnNuYXApIHtcclxuICAgICAgICByZXR1cm4gcGF0aENvbnRhaW5zKHdyaXRlUmVjb3JkLnBhdGgsIHBhdGgpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgZm9yIChjb25zdCBjaGlsZE5hbWUgaW4gd3JpdGVSZWNvcmQuY2hpbGRyZW4pIHtcclxuICAgICAgICAgICAgaWYgKHdyaXRlUmVjb3JkLmNoaWxkcmVuLmhhc093blByb3BlcnR5KGNoaWxkTmFtZSkgJiZcclxuICAgICAgICAgICAgICAgIHBhdGhDb250YWlucyhwYXRoQ2hpbGQod3JpdGVSZWNvcmQucGF0aCwgY2hpbGROYW1lKSwgcGF0aCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogUmUtbGF5ZXIgdGhlIHdyaXRlcyBhbmQgbWVyZ2VzIGludG8gYSB0cmVlIHNvIHdlIGNhbiBlZmZpY2llbnRseSBjYWxjdWxhdGUgZXZlbnQgc25hcHNob3RzXHJcbiAqL1xyXG5mdW5jdGlvbiB3cml0ZVRyZWVSZXNldFRyZWVfKHdyaXRlVHJlZSkge1xyXG4gICAgd3JpdGVUcmVlLnZpc2libGVXcml0ZXMgPSB3cml0ZVRyZWVMYXllclRyZWVfKHdyaXRlVHJlZS5hbGxXcml0ZXMsIHdyaXRlVHJlZURlZmF1bHRGaWx0ZXJfLCBuZXdFbXB0eVBhdGgoKSk7XHJcbiAgICBpZiAod3JpdGVUcmVlLmFsbFdyaXRlcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgd3JpdGVUcmVlLmxhc3RXcml0ZUlkID1cclxuICAgICAgICAgICAgd3JpdGVUcmVlLmFsbFdyaXRlc1t3cml0ZVRyZWUuYWxsV3JpdGVzLmxlbmd0aCAtIDFdLndyaXRlSWQ7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICB3cml0ZVRyZWUubGFzdFdyaXRlSWQgPSAtMTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogVGhlIGRlZmF1bHQgZmlsdGVyIHVzZWQgd2hlbiBjb25zdHJ1Y3RpbmcgdGhlIHRyZWUuIEtlZXAgZXZlcnl0aGluZyB0aGF0J3MgdmlzaWJsZS5cclxuICovXHJcbmZ1bmN0aW9uIHdyaXRlVHJlZURlZmF1bHRGaWx0ZXJfKHdyaXRlKSB7XHJcbiAgICByZXR1cm4gd3JpdGUudmlzaWJsZTtcclxufVxyXG4vKipcclxuICogU3RhdGljIG1ldGhvZC4gR2l2ZW4gYW4gYXJyYXkgb2YgV3JpdGVSZWNvcmRzLCBhIGZpbHRlciBmb3Igd2hpY2ggb25lcyB0byBpbmNsdWRlLCBhbmQgYSBwYXRoLCBjb25zdHJ1Y3QgdGhlIHRyZWUgb2ZcclxuICogZXZlbnQgZGF0YSBhdCB0aGF0IHBhdGguXHJcbiAqL1xyXG5mdW5jdGlvbiB3cml0ZVRyZWVMYXllclRyZWVfKHdyaXRlcywgZmlsdGVyLCB0cmVlUm9vdCkge1xyXG4gICAgbGV0IGNvbXBvdW5kV3JpdGUgPSBDb21wb3VuZFdyaXRlLmVtcHR5KCk7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHdyaXRlcy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgIGNvbnN0IHdyaXRlID0gd3JpdGVzW2ldO1xyXG4gICAgICAgIC8vIFRoZW9yeSwgYSBsYXRlciBzZXQgd2lsbCBlaXRoZXI6XHJcbiAgICAgICAgLy8gYSkgYWJvcnQgYSByZWxldmFudCB0cmFuc2FjdGlvbiwgc28gbm8gbmVlZCB0byB3b3JyeSBhYm91dCBleGNsdWRpbmcgaXQgZnJvbSBjYWxjdWxhdGluZyB0aGF0IHRyYW5zYWN0aW9uXHJcbiAgICAgICAgLy8gYikgbm90IGJlIHJlbGV2YW50IHRvIGEgdHJhbnNhY3Rpb24gKHNlcGFyYXRlIGJyYW5jaCksIHNvIGFnYWluIHdpbGwgbm90IGFmZmVjdCB0aGUgZGF0YSBmb3IgdGhhdCB0cmFuc2FjdGlvblxyXG4gICAgICAgIGlmIChmaWx0ZXIod3JpdGUpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHdyaXRlUGF0aCA9IHdyaXRlLnBhdGg7XHJcbiAgICAgICAgICAgIGxldCByZWxhdGl2ZVBhdGg7XHJcbiAgICAgICAgICAgIGlmICh3cml0ZS5zbmFwKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocGF0aENvbnRhaW5zKHRyZWVSb290LCB3cml0ZVBhdGgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVsYXRpdmVQYXRoID0gbmV3UmVsYXRpdmVQYXRoKHRyZWVSb290LCB3cml0ZVBhdGgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbXBvdW5kV3JpdGUgPSBjb21wb3VuZFdyaXRlQWRkV3JpdGUoY29tcG91bmRXcml0ZSwgcmVsYXRpdmVQYXRoLCB3cml0ZS5zbmFwKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHBhdGhDb250YWlucyh3cml0ZVBhdGgsIHRyZWVSb290KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlbGF0aXZlUGF0aCA9IG5ld1JlbGF0aXZlUGF0aCh3cml0ZVBhdGgsIHRyZWVSb290KTtcclxuICAgICAgICAgICAgICAgICAgICBjb21wb3VuZFdyaXRlID0gY29tcG91bmRXcml0ZUFkZFdyaXRlKGNvbXBvdW5kV3JpdGUsIG5ld0VtcHR5UGF0aCgpLCB3cml0ZS5zbmFwLmdldENoaWxkKHJlbGF0aXZlUGF0aCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAod3JpdGUuY2hpbGRyZW4pIHtcclxuICAgICAgICAgICAgICAgIGlmIChwYXRoQ29udGFpbnModHJlZVJvb3QsIHdyaXRlUGF0aCkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZWxhdGl2ZVBhdGggPSBuZXdSZWxhdGl2ZVBhdGgodHJlZVJvb3QsIHdyaXRlUGF0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29tcG91bmRXcml0ZSA9IGNvbXBvdW5kV3JpdGVBZGRXcml0ZXMoY29tcG91bmRXcml0ZSwgcmVsYXRpdmVQYXRoLCB3cml0ZS5jaGlsZHJlbik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChwYXRoQ29udGFpbnMod3JpdGVQYXRoLCB0cmVlUm9vdCkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZWxhdGl2ZVBhdGggPSBuZXdSZWxhdGl2ZVBhdGgod3JpdGVQYXRoLCB0cmVlUm9vdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhdGhJc0VtcHR5KHJlbGF0aXZlUGF0aCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29tcG91bmRXcml0ZSA9IGNvbXBvdW5kV3JpdGVBZGRXcml0ZXMoY29tcG91bmRXcml0ZSwgbmV3RW1wdHlQYXRoKCksIHdyaXRlLmNoaWxkcmVuKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkID0gc2FmZUdldCh3cml0ZS5jaGlsZHJlbiwgcGF0aEdldEZyb250KHJlbGF0aXZlUGF0aCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZXJlIGV4aXN0cyBhIGNoaWxkIGluIHRoaXMgbm9kZSB0aGF0IG1hdGNoZXMgdGhlIHJvb3QgcGF0aFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZGVlcE5vZGUgPSBjaGlsZC5nZXRDaGlsZChwYXRoUG9wRnJvbnQocmVsYXRpdmVQYXRoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wb3VuZFdyaXRlID0gY29tcG91bmRXcml0ZUFkZFdyaXRlKGNvbXBvdW5kV3JpdGUsIG5ld0VtcHR5UGF0aCgpLCBkZWVwTm9kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRocm93IGFzc2VydGlvbkVycm9yKCdXcml0ZVJlY29yZCBzaG91bGQgaGF2ZSAuc25hcCBvciAuY2hpbGRyZW4nKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBjb21wb3VuZFdyaXRlO1xyXG59XHJcbi8qKlxyXG4gKiBHaXZlbiBvcHRpb25hbCwgdW5kZXJseWluZyBzZXJ2ZXIgZGF0YSwgYW5kIGFuIG9wdGlvbmFsIHNldCBvZiBjb25zdHJhaW50cyAoZXhjbHVkZSBzb21lIHNldHMsIGluY2x1ZGUgaGlkZGVuXHJcbiAqIHdyaXRlcyksIGF0dGVtcHQgdG8gY2FsY3VsYXRlIGEgY29tcGxldGUgc25hcHNob3QgZm9yIHRoZSBnaXZlbiBwYXRoXHJcbiAqXHJcbiAqIEBwYXJhbSB3cml0ZUlkc1RvRXhjbHVkZSAtIEFuIG9wdGlvbmFsIHNldCB0byBiZSBleGNsdWRlZFxyXG4gKiBAcGFyYW0gaW5jbHVkZUhpZGRlbldyaXRlcyAtIERlZmF1bHRzIHRvIGZhbHNlLCB3aGV0aGVyIG9yIG5vdCB0byBsYXllciBvbiB3cml0ZXMgd2l0aCB2aXNpYmxlIHNldCB0byBmYWxzZVxyXG4gKi9cclxuZnVuY3Rpb24gd3JpdGVUcmVlQ2FsY0NvbXBsZXRlRXZlbnRDYWNoZSh3cml0ZVRyZWUsIHRyZWVQYXRoLCBjb21wbGV0ZVNlcnZlckNhY2hlLCB3cml0ZUlkc1RvRXhjbHVkZSwgaW5jbHVkZUhpZGRlbldyaXRlcykge1xyXG4gICAgaWYgKCF3cml0ZUlkc1RvRXhjbHVkZSAmJiAhaW5jbHVkZUhpZGRlbldyaXRlcykge1xyXG4gICAgICAgIGNvbnN0IHNoYWRvd2luZ05vZGUgPSBjb21wb3VuZFdyaXRlR2V0Q29tcGxldGVOb2RlKHdyaXRlVHJlZS52aXNpYmxlV3JpdGVzLCB0cmVlUGF0aCk7XHJcbiAgICAgICAgaWYgKHNoYWRvd2luZ05vZGUgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gc2hhZG93aW5nTm9kZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHN1Yk1lcmdlID0gY29tcG91bmRXcml0ZUNoaWxkQ29tcG91bmRXcml0ZSh3cml0ZVRyZWUudmlzaWJsZVdyaXRlcywgdHJlZVBhdGgpO1xyXG4gICAgICAgICAgICBpZiAoY29tcG91bmRXcml0ZUlzRW1wdHkoc3ViTWVyZ2UpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tcGxldGVTZXJ2ZXJDYWNoZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChjb21wbGV0ZVNlcnZlckNhY2hlID09IG51bGwgJiZcclxuICAgICAgICAgICAgICAgICFjb21wb3VuZFdyaXRlSGFzQ29tcGxldGVXcml0ZShzdWJNZXJnZSwgbmV3RW1wdHlQYXRoKCkpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBXZSB3b3VsZG4ndCBoYXZlIGEgY29tcGxldGUgc25hcHNob3QsIHNpbmNlIHRoZXJlJ3Mgbm8gdW5kZXJseWluZyBkYXRhIGFuZCBubyBjb21wbGV0ZSBzaGFkb3dcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbGF5ZXJlZENhY2hlID0gY29tcGxldGVTZXJ2ZXJDYWNoZSB8fCBDaGlsZHJlbk5vZGUuRU1QVFlfTk9ERTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjb21wb3VuZFdyaXRlQXBwbHkoc3ViTWVyZ2UsIGxheWVyZWRDYWNoZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBjb25zdCBtZXJnZSA9IGNvbXBvdW5kV3JpdGVDaGlsZENvbXBvdW5kV3JpdGUod3JpdGVUcmVlLnZpc2libGVXcml0ZXMsIHRyZWVQYXRoKTtcclxuICAgICAgICBpZiAoIWluY2x1ZGVIaWRkZW5Xcml0ZXMgJiYgY29tcG91bmRXcml0ZUlzRW1wdHkobWVyZ2UpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBjb21wbGV0ZVNlcnZlckNhY2hlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gSWYgdGhlIHNlcnZlciBjYWNoZSBpcyBudWxsLCBhbmQgd2UgZG9uJ3QgaGF2ZSBhIGNvbXBsZXRlIGNhY2hlLCB3ZSBuZWVkIHRvIHJldHVybiBudWxsXHJcbiAgICAgICAgICAgIGlmICghaW5jbHVkZUhpZGRlbldyaXRlcyAmJlxyXG4gICAgICAgICAgICAgICAgY29tcGxldGVTZXJ2ZXJDYWNoZSA9PSBudWxsICYmXHJcbiAgICAgICAgICAgICAgICAhY29tcG91bmRXcml0ZUhhc0NvbXBsZXRlV3JpdGUobWVyZ2UsIG5ld0VtcHR5UGF0aCgpKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBmaWx0ZXIgPSBmdW5jdGlvbiAod3JpdGUpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKCh3cml0ZS52aXNpYmxlIHx8IGluY2x1ZGVIaWRkZW5Xcml0ZXMpICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICghd3JpdGVJZHNUb0V4Y2x1ZGUgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICF+d3JpdGVJZHNUb0V4Y2x1ZGUuaW5kZXhPZih3cml0ZS53cml0ZUlkKSkgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgKHBhdGhDb250YWlucyh3cml0ZS5wYXRoLCB0cmVlUGF0aCkgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdGhDb250YWlucyh0cmVlUGF0aCwgd3JpdGUucGF0aCkpKTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICBjb25zdCBtZXJnZUF0UGF0aCA9IHdyaXRlVHJlZUxheWVyVHJlZV8od3JpdGVUcmVlLmFsbFdyaXRlcywgZmlsdGVyLCB0cmVlUGF0aCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBsYXllcmVkQ2FjaGUgPSBjb21wbGV0ZVNlcnZlckNhY2hlIHx8IENoaWxkcmVuTm9kZS5FTVBUWV9OT0RFO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbXBvdW5kV3JpdGVBcHBseShtZXJnZUF0UGF0aCwgbGF5ZXJlZENhY2hlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4vKipcclxuICogV2l0aCBvcHRpb25hbCwgdW5kZXJseWluZyBzZXJ2ZXIgZGF0YSwgYXR0ZW1wdCB0byByZXR1cm4gYSBjaGlsZHJlbiBub2RlIG9mIGNoaWxkcmVuIHRoYXQgd2UgaGF2ZSBjb21wbGV0ZSBkYXRhIGZvci5cclxuICogVXNlZCB3aGVuIGNyZWF0aW5nIG5ldyB2aWV3cywgdG8gcHJlLWZpbGwgdGhlaXIgY29tcGxldGUgZXZlbnQgY2hpbGRyZW4gc25hcHNob3QuXHJcbiAqL1xyXG5mdW5jdGlvbiB3cml0ZVRyZWVDYWxjQ29tcGxldGVFdmVudENoaWxkcmVuKHdyaXRlVHJlZSwgdHJlZVBhdGgsIGNvbXBsZXRlU2VydmVyQ2hpbGRyZW4pIHtcclxuICAgIGxldCBjb21wbGV0ZUNoaWxkcmVuID0gQ2hpbGRyZW5Ob2RlLkVNUFRZX05PREU7XHJcbiAgICBjb25zdCB0b3BMZXZlbFNldCA9IGNvbXBvdW5kV3JpdGVHZXRDb21wbGV0ZU5vZGUod3JpdGVUcmVlLnZpc2libGVXcml0ZXMsIHRyZWVQYXRoKTtcclxuICAgIGlmICh0b3BMZXZlbFNldCkge1xyXG4gICAgICAgIGlmICghdG9wTGV2ZWxTZXQuaXNMZWFmTm9kZSgpKSB7XHJcbiAgICAgICAgICAgIC8vIHdlJ3JlIHNoYWRvd2luZyBldmVyeXRoaW5nLiBSZXR1cm4gdGhlIGNoaWxkcmVuLlxyXG4gICAgICAgICAgICB0b3BMZXZlbFNldC5mb3JFYWNoQ2hpbGQoUFJJT1JJVFlfSU5ERVgsIChjaGlsZE5hbWUsIGNoaWxkU25hcCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29tcGxldGVDaGlsZHJlbiA9IGNvbXBsZXRlQ2hpbGRyZW4udXBkYXRlSW1tZWRpYXRlQ2hpbGQoY2hpbGROYW1lLCBjaGlsZFNuYXApO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGNvbXBsZXRlQ2hpbGRyZW47XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChjb21wbGV0ZVNlcnZlckNoaWxkcmVuKSB7XHJcbiAgICAgICAgLy8gTGF5ZXIgYW55IGNoaWxkcmVuIHdlIGhhdmUgb24gdG9wIG9mIHRoaXNcclxuICAgICAgICAvLyBXZSBrbm93IHdlIGRvbid0IGhhdmUgYSB0b3AtbGV2ZWwgc2V0LCBzbyBqdXN0IGVudW1lcmF0ZSBleGlzdGluZyBjaGlsZHJlblxyXG4gICAgICAgIGNvbnN0IG1lcmdlID0gY29tcG91bmRXcml0ZUNoaWxkQ29tcG91bmRXcml0ZSh3cml0ZVRyZWUudmlzaWJsZVdyaXRlcywgdHJlZVBhdGgpO1xyXG4gICAgICAgIGNvbXBsZXRlU2VydmVyQ2hpbGRyZW4uZm9yRWFjaENoaWxkKFBSSU9SSVRZX0lOREVYLCAoY2hpbGROYW1lLCBjaGlsZE5vZGUpID0+IHtcclxuICAgICAgICAgICAgY29uc3Qgbm9kZSA9IGNvbXBvdW5kV3JpdGVBcHBseShjb21wb3VuZFdyaXRlQ2hpbGRDb21wb3VuZFdyaXRlKG1lcmdlLCBuZXcgUGF0aChjaGlsZE5hbWUpKSwgY2hpbGROb2RlKTtcclxuICAgICAgICAgICAgY29tcGxldGVDaGlsZHJlbiA9IGNvbXBsZXRlQ2hpbGRyZW4udXBkYXRlSW1tZWRpYXRlQ2hpbGQoY2hpbGROYW1lLCBub2RlKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICAvLyBBZGQgYW55IGNvbXBsZXRlIGNoaWxkcmVuIHdlIGhhdmUgZnJvbSB0aGUgc2V0XHJcbiAgICAgICAgY29tcG91bmRXcml0ZUdldENvbXBsZXRlQ2hpbGRyZW4obWVyZ2UpLmZvckVhY2gobmFtZWROb2RlID0+IHtcclxuICAgICAgICAgICAgY29tcGxldGVDaGlsZHJlbiA9IGNvbXBsZXRlQ2hpbGRyZW4udXBkYXRlSW1tZWRpYXRlQ2hpbGQobmFtZWROb2RlLm5hbWUsIG5hbWVkTm9kZS5ub2RlKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gY29tcGxldGVDaGlsZHJlbjtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIC8vIFdlIGRvbid0IGhhdmUgYW55dGhpbmcgdG8gbGF5ZXIgb24gdG9wIG9mLiBMYXllciBvbiBhbnkgY2hpbGRyZW4gd2UgaGF2ZVxyXG4gICAgICAgIC8vIE5vdGUgdGhhdCB3ZSBjYW4gcmV0dXJuIGFuIGVtcHR5IHNuYXAgaWYgd2UgaGF2ZSBhIGRlZmluZWQgZGVsZXRlXHJcbiAgICAgICAgY29uc3QgbWVyZ2UgPSBjb21wb3VuZFdyaXRlQ2hpbGRDb21wb3VuZFdyaXRlKHdyaXRlVHJlZS52aXNpYmxlV3JpdGVzLCB0cmVlUGF0aCk7XHJcbiAgICAgICAgY29tcG91bmRXcml0ZUdldENvbXBsZXRlQ2hpbGRyZW4obWVyZ2UpLmZvckVhY2gobmFtZWROb2RlID0+IHtcclxuICAgICAgICAgICAgY29tcGxldGVDaGlsZHJlbiA9IGNvbXBsZXRlQ2hpbGRyZW4udXBkYXRlSW1tZWRpYXRlQ2hpbGQobmFtZWROb2RlLm5hbWUsIG5hbWVkTm9kZS5ub2RlKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gY29tcGxldGVDaGlsZHJlbjtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogR2l2ZW4gdGhhdCB0aGUgdW5kZXJseWluZyBzZXJ2ZXIgZGF0YSBoYXMgdXBkYXRlZCwgZGV0ZXJtaW5lIHdoYXQsIGlmIGFueXRoaW5nLCBuZWVkcyB0byBiZVxyXG4gKiBhcHBsaWVkIHRvIHRoZSBldmVudCBjYWNoZS5cclxuICpcclxuICogUG9zc2liaWxpdGllczpcclxuICpcclxuICogMS4gTm8gd3JpdGVzIGFyZSBzaGFkb3dpbmcuIEV2ZW50cyBzaG91bGQgYmUgcmFpc2VkLCB0aGUgc25hcCB0byBiZSBhcHBsaWVkIGNvbWVzIGZyb20gdGhlIHNlcnZlciBkYXRhXHJcbiAqXHJcbiAqIDIuIFNvbWUgd3JpdGUgaXMgY29tcGxldGVseSBzaGFkb3dpbmcuIE5vIGV2ZW50cyB0byBiZSByYWlzZWRcclxuICpcclxuICogMy4gSXMgcGFydGlhbGx5IHNoYWRvd2VkLiBFdmVudHNcclxuICpcclxuICogRWl0aGVyIGV4aXN0aW5nRXZlbnRTbmFwIG9yIGV4aXN0aW5nU2VydmVyU25hcCBtdXN0IGV4aXN0XHJcbiAqL1xyXG5mdW5jdGlvbiB3cml0ZVRyZWVDYWxjRXZlbnRDYWNoZUFmdGVyU2VydmVyT3ZlcndyaXRlKHdyaXRlVHJlZSwgdHJlZVBhdGgsIGNoaWxkUGF0aCwgZXhpc3RpbmdFdmVudFNuYXAsIGV4aXN0aW5nU2VydmVyU25hcCkge1xyXG4gICAgYXNzZXJ0KGV4aXN0aW5nRXZlbnRTbmFwIHx8IGV4aXN0aW5nU2VydmVyU25hcCwgJ0VpdGhlciBleGlzdGluZ0V2ZW50U25hcCBvciBleGlzdGluZ1NlcnZlclNuYXAgbXVzdCBleGlzdCcpO1xyXG4gICAgY29uc3QgcGF0aCA9IHBhdGhDaGlsZCh0cmVlUGF0aCwgY2hpbGRQYXRoKTtcclxuICAgIGlmIChjb21wb3VuZFdyaXRlSGFzQ29tcGxldGVXcml0ZSh3cml0ZVRyZWUudmlzaWJsZVdyaXRlcywgcGF0aCkpIHtcclxuICAgICAgICAvLyBBdCB0aGlzIHBvaW50IHdlIGNhbiBwcm9iYWJseSBndWFyYW50ZWUgdGhhdCB3ZSdyZSBpbiBjYXNlIDIsIG1lYW5pbmcgbm8gZXZlbnRzXHJcbiAgICAgICAgLy8gTWF5IG5lZWQgdG8gY2hlY2sgdmlzaWJpbGl0eSB3aGlsZSBkb2luZyB0aGUgZmluZFJvb3RNb3N0VmFsdWVBbmRQYXRoIGNhbGxcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIC8vIE5vIGNvbXBsZXRlIHNoYWRvd2luZy4gV2UncmUgZWl0aGVyIHBhcnRpYWxseSBzaGFkb3dpbmcgb3Igbm90IHNoYWRvd2luZyBhdCBhbGwuXHJcbiAgICAgICAgY29uc3QgY2hpbGRNZXJnZSA9IGNvbXBvdW5kV3JpdGVDaGlsZENvbXBvdW5kV3JpdGUod3JpdGVUcmVlLnZpc2libGVXcml0ZXMsIHBhdGgpO1xyXG4gICAgICAgIGlmIChjb21wb3VuZFdyaXRlSXNFbXB0eShjaGlsZE1lcmdlKSkge1xyXG4gICAgICAgICAgICAvLyBXZSdyZSBub3Qgc2hhZG93aW5nIGF0IGFsbC4gQ2FzZSAxXHJcbiAgICAgICAgICAgIHJldHVybiBleGlzdGluZ1NlcnZlclNuYXAuZ2V0Q2hpbGQoY2hpbGRQYXRoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIFRoaXMgY291bGQgYmUgbW9yZSBlZmZpY2llbnQgaWYgdGhlIHNlcnZlck5vZGUgKyB1cGRhdGVzIGRvZXNuJ3QgY2hhbmdlIHRoZSBldmVudFNuYXBcclxuICAgICAgICAgICAgLy8gSG93ZXZlciB0aGlzIGlzIHRyaWNreSB0byBmaW5kIG91dCwgc2luY2UgdXNlciB1cGRhdGVzIGRvbid0IG5lY2Vzc2FyeSBjaGFuZ2UgdGhlIHNlcnZlclxyXG4gICAgICAgICAgICAvLyBzbmFwLCBlLmcuIHByaW9yaXR5IHVwZGF0ZXMgb24gZW1wdHkgbm9kZXMsIG9yIGRlZXAgZGVsZXRlcy4gQW5vdGhlciBzcGVjaWFsIGNhc2UgaXMgaWYgdGhlIHNlcnZlclxyXG4gICAgICAgICAgICAvLyBhZGRzIG5vZGVzLCBidXQgZG9lc24ndCBjaGFuZ2UgYW55IGV4aXN0aW5nIHdyaXRlcy4gSXQgaXMgdGhlcmVmb3JlIG5vdCBlbm91Z2ggdG9cclxuICAgICAgICAgICAgLy8gb25seSBjaGVjayBpZiB0aGUgdXBkYXRlcyBjaGFuZ2UgdGhlIHNlcnZlck5vZGUuXHJcbiAgICAgICAgICAgIC8vIE1heWJlIGNoZWNrIGlmIHRoZSBtZXJnZSB0cmVlIGNvbnRhaW5zIHRoZXNlIHNwZWNpYWwgY2FzZXMgYW5kIG9ubHkgZG8gYSBmdWxsIG92ZXJ3cml0ZSBpbiB0aGF0IGNhc2U/XHJcbiAgICAgICAgICAgIHJldHVybiBjb21wb3VuZFdyaXRlQXBwbHkoY2hpbGRNZXJnZSwgZXhpc3RpbmdTZXJ2ZXJTbmFwLmdldENoaWxkKGNoaWxkUGF0aCkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4vKipcclxuICogUmV0dXJucyBhIGNvbXBsZXRlIGNoaWxkIGZvciBhIGdpdmVuIHNlcnZlciBzbmFwIGFmdGVyIGFwcGx5aW5nIGFsbCB1c2VyIHdyaXRlcyBvciBudWxsIGlmIHRoZXJlIGlzIG5vXHJcbiAqIGNvbXBsZXRlIGNoaWxkIGZvciB0aGlzIENoaWxkS2V5LlxyXG4gKi9cclxuZnVuY3Rpb24gd3JpdGVUcmVlQ2FsY0NvbXBsZXRlQ2hpbGQod3JpdGVUcmVlLCB0cmVlUGF0aCwgY2hpbGRLZXksIGV4aXN0aW5nU2VydmVyU25hcCkge1xyXG4gICAgY29uc3QgcGF0aCA9IHBhdGhDaGlsZCh0cmVlUGF0aCwgY2hpbGRLZXkpO1xyXG4gICAgY29uc3Qgc2hhZG93aW5nTm9kZSA9IGNvbXBvdW5kV3JpdGVHZXRDb21wbGV0ZU5vZGUod3JpdGVUcmVlLnZpc2libGVXcml0ZXMsIHBhdGgpO1xyXG4gICAgaWYgKHNoYWRvd2luZ05vZGUgIT0gbnVsbCkge1xyXG4gICAgICAgIHJldHVybiBzaGFkb3dpbmdOb2RlO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgaWYgKGV4aXN0aW5nU2VydmVyU25hcC5pc0NvbXBsZXRlRm9yQ2hpbGQoY2hpbGRLZXkpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkTWVyZ2UgPSBjb21wb3VuZFdyaXRlQ2hpbGRDb21wb3VuZFdyaXRlKHdyaXRlVHJlZS52aXNpYmxlV3JpdGVzLCBwYXRoKTtcclxuICAgICAgICAgICAgcmV0dXJuIGNvbXBvdW5kV3JpdGVBcHBseShjaGlsZE1lcmdlLCBleGlzdGluZ1NlcnZlclNuYXAuZ2V0Tm9kZSgpLmdldEltbWVkaWF0ZUNoaWxkKGNoaWxkS2V5KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybnMgYSBub2RlIGlmIHRoZXJlIGlzIGEgY29tcGxldGUgb3ZlcndyaXRlIGZvciB0aGlzIHBhdGguIE1vcmUgc3BlY2lmaWNhbGx5LCBpZiB0aGVyZSBpcyBhIHdyaXRlIGF0XHJcbiAqIGEgaGlnaGVyIHBhdGgsIHRoaXMgd2lsbCByZXR1cm4gdGhlIGNoaWxkIG9mIHRoYXQgd3JpdGUgcmVsYXRpdmUgdG8gdGhlIHdyaXRlIGFuZCB0aGlzIHBhdGguXHJcbiAqIFJldHVybnMgbnVsbCBpZiB0aGVyZSBpcyBubyB3cml0ZSBhdCB0aGlzIHBhdGguXHJcbiAqL1xyXG5mdW5jdGlvbiB3cml0ZVRyZWVTaGFkb3dpbmdXcml0ZSh3cml0ZVRyZWUsIHBhdGgpIHtcclxuICAgIHJldHVybiBjb21wb3VuZFdyaXRlR2V0Q29tcGxldGVOb2RlKHdyaXRlVHJlZS52aXNpYmxlV3JpdGVzLCBwYXRoKTtcclxufVxyXG4vKipcclxuICogVGhpcyBtZXRob2QgaXMgdXNlZCB3aGVuIHByb2Nlc3NpbmcgY2hpbGQgcmVtb3ZlIGV2ZW50cyBvbiBhIHF1ZXJ5LiBJZiB3ZSBjYW4sIHdlIHB1bGwgaW4gY2hpbGRyZW4gdGhhdCB3ZXJlIG91dHNpZGVcclxuICogdGhlIHdpbmRvdywgYnV0IG1heSBub3cgYmUgaW4gdGhlIHdpbmRvdy5cclxuICovXHJcbmZ1bmN0aW9uIHdyaXRlVHJlZUNhbGNJbmRleGVkU2xpY2Uod3JpdGVUcmVlLCB0cmVlUGF0aCwgY29tcGxldGVTZXJ2ZXJEYXRhLCBzdGFydFBvc3QsIGNvdW50LCByZXZlcnNlLCBpbmRleCkge1xyXG4gICAgbGV0IHRvSXRlcmF0ZTtcclxuICAgIGNvbnN0IG1lcmdlID0gY29tcG91bmRXcml0ZUNoaWxkQ29tcG91bmRXcml0ZSh3cml0ZVRyZWUudmlzaWJsZVdyaXRlcywgdHJlZVBhdGgpO1xyXG4gICAgY29uc3Qgc2hhZG93aW5nTm9kZSA9IGNvbXBvdW5kV3JpdGVHZXRDb21wbGV0ZU5vZGUobWVyZ2UsIG5ld0VtcHR5UGF0aCgpKTtcclxuICAgIGlmIChzaGFkb3dpbmdOb2RlICE9IG51bGwpIHtcclxuICAgICAgICB0b0l0ZXJhdGUgPSBzaGFkb3dpbmdOb2RlO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoY29tcGxldGVTZXJ2ZXJEYXRhICE9IG51bGwpIHtcclxuICAgICAgICB0b0l0ZXJhdGUgPSBjb21wb3VuZFdyaXRlQXBwbHkobWVyZ2UsIGNvbXBsZXRlU2VydmVyRGF0YSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICAvLyBubyBjaGlsZHJlbiB0byBpdGVyYXRlIG9uXHJcbiAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgfVxyXG4gICAgdG9JdGVyYXRlID0gdG9JdGVyYXRlLndpdGhJbmRleChpbmRleCk7XHJcbiAgICBpZiAoIXRvSXRlcmF0ZS5pc0VtcHR5KCkgJiYgIXRvSXRlcmF0ZS5pc0xlYWZOb2RlKCkpIHtcclxuICAgICAgICBjb25zdCBub2RlcyA9IFtdO1xyXG4gICAgICAgIGNvbnN0IGNtcCA9IGluZGV4LmdldENvbXBhcmUoKTtcclxuICAgICAgICBjb25zdCBpdGVyID0gcmV2ZXJzZVxyXG4gICAgICAgICAgICA/IHRvSXRlcmF0ZS5nZXRSZXZlcnNlSXRlcmF0b3JGcm9tKHN0YXJ0UG9zdCwgaW5kZXgpXHJcbiAgICAgICAgICAgIDogdG9JdGVyYXRlLmdldEl0ZXJhdG9yRnJvbShzdGFydFBvc3QsIGluZGV4KTtcclxuICAgICAgICBsZXQgbmV4dCA9IGl0ZXIuZ2V0TmV4dCgpO1xyXG4gICAgICAgIHdoaWxlIChuZXh0ICYmIG5vZGVzLmxlbmd0aCA8IGNvdW50KSB7XHJcbiAgICAgICAgICAgIGlmIChjbXAobmV4dCwgc3RhcnRQb3N0KSAhPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgbm9kZXMucHVzaChuZXh0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBuZXh0ID0gaXRlci5nZXROZXh0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBub2RlcztcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBbXTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBuZXdXcml0ZVRyZWUoKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHZpc2libGVXcml0ZXM6IENvbXBvdW5kV3JpdGUuZW1wdHkoKSxcclxuICAgICAgICBhbGxXcml0ZXM6IFtdLFxyXG4gICAgICAgIGxhc3RXcml0ZUlkOiAtMVxyXG4gICAgfTtcclxufVxyXG4vKipcclxuICogSWYgcG9zc2libGUsIHJldHVybnMgYSBjb21wbGV0ZSBldmVudCBjYWNoZSwgdXNpbmcgdGhlIHVuZGVybHlpbmcgc2VydmVyIGRhdGEgaWYgcG9zc2libGUuIEluIGFkZGl0aW9uLCBjYW4gYmUgdXNlZFxyXG4gKiB0byBnZXQgYSBjYWNoZSB0aGF0IGluY2x1ZGVzIGhpZGRlbiB3cml0ZXMsIGFuZCBleGNsdWRlcyBhcmJpdHJhcnkgd3JpdGVzLiBOb3RlIHRoYXQgY3VzdG9taXppbmcgdGhlIHJldHVybmVkIG5vZGVcclxuICogY2FuIGxlYWQgdG8gYSBtb3JlIGV4cGVuc2l2ZSBjYWxjdWxhdGlvbi5cclxuICpcclxuICogQHBhcmFtIHdyaXRlSWRzVG9FeGNsdWRlIC0gT3B0aW9uYWwgd3JpdGVzIHRvIGV4Y2x1ZGUuXHJcbiAqIEBwYXJhbSBpbmNsdWRlSGlkZGVuV3JpdGVzIC0gRGVmYXVsdHMgdG8gZmFsc2UsIHdoZXRoZXIgb3Igbm90IHRvIGxheWVyIG9uIHdyaXRlcyB3aXRoIHZpc2libGUgc2V0IHRvIGZhbHNlXHJcbiAqL1xyXG5mdW5jdGlvbiB3cml0ZVRyZWVSZWZDYWxjQ29tcGxldGVFdmVudENhY2hlKHdyaXRlVHJlZVJlZiwgY29tcGxldGVTZXJ2ZXJDYWNoZSwgd3JpdGVJZHNUb0V4Y2x1ZGUsIGluY2x1ZGVIaWRkZW5Xcml0ZXMpIHtcclxuICAgIHJldHVybiB3cml0ZVRyZWVDYWxjQ29tcGxldGVFdmVudENhY2hlKHdyaXRlVHJlZVJlZi53cml0ZVRyZWUsIHdyaXRlVHJlZVJlZi50cmVlUGF0aCwgY29tcGxldGVTZXJ2ZXJDYWNoZSwgd3JpdGVJZHNUb0V4Y2x1ZGUsIGluY2x1ZGVIaWRkZW5Xcml0ZXMpO1xyXG59XHJcbi8qKlxyXG4gKiBJZiBwb3NzaWJsZSwgcmV0dXJucyBhIGNoaWxkcmVuIG5vZGUgY29udGFpbmluZyBhbGwgb2YgdGhlIGNvbXBsZXRlIGNoaWxkcmVuIHdlIGhhdmUgZGF0YSBmb3IuIFRoZSByZXR1cm5lZCBkYXRhIGlzIGFcclxuICogbWl4IG9mIHRoZSBnaXZlbiBzZXJ2ZXIgZGF0YSBhbmQgd3JpdGUgZGF0YS5cclxuICpcclxuICovXHJcbmZ1bmN0aW9uIHdyaXRlVHJlZVJlZkNhbGNDb21wbGV0ZUV2ZW50Q2hpbGRyZW4od3JpdGVUcmVlUmVmLCBjb21wbGV0ZVNlcnZlckNoaWxkcmVuKSB7XHJcbiAgICByZXR1cm4gd3JpdGVUcmVlQ2FsY0NvbXBsZXRlRXZlbnRDaGlsZHJlbih3cml0ZVRyZWVSZWYud3JpdGVUcmVlLCB3cml0ZVRyZWVSZWYudHJlZVBhdGgsIGNvbXBsZXRlU2VydmVyQ2hpbGRyZW4pO1xyXG59XHJcbi8qKlxyXG4gKiBHaXZlbiB0aGF0IGVpdGhlciB0aGUgdW5kZXJseWluZyBzZXJ2ZXIgZGF0YSBoYXMgdXBkYXRlZCBvciB0aGUgb3V0c3RhbmRpbmcgd3JpdGVzIGhhdmUgdXBkYXRlZCwgZGV0ZXJtaW5lIHdoYXQsXHJcbiAqIGlmIGFueXRoaW5nLCBuZWVkcyB0byBiZSBhcHBsaWVkIHRvIHRoZSBldmVudCBjYWNoZS5cclxuICpcclxuICogUG9zc2liaWxpdGllczpcclxuICpcclxuICogMS4gTm8gd3JpdGVzIGFyZSBzaGFkb3dpbmcuIEV2ZW50cyBzaG91bGQgYmUgcmFpc2VkLCB0aGUgc25hcCB0byBiZSBhcHBsaWVkIGNvbWVzIGZyb20gdGhlIHNlcnZlciBkYXRhXHJcbiAqXHJcbiAqIDIuIFNvbWUgd3JpdGUgaXMgY29tcGxldGVseSBzaGFkb3dpbmcuIE5vIGV2ZW50cyB0byBiZSByYWlzZWRcclxuICpcclxuICogMy4gSXMgcGFydGlhbGx5IHNoYWRvd2VkLiBFdmVudHMgc2hvdWxkIGJlIHJhaXNlZFxyXG4gKlxyXG4gKiBFaXRoZXIgZXhpc3RpbmdFdmVudFNuYXAgb3IgZXhpc3RpbmdTZXJ2ZXJTbmFwIG11c3QgZXhpc3QsIHRoaXMgaXMgdmFsaWRhdGVkIHZpYSBhbiBhc3NlcnRcclxuICpcclxuICpcclxuICovXHJcbmZ1bmN0aW9uIHdyaXRlVHJlZVJlZkNhbGNFdmVudENhY2hlQWZ0ZXJTZXJ2ZXJPdmVyd3JpdGUod3JpdGVUcmVlUmVmLCBwYXRoLCBleGlzdGluZ0V2ZW50U25hcCwgZXhpc3RpbmdTZXJ2ZXJTbmFwKSB7XHJcbiAgICByZXR1cm4gd3JpdGVUcmVlQ2FsY0V2ZW50Q2FjaGVBZnRlclNlcnZlck92ZXJ3cml0ZSh3cml0ZVRyZWVSZWYud3JpdGVUcmVlLCB3cml0ZVRyZWVSZWYudHJlZVBhdGgsIHBhdGgsIGV4aXN0aW5nRXZlbnRTbmFwLCBleGlzdGluZ1NlcnZlclNuYXApO1xyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm5zIGEgbm9kZSBpZiB0aGVyZSBpcyBhIGNvbXBsZXRlIG92ZXJ3cml0ZSBmb3IgdGhpcyBwYXRoLiBNb3JlIHNwZWNpZmljYWxseSwgaWYgdGhlcmUgaXMgYSB3cml0ZSBhdFxyXG4gKiBhIGhpZ2hlciBwYXRoLCB0aGlzIHdpbGwgcmV0dXJuIHRoZSBjaGlsZCBvZiB0aGF0IHdyaXRlIHJlbGF0aXZlIHRvIHRoZSB3cml0ZSBhbmQgdGhpcyBwYXRoLlxyXG4gKiBSZXR1cm5zIG51bGwgaWYgdGhlcmUgaXMgbm8gd3JpdGUgYXQgdGhpcyBwYXRoLlxyXG4gKlxyXG4gKi9cclxuZnVuY3Rpb24gd3JpdGVUcmVlUmVmU2hhZG93aW5nV3JpdGUod3JpdGVUcmVlUmVmLCBwYXRoKSB7XHJcbiAgICByZXR1cm4gd3JpdGVUcmVlU2hhZG93aW5nV3JpdGUod3JpdGVUcmVlUmVmLndyaXRlVHJlZSwgcGF0aENoaWxkKHdyaXRlVHJlZVJlZi50cmVlUGF0aCwgcGF0aCkpO1xyXG59XHJcbi8qKlxyXG4gKiBUaGlzIG1ldGhvZCBpcyB1c2VkIHdoZW4gcHJvY2Vzc2luZyBjaGlsZCByZW1vdmUgZXZlbnRzIG9uIGEgcXVlcnkuIElmIHdlIGNhbiwgd2UgcHVsbCBpbiBjaGlsZHJlbiB0aGF0IHdlcmUgb3V0c2lkZVxyXG4gKiB0aGUgd2luZG93LCBidXQgbWF5IG5vdyBiZSBpbiB0aGUgd2luZG93XHJcbiAqL1xyXG5mdW5jdGlvbiB3cml0ZVRyZWVSZWZDYWxjSW5kZXhlZFNsaWNlKHdyaXRlVHJlZVJlZiwgY29tcGxldGVTZXJ2ZXJEYXRhLCBzdGFydFBvc3QsIGNvdW50LCByZXZlcnNlLCBpbmRleCkge1xyXG4gICAgcmV0dXJuIHdyaXRlVHJlZUNhbGNJbmRleGVkU2xpY2Uod3JpdGVUcmVlUmVmLndyaXRlVHJlZSwgd3JpdGVUcmVlUmVmLnRyZWVQYXRoLCBjb21wbGV0ZVNlcnZlckRhdGEsIHN0YXJ0UG9zdCwgY291bnQsIHJldmVyc2UsIGluZGV4KTtcclxufVxyXG4vKipcclxuICogUmV0dXJucyBhIGNvbXBsZXRlIGNoaWxkIGZvciBhIGdpdmVuIHNlcnZlciBzbmFwIGFmdGVyIGFwcGx5aW5nIGFsbCB1c2VyIHdyaXRlcyBvciBudWxsIGlmIHRoZXJlIGlzIG5vXHJcbiAqIGNvbXBsZXRlIGNoaWxkIGZvciB0aGlzIENoaWxkS2V5LlxyXG4gKi9cclxuZnVuY3Rpb24gd3JpdGVUcmVlUmVmQ2FsY0NvbXBsZXRlQ2hpbGQod3JpdGVUcmVlUmVmLCBjaGlsZEtleSwgZXhpc3RpbmdTZXJ2ZXJDYWNoZSkge1xyXG4gICAgcmV0dXJuIHdyaXRlVHJlZUNhbGNDb21wbGV0ZUNoaWxkKHdyaXRlVHJlZVJlZi53cml0ZVRyZWUsIHdyaXRlVHJlZVJlZi50cmVlUGF0aCwgY2hpbGRLZXksIGV4aXN0aW5nU2VydmVyQ2FjaGUpO1xyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm4gYSBXcml0ZVRyZWVSZWYgZm9yIGEgY2hpbGQuXHJcbiAqL1xyXG5mdW5jdGlvbiB3cml0ZVRyZWVSZWZDaGlsZCh3cml0ZVRyZWVSZWYsIGNoaWxkTmFtZSkge1xyXG4gICAgcmV0dXJuIG5ld1dyaXRlVHJlZVJlZihwYXRoQ2hpbGQod3JpdGVUcmVlUmVmLnRyZWVQYXRoLCBjaGlsZE5hbWUpLCB3cml0ZVRyZWVSZWYud3JpdGVUcmVlKTtcclxufVxyXG5mdW5jdGlvbiBuZXdXcml0ZVRyZWVSZWYocGF0aCwgd3JpdGVUcmVlKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHRyZWVQYXRoOiBwYXRoLFxyXG4gICAgICAgIHdyaXRlVHJlZVxyXG4gICAgfTtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5jbGFzcyBDaGlsZENoYW5nZUFjY3VtdWxhdG9yIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMuY2hhbmdlTWFwID0gbmV3IE1hcCgpO1xyXG4gICAgfVxyXG4gICAgdHJhY2tDaGlsZENoYW5nZShjaGFuZ2UpIHtcclxuICAgICAgICBjb25zdCB0eXBlID0gY2hhbmdlLnR5cGU7XHJcbiAgICAgICAgY29uc3QgY2hpbGRLZXkgPSBjaGFuZ2UuY2hpbGROYW1lO1xyXG4gICAgICAgIGFzc2VydCh0eXBlID09PSBcImNoaWxkX2FkZGVkXCIgLyogQ0hJTERfQURERUQgKi8gfHxcclxuICAgICAgICAgICAgdHlwZSA9PT0gXCJjaGlsZF9jaGFuZ2VkXCIgLyogQ0hJTERfQ0hBTkdFRCAqLyB8fFxyXG4gICAgICAgICAgICB0eXBlID09PSBcImNoaWxkX3JlbW92ZWRcIiAvKiBDSElMRF9SRU1PVkVEICovLCAnT25seSBjaGlsZCBjaGFuZ2VzIHN1cHBvcnRlZCBmb3IgdHJhY2tpbmcnKTtcclxuICAgICAgICBhc3NlcnQoY2hpbGRLZXkgIT09ICcucHJpb3JpdHknLCAnT25seSBub24tcHJpb3JpdHkgY2hpbGQgY2hhbmdlcyBjYW4gYmUgdHJhY2tlZC4nKTtcclxuICAgICAgICBjb25zdCBvbGRDaGFuZ2UgPSB0aGlzLmNoYW5nZU1hcC5nZXQoY2hpbGRLZXkpO1xyXG4gICAgICAgIGlmIChvbGRDaGFuZ2UpIHtcclxuICAgICAgICAgICAgY29uc3Qgb2xkVHlwZSA9IG9sZENoYW5nZS50eXBlO1xyXG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gXCJjaGlsZF9hZGRlZFwiIC8qIENISUxEX0FEREVEICovICYmXHJcbiAgICAgICAgICAgICAgICBvbGRUeXBlID09PSBcImNoaWxkX3JlbW92ZWRcIiAvKiBDSElMRF9SRU1PVkVEICovKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNoYW5nZU1hcC5zZXQoY2hpbGRLZXksIGNoYW5nZUNoaWxkQ2hhbmdlZChjaGlsZEtleSwgY2hhbmdlLnNuYXBzaG90Tm9kZSwgb2xkQ2hhbmdlLnNuYXBzaG90Tm9kZSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGUgPT09IFwiY2hpbGRfcmVtb3ZlZFwiIC8qIENISUxEX1JFTU9WRUQgKi8gJiZcclxuICAgICAgICAgICAgICAgIG9sZFR5cGUgPT09IFwiY2hpbGRfYWRkZWRcIiAvKiBDSElMRF9BRERFRCAqLykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jaGFuZ2VNYXAuZGVsZXRlKGNoaWxkS2V5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlID09PSBcImNoaWxkX3JlbW92ZWRcIiAvKiBDSElMRF9SRU1PVkVEICovICYmXHJcbiAgICAgICAgICAgICAgICBvbGRUeXBlID09PSBcImNoaWxkX2NoYW5nZWRcIiAvKiBDSElMRF9DSEFOR0VEICovKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNoYW5nZU1hcC5zZXQoY2hpbGRLZXksIGNoYW5nZUNoaWxkUmVtb3ZlZChjaGlsZEtleSwgb2xkQ2hhbmdlLm9sZFNuYXApKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlID09PSBcImNoaWxkX2NoYW5nZWRcIiAvKiBDSElMRF9DSEFOR0VEICovICYmXHJcbiAgICAgICAgICAgICAgICBvbGRUeXBlID09PSBcImNoaWxkX2FkZGVkXCIgLyogQ0hJTERfQURERUQgKi8pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2hhbmdlTWFwLnNldChjaGlsZEtleSwgY2hhbmdlQ2hpbGRBZGRlZChjaGlsZEtleSwgY2hhbmdlLnNuYXBzaG90Tm9kZSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGUgPT09IFwiY2hpbGRfY2hhbmdlZFwiIC8qIENISUxEX0NIQU5HRUQgKi8gJiZcclxuICAgICAgICAgICAgICAgIG9sZFR5cGUgPT09IFwiY2hpbGRfY2hhbmdlZFwiIC8qIENISUxEX0NIQU5HRUQgKi8pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2hhbmdlTWFwLnNldChjaGlsZEtleSwgY2hhbmdlQ2hpbGRDaGFuZ2VkKGNoaWxkS2V5LCBjaGFuZ2Uuc25hcHNob3ROb2RlLCBvbGRDaGFuZ2Uub2xkU25hcCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgYXNzZXJ0aW9uRXJyb3IoJ0lsbGVnYWwgY29tYmluYXRpb24gb2YgY2hhbmdlczogJyArXHJcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlICtcclxuICAgICAgICAgICAgICAgICAgICAnIG9jY3VycmVkIGFmdGVyICcgK1xyXG4gICAgICAgICAgICAgICAgICAgIG9sZENoYW5nZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuY2hhbmdlTWFwLnNldChjaGlsZEtleSwgY2hhbmdlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBnZXRDaGFuZ2VzKCkge1xyXG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMuY2hhbmdlTWFwLnZhbHVlcygpKTtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogQW4gaW1wbGVtZW50YXRpb24gb2YgQ29tcGxldGVDaGlsZFNvdXJjZSB0aGF0IG5ldmVyIHJldHVybnMgYW55IGFkZGl0aW9uYWwgY2hpbGRyZW5cclxuICovXHJcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb25cclxuY2xhc3MgTm9Db21wbGV0ZUNoaWxkU291cmNlXyB7XHJcbiAgICBnZXRDb21wbGV0ZUNoaWxkKGNoaWxkS2V5KSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICBnZXRDaGlsZEFmdGVyQ2hpbGQoaW5kZXgsIGNoaWxkLCByZXZlcnNlKSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFNpbmdsZXRvbiBpbnN0YW5jZS5cclxuICovXHJcbmNvbnN0IE5PX0NPTVBMRVRFX0NISUxEX1NPVVJDRSA9IG5ldyBOb0NvbXBsZXRlQ2hpbGRTb3VyY2VfKCk7XHJcbi8qKlxyXG4gKiBBbiBpbXBsZW1lbnRhdGlvbiBvZiBDb21wbGV0ZUNoaWxkU291cmNlIHRoYXQgdXNlcyBhIFdyaXRlVHJlZSBpbiBhZGRpdGlvbiB0byBhbnkgb3RoZXIgc2VydmVyIGRhdGEgb3JcclxuICogb2xkIGV2ZW50IGNhY2hlcyBhdmFpbGFibGUgdG8gY2FsY3VsYXRlIGNvbXBsZXRlIGNoaWxkcmVuLlxyXG4gKi9cclxuY2xhc3MgV3JpdGVUcmVlQ29tcGxldGVDaGlsZFNvdXJjZSB7XHJcbiAgICBjb25zdHJ1Y3Rvcih3cml0ZXNfLCB2aWV3Q2FjaGVfLCBvcHRDb21wbGV0ZVNlcnZlckNhY2hlXyA9IG51bGwpIHtcclxuICAgICAgICB0aGlzLndyaXRlc18gPSB3cml0ZXNfO1xyXG4gICAgICAgIHRoaXMudmlld0NhY2hlXyA9IHZpZXdDYWNoZV87XHJcbiAgICAgICAgdGhpcy5vcHRDb21wbGV0ZVNlcnZlckNhY2hlXyA9IG9wdENvbXBsZXRlU2VydmVyQ2FjaGVfO1xyXG4gICAgfVxyXG4gICAgZ2V0Q29tcGxldGVDaGlsZChjaGlsZEtleSkge1xyXG4gICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLnZpZXdDYWNoZV8uZXZlbnRDYWNoZTtcclxuICAgICAgICBpZiAobm9kZS5pc0NvbXBsZXRlRm9yQ2hpbGQoY2hpbGRLZXkpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBub2RlLmdldE5vZGUoKS5nZXRJbW1lZGlhdGVDaGlsZChjaGlsZEtleSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCBzZXJ2ZXJOb2RlID0gdGhpcy5vcHRDb21wbGV0ZVNlcnZlckNhY2hlXyAhPSBudWxsXHJcbiAgICAgICAgICAgICAgICA/IG5ldyBDYWNoZU5vZGUodGhpcy5vcHRDb21wbGV0ZVNlcnZlckNhY2hlXywgdHJ1ZSwgZmFsc2UpXHJcbiAgICAgICAgICAgICAgICA6IHRoaXMudmlld0NhY2hlXy5zZXJ2ZXJDYWNoZTtcclxuICAgICAgICAgICAgcmV0dXJuIHdyaXRlVHJlZVJlZkNhbGNDb21wbGV0ZUNoaWxkKHRoaXMud3JpdGVzXywgY2hpbGRLZXksIHNlcnZlck5vZGUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGdldENoaWxkQWZ0ZXJDaGlsZChpbmRleCwgY2hpbGQsIHJldmVyc2UpIHtcclxuICAgICAgICBjb25zdCBjb21wbGV0ZVNlcnZlckRhdGEgPSB0aGlzLm9wdENvbXBsZXRlU2VydmVyQ2FjaGVfICE9IG51bGxcclxuICAgICAgICAgICAgPyB0aGlzLm9wdENvbXBsZXRlU2VydmVyQ2FjaGVfXHJcbiAgICAgICAgICAgIDogdmlld0NhY2hlR2V0Q29tcGxldGVTZXJ2ZXJTbmFwKHRoaXMudmlld0NhY2hlXyk7XHJcbiAgICAgICAgY29uc3Qgbm9kZXMgPSB3cml0ZVRyZWVSZWZDYWxjSW5kZXhlZFNsaWNlKHRoaXMud3JpdGVzXywgY29tcGxldGVTZXJ2ZXJEYXRhLCBjaGlsZCwgMSwgcmV2ZXJzZSwgaW5kZXgpO1xyXG4gICAgICAgIGlmIChub2Rlcy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gbm9kZXNbMF07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmZ1bmN0aW9uIG5ld1ZpZXdQcm9jZXNzb3IoZmlsdGVyKSB7XHJcbiAgICByZXR1cm4geyBmaWx0ZXIgfTtcclxufVxyXG5mdW5jdGlvbiB2aWV3UHJvY2Vzc29yQXNzZXJ0SW5kZXhlZCh2aWV3UHJvY2Vzc29yLCB2aWV3Q2FjaGUpIHtcclxuICAgIGFzc2VydCh2aWV3Q2FjaGUuZXZlbnRDYWNoZS5nZXROb2RlKCkuaXNJbmRleGVkKHZpZXdQcm9jZXNzb3IuZmlsdGVyLmdldEluZGV4KCkpLCAnRXZlbnQgc25hcCBub3QgaW5kZXhlZCcpO1xyXG4gICAgYXNzZXJ0KHZpZXdDYWNoZS5zZXJ2ZXJDYWNoZS5nZXROb2RlKCkuaXNJbmRleGVkKHZpZXdQcm9jZXNzb3IuZmlsdGVyLmdldEluZGV4KCkpLCAnU2VydmVyIHNuYXAgbm90IGluZGV4ZWQnKTtcclxufVxyXG5mdW5jdGlvbiB2aWV3UHJvY2Vzc29yQXBwbHlPcGVyYXRpb24odmlld1Byb2Nlc3Nvciwgb2xkVmlld0NhY2hlLCBvcGVyYXRpb24sIHdyaXRlc0NhY2hlLCBjb21wbGV0ZUNhY2hlKSB7XHJcbiAgICBjb25zdCBhY2N1bXVsYXRvciA9IG5ldyBDaGlsZENoYW5nZUFjY3VtdWxhdG9yKCk7XHJcbiAgICBsZXQgbmV3Vmlld0NhY2hlLCBmaWx0ZXJTZXJ2ZXJOb2RlO1xyXG4gICAgaWYgKG9wZXJhdGlvbi50eXBlID09PSBPcGVyYXRpb25UeXBlLk9WRVJXUklURSkge1xyXG4gICAgICAgIGNvbnN0IG92ZXJ3cml0ZSA9IG9wZXJhdGlvbjtcclxuICAgICAgICBpZiAob3ZlcndyaXRlLnNvdXJjZS5mcm9tVXNlcikge1xyXG4gICAgICAgICAgICBuZXdWaWV3Q2FjaGUgPSB2aWV3UHJvY2Vzc29yQXBwbHlVc2VyT3ZlcndyaXRlKHZpZXdQcm9jZXNzb3IsIG9sZFZpZXdDYWNoZSwgb3ZlcndyaXRlLnBhdGgsIG92ZXJ3cml0ZS5zbmFwLCB3cml0ZXNDYWNoZSwgY29tcGxldGVDYWNoZSwgYWNjdW11bGF0b3IpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgYXNzZXJ0KG92ZXJ3cml0ZS5zb3VyY2UuZnJvbVNlcnZlciwgJ1Vua25vd24gc291cmNlLicpO1xyXG4gICAgICAgICAgICAvLyBXZSBmaWx0ZXIgdGhlIG5vZGUgaWYgaXQncyBhIHRhZ2dlZCB1cGRhdGUgb3IgdGhlIG5vZGUgaGFzIGJlZW4gcHJldmlvdXNseSBmaWx0ZXJlZCAgYW5kIHRoZVxyXG4gICAgICAgICAgICAvLyB1cGRhdGUgaXMgbm90IGF0IHRoZSByb290IGluIHdoaWNoIGNhc2UgaXQgaXMgb2sgKGFuZCBuZWNlc3NhcnkpIHRvIG1hcmsgdGhlIG5vZGUgdW5maWx0ZXJlZFxyXG4gICAgICAgICAgICAvLyBhZ2FpblxyXG4gICAgICAgICAgICBmaWx0ZXJTZXJ2ZXJOb2RlID1cclxuICAgICAgICAgICAgICAgIG92ZXJ3cml0ZS5zb3VyY2UudGFnZ2VkIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgKG9sZFZpZXdDYWNoZS5zZXJ2ZXJDYWNoZS5pc0ZpbHRlcmVkKCkgJiYgIXBhdGhJc0VtcHR5KG92ZXJ3cml0ZS5wYXRoKSk7XHJcbiAgICAgICAgICAgIG5ld1ZpZXdDYWNoZSA9IHZpZXdQcm9jZXNzb3JBcHBseVNlcnZlck92ZXJ3cml0ZSh2aWV3UHJvY2Vzc29yLCBvbGRWaWV3Q2FjaGUsIG92ZXJ3cml0ZS5wYXRoLCBvdmVyd3JpdGUuc25hcCwgd3JpdGVzQ2FjaGUsIGNvbXBsZXRlQ2FjaGUsIGZpbHRlclNlcnZlck5vZGUsIGFjY3VtdWxhdG9yKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChvcGVyYXRpb24udHlwZSA9PT0gT3BlcmF0aW9uVHlwZS5NRVJHRSkge1xyXG4gICAgICAgIGNvbnN0IG1lcmdlID0gb3BlcmF0aW9uO1xyXG4gICAgICAgIGlmIChtZXJnZS5zb3VyY2UuZnJvbVVzZXIpIHtcclxuICAgICAgICAgICAgbmV3Vmlld0NhY2hlID0gdmlld1Byb2Nlc3NvckFwcGx5VXNlck1lcmdlKHZpZXdQcm9jZXNzb3IsIG9sZFZpZXdDYWNoZSwgbWVyZ2UucGF0aCwgbWVyZ2UuY2hpbGRyZW4sIHdyaXRlc0NhY2hlLCBjb21wbGV0ZUNhY2hlLCBhY2N1bXVsYXRvcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBhc3NlcnQobWVyZ2Uuc291cmNlLmZyb21TZXJ2ZXIsICdVbmtub3duIHNvdXJjZS4nKTtcclxuICAgICAgICAgICAgLy8gV2UgZmlsdGVyIHRoZSBub2RlIGlmIGl0J3MgYSB0YWdnZWQgdXBkYXRlIG9yIHRoZSBub2RlIGhhcyBiZWVuIHByZXZpb3VzbHkgZmlsdGVyZWRcclxuICAgICAgICAgICAgZmlsdGVyU2VydmVyTm9kZSA9XHJcbiAgICAgICAgICAgICAgICBtZXJnZS5zb3VyY2UudGFnZ2VkIHx8IG9sZFZpZXdDYWNoZS5zZXJ2ZXJDYWNoZS5pc0ZpbHRlcmVkKCk7XHJcbiAgICAgICAgICAgIG5ld1ZpZXdDYWNoZSA9IHZpZXdQcm9jZXNzb3JBcHBseVNlcnZlck1lcmdlKHZpZXdQcm9jZXNzb3IsIG9sZFZpZXdDYWNoZSwgbWVyZ2UucGF0aCwgbWVyZ2UuY2hpbGRyZW4sIHdyaXRlc0NhY2hlLCBjb21wbGV0ZUNhY2hlLCBmaWx0ZXJTZXJ2ZXJOb2RlLCBhY2N1bXVsYXRvcik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAob3BlcmF0aW9uLnR5cGUgPT09IE9wZXJhdGlvblR5cGUuQUNLX1VTRVJfV1JJVEUpIHtcclxuICAgICAgICBjb25zdCBhY2tVc2VyV3JpdGUgPSBvcGVyYXRpb247XHJcbiAgICAgICAgaWYgKCFhY2tVc2VyV3JpdGUucmV2ZXJ0KSB7XHJcbiAgICAgICAgICAgIG5ld1ZpZXdDYWNoZSA9IHZpZXdQcm9jZXNzb3JBY2tVc2VyV3JpdGUodmlld1Byb2Nlc3Nvciwgb2xkVmlld0NhY2hlLCBhY2tVc2VyV3JpdGUucGF0aCwgYWNrVXNlcldyaXRlLmFmZmVjdGVkVHJlZSwgd3JpdGVzQ2FjaGUsIGNvbXBsZXRlQ2FjaGUsIGFjY3VtdWxhdG9yKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIG5ld1ZpZXdDYWNoZSA9IHZpZXdQcm9jZXNzb3JSZXZlcnRVc2VyV3JpdGUodmlld1Byb2Nlc3Nvciwgb2xkVmlld0NhY2hlLCBhY2tVc2VyV3JpdGUucGF0aCwgd3JpdGVzQ2FjaGUsIGNvbXBsZXRlQ2FjaGUsIGFjY3VtdWxhdG9yKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChvcGVyYXRpb24udHlwZSA9PT0gT3BlcmF0aW9uVHlwZS5MSVNURU5fQ09NUExFVEUpIHtcclxuICAgICAgICBuZXdWaWV3Q2FjaGUgPSB2aWV3UHJvY2Vzc29yTGlzdGVuQ29tcGxldGUodmlld1Byb2Nlc3Nvciwgb2xkVmlld0NhY2hlLCBvcGVyYXRpb24ucGF0aCwgd3JpdGVzQ2FjaGUsIGFjY3VtdWxhdG9yKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHRocm93IGFzc2VydGlvbkVycm9yKCdVbmtub3duIG9wZXJhdGlvbiB0eXBlOiAnICsgb3BlcmF0aW9uLnR5cGUpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgY2hhbmdlcyA9IGFjY3VtdWxhdG9yLmdldENoYW5nZXMoKTtcclxuICAgIHZpZXdQcm9jZXNzb3JNYXliZUFkZFZhbHVlRXZlbnQob2xkVmlld0NhY2hlLCBuZXdWaWV3Q2FjaGUsIGNoYW5nZXMpO1xyXG4gICAgcmV0dXJuIHsgdmlld0NhY2hlOiBuZXdWaWV3Q2FjaGUsIGNoYW5nZXMgfTtcclxufVxyXG5mdW5jdGlvbiB2aWV3UHJvY2Vzc29yTWF5YmVBZGRWYWx1ZUV2ZW50KG9sZFZpZXdDYWNoZSwgbmV3Vmlld0NhY2hlLCBhY2N1bXVsYXRvcikge1xyXG4gICAgY29uc3QgZXZlbnRTbmFwID0gbmV3Vmlld0NhY2hlLmV2ZW50Q2FjaGU7XHJcbiAgICBpZiAoZXZlbnRTbmFwLmlzRnVsbHlJbml0aWFsaXplZCgpKSB7XHJcbiAgICAgICAgY29uc3QgaXNMZWFmT3JFbXB0eSA9IGV2ZW50U25hcC5nZXROb2RlKCkuaXNMZWFmTm9kZSgpIHx8IGV2ZW50U25hcC5nZXROb2RlKCkuaXNFbXB0eSgpO1xyXG4gICAgICAgIGNvbnN0IG9sZENvbXBsZXRlU25hcCA9IHZpZXdDYWNoZUdldENvbXBsZXRlRXZlbnRTbmFwKG9sZFZpZXdDYWNoZSk7XHJcbiAgICAgICAgaWYgKGFjY3VtdWxhdG9yLmxlbmd0aCA+IDAgfHxcclxuICAgICAgICAgICAgIW9sZFZpZXdDYWNoZS5ldmVudENhY2hlLmlzRnVsbHlJbml0aWFsaXplZCgpIHx8XHJcbiAgICAgICAgICAgIChpc0xlYWZPckVtcHR5ICYmICFldmVudFNuYXAuZ2V0Tm9kZSgpLmVxdWFscyhvbGRDb21wbGV0ZVNuYXApKSB8fFxyXG4gICAgICAgICAgICAhZXZlbnRTbmFwLmdldE5vZGUoKS5nZXRQcmlvcml0eSgpLmVxdWFscyhvbGRDb21wbGV0ZVNuYXAuZ2V0UHJpb3JpdHkoKSkpIHtcclxuICAgICAgICAgICAgYWNjdW11bGF0b3IucHVzaChjaGFuZ2VWYWx1ZSh2aWV3Q2FjaGVHZXRDb21wbGV0ZUV2ZW50U25hcChuZXdWaWV3Q2FjaGUpKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHZpZXdQcm9jZXNzb3JHZW5lcmF0ZUV2ZW50Q2FjaGVBZnRlclNlcnZlckV2ZW50KHZpZXdQcm9jZXNzb3IsIHZpZXdDYWNoZSwgY2hhbmdlUGF0aCwgd3JpdGVzQ2FjaGUsIHNvdXJjZSwgYWNjdW11bGF0b3IpIHtcclxuICAgIGNvbnN0IG9sZEV2ZW50U25hcCA9IHZpZXdDYWNoZS5ldmVudENhY2hlO1xyXG4gICAgaWYgKHdyaXRlVHJlZVJlZlNoYWRvd2luZ1dyaXRlKHdyaXRlc0NhY2hlLCBjaGFuZ2VQYXRoKSAhPSBudWxsKSB7XHJcbiAgICAgICAgLy8gd2UgaGF2ZSBhIHNoYWRvd2luZyB3cml0ZSwgaWdub3JlIGNoYW5nZXNcclxuICAgICAgICByZXR1cm4gdmlld0NhY2hlO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgbGV0IG5ld0V2ZW50Q2FjaGUsIHNlcnZlck5vZGU7XHJcbiAgICAgICAgaWYgKHBhdGhJc0VtcHR5KGNoYW5nZVBhdGgpKSB7XHJcbiAgICAgICAgICAgIC8vIFRPRE86IGZpZ3VyZSBvdXQgaG93IHRoaXMgcGxheXMgd2l0aCBcInNsaWRpbmcgYWNrIHdpbmRvd3NcIlxyXG4gICAgICAgICAgICBhc3NlcnQodmlld0NhY2hlLnNlcnZlckNhY2hlLmlzRnVsbHlJbml0aWFsaXplZCgpLCAnSWYgY2hhbmdlIHBhdGggaXMgZW1wdHksIHdlIG11c3QgaGF2ZSBjb21wbGV0ZSBzZXJ2ZXIgZGF0YScpO1xyXG4gICAgICAgICAgICBpZiAodmlld0NhY2hlLnNlcnZlckNhY2hlLmlzRmlsdGVyZWQoKSkge1xyXG4gICAgICAgICAgICAgICAgLy8gV2UgbmVlZCB0byBzcGVjaWFsIGNhc2UgdGhpcywgYmVjYXVzZSB3ZSBuZWVkIHRvIG9ubHkgYXBwbHkgd3JpdGVzIHRvIGNvbXBsZXRlIGNoaWxkcmVuLCBvclxyXG4gICAgICAgICAgICAgICAgLy8gd2UgbWlnaHQgZW5kIHVwIHJhaXNpbmcgZXZlbnRzIGZvciBpbmNvbXBsZXRlIGNoaWxkcmVuLiBJZiB0aGUgc2VydmVyIGRhdGEgaXMgZmlsdGVyZWQgZGVlcFxyXG4gICAgICAgICAgICAgICAgLy8gd3JpdGVzIGNhbm5vdCBiZSBndWFyYW50ZWVkIHRvIGJlIGNvbXBsZXRlXHJcbiAgICAgICAgICAgICAgICBjb25zdCBzZXJ2ZXJDYWNoZSA9IHZpZXdDYWNoZUdldENvbXBsZXRlU2VydmVyU25hcCh2aWV3Q2FjaGUpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY29tcGxldGVDaGlsZHJlbiA9IHNlcnZlckNhY2hlIGluc3RhbmNlb2YgQ2hpbGRyZW5Ob2RlXHJcbiAgICAgICAgICAgICAgICAgICAgPyBzZXJ2ZXJDYWNoZVxyXG4gICAgICAgICAgICAgICAgICAgIDogQ2hpbGRyZW5Ob2RlLkVNUFRZX05PREU7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjb21wbGV0ZUV2ZW50Q2hpbGRyZW4gPSB3cml0ZVRyZWVSZWZDYWxjQ29tcGxldGVFdmVudENoaWxkcmVuKHdyaXRlc0NhY2hlLCBjb21wbGV0ZUNoaWxkcmVuKTtcclxuICAgICAgICAgICAgICAgIG5ld0V2ZW50Q2FjaGUgPSB2aWV3UHJvY2Vzc29yLmZpbHRlci51cGRhdGVGdWxsTm9kZSh2aWV3Q2FjaGUuZXZlbnRDYWNoZS5nZXROb2RlKCksIGNvbXBsZXRlRXZlbnRDaGlsZHJlbiwgYWNjdW11bGF0b3IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY29tcGxldGVOb2RlID0gd3JpdGVUcmVlUmVmQ2FsY0NvbXBsZXRlRXZlbnRDYWNoZSh3cml0ZXNDYWNoZSwgdmlld0NhY2hlR2V0Q29tcGxldGVTZXJ2ZXJTbmFwKHZpZXdDYWNoZSkpO1xyXG4gICAgICAgICAgICAgICAgbmV3RXZlbnRDYWNoZSA9IHZpZXdQcm9jZXNzb3IuZmlsdGVyLnVwZGF0ZUZ1bGxOb2RlKHZpZXdDYWNoZS5ldmVudENhY2hlLmdldE5vZGUoKSwgY29tcGxldGVOb2RlLCBhY2N1bXVsYXRvcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkS2V5ID0gcGF0aEdldEZyb250KGNoYW5nZVBhdGgpO1xyXG4gICAgICAgICAgICBpZiAoY2hpbGRLZXkgPT09ICcucHJpb3JpdHknKSB7XHJcbiAgICAgICAgICAgICAgICBhc3NlcnQocGF0aEdldExlbmd0aChjaGFuZ2VQYXRoKSA9PT0gMSwgXCJDYW4ndCBoYXZlIGEgcHJpb3JpdHkgd2l0aCBhZGRpdGlvbmFsIHBhdGggY29tcG9uZW50c1wiKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG9sZEV2ZW50Tm9kZSA9IG9sZEV2ZW50U25hcC5nZXROb2RlKCk7XHJcbiAgICAgICAgICAgICAgICBzZXJ2ZXJOb2RlID0gdmlld0NhY2hlLnNlcnZlckNhY2hlLmdldE5vZGUoKTtcclxuICAgICAgICAgICAgICAgIC8vIHdlIG1pZ2h0IGhhdmUgb3ZlcndyaXRlcyBmb3IgdGhpcyBwcmlvcml0eVxyXG4gICAgICAgICAgICAgICAgY29uc3QgdXBkYXRlZFByaW9yaXR5ID0gd3JpdGVUcmVlUmVmQ2FsY0V2ZW50Q2FjaGVBZnRlclNlcnZlck92ZXJ3cml0ZSh3cml0ZXNDYWNoZSwgY2hhbmdlUGF0aCwgb2xkRXZlbnROb2RlLCBzZXJ2ZXJOb2RlKTtcclxuICAgICAgICAgICAgICAgIGlmICh1cGRhdGVkUHJpb3JpdHkgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG5ld0V2ZW50Q2FjaGUgPSB2aWV3UHJvY2Vzc29yLmZpbHRlci51cGRhdGVQcmlvcml0eShvbGRFdmVudE5vZGUsIHVwZGF0ZWRQcmlvcml0eSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBwcmlvcml0eSBkaWRuJ3QgY2hhbmdlLCBrZWVwIG9sZCBub2RlXHJcbiAgICAgICAgICAgICAgICAgICAgbmV3RXZlbnRDYWNoZSA9IG9sZEV2ZW50U25hcC5nZXROb2RlKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjaGlsZENoYW5nZVBhdGggPSBwYXRoUG9wRnJvbnQoY2hhbmdlUGF0aCk7XHJcbiAgICAgICAgICAgICAgICAvLyB1cGRhdGUgY2hpbGRcclxuICAgICAgICAgICAgICAgIGxldCBuZXdFdmVudENoaWxkO1xyXG4gICAgICAgICAgICAgICAgaWYgKG9sZEV2ZW50U25hcC5pc0NvbXBsZXRlRm9yQ2hpbGQoY2hpbGRLZXkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VydmVyTm9kZSA9IHZpZXdDYWNoZS5zZXJ2ZXJDYWNoZS5nZXROb2RlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXZlbnRDaGlsZFVwZGF0ZSA9IHdyaXRlVHJlZVJlZkNhbGNFdmVudENhY2hlQWZ0ZXJTZXJ2ZXJPdmVyd3JpdGUod3JpdGVzQ2FjaGUsIGNoYW5nZVBhdGgsIG9sZEV2ZW50U25hcC5nZXROb2RlKCksIHNlcnZlck5vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChldmVudENoaWxkVXBkYXRlICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3RXZlbnRDaGlsZCA9IG9sZEV2ZW50U25hcFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmdldE5vZGUoKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmdldEltbWVkaWF0ZUNoaWxkKGNoaWxkS2V5KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnVwZGF0ZUNoaWxkKGNoaWxkQ2hhbmdlUGF0aCwgZXZlbnRDaGlsZFVwZGF0ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBOb3RoaW5nIGNoYW5nZWQsIGp1c3Qga2VlcCB0aGUgb2xkIGNoaWxkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld0V2ZW50Q2hpbGQgPSBvbGRFdmVudFNuYXAuZ2V0Tm9kZSgpLmdldEltbWVkaWF0ZUNoaWxkKGNoaWxkS2V5KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBuZXdFdmVudENoaWxkID0gd3JpdGVUcmVlUmVmQ2FsY0NvbXBsZXRlQ2hpbGQod3JpdGVzQ2FjaGUsIGNoaWxkS2V5LCB2aWV3Q2FjaGUuc2VydmVyQ2FjaGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKG5ld0V2ZW50Q2hpbGQgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG5ld0V2ZW50Q2FjaGUgPSB2aWV3UHJvY2Vzc29yLmZpbHRlci51cGRhdGVDaGlsZChvbGRFdmVudFNuYXAuZ2V0Tm9kZSgpLCBjaGlsZEtleSwgbmV3RXZlbnRDaGlsZCwgY2hpbGRDaGFuZ2VQYXRoLCBzb3VyY2UsIGFjY3VtdWxhdG9yKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIG5vIGNvbXBsZXRlIGNoaWxkIGF2YWlsYWJsZSBvciBubyBjaGFuZ2VcclxuICAgICAgICAgICAgICAgICAgICBuZXdFdmVudENhY2hlID0gb2xkRXZlbnRTbmFwLmdldE5vZGUoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdmlld0NhY2hlVXBkYXRlRXZlbnRTbmFwKHZpZXdDYWNoZSwgbmV3RXZlbnRDYWNoZSwgb2xkRXZlbnRTbmFwLmlzRnVsbHlJbml0aWFsaXplZCgpIHx8IHBhdGhJc0VtcHR5KGNoYW5nZVBhdGgpLCB2aWV3UHJvY2Vzc29yLmZpbHRlci5maWx0ZXJzTm9kZXMoKSk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gdmlld1Byb2Nlc3NvckFwcGx5U2VydmVyT3ZlcndyaXRlKHZpZXdQcm9jZXNzb3IsIG9sZFZpZXdDYWNoZSwgY2hhbmdlUGF0aCwgY2hhbmdlZFNuYXAsIHdyaXRlc0NhY2hlLCBjb21wbGV0ZUNhY2hlLCBmaWx0ZXJTZXJ2ZXJOb2RlLCBhY2N1bXVsYXRvcikge1xyXG4gICAgY29uc3Qgb2xkU2VydmVyU25hcCA9IG9sZFZpZXdDYWNoZS5zZXJ2ZXJDYWNoZTtcclxuICAgIGxldCBuZXdTZXJ2ZXJDYWNoZTtcclxuICAgIGNvbnN0IHNlcnZlckZpbHRlciA9IGZpbHRlclNlcnZlck5vZGVcclxuICAgICAgICA/IHZpZXdQcm9jZXNzb3IuZmlsdGVyXHJcbiAgICAgICAgOiB2aWV3UHJvY2Vzc29yLmZpbHRlci5nZXRJbmRleGVkRmlsdGVyKCk7XHJcbiAgICBpZiAocGF0aElzRW1wdHkoY2hhbmdlUGF0aCkpIHtcclxuICAgICAgICBuZXdTZXJ2ZXJDYWNoZSA9IHNlcnZlckZpbHRlci51cGRhdGVGdWxsTm9kZShvbGRTZXJ2ZXJTbmFwLmdldE5vZGUoKSwgY2hhbmdlZFNuYXAsIG51bGwpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoc2VydmVyRmlsdGVyLmZpbHRlcnNOb2RlcygpICYmICFvbGRTZXJ2ZXJTbmFwLmlzRmlsdGVyZWQoKSkge1xyXG4gICAgICAgIC8vIHdlIHdhbnQgdG8gZmlsdGVyIHRoZSBzZXJ2ZXIgbm9kZSwgYnV0IHdlIGRpZG4ndCBmaWx0ZXIgdGhlIHNlcnZlciBub2RlIHlldCwgc28gc2ltdWxhdGUgYSBmdWxsIHVwZGF0ZVxyXG4gICAgICAgIGNvbnN0IG5ld1NlcnZlck5vZGUgPSBvbGRTZXJ2ZXJTbmFwXHJcbiAgICAgICAgICAgIC5nZXROb2RlKClcclxuICAgICAgICAgICAgLnVwZGF0ZUNoaWxkKGNoYW5nZVBhdGgsIGNoYW5nZWRTbmFwKTtcclxuICAgICAgICBuZXdTZXJ2ZXJDYWNoZSA9IHNlcnZlckZpbHRlci51cGRhdGVGdWxsTm9kZShvbGRTZXJ2ZXJTbmFwLmdldE5vZGUoKSwgbmV3U2VydmVyTm9kZSwgbnVsbCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBjb25zdCBjaGlsZEtleSA9IHBhdGhHZXRGcm9udChjaGFuZ2VQYXRoKTtcclxuICAgICAgICBpZiAoIW9sZFNlcnZlclNuYXAuaXNDb21wbGV0ZUZvclBhdGgoY2hhbmdlUGF0aCkgJiZcclxuICAgICAgICAgICAgcGF0aEdldExlbmd0aChjaGFuZ2VQYXRoKSA+IDEpIHtcclxuICAgICAgICAgICAgLy8gV2UgZG9uJ3QgdXBkYXRlIGluY29tcGxldGUgbm9kZXMgd2l0aCB1cGRhdGVzIGludGVuZGVkIGZvciBvdGhlciBsaXN0ZW5lcnNcclxuICAgICAgICAgICAgcmV0dXJuIG9sZFZpZXdDYWNoZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgY2hpbGRDaGFuZ2VQYXRoID0gcGF0aFBvcEZyb250KGNoYW5nZVBhdGgpO1xyXG4gICAgICAgIGNvbnN0IGNoaWxkTm9kZSA9IG9sZFNlcnZlclNuYXAuZ2V0Tm9kZSgpLmdldEltbWVkaWF0ZUNoaWxkKGNoaWxkS2V5KTtcclxuICAgICAgICBjb25zdCBuZXdDaGlsZE5vZGUgPSBjaGlsZE5vZGUudXBkYXRlQ2hpbGQoY2hpbGRDaGFuZ2VQYXRoLCBjaGFuZ2VkU25hcCk7XHJcbiAgICAgICAgaWYgKGNoaWxkS2V5ID09PSAnLnByaW9yaXR5Jykge1xyXG4gICAgICAgICAgICBuZXdTZXJ2ZXJDYWNoZSA9IHNlcnZlckZpbHRlci51cGRhdGVQcmlvcml0eShvbGRTZXJ2ZXJTbmFwLmdldE5vZGUoKSwgbmV3Q2hpbGROb2RlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIG5ld1NlcnZlckNhY2hlID0gc2VydmVyRmlsdGVyLnVwZGF0ZUNoaWxkKG9sZFNlcnZlclNuYXAuZ2V0Tm9kZSgpLCBjaGlsZEtleSwgbmV3Q2hpbGROb2RlLCBjaGlsZENoYW5nZVBhdGgsIE5PX0NPTVBMRVRFX0NISUxEX1NPVVJDRSwgbnVsbCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY29uc3QgbmV3Vmlld0NhY2hlID0gdmlld0NhY2hlVXBkYXRlU2VydmVyU25hcChvbGRWaWV3Q2FjaGUsIG5ld1NlcnZlckNhY2hlLCBvbGRTZXJ2ZXJTbmFwLmlzRnVsbHlJbml0aWFsaXplZCgpIHx8IHBhdGhJc0VtcHR5KGNoYW5nZVBhdGgpLCBzZXJ2ZXJGaWx0ZXIuZmlsdGVyc05vZGVzKCkpO1xyXG4gICAgY29uc3Qgc291cmNlID0gbmV3IFdyaXRlVHJlZUNvbXBsZXRlQ2hpbGRTb3VyY2Uod3JpdGVzQ2FjaGUsIG5ld1ZpZXdDYWNoZSwgY29tcGxldGVDYWNoZSk7XHJcbiAgICByZXR1cm4gdmlld1Byb2Nlc3NvckdlbmVyYXRlRXZlbnRDYWNoZUFmdGVyU2VydmVyRXZlbnQodmlld1Byb2Nlc3NvciwgbmV3Vmlld0NhY2hlLCBjaGFuZ2VQYXRoLCB3cml0ZXNDYWNoZSwgc291cmNlLCBhY2N1bXVsYXRvcik7XHJcbn1cclxuZnVuY3Rpb24gdmlld1Byb2Nlc3NvckFwcGx5VXNlck92ZXJ3cml0ZSh2aWV3UHJvY2Vzc29yLCBvbGRWaWV3Q2FjaGUsIGNoYW5nZVBhdGgsIGNoYW5nZWRTbmFwLCB3cml0ZXNDYWNoZSwgY29tcGxldGVDYWNoZSwgYWNjdW11bGF0b3IpIHtcclxuICAgIGNvbnN0IG9sZEV2ZW50U25hcCA9IG9sZFZpZXdDYWNoZS5ldmVudENhY2hlO1xyXG4gICAgbGV0IG5ld1ZpZXdDYWNoZSwgbmV3RXZlbnRDYWNoZTtcclxuICAgIGNvbnN0IHNvdXJjZSA9IG5ldyBXcml0ZVRyZWVDb21wbGV0ZUNoaWxkU291cmNlKHdyaXRlc0NhY2hlLCBvbGRWaWV3Q2FjaGUsIGNvbXBsZXRlQ2FjaGUpO1xyXG4gICAgaWYgKHBhdGhJc0VtcHR5KGNoYW5nZVBhdGgpKSB7XHJcbiAgICAgICAgbmV3RXZlbnRDYWNoZSA9IHZpZXdQcm9jZXNzb3IuZmlsdGVyLnVwZGF0ZUZ1bGxOb2RlKG9sZFZpZXdDYWNoZS5ldmVudENhY2hlLmdldE5vZGUoKSwgY2hhbmdlZFNuYXAsIGFjY3VtdWxhdG9yKTtcclxuICAgICAgICBuZXdWaWV3Q2FjaGUgPSB2aWV3Q2FjaGVVcGRhdGVFdmVudFNuYXAob2xkVmlld0NhY2hlLCBuZXdFdmVudENhY2hlLCB0cnVlLCB2aWV3UHJvY2Vzc29yLmZpbHRlci5maWx0ZXJzTm9kZXMoKSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBjb25zdCBjaGlsZEtleSA9IHBhdGhHZXRGcm9udChjaGFuZ2VQYXRoKTtcclxuICAgICAgICBpZiAoY2hpbGRLZXkgPT09ICcucHJpb3JpdHknKSB7XHJcbiAgICAgICAgICAgIG5ld0V2ZW50Q2FjaGUgPSB2aWV3UHJvY2Vzc29yLmZpbHRlci51cGRhdGVQcmlvcml0eShvbGRWaWV3Q2FjaGUuZXZlbnRDYWNoZS5nZXROb2RlKCksIGNoYW5nZWRTbmFwKTtcclxuICAgICAgICAgICAgbmV3Vmlld0NhY2hlID0gdmlld0NhY2hlVXBkYXRlRXZlbnRTbmFwKG9sZFZpZXdDYWNoZSwgbmV3RXZlbnRDYWNoZSwgb2xkRXZlbnRTbmFwLmlzRnVsbHlJbml0aWFsaXplZCgpLCBvbGRFdmVudFNuYXAuaXNGaWx0ZXJlZCgpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkQ2hhbmdlUGF0aCA9IHBhdGhQb3BGcm9udChjaGFuZ2VQYXRoKTtcclxuICAgICAgICAgICAgY29uc3Qgb2xkQ2hpbGQgPSBvbGRFdmVudFNuYXAuZ2V0Tm9kZSgpLmdldEltbWVkaWF0ZUNoaWxkKGNoaWxkS2V5KTtcclxuICAgICAgICAgICAgbGV0IG5ld0NoaWxkO1xyXG4gICAgICAgICAgICBpZiAocGF0aElzRW1wdHkoY2hpbGRDaGFuZ2VQYXRoKSkge1xyXG4gICAgICAgICAgICAgICAgLy8gQ2hpbGQgb3ZlcndyaXRlLCB3ZSBjYW4gcmVwbGFjZSB0aGUgY2hpbGRcclxuICAgICAgICAgICAgICAgIG5ld0NoaWxkID0gY2hhbmdlZFNuYXA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjaGlsZE5vZGUgPSBzb3VyY2UuZ2V0Q29tcGxldGVDaGlsZChjaGlsZEtleSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGROb2RlICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocGF0aEdldEJhY2soY2hpbGRDaGFuZ2VQYXRoKSA9PT0gJy5wcmlvcml0eScgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGROb2RlLmdldENoaWxkKHBhdGhQYXJlbnQoY2hpbGRDaGFuZ2VQYXRoKSkuaXNFbXB0eSgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgYSBwcmlvcml0eSB1cGRhdGUgb24gYW4gZW1wdHkgbm9kZS4gSWYgdGhpcyBub2RlIGV4aXN0cyBvbiB0aGUgc2VydmVyLCB0aGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2VydmVyIHdpbGwgc2VuZCBkb3duIHRoZSBwcmlvcml0eSBpbiB0aGUgdXBkYXRlLCBzbyBpZ25vcmUgZm9yIG5vd1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdDaGlsZCA9IGNoaWxkTm9kZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld0NoaWxkID0gY2hpbGROb2RlLnVwZGF0ZUNoaWxkKGNoaWxkQ2hhbmdlUGF0aCwgY2hhbmdlZFNuYXApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZXJlIGlzIG5vIGNvbXBsZXRlIGNoaWxkIG5vZGUgYXZhaWxhYmxlXHJcbiAgICAgICAgICAgICAgICAgICAgbmV3Q2hpbGQgPSBDaGlsZHJlbk5vZGUuRU1QVFlfTk9ERTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIW9sZENoaWxkLmVxdWFscyhuZXdDaGlsZCkpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG5ld0V2ZW50U25hcCA9IHZpZXdQcm9jZXNzb3IuZmlsdGVyLnVwZGF0ZUNoaWxkKG9sZEV2ZW50U25hcC5nZXROb2RlKCksIGNoaWxkS2V5LCBuZXdDaGlsZCwgY2hpbGRDaGFuZ2VQYXRoLCBzb3VyY2UsIGFjY3VtdWxhdG9yKTtcclxuICAgICAgICAgICAgICAgIG5ld1ZpZXdDYWNoZSA9IHZpZXdDYWNoZVVwZGF0ZUV2ZW50U25hcChvbGRWaWV3Q2FjaGUsIG5ld0V2ZW50U25hcCwgb2xkRXZlbnRTbmFwLmlzRnVsbHlJbml0aWFsaXplZCgpLCB2aWV3UHJvY2Vzc29yLmZpbHRlci5maWx0ZXJzTm9kZXMoKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBuZXdWaWV3Q2FjaGUgPSBvbGRWaWV3Q2FjaGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbmV3Vmlld0NhY2hlO1xyXG59XHJcbmZ1bmN0aW9uIHZpZXdQcm9jZXNzb3JDYWNoZUhhc0NoaWxkKHZpZXdDYWNoZSwgY2hpbGRLZXkpIHtcclxuICAgIHJldHVybiB2aWV3Q2FjaGUuZXZlbnRDYWNoZS5pc0NvbXBsZXRlRm9yQ2hpbGQoY2hpbGRLZXkpO1xyXG59XHJcbmZ1bmN0aW9uIHZpZXdQcm9jZXNzb3JBcHBseVVzZXJNZXJnZSh2aWV3UHJvY2Vzc29yLCB2aWV3Q2FjaGUsIHBhdGgsIGNoYW5nZWRDaGlsZHJlbiwgd3JpdGVzQ2FjaGUsIHNlcnZlckNhY2hlLCBhY2N1bXVsYXRvcikge1xyXG4gICAgLy8gSEFDSzogSW4gdGhlIGNhc2Ugb2YgYSBsaW1pdCBxdWVyeSwgdGhlcmUgbWF5IGJlIHNvbWUgY2hhbmdlcyB0aGF0IGJ1bXAgdGhpbmdzIG91dCBvZiB0aGVcclxuICAgIC8vIHdpbmRvdyBsZWF2aW5nIHJvb20gZm9yIG5ldyBpdGVtcy4gIEl0J3MgaW1wb3J0YW50IHdlIHByb2Nlc3MgdGhlc2UgY2hhbmdlcyBmaXJzdCwgc28gd2VcclxuICAgIC8vIGl0ZXJhdGUgdGhlIGNoYW5nZXMgdHdpY2UsIGZpcnN0IHByb2Nlc3NpbmcgYW55IHRoYXQgYWZmZWN0IGl0ZW1zIGN1cnJlbnRseSBpbiB2aWV3LlxyXG4gICAgLy8gVE9ETzogSSBjb25zaWRlciBhbiBpdGVtIFwiaW4gdmlld1wiIGlmIGNhY2hlSGFzQ2hpbGQgaXMgdHJ1ZSwgd2hpY2ggY2hlY2tzIGJvdGggdGhlIHNlcnZlclxyXG4gICAgLy8gYW5kIGV2ZW50IHNuYXAuICBJJ20gbm90IHN1cmUgaWYgdGhpcyB3aWxsIHJlc3VsdCBpbiBlZGdlIGNhc2VzIHdoZW4gYSBjaGlsZCBpcyBpbiBvbmUgYnV0XHJcbiAgICAvLyBub3QgdGhlIG90aGVyLlxyXG4gICAgbGV0IGN1clZpZXdDYWNoZSA9IHZpZXdDYWNoZTtcclxuICAgIGNoYW5nZWRDaGlsZHJlbi5mb3JlYWNoKChyZWxhdGl2ZVBhdGgsIGNoaWxkTm9kZSkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHdyaXRlUGF0aCA9IHBhdGhDaGlsZChwYXRoLCByZWxhdGl2ZVBhdGgpO1xyXG4gICAgICAgIGlmICh2aWV3UHJvY2Vzc29yQ2FjaGVIYXNDaGlsZCh2aWV3Q2FjaGUsIHBhdGhHZXRGcm9udCh3cml0ZVBhdGgpKSkge1xyXG4gICAgICAgICAgICBjdXJWaWV3Q2FjaGUgPSB2aWV3UHJvY2Vzc29yQXBwbHlVc2VyT3ZlcndyaXRlKHZpZXdQcm9jZXNzb3IsIGN1clZpZXdDYWNoZSwgd3JpdGVQYXRoLCBjaGlsZE5vZGUsIHdyaXRlc0NhY2hlLCBzZXJ2ZXJDYWNoZSwgYWNjdW11bGF0b3IpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgY2hhbmdlZENoaWxkcmVuLmZvcmVhY2goKHJlbGF0aXZlUGF0aCwgY2hpbGROb2RlKSA9PiB7XHJcbiAgICAgICAgY29uc3Qgd3JpdGVQYXRoID0gcGF0aENoaWxkKHBhdGgsIHJlbGF0aXZlUGF0aCk7XHJcbiAgICAgICAgaWYgKCF2aWV3UHJvY2Vzc29yQ2FjaGVIYXNDaGlsZCh2aWV3Q2FjaGUsIHBhdGhHZXRGcm9udCh3cml0ZVBhdGgpKSkge1xyXG4gICAgICAgICAgICBjdXJWaWV3Q2FjaGUgPSB2aWV3UHJvY2Vzc29yQXBwbHlVc2VyT3ZlcndyaXRlKHZpZXdQcm9jZXNzb3IsIGN1clZpZXdDYWNoZSwgd3JpdGVQYXRoLCBjaGlsZE5vZGUsIHdyaXRlc0NhY2hlLCBzZXJ2ZXJDYWNoZSwgYWNjdW11bGF0b3IpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIGN1clZpZXdDYWNoZTtcclxufVxyXG5mdW5jdGlvbiB2aWV3UHJvY2Vzc29yQXBwbHlNZXJnZSh2aWV3UHJvY2Vzc29yLCBub2RlLCBtZXJnZSkge1xyXG4gICAgbWVyZ2UuZm9yZWFjaCgocmVsYXRpdmVQYXRoLCBjaGlsZE5vZGUpID0+IHtcclxuICAgICAgICBub2RlID0gbm9kZS51cGRhdGVDaGlsZChyZWxhdGl2ZVBhdGgsIGNoaWxkTm9kZSk7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBub2RlO1xyXG59XHJcbmZ1bmN0aW9uIHZpZXdQcm9jZXNzb3JBcHBseVNlcnZlck1lcmdlKHZpZXdQcm9jZXNzb3IsIHZpZXdDYWNoZSwgcGF0aCwgY2hhbmdlZENoaWxkcmVuLCB3cml0ZXNDYWNoZSwgc2VydmVyQ2FjaGUsIGZpbHRlclNlcnZlck5vZGUsIGFjY3VtdWxhdG9yKSB7XHJcbiAgICAvLyBJZiB3ZSBkb24ndCBoYXZlIGEgY2FjaGUgeWV0LCB0aGlzIG1lcmdlIHdhcyBpbnRlbmRlZCBmb3IgYSBwcmV2aW91c2x5IGxpc3RlbiBpbiB0aGUgc2FtZSBsb2NhdGlvbi4gSWdub3JlIGl0IGFuZFxyXG4gICAgLy8gd2FpdCBmb3IgdGhlIGNvbXBsZXRlIGRhdGEgdXBkYXRlIGNvbWluZyBzb29uLlxyXG4gICAgaWYgKHZpZXdDYWNoZS5zZXJ2ZXJDYWNoZS5nZXROb2RlKCkuaXNFbXB0eSgpICYmXHJcbiAgICAgICAgIXZpZXdDYWNoZS5zZXJ2ZXJDYWNoZS5pc0Z1bGx5SW5pdGlhbGl6ZWQoKSkge1xyXG4gICAgICAgIHJldHVybiB2aWV3Q2FjaGU7XHJcbiAgICB9XHJcbiAgICAvLyBIQUNLOiBJbiB0aGUgY2FzZSBvZiBhIGxpbWl0IHF1ZXJ5LCB0aGVyZSBtYXkgYmUgc29tZSBjaGFuZ2VzIHRoYXQgYnVtcCB0aGluZ3Mgb3V0IG9mIHRoZVxyXG4gICAgLy8gd2luZG93IGxlYXZpbmcgcm9vbSBmb3IgbmV3IGl0ZW1zLiAgSXQncyBpbXBvcnRhbnQgd2UgcHJvY2VzcyB0aGVzZSBjaGFuZ2VzIGZpcnN0LCBzbyB3ZVxyXG4gICAgLy8gaXRlcmF0ZSB0aGUgY2hhbmdlcyB0d2ljZSwgZmlyc3QgcHJvY2Vzc2luZyBhbnkgdGhhdCBhZmZlY3QgaXRlbXMgY3VycmVudGx5IGluIHZpZXcuXHJcbiAgICAvLyBUT0RPOiBJIGNvbnNpZGVyIGFuIGl0ZW0gXCJpbiB2aWV3XCIgaWYgY2FjaGVIYXNDaGlsZCBpcyB0cnVlLCB3aGljaCBjaGVja3MgYm90aCB0aGUgc2VydmVyXHJcbiAgICAvLyBhbmQgZXZlbnQgc25hcC4gIEknbSBub3Qgc3VyZSBpZiB0aGlzIHdpbGwgcmVzdWx0IGluIGVkZ2UgY2FzZXMgd2hlbiBhIGNoaWxkIGlzIGluIG9uZSBidXRcclxuICAgIC8vIG5vdCB0aGUgb3RoZXIuXHJcbiAgICBsZXQgY3VyVmlld0NhY2hlID0gdmlld0NhY2hlO1xyXG4gICAgbGV0IHZpZXdNZXJnZVRyZWU7XHJcbiAgICBpZiAocGF0aElzRW1wdHkocGF0aCkpIHtcclxuICAgICAgICB2aWV3TWVyZ2VUcmVlID0gY2hhbmdlZENoaWxkcmVuO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgdmlld01lcmdlVHJlZSA9IG5ldyBJbW11dGFibGVUcmVlKG51bGwpLnNldFRyZWUocGF0aCwgY2hhbmdlZENoaWxkcmVuKTtcclxuICAgIH1cclxuICAgIGNvbnN0IHNlcnZlck5vZGUgPSB2aWV3Q2FjaGUuc2VydmVyQ2FjaGUuZ2V0Tm9kZSgpO1xyXG4gICAgdmlld01lcmdlVHJlZS5jaGlsZHJlbi5pbm9yZGVyVHJhdmVyc2FsKChjaGlsZEtleSwgY2hpbGRUcmVlKSA9PiB7XHJcbiAgICAgICAgaWYgKHNlcnZlck5vZGUuaGFzQ2hpbGQoY2hpbGRLZXkpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHNlcnZlckNoaWxkID0gdmlld0NhY2hlLnNlcnZlckNhY2hlXHJcbiAgICAgICAgICAgICAgICAuZ2V0Tm9kZSgpXHJcbiAgICAgICAgICAgICAgICAuZ2V0SW1tZWRpYXRlQ2hpbGQoY2hpbGRLZXkpO1xyXG4gICAgICAgICAgICBjb25zdCBuZXdDaGlsZCA9IHZpZXdQcm9jZXNzb3JBcHBseU1lcmdlKHZpZXdQcm9jZXNzb3IsIHNlcnZlckNoaWxkLCBjaGlsZFRyZWUpO1xyXG4gICAgICAgICAgICBjdXJWaWV3Q2FjaGUgPSB2aWV3UHJvY2Vzc29yQXBwbHlTZXJ2ZXJPdmVyd3JpdGUodmlld1Byb2Nlc3NvciwgY3VyVmlld0NhY2hlLCBuZXcgUGF0aChjaGlsZEtleSksIG5ld0NoaWxkLCB3cml0ZXNDYWNoZSwgc2VydmVyQ2FjaGUsIGZpbHRlclNlcnZlck5vZGUsIGFjY3VtdWxhdG9yKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIHZpZXdNZXJnZVRyZWUuY2hpbGRyZW4uaW5vcmRlclRyYXZlcnNhbCgoY2hpbGRLZXksIGNoaWxkTWVyZ2VUcmVlKSA9PiB7XHJcbiAgICAgICAgY29uc3QgaXNVbmtub3duRGVlcE1lcmdlID0gIXZpZXdDYWNoZS5zZXJ2ZXJDYWNoZS5pc0NvbXBsZXRlRm9yQ2hpbGQoY2hpbGRLZXkpICYmXHJcbiAgICAgICAgICAgIGNoaWxkTWVyZ2VUcmVlLnZhbHVlID09PSB1bmRlZmluZWQ7XHJcbiAgICAgICAgaWYgKCFzZXJ2ZXJOb2RlLmhhc0NoaWxkKGNoaWxkS2V5KSAmJiAhaXNVbmtub3duRGVlcE1lcmdlKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHNlcnZlckNoaWxkID0gdmlld0NhY2hlLnNlcnZlckNhY2hlXHJcbiAgICAgICAgICAgICAgICAuZ2V0Tm9kZSgpXHJcbiAgICAgICAgICAgICAgICAuZ2V0SW1tZWRpYXRlQ2hpbGQoY2hpbGRLZXkpO1xyXG4gICAgICAgICAgICBjb25zdCBuZXdDaGlsZCA9IHZpZXdQcm9jZXNzb3JBcHBseU1lcmdlKHZpZXdQcm9jZXNzb3IsIHNlcnZlckNoaWxkLCBjaGlsZE1lcmdlVHJlZSk7XHJcbiAgICAgICAgICAgIGN1clZpZXdDYWNoZSA9IHZpZXdQcm9jZXNzb3JBcHBseVNlcnZlck92ZXJ3cml0ZSh2aWV3UHJvY2Vzc29yLCBjdXJWaWV3Q2FjaGUsIG5ldyBQYXRoKGNoaWxkS2V5KSwgbmV3Q2hpbGQsIHdyaXRlc0NhY2hlLCBzZXJ2ZXJDYWNoZSwgZmlsdGVyU2VydmVyTm9kZSwgYWNjdW11bGF0b3IpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIGN1clZpZXdDYWNoZTtcclxufVxyXG5mdW5jdGlvbiB2aWV3UHJvY2Vzc29yQWNrVXNlcldyaXRlKHZpZXdQcm9jZXNzb3IsIHZpZXdDYWNoZSwgYWNrUGF0aCwgYWZmZWN0ZWRUcmVlLCB3cml0ZXNDYWNoZSwgY29tcGxldGVDYWNoZSwgYWNjdW11bGF0b3IpIHtcclxuICAgIGlmICh3cml0ZVRyZWVSZWZTaGFkb3dpbmdXcml0ZSh3cml0ZXNDYWNoZSwgYWNrUGF0aCkgIT0gbnVsbCkge1xyXG4gICAgICAgIHJldHVybiB2aWV3Q2FjaGU7XHJcbiAgICB9XHJcbiAgICAvLyBPbmx5IGZpbHRlciBzZXJ2ZXIgbm9kZSBpZiBpdCBpcyBjdXJyZW50bHkgZmlsdGVyZWRcclxuICAgIGNvbnN0IGZpbHRlclNlcnZlck5vZGUgPSB2aWV3Q2FjaGUuc2VydmVyQ2FjaGUuaXNGaWx0ZXJlZCgpO1xyXG4gICAgLy8gRXNzZW50aWFsbHkgd2UnbGwganVzdCBnZXQgb3VyIGV4aXN0aW5nIHNlcnZlciBjYWNoZSBmb3IgdGhlIGFmZmVjdGVkIHBhdGhzIGFuZCByZS1hcHBseSBpdCBhcyBhIHNlcnZlciB1cGRhdGVcclxuICAgIC8vIG5vdyB0aGF0IGl0IHdvbid0IGJlIHNoYWRvd2VkLlxyXG4gICAgY29uc3Qgc2VydmVyQ2FjaGUgPSB2aWV3Q2FjaGUuc2VydmVyQ2FjaGU7XHJcbiAgICBpZiAoYWZmZWN0ZWRUcmVlLnZhbHVlICE9IG51bGwpIHtcclxuICAgICAgICAvLyBUaGlzIGlzIGFuIG92ZXJ3cml0ZS5cclxuICAgICAgICBpZiAoKHBhdGhJc0VtcHR5KGFja1BhdGgpICYmIHNlcnZlckNhY2hlLmlzRnVsbHlJbml0aWFsaXplZCgpKSB8fFxyXG4gICAgICAgICAgICBzZXJ2ZXJDYWNoZS5pc0NvbXBsZXRlRm9yUGF0aChhY2tQYXRoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdmlld1Byb2Nlc3NvckFwcGx5U2VydmVyT3ZlcndyaXRlKHZpZXdQcm9jZXNzb3IsIHZpZXdDYWNoZSwgYWNrUGF0aCwgc2VydmVyQ2FjaGUuZ2V0Tm9kZSgpLmdldENoaWxkKGFja1BhdGgpLCB3cml0ZXNDYWNoZSwgY29tcGxldGVDYWNoZSwgZmlsdGVyU2VydmVyTm9kZSwgYWNjdW11bGF0b3IpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChwYXRoSXNFbXB0eShhY2tQYXRoKSkge1xyXG4gICAgICAgICAgICAvLyBUaGlzIGlzIGEgZ29vZnkgZWRnZSBjYXNlIHdoZXJlIHdlIGFyZSBhY2tpbmcgZGF0YSBhdCB0aGlzIGxvY2F0aW9uIGJ1dCBkb24ndCBoYXZlIGZ1bGwgZGF0YS4gIFdlXHJcbiAgICAgICAgICAgIC8vIHNob3VsZCBqdXN0IHJlLWFwcGx5IHdoYXRldmVyIHdlIGhhdmUgaW4gb3VyIGNhY2hlIGFzIGEgbWVyZ2UuXHJcbiAgICAgICAgICAgIGxldCBjaGFuZ2VkQ2hpbGRyZW4gPSBuZXcgSW1tdXRhYmxlVHJlZShudWxsKTtcclxuICAgICAgICAgICAgc2VydmVyQ2FjaGUuZ2V0Tm9kZSgpLmZvckVhY2hDaGlsZChLRVlfSU5ERVgsIChuYW1lLCBub2RlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjaGFuZ2VkQ2hpbGRyZW4gPSBjaGFuZ2VkQ2hpbGRyZW4uc2V0KG5ldyBQYXRoKG5hbWUpLCBub2RlKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiB2aWV3UHJvY2Vzc29yQXBwbHlTZXJ2ZXJNZXJnZSh2aWV3UHJvY2Vzc29yLCB2aWV3Q2FjaGUsIGFja1BhdGgsIGNoYW5nZWRDaGlsZHJlbiwgd3JpdGVzQ2FjaGUsIGNvbXBsZXRlQ2FjaGUsIGZpbHRlclNlcnZlck5vZGUsIGFjY3VtdWxhdG9yKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB2aWV3Q2FjaGU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgLy8gVGhpcyBpcyBhIG1lcmdlLlxyXG4gICAgICAgIGxldCBjaGFuZ2VkQ2hpbGRyZW4gPSBuZXcgSW1tdXRhYmxlVHJlZShudWxsKTtcclxuICAgICAgICBhZmZlY3RlZFRyZWUuZm9yZWFjaCgobWVyZ2VQYXRoLCB2YWx1ZSkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBzZXJ2ZXJDYWNoZVBhdGggPSBwYXRoQ2hpbGQoYWNrUGF0aCwgbWVyZ2VQYXRoKTtcclxuICAgICAgICAgICAgaWYgKHNlcnZlckNhY2hlLmlzQ29tcGxldGVGb3JQYXRoKHNlcnZlckNhY2hlUGF0aCkpIHtcclxuICAgICAgICAgICAgICAgIGNoYW5nZWRDaGlsZHJlbiA9IGNoYW5nZWRDaGlsZHJlbi5zZXQobWVyZ2VQYXRoLCBzZXJ2ZXJDYWNoZS5nZXROb2RlKCkuZ2V0Q2hpbGQoc2VydmVyQ2FjaGVQYXRoKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gdmlld1Byb2Nlc3NvckFwcGx5U2VydmVyTWVyZ2Uodmlld1Byb2Nlc3Nvciwgdmlld0NhY2hlLCBhY2tQYXRoLCBjaGFuZ2VkQ2hpbGRyZW4sIHdyaXRlc0NhY2hlLCBjb21wbGV0ZUNhY2hlLCBmaWx0ZXJTZXJ2ZXJOb2RlLCBhY2N1bXVsYXRvcik7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gdmlld1Byb2Nlc3Nvckxpc3RlbkNvbXBsZXRlKHZpZXdQcm9jZXNzb3IsIHZpZXdDYWNoZSwgcGF0aCwgd3JpdGVzQ2FjaGUsIGFjY3VtdWxhdG9yKSB7XHJcbiAgICBjb25zdCBvbGRTZXJ2ZXJOb2RlID0gdmlld0NhY2hlLnNlcnZlckNhY2hlO1xyXG4gICAgY29uc3QgbmV3Vmlld0NhY2hlID0gdmlld0NhY2hlVXBkYXRlU2VydmVyU25hcCh2aWV3Q2FjaGUsIG9sZFNlcnZlck5vZGUuZ2V0Tm9kZSgpLCBvbGRTZXJ2ZXJOb2RlLmlzRnVsbHlJbml0aWFsaXplZCgpIHx8IHBhdGhJc0VtcHR5KHBhdGgpLCBvbGRTZXJ2ZXJOb2RlLmlzRmlsdGVyZWQoKSk7XHJcbiAgICByZXR1cm4gdmlld1Byb2Nlc3NvckdlbmVyYXRlRXZlbnRDYWNoZUFmdGVyU2VydmVyRXZlbnQodmlld1Byb2Nlc3NvciwgbmV3Vmlld0NhY2hlLCBwYXRoLCB3cml0ZXNDYWNoZSwgTk9fQ09NUExFVEVfQ0hJTERfU09VUkNFLCBhY2N1bXVsYXRvcik7XHJcbn1cclxuZnVuY3Rpb24gdmlld1Byb2Nlc3NvclJldmVydFVzZXJXcml0ZSh2aWV3UHJvY2Vzc29yLCB2aWV3Q2FjaGUsIHBhdGgsIHdyaXRlc0NhY2hlLCBjb21wbGV0ZVNlcnZlckNhY2hlLCBhY2N1bXVsYXRvcikge1xyXG4gICAgbGV0IGNvbXBsZXRlO1xyXG4gICAgaWYgKHdyaXRlVHJlZVJlZlNoYWRvd2luZ1dyaXRlKHdyaXRlc0NhY2hlLCBwYXRoKSAhPSBudWxsKSB7XHJcbiAgICAgICAgcmV0dXJuIHZpZXdDYWNoZTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGNvbnN0IHNvdXJjZSA9IG5ldyBXcml0ZVRyZWVDb21wbGV0ZUNoaWxkU291cmNlKHdyaXRlc0NhY2hlLCB2aWV3Q2FjaGUsIGNvbXBsZXRlU2VydmVyQ2FjaGUpO1xyXG4gICAgICAgIGNvbnN0IG9sZEV2ZW50Q2FjaGUgPSB2aWV3Q2FjaGUuZXZlbnRDYWNoZS5nZXROb2RlKCk7XHJcbiAgICAgICAgbGV0IG5ld0V2ZW50Q2FjaGU7XHJcbiAgICAgICAgaWYgKHBhdGhJc0VtcHR5KHBhdGgpIHx8IHBhdGhHZXRGcm9udChwYXRoKSA9PT0gJy5wcmlvcml0eScpIHtcclxuICAgICAgICAgICAgbGV0IG5ld05vZGU7XHJcbiAgICAgICAgICAgIGlmICh2aWV3Q2FjaGUuc2VydmVyQ2FjaGUuaXNGdWxseUluaXRpYWxpemVkKCkpIHtcclxuICAgICAgICAgICAgICAgIG5ld05vZGUgPSB3cml0ZVRyZWVSZWZDYWxjQ29tcGxldGVFdmVudENhY2hlKHdyaXRlc0NhY2hlLCB2aWV3Q2FjaGVHZXRDb21wbGV0ZVNlcnZlclNuYXAodmlld0NhY2hlKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzZXJ2ZXJDaGlsZHJlbiA9IHZpZXdDYWNoZS5zZXJ2ZXJDYWNoZS5nZXROb2RlKCk7XHJcbiAgICAgICAgICAgICAgICBhc3NlcnQoc2VydmVyQ2hpbGRyZW4gaW5zdGFuY2VvZiBDaGlsZHJlbk5vZGUsICdzZXJ2ZXJDaGlsZHJlbiB3b3VsZCBiZSBjb21wbGV0ZSBpZiBsZWFmIG5vZGUnKTtcclxuICAgICAgICAgICAgICAgIG5ld05vZGUgPSB3cml0ZVRyZWVSZWZDYWxjQ29tcGxldGVFdmVudENoaWxkcmVuKHdyaXRlc0NhY2hlLCBzZXJ2ZXJDaGlsZHJlbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbmV3Tm9kZSA9IG5ld05vZGU7XHJcbiAgICAgICAgICAgIG5ld0V2ZW50Q2FjaGUgPSB2aWV3UHJvY2Vzc29yLmZpbHRlci51cGRhdGVGdWxsTm9kZShvbGRFdmVudENhY2hlLCBuZXdOb2RlLCBhY2N1bXVsYXRvcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCBjaGlsZEtleSA9IHBhdGhHZXRGcm9udChwYXRoKTtcclxuICAgICAgICAgICAgbGV0IG5ld0NoaWxkID0gd3JpdGVUcmVlUmVmQ2FsY0NvbXBsZXRlQ2hpbGQod3JpdGVzQ2FjaGUsIGNoaWxkS2V5LCB2aWV3Q2FjaGUuc2VydmVyQ2FjaGUpO1xyXG4gICAgICAgICAgICBpZiAobmV3Q2hpbGQgPT0gbnVsbCAmJlxyXG4gICAgICAgICAgICAgICAgdmlld0NhY2hlLnNlcnZlckNhY2hlLmlzQ29tcGxldGVGb3JDaGlsZChjaGlsZEtleSkpIHtcclxuICAgICAgICAgICAgICAgIG5ld0NoaWxkID0gb2xkRXZlbnRDYWNoZS5nZXRJbW1lZGlhdGVDaGlsZChjaGlsZEtleSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKG5ld0NoaWxkICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIG5ld0V2ZW50Q2FjaGUgPSB2aWV3UHJvY2Vzc29yLmZpbHRlci51cGRhdGVDaGlsZChvbGRFdmVudENhY2hlLCBjaGlsZEtleSwgbmV3Q2hpbGQsIHBhdGhQb3BGcm9udChwYXRoKSwgc291cmNlLCBhY2N1bXVsYXRvcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodmlld0NhY2hlLmV2ZW50Q2FjaGUuZ2V0Tm9kZSgpLmhhc0NoaWxkKGNoaWxkS2V5KSkge1xyXG4gICAgICAgICAgICAgICAgLy8gTm8gY29tcGxldGUgY2hpbGQgYXZhaWxhYmxlLCBkZWxldGUgdGhlIGV4aXN0aW5nIG9uZSwgaWYgYW55XHJcbiAgICAgICAgICAgICAgICBuZXdFdmVudENhY2hlID0gdmlld1Byb2Nlc3Nvci5maWx0ZXIudXBkYXRlQ2hpbGQob2xkRXZlbnRDYWNoZSwgY2hpbGRLZXksIENoaWxkcmVuTm9kZS5FTVBUWV9OT0RFLCBwYXRoUG9wRnJvbnQocGF0aCksIHNvdXJjZSwgYWNjdW11bGF0b3IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbmV3RXZlbnRDYWNoZSA9IG9sZEV2ZW50Q2FjaGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKG5ld0V2ZW50Q2FjaGUuaXNFbXB0eSgpICYmXHJcbiAgICAgICAgICAgICAgICB2aWV3Q2FjaGUuc2VydmVyQ2FjaGUuaXNGdWxseUluaXRpYWxpemVkKCkpIHtcclxuICAgICAgICAgICAgICAgIC8vIFdlIG1pZ2h0IGhhdmUgcmV2ZXJ0ZWQgYWxsIGNoaWxkIHdyaXRlcy4gTWF5YmUgdGhlIG9sZCBldmVudCB3YXMgYSBsZWFmIG5vZGVcclxuICAgICAgICAgICAgICAgIGNvbXBsZXRlID0gd3JpdGVUcmVlUmVmQ2FsY0NvbXBsZXRlRXZlbnRDYWNoZSh3cml0ZXNDYWNoZSwgdmlld0NhY2hlR2V0Q29tcGxldGVTZXJ2ZXJTbmFwKHZpZXdDYWNoZSkpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGNvbXBsZXRlLmlzTGVhZk5vZGUoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG5ld0V2ZW50Q2FjaGUgPSB2aWV3UHJvY2Vzc29yLmZpbHRlci51cGRhdGVGdWxsTm9kZShuZXdFdmVudENhY2hlLCBjb21wbGV0ZSwgYWNjdW11bGF0b3IpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbXBsZXRlID1cclxuICAgICAgICAgICAgdmlld0NhY2hlLnNlcnZlckNhY2hlLmlzRnVsbHlJbml0aWFsaXplZCgpIHx8XHJcbiAgICAgICAgICAgICAgICB3cml0ZVRyZWVSZWZTaGFkb3dpbmdXcml0ZSh3cml0ZXNDYWNoZSwgbmV3RW1wdHlQYXRoKCkpICE9IG51bGw7XHJcbiAgICAgICAgcmV0dXJuIHZpZXdDYWNoZVVwZGF0ZUV2ZW50U25hcCh2aWV3Q2FjaGUsIG5ld0V2ZW50Q2FjaGUsIGNvbXBsZXRlLCB2aWV3UHJvY2Vzc29yLmZpbHRlci5maWx0ZXJzTm9kZXMoKSk7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIEEgdmlldyByZXByZXNlbnRzIGEgc3BlY2lmaWMgbG9jYXRpb24gYW5kIHF1ZXJ5IHRoYXQgaGFzIDEgb3IgbW9yZSBldmVudCByZWdpc3RyYXRpb25zLlxyXG4gKlxyXG4gKiBJdCBkb2VzIHNldmVyYWwgdGhpbmdzOlxyXG4gKiAgLSBNYWludGFpbnMgdGhlIGxpc3Qgb2YgZXZlbnQgcmVnaXN0cmF0aW9ucyBmb3IgdGhpcyBsb2NhdGlvbi9xdWVyeS5cclxuICogIC0gTWFpbnRhaW5zIGEgY2FjaGUgb2YgdGhlIGRhdGEgdmlzaWJsZSBmb3IgdGhpcyBsb2NhdGlvbi9xdWVyeS5cclxuICogIC0gQXBwbGllcyBuZXcgb3BlcmF0aW9ucyAodmlhIGFwcGx5T3BlcmF0aW9uKSwgdXBkYXRlcyB0aGUgY2FjaGUsIGFuZCBiYXNlZCBvbiB0aGUgZXZlbnRcclxuICogICAgcmVnaXN0cmF0aW9ucyByZXR1cm5zIHRoZSBzZXQgb2YgZXZlbnRzIHRvIGJlIHJhaXNlZC5cclxuICovXHJcbmNsYXNzIFZpZXcge1xyXG4gICAgY29uc3RydWN0b3IocXVlcnlfLCBpbml0aWFsVmlld0NhY2hlKSB7XHJcbiAgICAgICAgdGhpcy5xdWVyeV8gPSBxdWVyeV87XHJcbiAgICAgICAgdGhpcy5ldmVudFJlZ2lzdHJhdGlvbnNfID0gW107XHJcbiAgICAgICAgY29uc3QgcGFyYW1zID0gdGhpcy5xdWVyeV8uX3F1ZXJ5UGFyYW1zO1xyXG4gICAgICAgIGNvbnN0IGluZGV4RmlsdGVyID0gbmV3IEluZGV4ZWRGaWx0ZXIocGFyYW1zLmdldEluZGV4KCkpO1xyXG4gICAgICAgIGNvbnN0IGZpbHRlciA9IHF1ZXJ5UGFyYW1zR2V0Tm9kZUZpbHRlcihwYXJhbXMpO1xyXG4gICAgICAgIHRoaXMucHJvY2Vzc29yXyA9IG5ld1ZpZXdQcm9jZXNzb3IoZmlsdGVyKTtcclxuICAgICAgICBjb25zdCBpbml0aWFsU2VydmVyQ2FjaGUgPSBpbml0aWFsVmlld0NhY2hlLnNlcnZlckNhY2hlO1xyXG4gICAgICAgIGNvbnN0IGluaXRpYWxFdmVudENhY2hlID0gaW5pdGlhbFZpZXdDYWNoZS5ldmVudENhY2hlO1xyXG4gICAgICAgIC8vIERvbid0IGZpbHRlciBzZXJ2ZXIgbm9kZSB3aXRoIG90aGVyIGZpbHRlciB0aGFuIGluZGV4LCB3YWl0IGZvciB0YWdnZWQgbGlzdGVuXHJcbiAgICAgICAgY29uc3Qgc2VydmVyU25hcCA9IGluZGV4RmlsdGVyLnVwZGF0ZUZ1bGxOb2RlKENoaWxkcmVuTm9kZS5FTVBUWV9OT0RFLCBpbml0aWFsU2VydmVyQ2FjaGUuZ2V0Tm9kZSgpLCBudWxsKTtcclxuICAgICAgICBjb25zdCBldmVudFNuYXAgPSBmaWx0ZXIudXBkYXRlRnVsbE5vZGUoQ2hpbGRyZW5Ob2RlLkVNUFRZX05PREUsIGluaXRpYWxFdmVudENhY2hlLmdldE5vZGUoKSwgbnVsbCk7XHJcbiAgICAgICAgY29uc3QgbmV3U2VydmVyQ2FjaGUgPSBuZXcgQ2FjaGVOb2RlKHNlcnZlclNuYXAsIGluaXRpYWxTZXJ2ZXJDYWNoZS5pc0Z1bGx5SW5pdGlhbGl6ZWQoKSwgaW5kZXhGaWx0ZXIuZmlsdGVyc05vZGVzKCkpO1xyXG4gICAgICAgIGNvbnN0IG5ld0V2ZW50Q2FjaGUgPSBuZXcgQ2FjaGVOb2RlKGV2ZW50U25hcCwgaW5pdGlhbEV2ZW50Q2FjaGUuaXNGdWxseUluaXRpYWxpemVkKCksIGZpbHRlci5maWx0ZXJzTm9kZXMoKSk7XHJcbiAgICAgICAgdGhpcy52aWV3Q2FjaGVfID0gbmV3Vmlld0NhY2hlKG5ld0V2ZW50Q2FjaGUsIG5ld1NlcnZlckNhY2hlKTtcclxuICAgICAgICB0aGlzLmV2ZW50R2VuZXJhdG9yXyA9IG5ldyBFdmVudEdlbmVyYXRvcih0aGlzLnF1ZXJ5Xyk7XHJcbiAgICB9XHJcbiAgICBnZXQgcXVlcnkoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucXVlcnlfO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHZpZXdHZXRTZXJ2ZXJDYWNoZSh2aWV3KSB7XHJcbiAgICByZXR1cm4gdmlldy52aWV3Q2FjaGVfLnNlcnZlckNhY2hlLmdldE5vZGUoKTtcclxufVxyXG5mdW5jdGlvbiB2aWV3R2V0Q29tcGxldGVOb2RlKHZpZXcpIHtcclxuICAgIHJldHVybiB2aWV3Q2FjaGVHZXRDb21wbGV0ZUV2ZW50U25hcCh2aWV3LnZpZXdDYWNoZV8pO1xyXG59XHJcbmZ1bmN0aW9uIHZpZXdHZXRDb21wbGV0ZVNlcnZlckNhY2hlKHZpZXcsIHBhdGgpIHtcclxuICAgIGNvbnN0IGNhY2hlID0gdmlld0NhY2hlR2V0Q29tcGxldGVTZXJ2ZXJTbmFwKHZpZXcudmlld0NhY2hlXyk7XHJcbiAgICBpZiAoY2FjaGUpIHtcclxuICAgICAgICAvLyBJZiB0aGlzIGlzbid0IGEgXCJsb2Fkc0FsbERhdGFcIiB2aWV3LCB0aGVuIGNhY2hlIGlzbid0IGFjdHVhbGx5IGEgY29tcGxldGUgY2FjaGUgYW5kXHJcbiAgICAgICAgLy8gd2UgbmVlZCB0byBzZWUgaWYgaXQgY29udGFpbnMgdGhlIGNoaWxkIHdlJ3JlIGludGVyZXN0ZWQgaW4uXHJcbiAgICAgICAgaWYgKHZpZXcucXVlcnkuX3F1ZXJ5UGFyYW1zLmxvYWRzQWxsRGF0YSgpIHx8XHJcbiAgICAgICAgICAgICghcGF0aElzRW1wdHkocGF0aCkgJiZcclxuICAgICAgICAgICAgICAgICFjYWNoZS5nZXRJbW1lZGlhdGVDaGlsZChwYXRoR2V0RnJvbnQocGF0aCkpLmlzRW1wdHkoKSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlLmdldENoaWxkKHBhdGgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBudWxsO1xyXG59XHJcbmZ1bmN0aW9uIHZpZXdJc0VtcHR5KHZpZXcpIHtcclxuICAgIHJldHVybiB2aWV3LmV2ZW50UmVnaXN0cmF0aW9uc18ubGVuZ3RoID09PSAwO1xyXG59XHJcbmZ1bmN0aW9uIHZpZXdBZGRFdmVudFJlZ2lzdHJhdGlvbih2aWV3LCBldmVudFJlZ2lzdHJhdGlvbikge1xyXG4gICAgdmlldy5ldmVudFJlZ2lzdHJhdGlvbnNfLnB1c2goZXZlbnRSZWdpc3RyYXRpb24pO1xyXG59XHJcbi8qKlxyXG4gKiBAcGFyYW0gZXZlbnRSZWdpc3RyYXRpb24gLSBJZiBudWxsLCByZW1vdmUgYWxsIGNhbGxiYWNrcy5cclxuICogQHBhcmFtIGNhbmNlbEVycm9yIC0gSWYgYSBjYW5jZWxFcnJvciBpcyBwcm92aWRlZCwgYXBwcm9wcmlhdGUgY2FuY2VsIGV2ZW50cyB3aWxsIGJlIHJldHVybmVkLlxyXG4gKiBAcmV0dXJucyBDYW5jZWwgZXZlbnRzLCBpZiBjYW5jZWxFcnJvciB3YXMgcHJvdmlkZWQuXHJcbiAqL1xyXG5mdW5jdGlvbiB2aWV3UmVtb3ZlRXZlbnRSZWdpc3RyYXRpb24odmlldywgZXZlbnRSZWdpc3RyYXRpb24sIGNhbmNlbEVycm9yKSB7XHJcbiAgICBjb25zdCBjYW5jZWxFdmVudHMgPSBbXTtcclxuICAgIGlmIChjYW5jZWxFcnJvcikge1xyXG4gICAgICAgIGFzc2VydChldmVudFJlZ2lzdHJhdGlvbiA9PSBudWxsLCAnQSBjYW5jZWwgc2hvdWxkIGNhbmNlbCBhbGwgZXZlbnQgcmVnaXN0cmF0aW9ucy4nKTtcclxuICAgICAgICBjb25zdCBwYXRoID0gdmlldy5xdWVyeS5fcGF0aDtcclxuICAgICAgICB2aWV3LmV2ZW50UmVnaXN0cmF0aW9uc18uZm9yRWFjaChyZWdpc3RyYXRpb24gPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBtYXliZUV2ZW50ID0gcmVnaXN0cmF0aW9uLmNyZWF0ZUNhbmNlbEV2ZW50KGNhbmNlbEVycm9yLCBwYXRoKTtcclxuICAgICAgICAgICAgaWYgKG1heWJlRXZlbnQpIHtcclxuICAgICAgICAgICAgICAgIGNhbmNlbEV2ZW50cy5wdXNoKG1heWJlRXZlbnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBpZiAoZXZlbnRSZWdpc3RyYXRpb24pIHtcclxuICAgICAgICBsZXQgcmVtYWluaW5nID0gW107XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2aWV3LmV2ZW50UmVnaXN0cmF0aW9uc18ubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgY29uc3QgZXhpc3RpbmcgPSB2aWV3LmV2ZW50UmVnaXN0cmF0aW9uc19baV07XHJcbiAgICAgICAgICAgIGlmICghZXhpc3RpbmcubWF0Y2hlcyhldmVudFJlZ2lzdHJhdGlvbikpIHtcclxuICAgICAgICAgICAgICAgIHJlbWFpbmluZy5wdXNoKGV4aXN0aW5nKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChldmVudFJlZ2lzdHJhdGlvbi5oYXNBbnlDYWxsYmFjaygpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBXZSdyZSByZW1vdmluZyBqdXN0IHRoaXMgb25lXHJcbiAgICAgICAgICAgICAgICByZW1haW5pbmcgPSByZW1haW5pbmcuY29uY2F0KHZpZXcuZXZlbnRSZWdpc3RyYXRpb25zXy5zbGljZShpICsgMSkpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdmlldy5ldmVudFJlZ2lzdHJhdGlvbnNfID0gcmVtYWluaW5nO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgdmlldy5ldmVudFJlZ2lzdHJhdGlvbnNfID0gW107XHJcbiAgICB9XHJcbiAgICByZXR1cm4gY2FuY2VsRXZlbnRzO1xyXG59XHJcbi8qKlxyXG4gKiBBcHBsaWVzIHRoZSBnaXZlbiBPcGVyYXRpb24sIHVwZGF0ZXMgb3VyIGNhY2hlLCBhbmQgcmV0dXJucyB0aGUgYXBwcm9wcmlhdGUgZXZlbnRzLlxyXG4gKi9cclxuZnVuY3Rpb24gdmlld0FwcGx5T3BlcmF0aW9uKHZpZXcsIG9wZXJhdGlvbiwgd3JpdGVzQ2FjaGUsIGNvbXBsZXRlU2VydmVyQ2FjaGUpIHtcclxuICAgIGlmIChvcGVyYXRpb24udHlwZSA9PT0gT3BlcmF0aW9uVHlwZS5NRVJHRSAmJlxyXG4gICAgICAgIG9wZXJhdGlvbi5zb3VyY2UucXVlcnlJZCAhPT0gbnVsbCkge1xyXG4gICAgICAgIGFzc2VydCh2aWV3Q2FjaGVHZXRDb21wbGV0ZVNlcnZlclNuYXAodmlldy52aWV3Q2FjaGVfKSwgJ1dlIHNob3VsZCBhbHdheXMgaGF2ZSBhIGZ1bGwgY2FjaGUgYmVmb3JlIGhhbmRsaW5nIG1lcmdlcycpO1xyXG4gICAgICAgIGFzc2VydCh2aWV3Q2FjaGVHZXRDb21wbGV0ZUV2ZW50U25hcCh2aWV3LnZpZXdDYWNoZV8pLCAnTWlzc2luZyBldmVudCBjYWNoZSwgZXZlbiB0aG91Z2ggd2UgaGF2ZSBhIHNlcnZlciBjYWNoZScpO1xyXG4gICAgfVxyXG4gICAgY29uc3Qgb2xkVmlld0NhY2hlID0gdmlldy52aWV3Q2FjaGVfO1xyXG4gICAgY29uc3QgcmVzdWx0ID0gdmlld1Byb2Nlc3NvckFwcGx5T3BlcmF0aW9uKHZpZXcucHJvY2Vzc29yXywgb2xkVmlld0NhY2hlLCBvcGVyYXRpb24sIHdyaXRlc0NhY2hlLCBjb21wbGV0ZVNlcnZlckNhY2hlKTtcclxuICAgIHZpZXdQcm9jZXNzb3JBc3NlcnRJbmRleGVkKHZpZXcucHJvY2Vzc29yXywgcmVzdWx0LnZpZXdDYWNoZSk7XHJcbiAgICBhc3NlcnQocmVzdWx0LnZpZXdDYWNoZS5zZXJ2ZXJDYWNoZS5pc0Z1bGx5SW5pdGlhbGl6ZWQoKSB8fFxyXG4gICAgICAgICFvbGRWaWV3Q2FjaGUuc2VydmVyQ2FjaGUuaXNGdWxseUluaXRpYWxpemVkKCksICdPbmNlIGEgc2VydmVyIHNuYXAgaXMgY29tcGxldGUsIGl0IHNob3VsZCBuZXZlciBnbyBiYWNrJyk7XHJcbiAgICB2aWV3LnZpZXdDYWNoZV8gPSByZXN1bHQudmlld0NhY2hlO1xyXG4gICAgcmV0dXJuIHZpZXdHZW5lcmF0ZUV2ZW50c0ZvckNoYW5nZXNfKHZpZXcsIHJlc3VsdC5jaGFuZ2VzLCByZXN1bHQudmlld0NhY2hlLmV2ZW50Q2FjaGUuZ2V0Tm9kZSgpLCBudWxsKTtcclxufVxyXG5mdW5jdGlvbiB2aWV3R2V0SW5pdGlhbEV2ZW50cyh2aWV3LCByZWdpc3RyYXRpb24pIHtcclxuICAgIGNvbnN0IGV2ZW50U25hcCA9IHZpZXcudmlld0NhY2hlXy5ldmVudENhY2hlO1xyXG4gICAgY29uc3QgaW5pdGlhbENoYW5nZXMgPSBbXTtcclxuICAgIGlmICghZXZlbnRTbmFwLmdldE5vZGUoKS5pc0xlYWZOb2RlKCkpIHtcclxuICAgICAgICBjb25zdCBldmVudE5vZGUgPSBldmVudFNuYXAuZ2V0Tm9kZSgpO1xyXG4gICAgICAgIGV2ZW50Tm9kZS5mb3JFYWNoQ2hpbGQoUFJJT1JJVFlfSU5ERVgsIChrZXksIGNoaWxkTm9kZSkgPT4ge1xyXG4gICAgICAgICAgICBpbml0aWFsQ2hhbmdlcy5wdXNoKGNoYW5nZUNoaWxkQWRkZWQoa2V5LCBjaGlsZE5vZGUpKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGlmIChldmVudFNuYXAuaXNGdWxseUluaXRpYWxpemVkKCkpIHtcclxuICAgICAgICBpbml0aWFsQ2hhbmdlcy5wdXNoKGNoYW5nZVZhbHVlKGV2ZW50U25hcC5nZXROb2RlKCkpKTtcclxuICAgIH1cclxuICAgIHJldHVybiB2aWV3R2VuZXJhdGVFdmVudHNGb3JDaGFuZ2VzXyh2aWV3LCBpbml0aWFsQ2hhbmdlcywgZXZlbnRTbmFwLmdldE5vZGUoKSwgcmVnaXN0cmF0aW9uKTtcclxufVxyXG5mdW5jdGlvbiB2aWV3R2VuZXJhdGVFdmVudHNGb3JDaGFuZ2VzXyh2aWV3LCBjaGFuZ2VzLCBldmVudENhY2hlLCBldmVudFJlZ2lzdHJhdGlvbikge1xyXG4gICAgY29uc3QgcmVnaXN0cmF0aW9ucyA9IGV2ZW50UmVnaXN0cmF0aW9uXHJcbiAgICAgICAgPyBbZXZlbnRSZWdpc3RyYXRpb25dXHJcbiAgICAgICAgOiB2aWV3LmV2ZW50UmVnaXN0cmF0aW9uc187XHJcbiAgICByZXR1cm4gZXZlbnRHZW5lcmF0b3JHZW5lcmF0ZUV2ZW50c0ZvckNoYW5nZXModmlldy5ldmVudEdlbmVyYXRvcl8sIGNoYW5nZXMsIGV2ZW50Q2FjaGUsIHJlZ2lzdHJhdGlvbnMpO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmxldCByZWZlcmVuY2VDb25zdHJ1Y3RvciQxO1xyXG4vKipcclxuICogU3luY1BvaW50IHJlcHJlc2VudHMgYSBzaW5nbGUgbG9jYXRpb24gaW4gYSBTeW5jVHJlZSB3aXRoIDEgb3IgbW9yZSBldmVudCByZWdpc3RyYXRpb25zLCBtZWFuaW5nIHdlIG5lZWQgdG9cclxuICogbWFpbnRhaW4gMSBvciBtb3JlIFZpZXdzIGF0IHRoaXMgbG9jYXRpb24gdG8gY2FjaGUgc2VydmVyIGRhdGEgYW5kIHJhaXNlIGFwcHJvcHJpYXRlIGV2ZW50cyBmb3Igc2VydmVyIGNoYW5nZXNcclxuICogYW5kIHVzZXIgd3JpdGVzIChzZXQsIHRyYW5zYWN0aW9uLCB1cGRhdGUpLlxyXG4gKlxyXG4gKiBJdCdzIHJlc3BvbnNpYmxlIGZvcjpcclxuICogIC0gTWFpbnRhaW5pbmcgdGhlIHNldCBvZiAxIG9yIG1vcmUgdmlld3MgbmVjZXNzYXJ5IGF0IHRoaXMgbG9jYXRpb24gKGEgU3luY1BvaW50IHdpdGggMCB2aWV3cyBzaG91bGQgYmUgcmVtb3ZlZCkuXHJcbiAqICAtIFByb3h5aW5nIHVzZXIgLyBzZXJ2ZXIgb3BlcmF0aW9ucyB0byB0aGUgdmlld3MgYXMgYXBwcm9wcmlhdGUgKGkuZS4gYXBwbHlTZXJ2ZXJPdmVyd3JpdGUsXHJcbiAqICAgIGFwcGx5VXNlck92ZXJ3cml0ZSwgZXRjLilcclxuICovXHJcbmNsYXNzIFN5bmNQb2ludCB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgVmlld3MgYmVpbmcgdHJhY2tlZCBhdCB0aGlzIGxvY2F0aW9uIGluIHRoZSB0cmVlLCBzdG9yZWQgYXMgYSBtYXAgd2hlcmUgdGhlIGtleSBpcyBhXHJcbiAgICAgICAgICogcXVlcnlJZCBhbmQgdGhlIHZhbHVlIGlzIHRoZSBWaWV3IGZvciB0aGF0IHF1ZXJ5LlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogTk9URTogVGhpcyBsaXN0IHdpbGwgYmUgcXVpdGUgc21hbGwgKHVzdWFsbHkgMSwgYnV0IHBlcmhhcHMgMiBvciAzOyBhbnkgbW9yZSBpcyBhbiBvZGQgdXNlIGNhc2UpLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMudmlld3MgPSBuZXcgTWFwKCk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gc3luY1BvaW50U2V0UmVmZXJlbmNlQ29uc3RydWN0b3IodmFsKSB7XHJcbiAgICBhc3NlcnQoIXJlZmVyZW5jZUNvbnN0cnVjdG9yJDEsICdfX3JlZmVyZW5jZUNvbnN0cnVjdG9yIGhhcyBhbHJlYWR5IGJlZW4gZGVmaW5lZCcpO1xyXG4gICAgcmVmZXJlbmNlQ29uc3RydWN0b3IkMSA9IHZhbDtcclxufVxyXG5mdW5jdGlvbiBzeW5jUG9pbnRHZXRSZWZlcmVuY2VDb25zdHJ1Y3RvcigpIHtcclxuICAgIGFzc2VydChyZWZlcmVuY2VDb25zdHJ1Y3RvciQxLCAnUmVmZXJlbmNlLnRzIGhhcyBub3QgYmVlbiBsb2FkZWQnKTtcclxuICAgIHJldHVybiByZWZlcmVuY2VDb25zdHJ1Y3RvciQxO1xyXG59XHJcbmZ1bmN0aW9uIHN5bmNQb2ludElzRW1wdHkoc3luY1BvaW50KSB7XHJcbiAgICByZXR1cm4gc3luY1BvaW50LnZpZXdzLnNpemUgPT09IDA7XHJcbn1cclxuZnVuY3Rpb24gc3luY1BvaW50QXBwbHlPcGVyYXRpb24oc3luY1BvaW50LCBvcGVyYXRpb24sIHdyaXRlc0NhY2hlLCBvcHRDb21wbGV0ZVNlcnZlckNhY2hlKSB7XHJcbiAgICBjb25zdCBxdWVyeUlkID0gb3BlcmF0aW9uLnNvdXJjZS5xdWVyeUlkO1xyXG4gICAgaWYgKHF1ZXJ5SWQgIT09IG51bGwpIHtcclxuICAgICAgICBjb25zdCB2aWV3ID0gc3luY1BvaW50LnZpZXdzLmdldChxdWVyeUlkKTtcclxuICAgICAgICBhc3NlcnQodmlldyAhPSBudWxsLCAnU3luY1RyZWUgZ2F2ZSB1cyBhbiBvcCBmb3IgYW4gaW52YWxpZCBxdWVyeS4nKTtcclxuICAgICAgICByZXR1cm4gdmlld0FwcGx5T3BlcmF0aW9uKHZpZXcsIG9wZXJhdGlvbiwgd3JpdGVzQ2FjaGUsIG9wdENvbXBsZXRlU2VydmVyQ2FjaGUpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgbGV0IGV2ZW50cyA9IFtdO1xyXG4gICAgICAgIGZvciAoY29uc3QgdmlldyBvZiBzeW5jUG9pbnQudmlld3MudmFsdWVzKCkpIHtcclxuICAgICAgICAgICAgZXZlbnRzID0gZXZlbnRzLmNvbmNhdCh2aWV3QXBwbHlPcGVyYXRpb24odmlldywgb3BlcmF0aW9uLCB3cml0ZXNDYWNoZSwgb3B0Q29tcGxldGVTZXJ2ZXJDYWNoZSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZXZlbnRzO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBHZXQgYSB2aWV3IGZvciB0aGUgc3BlY2lmaWVkIHF1ZXJ5LlxyXG4gKlxyXG4gKiBAcGFyYW0gcXVlcnkgLSBUaGUgcXVlcnkgdG8gcmV0dXJuIGEgdmlldyBmb3JcclxuICogQHBhcmFtIHdyaXRlc0NhY2hlXHJcbiAqIEBwYXJhbSBzZXJ2ZXJDYWNoZVxyXG4gKiBAcGFyYW0gc2VydmVyQ2FjaGVDb21wbGV0ZVxyXG4gKiBAcmV0dXJucyBFdmVudHMgdG8gcmFpc2UuXHJcbiAqL1xyXG5mdW5jdGlvbiBzeW5jUG9pbnRHZXRWaWV3KHN5bmNQb2ludCwgcXVlcnksIHdyaXRlc0NhY2hlLCBzZXJ2ZXJDYWNoZSwgc2VydmVyQ2FjaGVDb21wbGV0ZSkge1xyXG4gICAgY29uc3QgcXVlcnlJZCA9IHF1ZXJ5Ll9xdWVyeUlkZW50aWZpZXI7XHJcbiAgICBjb25zdCB2aWV3ID0gc3luY1BvaW50LnZpZXdzLmdldChxdWVyeUlkKTtcclxuICAgIGlmICghdmlldykge1xyXG4gICAgICAgIC8vIFRPRE86IG1ha2Ugd3JpdGVzQ2FjaGUgdGFrZSBmbGFnIGZvciBjb21wbGV0ZSBzZXJ2ZXIgbm9kZVxyXG4gICAgICAgIGxldCBldmVudENhY2hlID0gd3JpdGVUcmVlUmVmQ2FsY0NvbXBsZXRlRXZlbnRDYWNoZSh3cml0ZXNDYWNoZSwgc2VydmVyQ2FjaGVDb21wbGV0ZSA/IHNlcnZlckNhY2hlIDogbnVsbCk7XHJcbiAgICAgICAgbGV0IGV2ZW50Q2FjaGVDb21wbGV0ZSA9IGZhbHNlO1xyXG4gICAgICAgIGlmIChldmVudENhY2hlKSB7XHJcbiAgICAgICAgICAgIGV2ZW50Q2FjaGVDb21wbGV0ZSA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHNlcnZlckNhY2hlIGluc3RhbmNlb2YgQ2hpbGRyZW5Ob2RlKSB7XHJcbiAgICAgICAgICAgIGV2ZW50Q2FjaGUgPSB3cml0ZVRyZWVSZWZDYWxjQ29tcGxldGVFdmVudENoaWxkcmVuKHdyaXRlc0NhY2hlLCBzZXJ2ZXJDYWNoZSk7XHJcbiAgICAgICAgICAgIGV2ZW50Q2FjaGVDb21wbGV0ZSA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZXZlbnRDYWNoZSA9IENoaWxkcmVuTm9kZS5FTVBUWV9OT0RFO1xyXG4gICAgICAgICAgICBldmVudENhY2hlQ29tcGxldGUgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3Qgdmlld0NhY2hlID0gbmV3Vmlld0NhY2hlKG5ldyBDYWNoZU5vZGUoZXZlbnRDYWNoZSwgZXZlbnRDYWNoZUNvbXBsZXRlLCBmYWxzZSksIG5ldyBDYWNoZU5vZGUoc2VydmVyQ2FjaGUsIHNlcnZlckNhY2hlQ29tcGxldGUsIGZhbHNlKSk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBWaWV3KHF1ZXJ5LCB2aWV3Q2FjaGUpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHZpZXc7XHJcbn1cclxuLyoqXHJcbiAqIEFkZCBhbiBldmVudCBjYWxsYmFjayBmb3IgdGhlIHNwZWNpZmllZCBxdWVyeS5cclxuICpcclxuICogQHBhcmFtIHF1ZXJ5XHJcbiAqIEBwYXJhbSBldmVudFJlZ2lzdHJhdGlvblxyXG4gKiBAcGFyYW0gd3JpdGVzQ2FjaGVcclxuICogQHBhcmFtIHNlcnZlckNhY2hlIC0gQ29tcGxldGUgc2VydmVyIGNhY2hlLCBpZiB3ZSBoYXZlIGl0LlxyXG4gKiBAcGFyYW0gc2VydmVyQ2FjaGVDb21wbGV0ZVxyXG4gKiBAcmV0dXJucyBFdmVudHMgdG8gcmFpc2UuXHJcbiAqL1xyXG5mdW5jdGlvbiBzeW5jUG9pbnRBZGRFdmVudFJlZ2lzdHJhdGlvbihzeW5jUG9pbnQsIHF1ZXJ5LCBldmVudFJlZ2lzdHJhdGlvbiwgd3JpdGVzQ2FjaGUsIHNlcnZlckNhY2hlLCBzZXJ2ZXJDYWNoZUNvbXBsZXRlKSB7XHJcbiAgICBjb25zdCB2aWV3ID0gc3luY1BvaW50R2V0VmlldyhzeW5jUG9pbnQsIHF1ZXJ5LCB3cml0ZXNDYWNoZSwgc2VydmVyQ2FjaGUsIHNlcnZlckNhY2hlQ29tcGxldGUpO1xyXG4gICAgaWYgKCFzeW5jUG9pbnQudmlld3MuaGFzKHF1ZXJ5Ll9xdWVyeUlkZW50aWZpZXIpKSB7XHJcbiAgICAgICAgc3luY1BvaW50LnZpZXdzLnNldChxdWVyeS5fcXVlcnlJZGVudGlmaWVyLCB2aWV3KTtcclxuICAgIH1cclxuICAgIC8vIFRoaXMgaXMgZ3VhcmFudGVlZCB0byBleGlzdCBub3csIHdlIGp1c3QgY3JlYXRlZCBhbnl0aGluZyB0aGF0IHdhcyBtaXNzaW5nXHJcbiAgICB2aWV3QWRkRXZlbnRSZWdpc3RyYXRpb24odmlldywgZXZlbnRSZWdpc3RyYXRpb24pO1xyXG4gICAgcmV0dXJuIHZpZXdHZXRJbml0aWFsRXZlbnRzKHZpZXcsIGV2ZW50UmVnaXN0cmF0aW9uKTtcclxufVxyXG4vKipcclxuICogUmVtb3ZlIGV2ZW50IGNhbGxiYWNrKHMpLiAgUmV0dXJuIGNhbmNlbEV2ZW50cyBpZiBhIGNhbmNlbEVycm9yIGlzIHNwZWNpZmllZC5cclxuICpcclxuICogSWYgcXVlcnkgaXMgdGhlIGRlZmF1bHQgcXVlcnksIHdlJ2xsIGNoZWNrIGFsbCB2aWV3cyBmb3IgdGhlIHNwZWNpZmllZCBldmVudFJlZ2lzdHJhdGlvbi5cclxuICogSWYgZXZlbnRSZWdpc3RyYXRpb24gaXMgbnVsbCwgd2UnbGwgcmVtb3ZlIGFsbCBjYWxsYmFja3MgZm9yIHRoZSBzcGVjaWZpZWQgdmlldyhzKS5cclxuICpcclxuICogQHBhcmFtIGV2ZW50UmVnaXN0cmF0aW9uIC0gSWYgbnVsbCwgcmVtb3ZlIGFsbCBjYWxsYmFja3MuXHJcbiAqIEBwYXJhbSBjYW5jZWxFcnJvciAtIElmIGEgY2FuY2VsRXJyb3IgaXMgcHJvdmlkZWQsIGFwcHJvcHJpYXRlIGNhbmNlbCBldmVudHMgd2lsbCBiZSByZXR1cm5lZC5cclxuICogQHJldHVybnMgcmVtb3ZlZCBxdWVyaWVzIGFuZCBhbnkgY2FuY2VsIGV2ZW50c1xyXG4gKi9cclxuZnVuY3Rpb24gc3luY1BvaW50UmVtb3ZlRXZlbnRSZWdpc3RyYXRpb24oc3luY1BvaW50LCBxdWVyeSwgZXZlbnRSZWdpc3RyYXRpb24sIGNhbmNlbEVycm9yKSB7XHJcbiAgICBjb25zdCBxdWVyeUlkID0gcXVlcnkuX3F1ZXJ5SWRlbnRpZmllcjtcclxuICAgIGNvbnN0IHJlbW92ZWQgPSBbXTtcclxuICAgIGxldCBjYW5jZWxFdmVudHMgPSBbXTtcclxuICAgIGNvbnN0IGhhZENvbXBsZXRlVmlldyA9IHN5bmNQb2ludEhhc0NvbXBsZXRlVmlldyhzeW5jUG9pbnQpO1xyXG4gICAgaWYgKHF1ZXJ5SWQgPT09ICdkZWZhdWx0Jykge1xyXG4gICAgICAgIC8vIFdoZW4geW91IGRvIHJlZi5vZmYoLi4uKSwgd2Ugc2VhcmNoIGFsbCB2aWV3cyBmb3IgdGhlIHJlZ2lzdHJhdGlvbiB0byByZW1vdmUuXHJcbiAgICAgICAgZm9yIChjb25zdCBbdmlld1F1ZXJ5SWQsIHZpZXddIG9mIHN5bmNQb2ludC52aWV3cy5lbnRyaWVzKCkpIHtcclxuICAgICAgICAgICAgY2FuY2VsRXZlbnRzID0gY2FuY2VsRXZlbnRzLmNvbmNhdCh2aWV3UmVtb3ZlRXZlbnRSZWdpc3RyYXRpb24odmlldywgZXZlbnRSZWdpc3RyYXRpb24sIGNhbmNlbEVycm9yKSk7XHJcbiAgICAgICAgICAgIGlmICh2aWV3SXNFbXB0eSh2aWV3KSkge1xyXG4gICAgICAgICAgICAgICAgc3luY1BvaW50LnZpZXdzLmRlbGV0ZSh2aWV3UXVlcnlJZCk7XHJcbiAgICAgICAgICAgICAgICAvLyBXZSdsbCBkZWFsIHdpdGggY29tcGxldGUgdmlld3MgbGF0ZXIuXHJcbiAgICAgICAgICAgICAgICBpZiAoIXZpZXcucXVlcnkuX3F1ZXJ5UGFyYW1zLmxvYWRzQWxsRGF0YSgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlZC5wdXNoKHZpZXcucXVlcnkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgLy8gcmVtb3ZlIHRoZSBjYWxsYmFjayBmcm9tIHRoZSBzcGVjaWZpYyB2aWV3LlxyXG4gICAgICAgIGNvbnN0IHZpZXcgPSBzeW5jUG9pbnQudmlld3MuZ2V0KHF1ZXJ5SWQpO1xyXG4gICAgICAgIGlmICh2aWV3KSB7XHJcbiAgICAgICAgICAgIGNhbmNlbEV2ZW50cyA9IGNhbmNlbEV2ZW50cy5jb25jYXQodmlld1JlbW92ZUV2ZW50UmVnaXN0cmF0aW9uKHZpZXcsIGV2ZW50UmVnaXN0cmF0aW9uLCBjYW5jZWxFcnJvcikpO1xyXG4gICAgICAgICAgICBpZiAodmlld0lzRW1wdHkodmlldykpIHtcclxuICAgICAgICAgICAgICAgIHN5bmNQb2ludC52aWV3cy5kZWxldGUocXVlcnlJZCk7XHJcbiAgICAgICAgICAgICAgICAvLyBXZSdsbCBkZWFsIHdpdGggY29tcGxldGUgdmlld3MgbGF0ZXIuXHJcbiAgICAgICAgICAgICAgICBpZiAoIXZpZXcucXVlcnkuX3F1ZXJ5UGFyYW1zLmxvYWRzQWxsRGF0YSgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlZC5wdXNoKHZpZXcucXVlcnkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKGhhZENvbXBsZXRlVmlldyAmJiAhc3luY1BvaW50SGFzQ29tcGxldGVWaWV3KHN5bmNQb2ludCkpIHtcclxuICAgICAgICAvLyBXZSByZW1vdmVkIG91ciBsYXN0IGNvbXBsZXRlIHZpZXcuXHJcbiAgICAgICAgcmVtb3ZlZC5wdXNoKG5ldyAoc3luY1BvaW50R2V0UmVmZXJlbmNlQ29uc3RydWN0b3IoKSkocXVlcnkuX3JlcG8sIHF1ZXJ5Ll9wYXRoKSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4geyByZW1vdmVkLCBldmVudHM6IGNhbmNlbEV2ZW50cyB9O1xyXG59XHJcbmZ1bmN0aW9uIHN5bmNQb2ludEdldFF1ZXJ5Vmlld3Moc3luY1BvaW50KSB7XHJcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcclxuICAgIGZvciAoY29uc3QgdmlldyBvZiBzeW5jUG9pbnQudmlld3MudmFsdWVzKCkpIHtcclxuICAgICAgICBpZiAoIXZpZXcucXVlcnkuX3F1ZXJ5UGFyYW1zLmxvYWRzQWxsRGF0YSgpKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHZpZXcpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuLyoqXHJcbiAqIEBwYXJhbSBwYXRoIC0gVGhlIHBhdGggdG8gdGhlIGRlc2lyZWQgY29tcGxldGUgc25hcHNob3RcclxuICogQHJldHVybnMgQSBjb21wbGV0ZSBjYWNoZSwgaWYgaXQgZXhpc3RzXHJcbiAqL1xyXG5mdW5jdGlvbiBzeW5jUG9pbnRHZXRDb21wbGV0ZVNlcnZlckNhY2hlKHN5bmNQb2ludCwgcGF0aCkge1xyXG4gICAgbGV0IHNlcnZlckNhY2hlID0gbnVsbDtcclxuICAgIGZvciAoY29uc3QgdmlldyBvZiBzeW5jUG9pbnQudmlld3MudmFsdWVzKCkpIHtcclxuICAgICAgICBzZXJ2ZXJDYWNoZSA9IHNlcnZlckNhY2hlIHx8IHZpZXdHZXRDb21wbGV0ZVNlcnZlckNhY2hlKHZpZXcsIHBhdGgpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHNlcnZlckNhY2hlO1xyXG59XHJcbmZ1bmN0aW9uIHN5bmNQb2ludFZpZXdGb3JRdWVyeShzeW5jUG9pbnQsIHF1ZXJ5KSB7XHJcbiAgICBjb25zdCBwYXJhbXMgPSBxdWVyeS5fcXVlcnlQYXJhbXM7XHJcbiAgICBpZiAocGFyYW1zLmxvYWRzQWxsRGF0YSgpKSB7XHJcbiAgICAgICAgcmV0dXJuIHN5bmNQb2ludEdldENvbXBsZXRlVmlldyhzeW5jUG9pbnQpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgY29uc3QgcXVlcnlJZCA9IHF1ZXJ5Ll9xdWVyeUlkZW50aWZpZXI7XHJcbiAgICAgICAgcmV0dXJuIHN5bmNQb2ludC52aWV3cy5nZXQocXVlcnlJZCk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gc3luY1BvaW50Vmlld0V4aXN0c0ZvclF1ZXJ5KHN5bmNQb2ludCwgcXVlcnkpIHtcclxuICAgIHJldHVybiBzeW5jUG9pbnRWaWV3Rm9yUXVlcnkoc3luY1BvaW50LCBxdWVyeSkgIT0gbnVsbDtcclxufVxyXG5mdW5jdGlvbiBzeW5jUG9pbnRIYXNDb21wbGV0ZVZpZXcoc3luY1BvaW50KSB7XHJcbiAgICByZXR1cm4gc3luY1BvaW50R2V0Q29tcGxldGVWaWV3KHN5bmNQb2ludCkgIT0gbnVsbDtcclxufVxyXG5mdW5jdGlvbiBzeW5jUG9pbnRHZXRDb21wbGV0ZVZpZXcoc3luY1BvaW50KSB7XHJcbiAgICBmb3IgKGNvbnN0IHZpZXcgb2Ygc3luY1BvaW50LnZpZXdzLnZhbHVlcygpKSB7XHJcbiAgICAgICAgaWYgKHZpZXcucXVlcnkuX3F1ZXJ5UGFyYW1zLmxvYWRzQWxsRGF0YSgpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB2aWV3O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBudWxsO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmxldCByZWZlcmVuY2VDb25zdHJ1Y3RvcjtcclxuZnVuY3Rpb24gc3luY1RyZWVTZXRSZWZlcmVuY2VDb25zdHJ1Y3Rvcih2YWwpIHtcclxuICAgIGFzc2VydCghcmVmZXJlbmNlQ29uc3RydWN0b3IsICdfX3JlZmVyZW5jZUNvbnN0cnVjdG9yIGhhcyBhbHJlYWR5IGJlZW4gZGVmaW5lZCcpO1xyXG4gICAgcmVmZXJlbmNlQ29uc3RydWN0b3IgPSB2YWw7XHJcbn1cclxuZnVuY3Rpb24gc3luY1RyZWVHZXRSZWZlcmVuY2VDb25zdHJ1Y3RvcigpIHtcclxuICAgIGFzc2VydChyZWZlcmVuY2VDb25zdHJ1Y3RvciwgJ1JlZmVyZW5jZS50cyBoYXMgbm90IGJlZW4gbG9hZGVkJyk7XHJcbiAgICByZXR1cm4gcmVmZXJlbmNlQ29uc3RydWN0b3I7XHJcbn1cclxuLyoqXHJcbiAqIFN0YXRpYyB0cmFja2VyIGZvciBuZXh0IHF1ZXJ5IHRhZy5cclxuICovXHJcbmxldCBzeW5jVHJlZU5leHRRdWVyeVRhZ18gPSAxO1xyXG4vKipcclxuICogU3luY1RyZWUgaXMgdGhlIGNlbnRyYWwgY2xhc3MgZm9yIG1hbmFnaW5nIGV2ZW50IGNhbGxiYWNrIHJlZ2lzdHJhdGlvbiwgZGF0YSBjYWNoaW5nLCB2aWV3c1xyXG4gKiAocXVlcnkgcHJvY2Vzc2luZyksIGFuZCBldmVudCBnZW5lcmF0aW9uLiAgVGhlcmUgYXJlIHR5cGljYWxseSB0d28gU3luY1RyZWUgaW5zdGFuY2VzIGZvclxyXG4gKiBlYWNoIFJlcG8sIG9uZSBmb3IgdGhlIG5vcm1hbCBGaXJlYmFzZSBkYXRhLCBhbmQgb25lIGZvciB0aGUgLmluZm8gZGF0YS5cclxuICpcclxuICogSXQgaGFzIGEgbnVtYmVyIG9mIHJlc3BvbnNpYmlsaXRpZXMsIGluY2x1ZGluZzpcclxuICogIC0gVHJhY2tpbmcgYWxsIHVzZXIgZXZlbnQgY2FsbGJhY2tzIChyZWdpc3RlcmVkIHZpYSBhZGRFdmVudFJlZ2lzdHJhdGlvbigpIGFuZCByZW1vdmVFdmVudFJlZ2lzdHJhdGlvbigpKS5cclxuICogIC0gQXBwbHlpbmcgYW5kIGNhY2hpbmcgZGF0YSBjaGFuZ2VzIGZvciB1c2VyIHNldCgpLCB0cmFuc2FjdGlvbigpLCBhbmQgdXBkYXRlKCkgY2FsbHNcclxuICogICAgKGFwcGx5VXNlck92ZXJ3cml0ZSgpLCBhcHBseVVzZXJNZXJnZSgpKS5cclxuICogIC0gQXBwbHlpbmcgYW5kIGNhY2hpbmcgZGF0YSBjaGFuZ2VzIGZvciBzZXJ2ZXIgZGF0YSBjaGFuZ2VzIChhcHBseVNlcnZlck92ZXJ3cml0ZSgpLFxyXG4gKiAgICBhcHBseVNlcnZlck1lcmdlKCkpLlxyXG4gKiAgLSBHZW5lcmF0aW5nIHVzZXItZmFjaW5nIGV2ZW50cyBmb3Igc2VydmVyIGFuZCB1c2VyIGNoYW5nZXMgKGFsbCBvZiB0aGUgYXBwbHkqIG1ldGhvZHNcclxuICogICAgcmV0dXJuIHRoZSBzZXQgb2YgZXZlbnRzIHRoYXQgbmVlZCB0byBiZSByYWlzZWQgYXMgYSByZXN1bHQpLlxyXG4gKiAgLSBNYWludGFpbmluZyB0aGUgYXBwcm9wcmlhdGUgc2V0IG9mIHNlcnZlciBsaXN0ZW5zIHRvIGVuc3VyZSB3ZSBhcmUgYWx3YXlzIHN1YnNjcmliZWRcclxuICogICAgdG8gdGhlIGNvcnJlY3Qgc2V0IG9mIHBhdGhzIGFuZCBxdWVyaWVzIHRvIHNhdGlzZnkgdGhlIGN1cnJlbnQgc2V0IG9mIHVzZXIgZXZlbnRcclxuICogICAgY2FsbGJhY2tzIChsaXN0ZW5zIGFyZSBzdGFydGVkL3N0b3BwZWQgdXNpbmcgdGhlIHByb3ZpZGVkIGxpc3RlblByb3ZpZGVyKS5cclxuICpcclxuICogTk9URTogQWx0aG91Z2ggU3luY1RyZWUgdHJhY2tzIGV2ZW50IGNhbGxiYWNrcyBhbmQgY2FsY3VsYXRlcyBldmVudHMgdG8gcmFpc2UsIHRoZSBhY3R1YWxcclxuICogZXZlbnRzIGFyZSByZXR1cm5lZCB0byB0aGUgY2FsbGVyIHJhdGhlciB0aGFuIHJhaXNlZCBzeW5jaHJvbm91c2x5LlxyXG4gKlxyXG4gKi9cclxuY2xhc3MgU3luY1RyZWUge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gbGlzdGVuUHJvdmlkZXJfIC0gVXNlZCBieSBTeW5jVHJlZSB0byBzdGFydCAvIHN0b3AgbGlzdGVuaW5nXHJcbiAgICAgKiAgIHRvIHNlcnZlciBkYXRhLlxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihsaXN0ZW5Qcm92aWRlcl8pIHtcclxuICAgICAgICB0aGlzLmxpc3RlblByb3ZpZGVyXyA9IGxpc3RlblByb3ZpZGVyXztcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUcmVlIG9mIFN5bmNQb2ludHMuICBUaGVyZSdzIGEgU3luY1BvaW50IGF0IGFueSBsb2NhdGlvbiB0aGF0IGhhcyAxIG9yIG1vcmUgdmlld3MuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5zeW5jUG9pbnRUcmVlXyA9IG5ldyBJbW11dGFibGVUcmVlKG51bGwpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEEgdHJlZSBvZiBhbGwgcGVuZGluZyB1c2VyIHdyaXRlcyAodXNlci1pbml0aWF0ZWQgc2V0KCkncywgdHJhbnNhY3Rpb24oKSdzLCB1cGRhdGUoKSdzLCBldGMuKS5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnBlbmRpbmdXcml0ZVRyZWVfID0gbmV3V3JpdGVUcmVlKCk7XHJcbiAgICAgICAgdGhpcy50YWdUb1F1ZXJ5TWFwID0gbmV3IE1hcCgpO1xyXG4gICAgICAgIHRoaXMucXVlcnlUb1RhZ01hcCA9IG5ldyBNYXAoKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQXBwbHkgdGhlIGRhdGEgY2hhbmdlcyBmb3IgYSB1c2VyLWdlbmVyYXRlZCBzZXQoKSBvciB0cmFuc2FjdGlvbigpIGNhbGwuXHJcbiAqXHJcbiAqIEByZXR1cm5zIEV2ZW50cyB0byByYWlzZS5cclxuICovXHJcbmZ1bmN0aW9uIHN5bmNUcmVlQXBwbHlVc2VyT3ZlcndyaXRlKHN5bmNUcmVlLCBwYXRoLCBuZXdEYXRhLCB3cml0ZUlkLCB2aXNpYmxlKSB7XHJcbiAgICAvLyBSZWNvcmQgcGVuZGluZyB3cml0ZS5cclxuICAgIHdyaXRlVHJlZUFkZE92ZXJ3cml0ZShzeW5jVHJlZS5wZW5kaW5nV3JpdGVUcmVlXywgcGF0aCwgbmV3RGF0YSwgd3JpdGVJZCwgdmlzaWJsZSk7XHJcbiAgICBpZiAoIXZpc2libGUpIHtcclxuICAgICAgICByZXR1cm4gW107XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gc3luY1RyZWVBcHBseU9wZXJhdGlvblRvU3luY1BvaW50c18oc3luY1RyZWUsIG5ldyBPdmVyd3JpdGUobmV3T3BlcmF0aW9uU291cmNlVXNlcigpLCBwYXRoLCBuZXdEYXRhKSk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEFwcGx5IHRoZSBkYXRhIGZyb20gYSB1c2VyLWdlbmVyYXRlZCB1cGRhdGUoKSBjYWxsXHJcbiAqXHJcbiAqIEByZXR1cm5zIEV2ZW50cyB0byByYWlzZS5cclxuICovXHJcbmZ1bmN0aW9uIHN5bmNUcmVlQXBwbHlVc2VyTWVyZ2Uoc3luY1RyZWUsIHBhdGgsIGNoYW5nZWRDaGlsZHJlbiwgd3JpdGVJZCkge1xyXG4gICAgLy8gUmVjb3JkIHBlbmRpbmcgbWVyZ2UuXHJcbiAgICB3cml0ZVRyZWVBZGRNZXJnZShzeW5jVHJlZS5wZW5kaW5nV3JpdGVUcmVlXywgcGF0aCwgY2hhbmdlZENoaWxkcmVuLCB3cml0ZUlkKTtcclxuICAgIGNvbnN0IGNoYW5nZVRyZWUgPSBJbW11dGFibGVUcmVlLmZyb21PYmplY3QoY2hhbmdlZENoaWxkcmVuKTtcclxuICAgIHJldHVybiBzeW5jVHJlZUFwcGx5T3BlcmF0aW9uVG9TeW5jUG9pbnRzXyhzeW5jVHJlZSwgbmV3IE1lcmdlKG5ld09wZXJhdGlvblNvdXJjZVVzZXIoKSwgcGF0aCwgY2hhbmdlVHJlZSkpO1xyXG59XHJcbi8qKlxyXG4gKiBBY2tub3dsZWRnZSBhIHBlbmRpbmcgdXNlciB3cml0ZSB0aGF0IHdhcyBwcmV2aW91c2x5IHJlZ2lzdGVyZWQgd2l0aCBhcHBseVVzZXJPdmVyd3JpdGUoKSBvciBhcHBseVVzZXJNZXJnZSgpLlxyXG4gKlxyXG4gKiBAcGFyYW0gcmV2ZXJ0IC0gVHJ1ZSBpZiB0aGUgZ2l2ZW4gd3JpdGUgZmFpbGVkIGFuZCBuZWVkcyB0byBiZSByZXZlcnRlZFxyXG4gKiBAcmV0dXJucyBFdmVudHMgdG8gcmFpc2UuXHJcbiAqL1xyXG5mdW5jdGlvbiBzeW5jVHJlZUFja1VzZXJXcml0ZShzeW5jVHJlZSwgd3JpdGVJZCwgcmV2ZXJ0ID0gZmFsc2UpIHtcclxuICAgIGNvbnN0IHdyaXRlID0gd3JpdGVUcmVlR2V0V3JpdGUoc3luY1RyZWUucGVuZGluZ1dyaXRlVHJlZV8sIHdyaXRlSWQpO1xyXG4gICAgY29uc3QgbmVlZFRvUmVldmFsdWF0ZSA9IHdyaXRlVHJlZVJlbW92ZVdyaXRlKHN5bmNUcmVlLnBlbmRpbmdXcml0ZVRyZWVfLCB3cml0ZUlkKTtcclxuICAgIGlmICghbmVlZFRvUmVldmFsdWF0ZSkge1xyXG4gICAgICAgIHJldHVybiBbXTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGxldCBhZmZlY3RlZFRyZWUgPSBuZXcgSW1tdXRhYmxlVHJlZShudWxsKTtcclxuICAgICAgICBpZiAod3JpdGUuc25hcCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIC8vIG92ZXJ3cml0ZVxyXG4gICAgICAgICAgICBhZmZlY3RlZFRyZWUgPSBhZmZlY3RlZFRyZWUuc2V0KG5ld0VtcHR5UGF0aCgpLCB0cnVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGVhY2god3JpdGUuY2hpbGRyZW4sIChwYXRoU3RyaW5nKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBhZmZlY3RlZFRyZWUgPSBhZmZlY3RlZFRyZWUuc2V0KG5ldyBQYXRoKHBhdGhTdHJpbmcpLCB0cnVlKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzeW5jVHJlZUFwcGx5T3BlcmF0aW9uVG9TeW5jUG9pbnRzXyhzeW5jVHJlZSwgbmV3IEFja1VzZXJXcml0ZSh3cml0ZS5wYXRoLCBhZmZlY3RlZFRyZWUsIHJldmVydCkpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBBcHBseSBuZXcgc2VydmVyIGRhdGEgZm9yIHRoZSBzcGVjaWZpZWQgcGF0aC4uXHJcbiAqXHJcbiAqIEByZXR1cm5zIEV2ZW50cyB0byByYWlzZS5cclxuICovXHJcbmZ1bmN0aW9uIHN5bmNUcmVlQXBwbHlTZXJ2ZXJPdmVyd3JpdGUoc3luY1RyZWUsIHBhdGgsIG5ld0RhdGEpIHtcclxuICAgIHJldHVybiBzeW5jVHJlZUFwcGx5T3BlcmF0aW9uVG9TeW5jUG9pbnRzXyhzeW5jVHJlZSwgbmV3IE92ZXJ3cml0ZShuZXdPcGVyYXRpb25Tb3VyY2VTZXJ2ZXIoKSwgcGF0aCwgbmV3RGF0YSkpO1xyXG59XHJcbi8qKlxyXG4gKiBBcHBseSBuZXcgc2VydmVyIGRhdGEgdG8gYmUgbWVyZ2VkIGluIGF0IHRoZSBzcGVjaWZpZWQgcGF0aC5cclxuICpcclxuICogQHJldHVybnMgRXZlbnRzIHRvIHJhaXNlLlxyXG4gKi9cclxuZnVuY3Rpb24gc3luY1RyZWVBcHBseVNlcnZlck1lcmdlKHN5bmNUcmVlLCBwYXRoLCBjaGFuZ2VkQ2hpbGRyZW4pIHtcclxuICAgIGNvbnN0IGNoYW5nZVRyZWUgPSBJbW11dGFibGVUcmVlLmZyb21PYmplY3QoY2hhbmdlZENoaWxkcmVuKTtcclxuICAgIHJldHVybiBzeW5jVHJlZUFwcGx5T3BlcmF0aW9uVG9TeW5jUG9pbnRzXyhzeW5jVHJlZSwgbmV3IE1lcmdlKG5ld09wZXJhdGlvblNvdXJjZVNlcnZlcigpLCBwYXRoLCBjaGFuZ2VUcmVlKSk7XHJcbn1cclxuLyoqXHJcbiAqIEFwcGx5IGEgbGlzdGVuIGNvbXBsZXRlIGZvciBhIHF1ZXJ5XHJcbiAqXHJcbiAqIEByZXR1cm5zIEV2ZW50cyB0byByYWlzZS5cclxuICovXHJcbmZ1bmN0aW9uIHN5bmNUcmVlQXBwbHlMaXN0ZW5Db21wbGV0ZShzeW5jVHJlZSwgcGF0aCkge1xyXG4gICAgcmV0dXJuIHN5bmNUcmVlQXBwbHlPcGVyYXRpb25Ub1N5bmNQb2ludHNfKHN5bmNUcmVlLCBuZXcgTGlzdGVuQ29tcGxldGUobmV3T3BlcmF0aW9uU291cmNlU2VydmVyKCksIHBhdGgpKTtcclxufVxyXG4vKipcclxuICogQXBwbHkgYSBsaXN0ZW4gY29tcGxldGUgZm9yIGEgdGFnZ2VkIHF1ZXJ5XHJcbiAqXHJcbiAqIEByZXR1cm5zIEV2ZW50cyB0byByYWlzZS5cclxuICovXHJcbmZ1bmN0aW9uIHN5bmNUcmVlQXBwbHlUYWdnZWRMaXN0ZW5Db21wbGV0ZShzeW5jVHJlZSwgcGF0aCwgdGFnKSB7XHJcbiAgICBjb25zdCBxdWVyeUtleSA9IHN5bmNUcmVlUXVlcnlLZXlGb3JUYWdfKHN5bmNUcmVlLCB0YWcpO1xyXG4gICAgaWYgKHF1ZXJ5S2V5KSB7XHJcbiAgICAgICAgY29uc3QgciA9IHN5bmNUcmVlUGFyc2VRdWVyeUtleV8ocXVlcnlLZXkpO1xyXG4gICAgICAgIGNvbnN0IHF1ZXJ5UGF0aCA9IHIucGF0aCwgcXVlcnlJZCA9IHIucXVlcnlJZDtcclxuICAgICAgICBjb25zdCByZWxhdGl2ZVBhdGggPSBuZXdSZWxhdGl2ZVBhdGgocXVlcnlQYXRoLCBwYXRoKTtcclxuICAgICAgICBjb25zdCBvcCA9IG5ldyBMaXN0ZW5Db21wbGV0ZShuZXdPcGVyYXRpb25Tb3VyY2VTZXJ2ZXJUYWdnZWRRdWVyeShxdWVyeUlkKSwgcmVsYXRpdmVQYXRoKTtcclxuICAgICAgICByZXR1cm4gc3luY1RyZWVBcHBseVRhZ2dlZE9wZXJhdGlvbl8oc3luY1RyZWUsIHF1ZXJ5UGF0aCwgb3ApO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgLy8gV2UndmUgYWxyZWFkeSByZW1vdmVkIHRoZSBxdWVyeS4gTm8gYmlnIGRlYWwsIGlnbm9yZSB0aGUgdXBkYXRlXHJcbiAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBSZW1vdmUgZXZlbnQgY2FsbGJhY2socykuXHJcbiAqXHJcbiAqIElmIHF1ZXJ5IGlzIHRoZSBkZWZhdWx0IHF1ZXJ5LCB3ZSdsbCBjaGVjayBhbGwgcXVlcmllcyBmb3IgdGhlIHNwZWNpZmllZCBldmVudFJlZ2lzdHJhdGlvbi5cclxuICogSWYgZXZlbnRSZWdpc3RyYXRpb24gaXMgbnVsbCwgd2UnbGwgcmVtb3ZlIGFsbCBjYWxsYmFja3MgZm9yIHRoZSBzcGVjaWZpZWQgcXVlcnkvcXVlcmllcy5cclxuICpcclxuICogQHBhcmFtIGV2ZW50UmVnaXN0cmF0aW9uIC0gSWYgbnVsbCwgYWxsIGNhbGxiYWNrcyBhcmUgcmVtb3ZlZC5cclxuICogQHBhcmFtIGNhbmNlbEVycm9yIC0gSWYgYSBjYW5jZWxFcnJvciBpcyBwcm92aWRlZCwgYXBwcm9wcmlhdGUgY2FuY2VsIGV2ZW50cyB3aWxsIGJlIHJldHVybmVkLlxyXG4gKiBAcmV0dXJucyBDYW5jZWwgZXZlbnRzLCBpZiBjYW5jZWxFcnJvciB3YXMgcHJvdmlkZWQuXHJcbiAqL1xyXG5mdW5jdGlvbiBzeW5jVHJlZVJlbW92ZUV2ZW50UmVnaXN0cmF0aW9uKHN5bmNUcmVlLCBxdWVyeSwgZXZlbnRSZWdpc3RyYXRpb24sIGNhbmNlbEVycm9yKSB7XHJcbiAgICAvLyBGaW5kIHRoZSBzeW5jUG9pbnQgZmlyc3QuIFRoZW4gZGVhbCB3aXRoIHdoZXRoZXIgb3Igbm90IGl0IGhhcyBtYXRjaGluZyBsaXN0ZW5lcnNcclxuICAgIGNvbnN0IHBhdGggPSBxdWVyeS5fcGF0aDtcclxuICAgIGNvbnN0IG1heWJlU3luY1BvaW50ID0gc3luY1RyZWUuc3luY1BvaW50VHJlZV8uZ2V0KHBhdGgpO1xyXG4gICAgbGV0IGNhbmNlbEV2ZW50cyA9IFtdO1xyXG4gICAgLy8gQSByZW1vdmFsIG9uIGEgZGVmYXVsdCBxdWVyeSBhZmZlY3RzIGFsbCBxdWVyaWVzIGF0IHRoYXQgbG9jYXRpb24uIEEgcmVtb3ZhbCBvbiBhbiBpbmRleGVkIHF1ZXJ5LCBldmVuIG9uZSB3aXRob3V0XHJcbiAgICAvLyBvdGhlciBxdWVyeSBjb25zdHJhaW50cywgZG9lcyAqbm90KiBhZmZlY3QgYWxsIHF1ZXJpZXMgYXQgdGhhdCBsb2NhdGlvbi4gU28gdGhpcyBjaGVjayBtdXN0IGJlIGZvciAnZGVmYXVsdCcsIGFuZFxyXG4gICAgLy8gbm90IGxvYWRzQWxsRGF0YSgpLlxyXG4gICAgaWYgKG1heWJlU3luY1BvaW50ICYmXHJcbiAgICAgICAgKHF1ZXJ5Ll9xdWVyeUlkZW50aWZpZXIgPT09ICdkZWZhdWx0JyB8fFxyXG4gICAgICAgICAgICBzeW5jUG9pbnRWaWV3RXhpc3RzRm9yUXVlcnkobWF5YmVTeW5jUG9pbnQsIHF1ZXJ5KSkpIHtcclxuICAgICAgICBjb25zdCByZW1vdmVkQW5kRXZlbnRzID0gc3luY1BvaW50UmVtb3ZlRXZlbnRSZWdpc3RyYXRpb24obWF5YmVTeW5jUG9pbnQsIHF1ZXJ5LCBldmVudFJlZ2lzdHJhdGlvbiwgY2FuY2VsRXJyb3IpO1xyXG4gICAgICAgIGlmIChzeW5jUG9pbnRJc0VtcHR5KG1heWJlU3luY1BvaW50KSkge1xyXG4gICAgICAgICAgICBzeW5jVHJlZS5zeW5jUG9pbnRUcmVlXyA9IHN5bmNUcmVlLnN5bmNQb2ludFRyZWVfLnJlbW92ZShwYXRoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgcmVtb3ZlZCA9IHJlbW92ZWRBbmRFdmVudHMucmVtb3ZlZDtcclxuICAgICAgICBjYW5jZWxFdmVudHMgPSByZW1vdmVkQW5kRXZlbnRzLmV2ZW50cztcclxuICAgICAgICAvLyBXZSBtYXkgaGF2ZSBqdXN0IHJlbW92ZWQgb25lIG9mIG1hbnkgbGlzdGVuZXJzIGFuZCBjYW4gc2hvcnQtY2lyY3VpdCB0aGlzIHdob2xlIHByb2Nlc3NcclxuICAgICAgICAvLyBXZSBtYXkgYWxzbyBub3QgaGF2ZSByZW1vdmVkIGEgZGVmYXVsdCBsaXN0ZW5lciwgaW4gd2hpY2ggY2FzZSBhbGwgb2YgdGhlIGRlc2NlbmRhbnQgbGlzdGVuZXJzIHNob3VsZCBhbHJlYWR5IGJlXHJcbiAgICAgICAgLy8gcHJvcGVybHkgc2V0IHVwLlxyXG4gICAgICAgIC8vXHJcbiAgICAgICAgLy8gU2luY2UgaW5kZXhlZCBxdWVyaWVzIGNhbiBzaGFkb3cgaWYgdGhleSBkb24ndCBoYXZlIG90aGVyIHF1ZXJ5IGNvbnN0cmFpbnRzLCBjaGVjayBmb3IgbG9hZHNBbGxEYXRhKCksIGluc3RlYWQgb2ZcclxuICAgICAgICAvLyBxdWVyeUlkID09PSAnZGVmYXVsdCdcclxuICAgICAgICBjb25zdCByZW1vdmluZ0RlZmF1bHQgPSAtMSAhPT1cclxuICAgICAgICAgICAgcmVtb3ZlZC5maW5kSW5kZXgocXVlcnkgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHF1ZXJ5Ll9xdWVyeVBhcmFtcy5sb2Fkc0FsbERhdGEoKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgY29uc3QgY292ZXJlZCA9IHN5bmNUcmVlLnN5bmNQb2ludFRyZWVfLmZpbmRPblBhdGgocGF0aCwgKHJlbGF0aXZlUGF0aCwgcGFyZW50U3luY1BvaW50KSA9PiBzeW5jUG9pbnRIYXNDb21wbGV0ZVZpZXcocGFyZW50U3luY1BvaW50KSk7XHJcbiAgICAgICAgaWYgKHJlbW92aW5nRGVmYXVsdCAmJiAhY292ZXJlZCkge1xyXG4gICAgICAgICAgICBjb25zdCBzdWJ0cmVlID0gc3luY1RyZWUuc3luY1BvaW50VHJlZV8uc3VidHJlZShwYXRoKTtcclxuICAgICAgICAgICAgLy8gVGhlcmUgYXJlIHBvdGVudGlhbGx5IGNoaWxkIGxpc3RlbmVycy4gRGV0ZXJtaW5lIHdoYXQgaWYgYW55IGxpc3RlbnMgd2UgbmVlZCB0byBzZW5kIGJlZm9yZSBleGVjdXRpbmcgdGhlXHJcbiAgICAgICAgICAgIC8vIHJlbW92YWxcclxuICAgICAgICAgICAgaWYgKCFzdWJ0cmVlLmlzRW1wdHkoKSkge1xyXG4gICAgICAgICAgICAgICAgLy8gV2UgbmVlZCB0byBmb2xkIG92ZXIgb3VyIHN1YnRyZWUgYW5kIGNvbGxlY3QgdGhlIGxpc3RlbmVycyB0byBzZW5kXHJcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdWaWV3cyA9IHN5bmNUcmVlQ29sbGVjdERpc3RpbmN0Vmlld3NGb3JTdWJUcmVlXyhzdWJ0cmVlKTtcclxuICAgICAgICAgICAgICAgIC8vIE9rLCB3ZSd2ZSBjb2xsZWN0ZWQgYWxsIHRoZSBsaXN0ZW5zIHdlIG5lZWQuIFNldCB0aGVtIHVwLlxyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuZXdWaWV3cy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZpZXcgPSBuZXdWaWV3c1tpXSwgbmV3UXVlcnkgPSB2aWV3LnF1ZXJ5O1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxpc3RlbmVyID0gc3luY1RyZWVDcmVhdGVMaXN0ZW5lckZvclZpZXdfKHN5bmNUcmVlLCB2aWV3KTtcclxuICAgICAgICAgICAgICAgICAgICBzeW5jVHJlZS5saXN0ZW5Qcm92aWRlcl8uc3RhcnRMaXN0ZW5pbmcoc3luY1RyZWVRdWVyeUZvckxpc3RlbmluZ18obmV3UXVlcnkpLCBzeW5jVHJlZVRhZ0ZvclF1ZXJ5XyhzeW5jVHJlZSwgbmV3UXVlcnkpLCBsaXN0ZW5lci5oYXNoRm4sIGxpc3RlbmVyLm9uQ29tcGxldGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIElmIHdlIHJlbW92ZWQgYW55dGhpbmcgYW5kIHdlJ3JlIG5vdCBjb3ZlcmVkIGJ5IGEgaGlnaGVyIHVwIGxpc3Rlbiwgd2UgbmVlZCB0byBzdG9wIGxpc3RlbmluZyBvbiB0aGlzIHF1ZXJ5XHJcbiAgICAgICAgLy8gVGhlIGFib3ZlIGJsb2NrIGhhcyB1cyBjb3ZlcmVkIGluIHRlcm1zIG9mIG1ha2luZyBzdXJlIHdlJ3JlIHNldCB1cCBvbiBsaXN0ZW5zIGxvd2VyIGluIHRoZSB0cmVlLlxyXG4gICAgICAgIC8vIEFsc28sIG5vdGUgdGhhdCBpZiB3ZSBoYXZlIGEgY2FuY2VsRXJyb3IsIGl0J3MgYWxyZWFkeSBiZWVuIHJlbW92ZWQgYXQgdGhlIHByb3ZpZGVyIGxldmVsLlxyXG4gICAgICAgIGlmICghY292ZXJlZCAmJiByZW1vdmVkLmxlbmd0aCA+IDAgJiYgIWNhbmNlbEVycm9yKSB7XHJcbiAgICAgICAgICAgIC8vIElmIHdlIHJlbW92ZWQgYSBkZWZhdWx0LCB0aGVuIHdlIHdlcmVuJ3QgbGlzdGVuaW5nIG9uIGFueSBvZiB0aGUgb3RoZXIgcXVlcmllcyBoZXJlLiBKdXN0IGNhbmNlbCB0aGUgb25lXHJcbiAgICAgICAgICAgIC8vIGRlZmF1bHQuIE90aGVyd2lzZSwgd2UgbmVlZCB0byBpdGVyYXRlIHRocm91Z2ggYW5kIGNhbmNlbCBlYWNoIGluZGl2aWR1YWwgcXVlcnlcclxuICAgICAgICAgICAgaWYgKHJlbW92aW5nRGVmYXVsdCkge1xyXG4gICAgICAgICAgICAgICAgLy8gV2UgZG9uJ3QgdGFnIGRlZmF1bHQgbGlzdGVuZXJzXHJcbiAgICAgICAgICAgICAgICBjb25zdCBkZWZhdWx0VGFnID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIHN5bmNUcmVlLmxpc3RlblByb3ZpZGVyXy5zdG9wTGlzdGVuaW5nKHN5bmNUcmVlUXVlcnlGb3JMaXN0ZW5pbmdfKHF1ZXJ5KSwgZGVmYXVsdFRhZyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZW1vdmVkLmZvckVhY2goKHF1ZXJ5VG9SZW1vdmUpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB0YWdUb1JlbW92ZSA9IHN5bmNUcmVlLnF1ZXJ5VG9UYWdNYXAuZ2V0KHN5bmNUcmVlTWFrZVF1ZXJ5S2V5XyhxdWVyeVRvUmVtb3ZlKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgc3luY1RyZWUubGlzdGVuUHJvdmlkZXJfLnN0b3BMaXN0ZW5pbmcoc3luY1RyZWVRdWVyeUZvckxpc3RlbmluZ18ocXVlcnlUb1JlbW92ZSksIHRhZ1RvUmVtb3ZlKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIE5vdywgY2xlYXIgYWxsIG9mIHRoZSB0YWdzIHdlJ3JlIHRyYWNraW5nIGZvciB0aGUgcmVtb3ZlZCBsaXN0ZW5zXHJcbiAgICAgICAgc3luY1RyZWVSZW1vdmVUYWdzXyhzeW5jVHJlZSwgcmVtb3ZlZCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gY2FuY2VsRXZlbnRzO1xyXG59XHJcbi8qKlxyXG4gKiBBcHBseSBuZXcgc2VydmVyIGRhdGEgZm9yIHRoZSBzcGVjaWZpZWQgdGFnZ2VkIHF1ZXJ5LlxyXG4gKlxyXG4gKiBAcmV0dXJucyBFdmVudHMgdG8gcmFpc2UuXHJcbiAqL1xyXG5mdW5jdGlvbiBzeW5jVHJlZUFwcGx5VGFnZ2VkUXVlcnlPdmVyd3JpdGUoc3luY1RyZWUsIHBhdGgsIHNuYXAsIHRhZykge1xyXG4gICAgY29uc3QgcXVlcnlLZXkgPSBzeW5jVHJlZVF1ZXJ5S2V5Rm9yVGFnXyhzeW5jVHJlZSwgdGFnKTtcclxuICAgIGlmIChxdWVyeUtleSAhPSBudWxsKSB7XHJcbiAgICAgICAgY29uc3QgciA9IHN5bmNUcmVlUGFyc2VRdWVyeUtleV8ocXVlcnlLZXkpO1xyXG4gICAgICAgIGNvbnN0IHF1ZXJ5UGF0aCA9IHIucGF0aCwgcXVlcnlJZCA9IHIucXVlcnlJZDtcclxuICAgICAgICBjb25zdCByZWxhdGl2ZVBhdGggPSBuZXdSZWxhdGl2ZVBhdGgocXVlcnlQYXRoLCBwYXRoKTtcclxuICAgICAgICBjb25zdCBvcCA9IG5ldyBPdmVyd3JpdGUobmV3T3BlcmF0aW9uU291cmNlU2VydmVyVGFnZ2VkUXVlcnkocXVlcnlJZCksIHJlbGF0aXZlUGF0aCwgc25hcCk7XHJcbiAgICAgICAgcmV0dXJuIHN5bmNUcmVlQXBwbHlUYWdnZWRPcGVyYXRpb25fKHN5bmNUcmVlLCBxdWVyeVBhdGgsIG9wKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIC8vIFF1ZXJ5IG11c3QgaGF2ZSBiZWVuIHJlbW92ZWQgYWxyZWFkeVxyXG4gICAgICAgIHJldHVybiBbXTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQXBwbHkgc2VydmVyIGRhdGEgdG8gYmUgbWVyZ2VkIGluIGZvciB0aGUgc3BlY2lmaWVkIHRhZ2dlZCBxdWVyeS5cclxuICpcclxuICogQHJldHVybnMgRXZlbnRzIHRvIHJhaXNlLlxyXG4gKi9cclxuZnVuY3Rpb24gc3luY1RyZWVBcHBseVRhZ2dlZFF1ZXJ5TWVyZ2Uoc3luY1RyZWUsIHBhdGgsIGNoYW5nZWRDaGlsZHJlbiwgdGFnKSB7XHJcbiAgICBjb25zdCBxdWVyeUtleSA9IHN5bmNUcmVlUXVlcnlLZXlGb3JUYWdfKHN5bmNUcmVlLCB0YWcpO1xyXG4gICAgaWYgKHF1ZXJ5S2V5KSB7XHJcbiAgICAgICAgY29uc3QgciA9IHN5bmNUcmVlUGFyc2VRdWVyeUtleV8ocXVlcnlLZXkpO1xyXG4gICAgICAgIGNvbnN0IHF1ZXJ5UGF0aCA9IHIucGF0aCwgcXVlcnlJZCA9IHIucXVlcnlJZDtcclxuICAgICAgICBjb25zdCByZWxhdGl2ZVBhdGggPSBuZXdSZWxhdGl2ZVBhdGgocXVlcnlQYXRoLCBwYXRoKTtcclxuICAgICAgICBjb25zdCBjaGFuZ2VUcmVlID0gSW1tdXRhYmxlVHJlZS5mcm9tT2JqZWN0KGNoYW5nZWRDaGlsZHJlbik7XHJcbiAgICAgICAgY29uc3Qgb3AgPSBuZXcgTWVyZ2UobmV3T3BlcmF0aW9uU291cmNlU2VydmVyVGFnZ2VkUXVlcnkocXVlcnlJZCksIHJlbGF0aXZlUGF0aCwgY2hhbmdlVHJlZSk7XHJcbiAgICAgICAgcmV0dXJuIHN5bmNUcmVlQXBwbHlUYWdnZWRPcGVyYXRpb25fKHN5bmNUcmVlLCBxdWVyeVBhdGgsIG9wKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIC8vIFdlJ3ZlIGFscmVhZHkgcmVtb3ZlZCB0aGUgcXVlcnkuIE5vIGJpZyBkZWFsLCBpZ25vcmUgdGhlIHVwZGF0ZVxyXG4gICAgICAgIHJldHVybiBbXTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQWRkIGFuIGV2ZW50IGNhbGxiYWNrIGZvciB0aGUgc3BlY2lmaWVkIHF1ZXJ5LlxyXG4gKlxyXG4gKiBAcmV0dXJucyBFdmVudHMgdG8gcmFpc2UuXHJcbiAqL1xyXG5mdW5jdGlvbiBzeW5jVHJlZUFkZEV2ZW50UmVnaXN0cmF0aW9uKHN5bmNUcmVlLCBxdWVyeSwgZXZlbnRSZWdpc3RyYXRpb24pIHtcclxuICAgIGNvbnN0IHBhdGggPSBxdWVyeS5fcGF0aDtcclxuICAgIGxldCBzZXJ2ZXJDYWNoZSA9IG51bGw7XHJcbiAgICBsZXQgZm91bmRBbmNlc3RvckRlZmF1bHRWaWV3ID0gZmFsc2U7XHJcbiAgICAvLyBBbnkgY292ZXJpbmcgd3JpdGVzIHdpbGwgbmVjZXNzYXJpbHkgYmUgYXQgdGhlIHJvb3QsIHNvIHJlYWxseSBhbGwgd2UgbmVlZCB0byBmaW5kIGlzIHRoZSBzZXJ2ZXIgY2FjaGUuXHJcbiAgICAvLyBDb25zaWRlciBvcHRpbWl6aW5nIHRoaXMgb25jZSB0aGVyZSdzIGEgYmV0dGVyIHVuZGVyc3RhbmRpbmcgb2Ygd2hhdCBhY3R1YWwgYmVoYXZpb3Igd2lsbCBiZS5cclxuICAgIHN5bmNUcmVlLnN5bmNQb2ludFRyZWVfLmZvcmVhY2hPblBhdGgocGF0aCwgKHBhdGhUb1N5bmNQb2ludCwgc3ApID0+IHtcclxuICAgICAgICBjb25zdCByZWxhdGl2ZVBhdGggPSBuZXdSZWxhdGl2ZVBhdGgocGF0aFRvU3luY1BvaW50LCBwYXRoKTtcclxuICAgICAgICBzZXJ2ZXJDYWNoZSA9XHJcbiAgICAgICAgICAgIHNlcnZlckNhY2hlIHx8IHN5bmNQb2ludEdldENvbXBsZXRlU2VydmVyQ2FjaGUoc3AsIHJlbGF0aXZlUGF0aCk7XHJcbiAgICAgICAgZm91bmRBbmNlc3RvckRlZmF1bHRWaWV3ID1cclxuICAgICAgICAgICAgZm91bmRBbmNlc3RvckRlZmF1bHRWaWV3IHx8IHN5bmNQb2ludEhhc0NvbXBsZXRlVmlldyhzcCk7XHJcbiAgICB9KTtcclxuICAgIGxldCBzeW5jUG9pbnQgPSBzeW5jVHJlZS5zeW5jUG9pbnRUcmVlXy5nZXQocGF0aCk7XHJcbiAgICBpZiAoIXN5bmNQb2ludCkge1xyXG4gICAgICAgIHN5bmNQb2ludCA9IG5ldyBTeW5jUG9pbnQoKTtcclxuICAgICAgICBzeW5jVHJlZS5zeW5jUG9pbnRUcmVlXyA9IHN5bmNUcmVlLnN5bmNQb2ludFRyZWVfLnNldChwYXRoLCBzeW5jUG9pbnQpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgZm91bmRBbmNlc3RvckRlZmF1bHRWaWV3ID1cclxuICAgICAgICAgICAgZm91bmRBbmNlc3RvckRlZmF1bHRWaWV3IHx8IHN5bmNQb2ludEhhc0NvbXBsZXRlVmlldyhzeW5jUG9pbnQpO1xyXG4gICAgICAgIHNlcnZlckNhY2hlID1cclxuICAgICAgICAgICAgc2VydmVyQ2FjaGUgfHwgc3luY1BvaW50R2V0Q29tcGxldGVTZXJ2ZXJDYWNoZShzeW5jUG9pbnQsIG5ld0VtcHR5UGF0aCgpKTtcclxuICAgIH1cclxuICAgIGxldCBzZXJ2ZXJDYWNoZUNvbXBsZXRlO1xyXG4gICAgaWYgKHNlcnZlckNhY2hlICE9IG51bGwpIHtcclxuICAgICAgICBzZXJ2ZXJDYWNoZUNvbXBsZXRlID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHNlcnZlckNhY2hlQ29tcGxldGUgPSBmYWxzZTtcclxuICAgICAgICBzZXJ2ZXJDYWNoZSA9IENoaWxkcmVuTm9kZS5FTVBUWV9OT0RFO1xyXG4gICAgICAgIGNvbnN0IHN1YnRyZWUgPSBzeW5jVHJlZS5zeW5jUG9pbnRUcmVlXy5zdWJ0cmVlKHBhdGgpO1xyXG4gICAgICAgIHN1YnRyZWUuZm9yZWFjaENoaWxkKChjaGlsZE5hbWUsIGNoaWxkU3luY1BvaW50KSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNvbXBsZXRlQ2FjaGUgPSBzeW5jUG9pbnRHZXRDb21wbGV0ZVNlcnZlckNhY2hlKGNoaWxkU3luY1BvaW50LCBuZXdFbXB0eVBhdGgoKSk7XHJcbiAgICAgICAgICAgIGlmIChjb21wbGV0ZUNhY2hlKSB7XHJcbiAgICAgICAgICAgICAgICBzZXJ2ZXJDYWNoZSA9IHNlcnZlckNhY2hlLnVwZGF0ZUltbWVkaWF0ZUNoaWxkKGNoaWxkTmFtZSwgY29tcGxldGVDYWNoZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGNvbnN0IHZpZXdBbHJlYWR5RXhpc3RzID0gc3luY1BvaW50Vmlld0V4aXN0c0ZvclF1ZXJ5KHN5bmNQb2ludCwgcXVlcnkpO1xyXG4gICAgaWYgKCF2aWV3QWxyZWFkeUV4aXN0cyAmJiAhcXVlcnkuX3F1ZXJ5UGFyYW1zLmxvYWRzQWxsRGF0YSgpKSB7XHJcbiAgICAgICAgLy8gV2UgbmVlZCB0byB0cmFjayBhIHRhZyBmb3IgdGhpcyBxdWVyeVxyXG4gICAgICAgIGNvbnN0IHF1ZXJ5S2V5ID0gc3luY1RyZWVNYWtlUXVlcnlLZXlfKHF1ZXJ5KTtcclxuICAgICAgICBhc3NlcnQoIXN5bmNUcmVlLnF1ZXJ5VG9UYWdNYXAuaGFzKHF1ZXJ5S2V5KSwgJ1ZpZXcgZG9lcyBub3QgZXhpc3QsIGJ1dCB3ZSBoYXZlIGEgdGFnJyk7XHJcbiAgICAgICAgY29uc3QgdGFnID0gc3luY1RyZWVHZXROZXh0UXVlcnlUYWdfKCk7XHJcbiAgICAgICAgc3luY1RyZWUucXVlcnlUb1RhZ01hcC5zZXQocXVlcnlLZXksIHRhZyk7XHJcbiAgICAgICAgc3luY1RyZWUudGFnVG9RdWVyeU1hcC5zZXQodGFnLCBxdWVyeUtleSk7XHJcbiAgICB9XHJcbiAgICBjb25zdCB3cml0ZXNDYWNoZSA9IHdyaXRlVHJlZUNoaWxkV3JpdGVzKHN5bmNUcmVlLnBlbmRpbmdXcml0ZVRyZWVfLCBwYXRoKTtcclxuICAgIGxldCBldmVudHMgPSBzeW5jUG9pbnRBZGRFdmVudFJlZ2lzdHJhdGlvbihzeW5jUG9pbnQsIHF1ZXJ5LCBldmVudFJlZ2lzdHJhdGlvbiwgd3JpdGVzQ2FjaGUsIHNlcnZlckNhY2hlLCBzZXJ2ZXJDYWNoZUNvbXBsZXRlKTtcclxuICAgIGlmICghdmlld0FscmVhZHlFeGlzdHMgJiYgIWZvdW5kQW5jZXN0b3JEZWZhdWx0Vmlldykge1xyXG4gICAgICAgIGNvbnN0IHZpZXcgPSBzeW5jUG9pbnRWaWV3Rm9yUXVlcnkoc3luY1BvaW50LCBxdWVyeSk7XHJcbiAgICAgICAgZXZlbnRzID0gZXZlbnRzLmNvbmNhdChzeW5jVHJlZVNldHVwTGlzdGVuZXJfKHN5bmNUcmVlLCBxdWVyeSwgdmlldykpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGV2ZW50cztcclxufVxyXG4vKipcclxuICogUmV0dXJucyBhIGNvbXBsZXRlIGNhY2hlLCBpZiB3ZSBoYXZlIG9uZSwgb2YgdGhlIGRhdGEgYXQgYSBwYXJ0aWN1bGFyIHBhdGguIElmIHRoZSBsb2NhdGlvbiBkb2VzIG5vdCBoYXZlIGFcclxuICogbGlzdGVuZXIgYWJvdmUgaXQsIHdlIHdpbGwgZ2V0IGEgZmFsc2UgXCJudWxsXCIuIFRoaXMgc2hvdWxkbid0IGJlIGEgcHJvYmxlbSBiZWNhdXNlIHRyYW5zYWN0aW9ucyB3aWxsIGFsd2F5c1xyXG4gKiBoYXZlIGEgbGlzdGVuZXIgYWJvdmUsIGFuZCBhdG9taWMgb3BlcmF0aW9ucyB3b3VsZCBjb3JyZWN0bHkgc2hvdyBhIGppdHRlciBvZiA8aW5jcmVtZW50IHZhbHVlPiAtPlxyXG4gKiAgICAgPGluY3JlbWVudGVkIHRvdGFsPiBhcyB0aGUgd3JpdGUgaXMgYXBwbGllZCBsb2NhbGx5IGFuZCB0aGVuIGFja25vd2xlZGdlZCBhdCB0aGUgc2VydmVyLlxyXG4gKlxyXG4gKiBOb3RlOiB0aGlzIG1ldGhvZCB3aWxsICppbmNsdWRlKiBoaWRkZW4gd3JpdGVzIGZyb20gdHJhbnNhY3Rpb24gd2l0aCBhcHBseUxvY2FsbHkgc2V0IHRvIGZhbHNlLlxyXG4gKlxyXG4gKiBAcGFyYW0gcGF0aCAtIFRoZSBwYXRoIHRvIHRoZSBkYXRhIHdlIHdhbnRcclxuICogQHBhcmFtIHdyaXRlSWRzVG9FeGNsdWRlIC0gQSBzcGVjaWZpYyBzZXQgdG8gYmUgZXhjbHVkZWRcclxuICovXHJcbmZ1bmN0aW9uIHN5bmNUcmVlQ2FsY0NvbXBsZXRlRXZlbnRDYWNoZShzeW5jVHJlZSwgcGF0aCwgd3JpdGVJZHNUb0V4Y2x1ZGUpIHtcclxuICAgIGNvbnN0IGluY2x1ZGVIaWRkZW5TZXRzID0gdHJ1ZTtcclxuICAgIGNvbnN0IHdyaXRlVHJlZSA9IHN5bmNUcmVlLnBlbmRpbmdXcml0ZVRyZWVfO1xyXG4gICAgY29uc3Qgc2VydmVyQ2FjaGUgPSBzeW5jVHJlZS5zeW5jUG9pbnRUcmVlXy5maW5kT25QYXRoKHBhdGgsIChwYXRoU29GYXIsIHN5bmNQb2ludCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHJlbGF0aXZlUGF0aCA9IG5ld1JlbGF0aXZlUGF0aChwYXRoU29GYXIsIHBhdGgpO1xyXG4gICAgICAgIGNvbnN0IHNlcnZlckNhY2hlID0gc3luY1BvaW50R2V0Q29tcGxldGVTZXJ2ZXJDYWNoZShzeW5jUG9pbnQsIHJlbGF0aXZlUGF0aCk7XHJcbiAgICAgICAgaWYgKHNlcnZlckNhY2hlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzZXJ2ZXJDYWNoZTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIHJldHVybiB3cml0ZVRyZWVDYWxjQ29tcGxldGVFdmVudENhY2hlKHdyaXRlVHJlZSwgcGF0aCwgc2VydmVyQ2FjaGUsIHdyaXRlSWRzVG9FeGNsdWRlLCBpbmNsdWRlSGlkZGVuU2V0cyk7XHJcbn1cclxuZnVuY3Rpb24gc3luY1RyZWVHZXRTZXJ2ZXJWYWx1ZShzeW5jVHJlZSwgcXVlcnkpIHtcclxuICAgIGNvbnN0IHBhdGggPSBxdWVyeS5fcGF0aDtcclxuICAgIGxldCBzZXJ2ZXJDYWNoZSA9IG51bGw7XHJcbiAgICAvLyBBbnkgY292ZXJpbmcgd3JpdGVzIHdpbGwgbmVjZXNzYXJpbHkgYmUgYXQgdGhlIHJvb3QsIHNvIHJlYWxseSBhbGwgd2UgbmVlZCB0byBmaW5kIGlzIHRoZSBzZXJ2ZXIgY2FjaGUuXHJcbiAgICAvLyBDb25zaWRlciBvcHRpbWl6aW5nIHRoaXMgb25jZSB0aGVyZSdzIGEgYmV0dGVyIHVuZGVyc3RhbmRpbmcgb2Ygd2hhdCBhY3R1YWwgYmVoYXZpb3Igd2lsbCBiZS5cclxuICAgIHN5bmNUcmVlLnN5bmNQb2ludFRyZWVfLmZvcmVhY2hPblBhdGgocGF0aCwgKHBhdGhUb1N5bmNQb2ludCwgc3ApID0+IHtcclxuICAgICAgICBjb25zdCByZWxhdGl2ZVBhdGggPSBuZXdSZWxhdGl2ZVBhdGgocGF0aFRvU3luY1BvaW50LCBwYXRoKTtcclxuICAgICAgICBzZXJ2ZXJDYWNoZSA9XHJcbiAgICAgICAgICAgIHNlcnZlckNhY2hlIHx8IHN5bmNQb2ludEdldENvbXBsZXRlU2VydmVyQ2FjaGUoc3AsIHJlbGF0aXZlUGF0aCk7XHJcbiAgICB9KTtcclxuICAgIGxldCBzeW5jUG9pbnQgPSBzeW5jVHJlZS5zeW5jUG9pbnRUcmVlXy5nZXQocGF0aCk7XHJcbiAgICBpZiAoIXN5bmNQb2ludCkge1xyXG4gICAgICAgIHN5bmNQb2ludCA9IG5ldyBTeW5jUG9pbnQoKTtcclxuICAgICAgICBzeW5jVHJlZS5zeW5jUG9pbnRUcmVlXyA9IHN5bmNUcmVlLnN5bmNQb2ludFRyZWVfLnNldChwYXRoLCBzeW5jUG9pbnQpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgc2VydmVyQ2FjaGUgPVxyXG4gICAgICAgICAgICBzZXJ2ZXJDYWNoZSB8fCBzeW5jUG9pbnRHZXRDb21wbGV0ZVNlcnZlckNhY2hlKHN5bmNQb2ludCwgbmV3RW1wdHlQYXRoKCkpO1xyXG4gICAgfVxyXG4gICAgY29uc3Qgc2VydmVyQ2FjaGVDb21wbGV0ZSA9IHNlcnZlckNhY2hlICE9IG51bGw7XHJcbiAgICBjb25zdCBzZXJ2ZXJDYWNoZU5vZGUgPSBzZXJ2ZXJDYWNoZUNvbXBsZXRlXHJcbiAgICAgICAgPyBuZXcgQ2FjaGVOb2RlKHNlcnZlckNhY2hlLCB0cnVlLCBmYWxzZSlcclxuICAgICAgICA6IG51bGw7XHJcbiAgICBjb25zdCB3cml0ZXNDYWNoZSA9IHdyaXRlVHJlZUNoaWxkV3JpdGVzKHN5bmNUcmVlLnBlbmRpbmdXcml0ZVRyZWVfLCBxdWVyeS5fcGF0aCk7XHJcbiAgICBjb25zdCB2aWV3ID0gc3luY1BvaW50R2V0VmlldyhzeW5jUG9pbnQsIHF1ZXJ5LCB3cml0ZXNDYWNoZSwgc2VydmVyQ2FjaGVDb21wbGV0ZSA/IHNlcnZlckNhY2hlTm9kZS5nZXROb2RlKCkgOiBDaGlsZHJlbk5vZGUuRU1QVFlfTk9ERSwgc2VydmVyQ2FjaGVDb21wbGV0ZSk7XHJcbiAgICByZXR1cm4gdmlld0dldENvbXBsZXRlTm9kZSh2aWV3KTtcclxufVxyXG4vKipcclxuICogQSBoZWxwZXIgbWV0aG9kIHRoYXQgdmlzaXRzIGFsbCBkZXNjZW5kYW50IGFuZCBhbmNlc3RvciBTeW5jUG9pbnRzLCBhcHBseWluZyB0aGUgb3BlcmF0aW9uLlxyXG4gKlxyXG4gKiBOT1RFUzpcclxuICogLSBEZXNjZW5kYW50IFN5bmNQb2ludHMgd2lsbCBiZSB2aXNpdGVkIGZpcnN0IChzaW5jZSB3ZSByYWlzZSBldmVudHMgZGVwdGgtZmlyc3QpLlxyXG4gKlxyXG4gKiAtIFdlIGNhbGwgYXBwbHlPcGVyYXRpb24oKSBvbiBlYWNoIFN5bmNQb2ludCBwYXNzaW5nIHRocmVlIHRoaW5nczpcclxuICogICAxLiBBIHZlcnNpb24gb2YgdGhlIE9wZXJhdGlvbiB0aGF0IGhhcyBiZWVuIG1hZGUgcmVsYXRpdmUgdG8gdGhlIFN5bmNQb2ludCBsb2NhdGlvbi5cclxuICogICAyLiBBIFdyaXRlVHJlZVJlZiBvZiBhbnkgd3JpdGVzIHdlIGhhdmUgY2FjaGVkIGF0IHRoZSBTeW5jUG9pbnQgbG9jYXRpb24uXHJcbiAqICAgMy4gQSBzbmFwc2hvdCBOb2RlIHdpdGggY2FjaGVkIHNlcnZlciBkYXRhLCBpZiB3ZSBoYXZlIGl0LlxyXG4gKlxyXG4gKiAtIFdlIGNvbmNhdGVuYXRlIGFsbCBvZiB0aGUgZXZlbnRzIHJldHVybmVkIGJ5IGVhY2ggU3luY1BvaW50IGFuZCByZXR1cm4gdGhlIHJlc3VsdC5cclxuICovXHJcbmZ1bmN0aW9uIHN5bmNUcmVlQXBwbHlPcGVyYXRpb25Ub1N5bmNQb2ludHNfKHN5bmNUcmVlLCBvcGVyYXRpb24pIHtcclxuICAgIHJldHVybiBzeW5jVHJlZUFwcGx5T3BlcmF0aW9uSGVscGVyXyhvcGVyYXRpb24sIHN5bmNUcmVlLnN5bmNQb2ludFRyZWVfLCBcclxuICAgIC8qc2VydmVyQ2FjaGU9Ki8gbnVsbCwgd3JpdGVUcmVlQ2hpbGRXcml0ZXMoc3luY1RyZWUucGVuZGluZ1dyaXRlVHJlZV8sIG5ld0VtcHR5UGF0aCgpKSk7XHJcbn1cclxuLyoqXHJcbiAqIFJlY3Vyc2l2ZSBoZWxwZXIgZm9yIGFwcGx5T3BlcmF0aW9uVG9TeW5jUG9pbnRzX1xyXG4gKi9cclxuZnVuY3Rpb24gc3luY1RyZWVBcHBseU9wZXJhdGlvbkhlbHBlcl8ob3BlcmF0aW9uLCBzeW5jUG9pbnRUcmVlLCBzZXJ2ZXJDYWNoZSwgd3JpdGVzQ2FjaGUpIHtcclxuICAgIGlmIChwYXRoSXNFbXB0eShvcGVyYXRpb24ucGF0aCkpIHtcclxuICAgICAgICByZXR1cm4gc3luY1RyZWVBcHBseU9wZXJhdGlvbkRlc2NlbmRhbnRzSGVscGVyXyhvcGVyYXRpb24sIHN5bmNQb2ludFRyZWUsIHNlcnZlckNhY2hlLCB3cml0ZXNDYWNoZSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBjb25zdCBzeW5jUG9pbnQgPSBzeW5jUG9pbnRUcmVlLmdldChuZXdFbXB0eVBhdGgoKSk7XHJcbiAgICAgICAgLy8gSWYgd2UgZG9uJ3QgaGF2ZSBjYWNoZWQgc2VydmVyIGRhdGEsIHNlZSBpZiB3ZSBjYW4gZ2V0IGl0IGZyb20gdGhpcyBTeW5jUG9pbnQuXHJcbiAgICAgICAgaWYgKHNlcnZlckNhY2hlID09IG51bGwgJiYgc3luY1BvaW50ICE9IG51bGwpIHtcclxuICAgICAgICAgICAgc2VydmVyQ2FjaGUgPSBzeW5jUG9pbnRHZXRDb21wbGV0ZVNlcnZlckNhY2hlKHN5bmNQb2ludCwgbmV3RW1wdHlQYXRoKCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgZXZlbnRzID0gW107XHJcbiAgICAgICAgY29uc3QgY2hpbGROYW1lID0gcGF0aEdldEZyb250KG9wZXJhdGlvbi5wYXRoKTtcclxuICAgICAgICBjb25zdCBjaGlsZE9wZXJhdGlvbiA9IG9wZXJhdGlvbi5vcGVyYXRpb25Gb3JDaGlsZChjaGlsZE5hbWUpO1xyXG4gICAgICAgIGNvbnN0IGNoaWxkVHJlZSA9IHN5bmNQb2ludFRyZWUuY2hpbGRyZW4uZ2V0KGNoaWxkTmFtZSk7XHJcbiAgICAgICAgaWYgKGNoaWxkVHJlZSAmJiBjaGlsZE9wZXJhdGlvbikge1xyXG4gICAgICAgICAgICBjb25zdCBjaGlsZFNlcnZlckNhY2hlID0gc2VydmVyQ2FjaGVcclxuICAgICAgICAgICAgICAgID8gc2VydmVyQ2FjaGUuZ2V0SW1tZWRpYXRlQ2hpbGQoY2hpbGROYW1lKVxyXG4gICAgICAgICAgICAgICAgOiBudWxsO1xyXG4gICAgICAgICAgICBjb25zdCBjaGlsZFdyaXRlc0NhY2hlID0gd3JpdGVUcmVlUmVmQ2hpbGQod3JpdGVzQ2FjaGUsIGNoaWxkTmFtZSk7XHJcbiAgICAgICAgICAgIGV2ZW50cyA9IGV2ZW50cy5jb25jYXQoc3luY1RyZWVBcHBseU9wZXJhdGlvbkhlbHBlcl8oY2hpbGRPcGVyYXRpb24sIGNoaWxkVHJlZSwgY2hpbGRTZXJ2ZXJDYWNoZSwgY2hpbGRXcml0ZXNDYWNoZSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc3luY1BvaW50KSB7XHJcbiAgICAgICAgICAgIGV2ZW50cyA9IGV2ZW50cy5jb25jYXQoc3luY1BvaW50QXBwbHlPcGVyYXRpb24oc3luY1BvaW50LCBvcGVyYXRpb24sIHdyaXRlc0NhY2hlLCBzZXJ2ZXJDYWNoZSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZXZlbnRzO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBSZWN1cnNpdmUgaGVscGVyIGZvciBhcHBseU9wZXJhdGlvblRvU3luY1BvaW50c19cclxuICovXHJcbmZ1bmN0aW9uIHN5bmNUcmVlQXBwbHlPcGVyYXRpb25EZXNjZW5kYW50c0hlbHBlcl8ob3BlcmF0aW9uLCBzeW5jUG9pbnRUcmVlLCBzZXJ2ZXJDYWNoZSwgd3JpdGVzQ2FjaGUpIHtcclxuICAgIGNvbnN0IHN5bmNQb2ludCA9IHN5bmNQb2ludFRyZWUuZ2V0KG5ld0VtcHR5UGF0aCgpKTtcclxuICAgIC8vIElmIHdlIGRvbid0IGhhdmUgY2FjaGVkIHNlcnZlciBkYXRhLCBzZWUgaWYgd2UgY2FuIGdldCBpdCBmcm9tIHRoaXMgU3luY1BvaW50LlxyXG4gICAgaWYgKHNlcnZlckNhY2hlID09IG51bGwgJiYgc3luY1BvaW50ICE9IG51bGwpIHtcclxuICAgICAgICBzZXJ2ZXJDYWNoZSA9IHN5bmNQb2ludEdldENvbXBsZXRlU2VydmVyQ2FjaGUoc3luY1BvaW50LCBuZXdFbXB0eVBhdGgoKSk7XHJcbiAgICB9XHJcbiAgICBsZXQgZXZlbnRzID0gW107XHJcbiAgICBzeW5jUG9pbnRUcmVlLmNoaWxkcmVuLmlub3JkZXJUcmF2ZXJzYWwoKGNoaWxkTmFtZSwgY2hpbGRUcmVlKSA9PiB7XHJcbiAgICAgICAgY29uc3QgY2hpbGRTZXJ2ZXJDYWNoZSA9IHNlcnZlckNhY2hlXHJcbiAgICAgICAgICAgID8gc2VydmVyQ2FjaGUuZ2V0SW1tZWRpYXRlQ2hpbGQoY2hpbGROYW1lKVxyXG4gICAgICAgICAgICA6IG51bGw7XHJcbiAgICAgICAgY29uc3QgY2hpbGRXcml0ZXNDYWNoZSA9IHdyaXRlVHJlZVJlZkNoaWxkKHdyaXRlc0NhY2hlLCBjaGlsZE5hbWUpO1xyXG4gICAgICAgIGNvbnN0IGNoaWxkT3BlcmF0aW9uID0gb3BlcmF0aW9uLm9wZXJhdGlvbkZvckNoaWxkKGNoaWxkTmFtZSk7XHJcbiAgICAgICAgaWYgKGNoaWxkT3BlcmF0aW9uKSB7XHJcbiAgICAgICAgICAgIGV2ZW50cyA9IGV2ZW50cy5jb25jYXQoc3luY1RyZWVBcHBseU9wZXJhdGlvbkRlc2NlbmRhbnRzSGVscGVyXyhjaGlsZE9wZXJhdGlvbiwgY2hpbGRUcmVlLCBjaGlsZFNlcnZlckNhY2hlLCBjaGlsZFdyaXRlc0NhY2hlKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICBpZiAoc3luY1BvaW50KSB7XHJcbiAgICAgICAgZXZlbnRzID0gZXZlbnRzLmNvbmNhdChzeW5jUG9pbnRBcHBseU9wZXJhdGlvbihzeW5jUG9pbnQsIG9wZXJhdGlvbiwgd3JpdGVzQ2FjaGUsIHNlcnZlckNhY2hlKSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZXZlbnRzO1xyXG59XHJcbmZ1bmN0aW9uIHN5bmNUcmVlQ3JlYXRlTGlzdGVuZXJGb3JWaWV3XyhzeW5jVHJlZSwgdmlldykge1xyXG4gICAgY29uc3QgcXVlcnkgPSB2aWV3LnF1ZXJ5O1xyXG4gICAgY29uc3QgdGFnID0gc3luY1RyZWVUYWdGb3JRdWVyeV8oc3luY1RyZWUsIHF1ZXJ5KTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgaGFzaEZuOiAoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNhY2hlID0gdmlld0dldFNlcnZlckNhY2hlKHZpZXcpIHx8IENoaWxkcmVuTm9kZS5FTVBUWV9OT0RFO1xyXG4gICAgICAgICAgICByZXR1cm4gY2FjaGUuaGFzaCgpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgb25Db21wbGV0ZTogKHN0YXR1cykgPT4ge1xyXG4gICAgICAgICAgICBpZiAoc3RhdHVzID09PSAnb2snKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGFnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN5bmNUcmVlQXBwbHlUYWdnZWRMaXN0ZW5Db21wbGV0ZShzeW5jVHJlZSwgcXVlcnkuX3BhdGgsIHRhZyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3luY1RyZWVBcHBseUxpc3RlbkNvbXBsZXRlKHN5bmNUcmVlLCBxdWVyeS5fcGF0aCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBJZiBhIGxpc3RlbiBmYWlsZWQsIGtpbGwgYWxsIG9mIHRoZSBsaXN0ZW5lcnMgaGVyZSwgbm90IGp1c3QgdGhlIG9uZSB0aGF0IHRyaWdnZXJlZCB0aGUgZXJyb3IuXHJcbiAgICAgICAgICAgICAgICAvLyBOb3RlIHRoYXQgdGhpcyBtYXkgbmVlZCB0byBiZSBzY29wZWQgdG8ganVzdCB0aGlzIGxpc3RlbmVyIGlmIHdlIGNoYW5nZSBwZXJtaXNzaW9ucyBvbiBmaWx0ZXJlZCBjaGlsZHJlblxyXG4gICAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBlcnJvckZvclNlcnZlckNvZGUoc3RhdHVzLCBxdWVyeSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc3luY1RyZWVSZW1vdmVFdmVudFJlZ2lzdHJhdGlvbihzeW5jVHJlZSwgcXVlcnksIFxyXG4gICAgICAgICAgICAgICAgLypldmVudFJlZ2lzdHJhdGlvbiovIG51bGwsIGVycm9yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybiB0aGUgdGFnIGFzc29jaWF0ZWQgd2l0aCB0aGUgZ2l2ZW4gcXVlcnkuXHJcbiAqL1xyXG5mdW5jdGlvbiBzeW5jVHJlZVRhZ0ZvclF1ZXJ5XyhzeW5jVHJlZSwgcXVlcnkpIHtcclxuICAgIGNvbnN0IHF1ZXJ5S2V5ID0gc3luY1RyZWVNYWtlUXVlcnlLZXlfKHF1ZXJ5KTtcclxuICAgIHJldHVybiBzeW5jVHJlZS5xdWVyeVRvVGFnTWFwLmdldChxdWVyeUtleSk7XHJcbn1cclxuLyoqXHJcbiAqIEdpdmVuIGEgcXVlcnksIGNvbXB1dGVzIGEgXCJxdWVyeUtleVwiIHN1aXRhYmxlIGZvciB1c2UgaW4gb3VyIHF1ZXJ5VG9UYWdNYXBfLlxyXG4gKi9cclxuZnVuY3Rpb24gc3luY1RyZWVNYWtlUXVlcnlLZXlfKHF1ZXJ5KSB7XHJcbiAgICByZXR1cm4gcXVlcnkuX3BhdGgudG9TdHJpbmcoKSArICckJyArIHF1ZXJ5Ll9xdWVyeUlkZW50aWZpZXI7XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybiB0aGUgcXVlcnkgYXNzb2NpYXRlZCB3aXRoIHRoZSBnaXZlbiB0YWcsIGlmIHdlIGhhdmUgb25lXHJcbiAqL1xyXG5mdW5jdGlvbiBzeW5jVHJlZVF1ZXJ5S2V5Rm9yVGFnXyhzeW5jVHJlZSwgdGFnKSB7XHJcbiAgICByZXR1cm4gc3luY1RyZWUudGFnVG9RdWVyeU1hcC5nZXQodGFnKTtcclxufVxyXG4vKipcclxuICogR2l2ZW4gYSBxdWVyeUtleSAoY3JlYXRlZCBieSBtYWtlUXVlcnlLZXkpLCBwYXJzZSBpdCBiYWNrIGludG8gYSBwYXRoIGFuZCBxdWVyeUlkLlxyXG4gKi9cclxuZnVuY3Rpb24gc3luY1RyZWVQYXJzZVF1ZXJ5S2V5XyhxdWVyeUtleSkge1xyXG4gICAgY29uc3Qgc3BsaXRJbmRleCA9IHF1ZXJ5S2V5LmluZGV4T2YoJyQnKTtcclxuICAgIGFzc2VydChzcGxpdEluZGV4ICE9PSAtMSAmJiBzcGxpdEluZGV4IDwgcXVlcnlLZXkubGVuZ3RoIC0gMSwgJ0JhZCBxdWVyeUtleS4nKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgcXVlcnlJZDogcXVlcnlLZXkuc3Vic3RyKHNwbGl0SW5kZXggKyAxKSxcclxuICAgICAgICBwYXRoOiBuZXcgUGF0aChxdWVyeUtleS5zdWJzdHIoMCwgc3BsaXRJbmRleCkpXHJcbiAgICB9O1xyXG59XHJcbi8qKlxyXG4gKiBBIGhlbHBlciBtZXRob2QgdG8gYXBwbHkgdGFnZ2VkIG9wZXJhdGlvbnNcclxuICovXHJcbmZ1bmN0aW9uIHN5bmNUcmVlQXBwbHlUYWdnZWRPcGVyYXRpb25fKHN5bmNUcmVlLCBxdWVyeVBhdGgsIG9wZXJhdGlvbikge1xyXG4gICAgY29uc3Qgc3luY1BvaW50ID0gc3luY1RyZWUuc3luY1BvaW50VHJlZV8uZ2V0KHF1ZXJ5UGF0aCk7XHJcbiAgICBhc3NlcnQoc3luY1BvaW50LCBcIk1pc3Npbmcgc3luYyBwb2ludCBmb3IgcXVlcnkgdGFnIHRoYXQgd2UncmUgdHJhY2tpbmdcIik7XHJcbiAgICBjb25zdCB3cml0ZXNDYWNoZSA9IHdyaXRlVHJlZUNoaWxkV3JpdGVzKHN5bmNUcmVlLnBlbmRpbmdXcml0ZVRyZWVfLCBxdWVyeVBhdGgpO1xyXG4gICAgcmV0dXJuIHN5bmNQb2ludEFwcGx5T3BlcmF0aW9uKHN5bmNQb2ludCwgb3BlcmF0aW9uLCB3cml0ZXNDYWNoZSwgbnVsbCk7XHJcbn1cclxuLyoqXHJcbiAqIFRoaXMgY29sbGFwc2VzIG11bHRpcGxlIHVuZmlsdGVyZWQgdmlld3MgaW50byBhIHNpbmdsZSB2aWV3LCBzaW5jZSB3ZSBvbmx5IG5lZWQgYSBzaW5nbGVcclxuICogbGlzdGVuZXIgZm9yIHRoZW0uXHJcbiAqL1xyXG5mdW5jdGlvbiBzeW5jVHJlZUNvbGxlY3REaXN0aW5jdFZpZXdzRm9yU3ViVHJlZV8oc3VidHJlZSkge1xyXG4gICAgcmV0dXJuIHN1YnRyZWUuZm9sZCgocmVsYXRpdmVQYXRoLCBtYXliZUNoaWxkU3luY1BvaW50LCBjaGlsZE1hcCkgPT4ge1xyXG4gICAgICAgIGlmIChtYXliZUNoaWxkU3luY1BvaW50ICYmIHN5bmNQb2ludEhhc0NvbXBsZXRlVmlldyhtYXliZUNoaWxkU3luY1BvaW50KSkge1xyXG4gICAgICAgICAgICBjb25zdCBjb21wbGV0ZVZpZXcgPSBzeW5jUG9pbnRHZXRDb21wbGV0ZVZpZXcobWF5YmVDaGlsZFN5bmNQb2ludCk7XHJcbiAgICAgICAgICAgIHJldHVybiBbY29tcGxldGVWaWV3XTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIE5vIGNvbXBsZXRlIHZpZXcgaGVyZSwgZmxhdHRlbiBhbnkgZGVlcGVyIGxpc3RlbnMgaW50byBhbiBhcnJheVxyXG4gICAgICAgICAgICBsZXQgdmlld3MgPSBbXTtcclxuICAgICAgICAgICAgaWYgKG1heWJlQ2hpbGRTeW5jUG9pbnQpIHtcclxuICAgICAgICAgICAgICAgIHZpZXdzID0gc3luY1BvaW50R2V0UXVlcnlWaWV3cyhtYXliZUNoaWxkU3luY1BvaW50KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlYWNoKGNoaWxkTWFwLCAoX2tleSwgY2hpbGRWaWV3cykgPT4ge1xyXG4gICAgICAgICAgICAgICAgdmlld3MgPSB2aWV3cy5jb25jYXQoY2hpbGRWaWV3cyk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gdmlld3M7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbn1cclxuLyoqXHJcbiAqIE5vcm1hbGl6ZXMgYSBxdWVyeSB0byBhIHF1ZXJ5IHdlIHNlbmQgdGhlIHNlcnZlciBmb3IgbGlzdGVuaW5nXHJcbiAqXHJcbiAqIEByZXR1cm5zIFRoZSBub3JtYWxpemVkIHF1ZXJ5XHJcbiAqL1xyXG5mdW5jdGlvbiBzeW5jVHJlZVF1ZXJ5Rm9yTGlzdGVuaW5nXyhxdWVyeSkge1xyXG4gICAgaWYgKHF1ZXJ5Ll9xdWVyeVBhcmFtcy5sb2Fkc0FsbERhdGEoKSAmJiAhcXVlcnkuX3F1ZXJ5UGFyYW1zLmlzRGVmYXVsdCgpKSB7XHJcbiAgICAgICAgLy8gV2UgdHJlYXQgcXVlcmllcyB0aGF0IGxvYWQgYWxsIGRhdGEgYXMgZGVmYXVsdCBxdWVyaWVzXHJcbiAgICAgICAgLy8gQ2FzdCBpcyBuZWNlc3NhcnkgYmVjYXVzZSByZWYoKSB0ZWNobmljYWxseSByZXR1cm5zIEZpcmViYXNlIHdoaWNoIGlzIGFjdHVhbGx5IGZiLmFwaS5GaXJlYmFzZSB3aGljaCBpbmhlcml0c1xyXG4gICAgICAgIC8vIGZyb20gUXVlcnlcclxuICAgICAgICByZXR1cm4gbmV3IChzeW5jVHJlZUdldFJlZmVyZW5jZUNvbnN0cnVjdG9yKCkpKHF1ZXJ5Ll9yZXBvLCBxdWVyeS5fcGF0aCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gcXVlcnk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gc3luY1RyZWVSZW1vdmVUYWdzXyhzeW5jVHJlZSwgcXVlcmllcykge1xyXG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCBxdWVyaWVzLmxlbmd0aDsgKytqKSB7XHJcbiAgICAgICAgY29uc3QgcmVtb3ZlZFF1ZXJ5ID0gcXVlcmllc1tqXTtcclxuICAgICAgICBpZiAoIXJlbW92ZWRRdWVyeS5fcXVlcnlQYXJhbXMubG9hZHNBbGxEYXRhKCkpIHtcclxuICAgICAgICAgICAgLy8gV2Ugc2hvdWxkIGhhdmUgYSB0YWcgZm9yIHRoaXNcclxuICAgICAgICAgICAgY29uc3QgcmVtb3ZlZFF1ZXJ5S2V5ID0gc3luY1RyZWVNYWtlUXVlcnlLZXlfKHJlbW92ZWRRdWVyeSk7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlbW92ZWRRdWVyeVRhZyA9IHN5bmNUcmVlLnF1ZXJ5VG9UYWdNYXAuZ2V0KHJlbW92ZWRRdWVyeUtleSk7XHJcbiAgICAgICAgICAgIHN5bmNUcmVlLnF1ZXJ5VG9UYWdNYXAuZGVsZXRlKHJlbW92ZWRRdWVyeUtleSk7XHJcbiAgICAgICAgICAgIHN5bmNUcmVlLnRhZ1RvUXVlcnlNYXAuZGVsZXRlKHJlbW92ZWRRdWVyeVRhZyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBTdGF0aWMgYWNjZXNzb3IgZm9yIHF1ZXJ5IHRhZ3MuXHJcbiAqL1xyXG5mdW5jdGlvbiBzeW5jVHJlZUdldE5leHRRdWVyeVRhZ18oKSB7XHJcbiAgICByZXR1cm4gc3luY1RyZWVOZXh0UXVlcnlUYWdfKys7XHJcbn1cclxuLyoqXHJcbiAqIEZvciBhIGdpdmVuIG5ldyBsaXN0ZW4sIG1hbmFnZSB0aGUgZGUtZHVwbGljYXRpb24gb2Ygb3V0c3RhbmRpbmcgc3Vic2NyaXB0aW9ucy5cclxuICpcclxuICogQHJldHVybnMgVGhpcyBtZXRob2QgY2FuIHJldHVybiBldmVudHMgdG8gc3VwcG9ydCBzeW5jaHJvbm91cyBkYXRhIHNvdXJjZXNcclxuICovXHJcbmZ1bmN0aW9uIHN5bmNUcmVlU2V0dXBMaXN0ZW5lcl8oc3luY1RyZWUsIHF1ZXJ5LCB2aWV3KSB7XHJcbiAgICBjb25zdCBwYXRoID0gcXVlcnkuX3BhdGg7XHJcbiAgICBjb25zdCB0YWcgPSBzeW5jVHJlZVRhZ0ZvclF1ZXJ5XyhzeW5jVHJlZSwgcXVlcnkpO1xyXG4gICAgY29uc3QgbGlzdGVuZXIgPSBzeW5jVHJlZUNyZWF0ZUxpc3RlbmVyRm9yVmlld18oc3luY1RyZWUsIHZpZXcpO1xyXG4gICAgY29uc3QgZXZlbnRzID0gc3luY1RyZWUubGlzdGVuUHJvdmlkZXJfLnN0YXJ0TGlzdGVuaW5nKHN5bmNUcmVlUXVlcnlGb3JMaXN0ZW5pbmdfKHF1ZXJ5KSwgdGFnLCBsaXN0ZW5lci5oYXNoRm4sIGxpc3RlbmVyLm9uQ29tcGxldGUpO1xyXG4gICAgY29uc3Qgc3VidHJlZSA9IHN5bmNUcmVlLnN5bmNQb2ludFRyZWVfLnN1YnRyZWUocGF0aCk7XHJcbiAgICAvLyBUaGUgcm9vdCBvZiB0aGlzIHN1YnRyZWUgaGFzIG91ciBxdWVyeS4gV2UncmUgaGVyZSBiZWNhdXNlIHdlIGRlZmluaXRlbHkgbmVlZCB0byBzZW5kIGEgbGlzdGVuIGZvciB0aGF0LCBidXQgd2VcclxuICAgIC8vIG1heSBuZWVkIHRvIHNoYWRvdyBvdGhlciBsaXN0ZW5zIGFzIHdlbGwuXHJcbiAgICBpZiAodGFnKSB7XHJcbiAgICAgICAgYXNzZXJ0KCFzeW5jUG9pbnRIYXNDb21wbGV0ZVZpZXcoc3VidHJlZS52YWx1ZSksIFwiSWYgd2UncmUgYWRkaW5nIGEgcXVlcnksIGl0IHNob3VsZG4ndCBiZSBzaGFkb3dlZFwiKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIC8vIFNoYWRvdyBldmVyeXRoaW5nIGF0IG9yIGJlbG93IHRoaXMgbG9jYXRpb24sIHRoaXMgaXMgYSBkZWZhdWx0IGxpc3RlbmVyLlxyXG4gICAgICAgIGNvbnN0IHF1ZXJpZXNUb1N0b3AgPSBzdWJ0cmVlLmZvbGQoKHJlbGF0aXZlUGF0aCwgbWF5YmVDaGlsZFN5bmNQb2ludCwgY2hpbGRNYXApID0+IHtcclxuICAgICAgICAgICAgaWYgKCFwYXRoSXNFbXB0eShyZWxhdGl2ZVBhdGgpICYmXHJcbiAgICAgICAgICAgICAgICBtYXliZUNoaWxkU3luY1BvaW50ICYmXHJcbiAgICAgICAgICAgICAgICBzeW5jUG9pbnRIYXNDb21wbGV0ZVZpZXcobWF5YmVDaGlsZFN5bmNQb2ludCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBbc3luY1BvaW50R2V0Q29tcGxldGVWaWV3KG1heWJlQ2hpbGRTeW5jUG9pbnQpLnF1ZXJ5XTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIE5vIGRlZmF1bHQgbGlzdGVuZXIgaGVyZSwgZmxhdHRlbiBhbnkgZGVlcGVyIHF1ZXJpZXMgaW50byBhbiBhcnJheVxyXG4gICAgICAgICAgICAgICAgbGV0IHF1ZXJpZXMgPSBbXTtcclxuICAgICAgICAgICAgICAgIGlmIChtYXliZUNoaWxkU3luY1BvaW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcXVlcmllcyA9IHF1ZXJpZXMuY29uY2F0KHN5bmNQb2ludEdldFF1ZXJ5Vmlld3MobWF5YmVDaGlsZFN5bmNQb2ludCkubWFwKHZpZXcgPT4gdmlldy5xdWVyeSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWFjaChjaGlsZE1hcCwgKF9rZXksIGNoaWxkUXVlcmllcykgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHF1ZXJpZXMgPSBxdWVyaWVzLmNvbmNhdChjaGlsZFF1ZXJpZXMpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcXVlcmllcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcXVlcmllc1RvU3RvcC5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICBjb25zdCBxdWVyeVRvU3RvcCA9IHF1ZXJpZXNUb1N0b3BbaV07XHJcbiAgICAgICAgICAgIHN5bmNUcmVlLmxpc3RlblByb3ZpZGVyXy5zdG9wTGlzdGVuaW5nKHN5bmNUcmVlUXVlcnlGb3JMaXN0ZW5pbmdfKHF1ZXJ5VG9TdG9wKSwgc3luY1RyZWVUYWdGb3JRdWVyeV8oc3luY1RyZWUsIHF1ZXJ5VG9TdG9wKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGV2ZW50cztcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5jbGFzcyBFeGlzdGluZ1ZhbHVlUHJvdmlkZXIge1xyXG4gICAgY29uc3RydWN0b3Iobm9kZV8pIHtcclxuICAgICAgICB0aGlzLm5vZGVfID0gbm9kZV87XHJcbiAgICB9XHJcbiAgICBnZXRJbW1lZGlhdGVDaGlsZChjaGlsZE5hbWUpIHtcclxuICAgICAgICBjb25zdCBjaGlsZCA9IHRoaXMubm9kZV8uZ2V0SW1tZWRpYXRlQ2hpbGQoY2hpbGROYW1lKTtcclxuICAgICAgICByZXR1cm4gbmV3IEV4aXN0aW5nVmFsdWVQcm92aWRlcihjaGlsZCk7XHJcbiAgICB9XHJcbiAgICBub2RlKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm5vZGVfO1xyXG4gICAgfVxyXG59XHJcbmNsYXNzIERlZmVycmVkVmFsdWVQcm92aWRlciB7XHJcbiAgICBjb25zdHJ1Y3RvcihzeW5jVHJlZSwgcGF0aCkge1xyXG4gICAgICAgIHRoaXMuc3luY1RyZWVfID0gc3luY1RyZWU7XHJcbiAgICAgICAgdGhpcy5wYXRoXyA9IHBhdGg7XHJcbiAgICB9XHJcbiAgICBnZXRJbW1lZGlhdGVDaGlsZChjaGlsZE5hbWUpIHtcclxuICAgICAgICBjb25zdCBjaGlsZFBhdGggPSBwYXRoQ2hpbGQodGhpcy5wYXRoXywgY2hpbGROYW1lKTtcclxuICAgICAgICByZXR1cm4gbmV3IERlZmVycmVkVmFsdWVQcm92aWRlcih0aGlzLnN5bmNUcmVlXywgY2hpbGRQYXRoKTtcclxuICAgIH1cclxuICAgIG5vZGUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHN5bmNUcmVlQ2FsY0NvbXBsZXRlRXZlbnRDYWNoZSh0aGlzLnN5bmNUcmVlXywgdGhpcy5wYXRoXyk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEdlbmVyYXRlIHBsYWNlaG9sZGVycyBmb3IgZGVmZXJyZWQgdmFsdWVzLlxyXG4gKi9cclxuY29uc3QgZ2VuZXJhdGVXaXRoVmFsdWVzID0gZnVuY3Rpb24gKHZhbHVlcykge1xyXG4gICAgdmFsdWVzID0gdmFsdWVzIHx8IHt9O1xyXG4gICAgdmFsdWVzWyd0aW1lc3RhbXAnXSA9IHZhbHVlc1sndGltZXN0YW1wJ10gfHwgbmV3IERhdGUoKS5nZXRUaW1lKCk7XHJcbiAgICByZXR1cm4gdmFsdWVzO1xyXG59O1xyXG4vKipcclxuICogVmFsdWUgdG8gdXNlIHdoZW4gZmlyaW5nIGxvY2FsIGV2ZW50cy4gV2hlbiB3cml0aW5nIHNlcnZlciB2YWx1ZXMsIGZpcmVcclxuICogbG9jYWwgZXZlbnRzIHdpdGggYW4gYXBwcm94aW1hdGUgdmFsdWUsIG90aGVyd2lzZSByZXR1cm4gdmFsdWUgYXMtaXMuXHJcbiAqL1xyXG5jb25zdCByZXNvbHZlRGVmZXJyZWRMZWFmVmFsdWUgPSBmdW5jdGlvbiAodmFsdWUsIGV4aXN0aW5nVmFsLCBzZXJ2ZXJWYWx1ZXMpIHtcclxuICAgIGlmICghdmFsdWUgfHwgdHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0Jykge1xyXG4gICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgIH1cclxuICAgIGFzc2VydCgnLnN2JyBpbiB2YWx1ZSwgJ1VuZXhwZWN0ZWQgbGVhZiBub2RlIG9yIHByaW9yaXR5IGNvbnRlbnRzJyk7XHJcbiAgICBpZiAodHlwZW9mIHZhbHVlWycuc3YnXSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICByZXR1cm4gcmVzb2x2ZVNjYWxhckRlZmVycmVkVmFsdWUodmFsdWVbJy5zdiddLCBleGlzdGluZ1ZhbCwgc2VydmVyVmFsdWVzKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZVsnLnN2J10gPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgcmV0dXJuIHJlc29sdmVDb21wbGV4RGVmZXJyZWRWYWx1ZSh2YWx1ZVsnLnN2J10sIGV4aXN0aW5nVmFsKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGFzc2VydChmYWxzZSwgJ1VuZXhwZWN0ZWQgc2VydmVyIHZhbHVlOiAnICsgSlNPTi5zdHJpbmdpZnkodmFsdWUsIG51bGwsIDIpKTtcclxuICAgIH1cclxufTtcclxuY29uc3QgcmVzb2x2ZVNjYWxhckRlZmVycmVkVmFsdWUgPSBmdW5jdGlvbiAob3AsIGV4aXN0aW5nLCBzZXJ2ZXJWYWx1ZXMpIHtcclxuICAgIHN3aXRjaCAob3ApIHtcclxuICAgICAgICBjYXNlICd0aW1lc3RhbXAnOlxyXG4gICAgICAgICAgICByZXR1cm4gc2VydmVyVmFsdWVzWyd0aW1lc3RhbXAnXTtcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICBhc3NlcnQoZmFsc2UsICdVbmV4cGVjdGVkIHNlcnZlciB2YWx1ZTogJyArIG9wKTtcclxuICAgIH1cclxufTtcclxuY29uc3QgcmVzb2x2ZUNvbXBsZXhEZWZlcnJlZFZhbHVlID0gZnVuY3Rpb24gKG9wLCBleGlzdGluZywgdW51c2VkKSB7XHJcbiAgICBpZiAoIW9wLmhhc093blByb3BlcnR5KCdpbmNyZW1lbnQnKSkge1xyXG4gICAgICAgIGFzc2VydChmYWxzZSwgJ1VuZXhwZWN0ZWQgc2VydmVyIHZhbHVlOiAnICsgSlNPTi5zdHJpbmdpZnkob3AsIG51bGwsIDIpKTtcclxuICAgIH1cclxuICAgIGNvbnN0IGRlbHRhID0gb3BbJ2luY3JlbWVudCddO1xyXG4gICAgaWYgKHR5cGVvZiBkZWx0YSAhPT0gJ251bWJlcicpIHtcclxuICAgICAgICBhc3NlcnQoZmFsc2UsICdVbmV4cGVjdGVkIGluY3JlbWVudCB2YWx1ZTogJyArIGRlbHRhKTtcclxuICAgIH1cclxuICAgIGNvbnN0IGV4aXN0aW5nTm9kZSA9IGV4aXN0aW5nLm5vZGUoKTtcclxuICAgIGFzc2VydChleGlzdGluZ05vZGUgIT09IG51bGwgJiYgdHlwZW9mIGV4aXN0aW5nTm9kZSAhPT0gJ3VuZGVmaW5lZCcsICdFeHBlY3RlZCBDaGlsZHJlbk5vZGUuRU1QVFlfTk9ERSBmb3IgbnVsbHMnKTtcclxuICAgIC8vIEluY3JlbWVudGluZyBhIG5vbi1udW1iZXIgc2V0cyB0aGUgdmFsdWUgdG8gdGhlIGluY3JlbWVudGVkIGFtb3VudFxyXG4gICAgaWYgKCFleGlzdGluZ05vZGUuaXNMZWFmTm9kZSgpKSB7XHJcbiAgICAgICAgcmV0dXJuIGRlbHRhO1xyXG4gICAgfVxyXG4gICAgY29uc3QgbGVhZiA9IGV4aXN0aW5nTm9kZTtcclxuICAgIGNvbnN0IGV4aXN0aW5nVmFsID0gbGVhZi5nZXRWYWx1ZSgpO1xyXG4gICAgaWYgKHR5cGVvZiBleGlzdGluZ1ZhbCAhPT0gJ251bWJlcicpIHtcclxuICAgICAgICByZXR1cm4gZGVsdGE7XHJcbiAgICB9XHJcbiAgICAvLyBObyBuZWVkIHRvIGRvIG92ZXIvdW5kZXJmbG93IGFyaXRobWV0aWMgaGVyZSBiZWNhdXNlIEpTIG9ubHkgaGFuZGxlcyBmbG9hdHMgdW5kZXIgdGhlIGNvdmVyc1xyXG4gICAgcmV0dXJuIGV4aXN0aW5nVmFsICsgZGVsdGE7XHJcbn07XHJcbi8qKlxyXG4gKiBSZWN1cnNpdmVseSByZXBsYWNlIGFsbCBkZWZlcnJlZCB2YWx1ZXMgYW5kIHByaW9yaXRpZXMgaW4gdGhlIHRyZWUgd2l0aCB0aGVcclxuICogc3BlY2lmaWVkIGdlbmVyYXRlZCByZXBsYWNlbWVudCB2YWx1ZXMuXHJcbiAqIEBwYXJhbSBwYXRoIC0gcGF0aCB0byB3aGljaCB3cml0ZSBpcyByZWxhdGl2ZVxyXG4gKiBAcGFyYW0gbm9kZSAtIG5ldyBkYXRhIHdyaXR0ZW4gYXQgcGF0aFxyXG4gKiBAcGFyYW0gc3luY1RyZWUgLSBjdXJyZW50IGRhdGFcclxuICovXHJcbmNvbnN0IHJlc29sdmVEZWZlcnJlZFZhbHVlVHJlZSA9IGZ1bmN0aW9uIChwYXRoLCBub2RlLCBzeW5jVHJlZSwgc2VydmVyVmFsdWVzKSB7XHJcbiAgICByZXR1cm4gcmVzb2x2ZURlZmVycmVkVmFsdWUobm9kZSwgbmV3IERlZmVycmVkVmFsdWVQcm92aWRlcihzeW5jVHJlZSwgcGF0aCksIHNlcnZlclZhbHVlcyk7XHJcbn07XHJcbi8qKlxyXG4gKiBSZWN1cnNpdmVseSByZXBsYWNlIGFsbCBkZWZlcnJlZCB2YWx1ZXMgYW5kIHByaW9yaXRpZXMgaW4gdGhlIG5vZGUgd2l0aCB0aGVcclxuICogc3BlY2lmaWVkIGdlbmVyYXRlZCByZXBsYWNlbWVudCB2YWx1ZXMuICBJZiB0aGVyZSBhcmUgbm8gc2VydmVyIHZhbHVlcyBpbiB0aGUgbm9kZSxcclxuICogaXQnbGwgYmUgcmV0dXJuZWQgYXMtaXMuXHJcbiAqL1xyXG5jb25zdCByZXNvbHZlRGVmZXJyZWRWYWx1ZVNuYXBzaG90ID0gZnVuY3Rpb24gKG5vZGUsIGV4aXN0aW5nLCBzZXJ2ZXJWYWx1ZXMpIHtcclxuICAgIHJldHVybiByZXNvbHZlRGVmZXJyZWRWYWx1ZShub2RlLCBuZXcgRXhpc3RpbmdWYWx1ZVByb3ZpZGVyKGV4aXN0aW5nKSwgc2VydmVyVmFsdWVzKTtcclxufTtcclxuZnVuY3Rpb24gcmVzb2x2ZURlZmVycmVkVmFsdWUobm9kZSwgZXhpc3RpbmdWYWwsIHNlcnZlclZhbHVlcykge1xyXG4gICAgY29uc3QgcmF3UHJpID0gbm9kZS5nZXRQcmlvcml0eSgpLnZhbCgpO1xyXG4gICAgY29uc3QgcHJpb3JpdHkgPSByZXNvbHZlRGVmZXJyZWRMZWFmVmFsdWUocmF3UHJpLCBleGlzdGluZ1ZhbC5nZXRJbW1lZGlhdGVDaGlsZCgnLnByaW9yaXR5JyksIHNlcnZlclZhbHVlcyk7XHJcbiAgICBsZXQgbmV3Tm9kZTtcclxuICAgIGlmIChub2RlLmlzTGVhZk5vZGUoKSkge1xyXG4gICAgICAgIGNvbnN0IGxlYWZOb2RlID0gbm9kZTtcclxuICAgICAgICBjb25zdCB2YWx1ZSA9IHJlc29sdmVEZWZlcnJlZExlYWZWYWx1ZShsZWFmTm9kZS5nZXRWYWx1ZSgpLCBleGlzdGluZ1ZhbCwgc2VydmVyVmFsdWVzKTtcclxuICAgICAgICBpZiAodmFsdWUgIT09IGxlYWZOb2RlLmdldFZhbHVlKCkgfHxcclxuICAgICAgICAgICAgcHJpb3JpdHkgIT09IGxlYWZOb2RlLmdldFByaW9yaXR5KCkudmFsKCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBMZWFmTm9kZSh2YWx1ZSwgbm9kZUZyb21KU09OKHByaW9yaXR5KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gbm9kZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBjb25zdCBjaGlsZHJlbk5vZGUgPSBub2RlO1xyXG4gICAgICAgIG5ld05vZGUgPSBjaGlsZHJlbk5vZGU7XHJcbiAgICAgICAgaWYgKHByaW9yaXR5ICE9PSBjaGlsZHJlbk5vZGUuZ2V0UHJpb3JpdHkoKS52YWwoKSkge1xyXG4gICAgICAgICAgICBuZXdOb2RlID0gbmV3Tm9kZS51cGRhdGVQcmlvcml0eShuZXcgTGVhZk5vZGUocHJpb3JpdHkpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2hpbGRyZW5Ob2RlLmZvckVhY2hDaGlsZChQUklPUklUWV9JTkRFWCwgKGNoaWxkTmFtZSwgY2hpbGROb2RlKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IG5ld0NoaWxkTm9kZSA9IHJlc29sdmVEZWZlcnJlZFZhbHVlKGNoaWxkTm9kZSwgZXhpc3RpbmdWYWwuZ2V0SW1tZWRpYXRlQ2hpbGQoY2hpbGROYW1lKSwgc2VydmVyVmFsdWVzKTtcclxuICAgICAgICAgICAgaWYgKG5ld0NoaWxkTm9kZSAhPT0gY2hpbGROb2RlKSB7XHJcbiAgICAgICAgICAgICAgICBuZXdOb2RlID0gbmV3Tm9kZS51cGRhdGVJbW1lZGlhdGVDaGlsZChjaGlsZE5hbWUsIG5ld0NoaWxkTm9kZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gbmV3Tm9kZTtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogQSBsaWdodC13ZWlnaHQgdHJlZSwgdHJhdmVyc2FibGUgYnkgcGF0aC4gIE5vZGVzIGNhbiBoYXZlIGJvdGggdmFsdWVzIGFuZCBjaGlsZHJlbi5cclxuICogTm9kZXMgYXJlIG5vdCBlbnVtZXJhdGVkIChieSBmb3JFYWNoQ2hpbGQpIHVubGVzcyB0aGV5IGhhdmUgYSB2YWx1ZSBvciBub24tZW1wdHlcclxuICogY2hpbGRyZW4uXHJcbiAqL1xyXG5jbGFzcyBUcmVlIHtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIG5hbWUgLSBPcHRpb25hbCBuYW1lIG9mIHRoZSBub2RlLlxyXG4gICAgICogQHBhcmFtIHBhcmVudCAtIE9wdGlvbmFsIHBhcmVudCBub2RlLlxyXG4gICAgICogQHBhcmFtIG5vZGUgLSBPcHRpb25hbCBub2RlIHRvIHdyYXAuXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKG5hbWUgPSAnJywgcGFyZW50ID0gbnVsbCwgbm9kZSA9IHsgY2hpbGRyZW46IHt9LCBjaGlsZENvdW50OiAwIH0pIHtcclxuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xyXG4gICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xyXG4gICAgICAgIHRoaXMubm9kZSA9IG5vZGU7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybnMgYSBzdWItVHJlZSBmb3IgdGhlIGdpdmVuIHBhdGguXHJcbiAqXHJcbiAqIEBwYXJhbSBwYXRoT2JqIC0gUGF0aCB0byBsb29rIHVwLlxyXG4gKiBAcmV0dXJucyBUcmVlIGZvciBwYXRoLlxyXG4gKi9cclxuZnVuY3Rpb24gdHJlZVN1YlRyZWUodHJlZSwgcGF0aE9iaikge1xyXG4gICAgLy8gVE9ETzogUmVxdWlyZSBwYXRoT2JqIHRvIGJlIFBhdGg/XHJcbiAgICBsZXQgcGF0aCA9IHBhdGhPYmogaW5zdGFuY2VvZiBQYXRoID8gcGF0aE9iaiA6IG5ldyBQYXRoKHBhdGhPYmopO1xyXG4gICAgbGV0IGNoaWxkID0gdHJlZSwgbmV4dCA9IHBhdGhHZXRGcm9udChwYXRoKTtcclxuICAgIHdoaWxlIChuZXh0ICE9PSBudWxsKSB7XHJcbiAgICAgICAgY29uc3QgY2hpbGROb2RlID0gc2FmZUdldChjaGlsZC5ub2RlLmNoaWxkcmVuLCBuZXh0KSB8fCB7XHJcbiAgICAgICAgICAgIGNoaWxkcmVuOiB7fSxcclxuICAgICAgICAgICAgY2hpbGRDb3VudDogMFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgY2hpbGQgPSBuZXcgVHJlZShuZXh0LCBjaGlsZCwgY2hpbGROb2RlKTtcclxuICAgICAgICBwYXRoID0gcGF0aFBvcEZyb250KHBhdGgpO1xyXG4gICAgICAgIG5leHQgPSBwYXRoR2V0RnJvbnQocGF0aCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gY2hpbGQ7XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybnMgdGhlIGRhdGEgYXNzb2NpYXRlZCB3aXRoIHRoaXMgdHJlZSBub2RlLlxyXG4gKlxyXG4gKiBAcmV0dXJucyBUaGUgZGF0YSBvciBudWxsIGlmIG5vIGRhdGEgZXhpc3RzLlxyXG4gKi9cclxuZnVuY3Rpb24gdHJlZUdldFZhbHVlKHRyZWUpIHtcclxuICAgIHJldHVybiB0cmVlLm5vZGUudmFsdWU7XHJcbn1cclxuLyoqXHJcbiAqIFNldHMgZGF0YSB0byB0aGlzIHRyZWUgbm9kZS5cclxuICpcclxuICogQHBhcmFtIHZhbHVlIC0gVmFsdWUgdG8gc2V0LlxyXG4gKi9cclxuZnVuY3Rpb24gdHJlZVNldFZhbHVlKHRyZWUsIHZhbHVlKSB7XHJcbiAgICB0cmVlLm5vZGUudmFsdWUgPSB2YWx1ZTtcclxuICAgIHRyZWVVcGRhdGVQYXJlbnRzKHRyZWUpO1xyXG59XHJcbi8qKlxyXG4gKiBAcmV0dXJucyBXaGV0aGVyIHRoZSB0cmVlIGhhcyBhbnkgY2hpbGRyZW4uXHJcbiAqL1xyXG5mdW5jdGlvbiB0cmVlSGFzQ2hpbGRyZW4odHJlZSkge1xyXG4gICAgcmV0dXJuIHRyZWUubm9kZS5jaGlsZENvdW50ID4gMDtcclxufVxyXG4vKipcclxuICogQHJldHVybnMgV2hldGhlIHJ0aGUgdHJlZSBpcyBlbXB0eSAobm8gdmFsdWUgb3IgY2hpbGRyZW4pLlxyXG4gKi9cclxuZnVuY3Rpb24gdHJlZUlzRW1wdHkodHJlZSkge1xyXG4gICAgcmV0dXJuIHRyZWVHZXRWYWx1ZSh0cmVlKSA9PT0gdW5kZWZpbmVkICYmICF0cmVlSGFzQ2hpbGRyZW4odHJlZSk7XHJcbn1cclxuLyoqXHJcbiAqIENhbGxzIGFjdGlvbiBmb3IgZWFjaCBjaGlsZCBvZiB0aGlzIHRyZWUgbm9kZS5cclxuICpcclxuICogQHBhcmFtIGFjdGlvbiAtIEFjdGlvbiB0byBiZSBjYWxsZWQgZm9yIGVhY2ggY2hpbGQuXHJcbiAqL1xyXG5mdW5jdGlvbiB0cmVlRm9yRWFjaENoaWxkKHRyZWUsIGFjdGlvbikge1xyXG4gICAgZWFjaCh0cmVlLm5vZGUuY2hpbGRyZW4sIChjaGlsZCwgY2hpbGRUcmVlKSA9PiB7XHJcbiAgICAgICAgYWN0aW9uKG5ldyBUcmVlKGNoaWxkLCB0cmVlLCBjaGlsZFRyZWUpKTtcclxuICAgIH0pO1xyXG59XHJcbi8qKlxyXG4gKiBEb2VzIGEgZGVwdGgtZmlyc3QgdHJhdmVyc2FsIG9mIHRoaXMgbm9kZSdzIGRlc2NlbmRhbnRzLCBjYWxsaW5nIGFjdGlvbiBmb3IgZWFjaCBvbmUuXHJcbiAqXHJcbiAqIEBwYXJhbSBhY3Rpb24gLSBBY3Rpb24gdG8gYmUgY2FsbGVkIGZvciBlYWNoIGNoaWxkLlxyXG4gKiBAcGFyYW0gaW5jbHVkZVNlbGYgLSBXaGV0aGVyIHRvIGNhbGwgYWN0aW9uIG9uIHRoaXMgbm9kZSBhcyB3ZWxsLiBEZWZhdWx0cyB0b1xyXG4gKiAgIGZhbHNlLlxyXG4gKiBAcGFyYW0gY2hpbGRyZW5GaXJzdCAtIFdoZXRoZXIgdG8gY2FsbCBhY3Rpb24gb24gY2hpbGRyZW4gYmVmb3JlIGNhbGxpbmcgaXQgb25cclxuICogICBwYXJlbnQuXHJcbiAqL1xyXG5mdW5jdGlvbiB0cmVlRm9yRWFjaERlc2NlbmRhbnQodHJlZSwgYWN0aW9uLCBpbmNsdWRlU2VsZiwgY2hpbGRyZW5GaXJzdCkge1xyXG4gICAgaWYgKGluY2x1ZGVTZWxmICYmICFjaGlsZHJlbkZpcnN0KSB7XHJcbiAgICAgICAgYWN0aW9uKHRyZWUpO1xyXG4gICAgfVxyXG4gICAgdHJlZUZvckVhY2hDaGlsZCh0cmVlLCBjaGlsZCA9PiB7XHJcbiAgICAgICAgdHJlZUZvckVhY2hEZXNjZW5kYW50KGNoaWxkLCBhY3Rpb24sIHRydWUsIGNoaWxkcmVuRmlyc3QpO1xyXG4gICAgfSk7XHJcbiAgICBpZiAoaW5jbHVkZVNlbGYgJiYgY2hpbGRyZW5GaXJzdCkge1xyXG4gICAgICAgIGFjdGlvbih0cmVlKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQ2FsbHMgYWN0aW9uIG9uIGVhY2ggYW5jZXN0b3Igbm9kZS5cclxuICpcclxuICogQHBhcmFtIGFjdGlvbiAtIEFjdGlvbiB0byBiZSBjYWxsZWQgb24gZWFjaCBwYXJlbnQ7IHJldHVyblxyXG4gKiAgIHRydWUgdG8gYWJvcnQuXHJcbiAqIEBwYXJhbSBpbmNsdWRlU2VsZiAtIFdoZXRoZXIgdG8gY2FsbCBhY3Rpb24gb24gdGhpcyBub2RlIGFzIHdlbGwuXHJcbiAqIEByZXR1cm5zIHRydWUgaWYgdGhlIGFjdGlvbiBjYWxsYmFjayByZXR1cm5lZCB0cnVlLlxyXG4gKi9cclxuZnVuY3Rpb24gdHJlZUZvckVhY2hBbmNlc3Rvcih0cmVlLCBhY3Rpb24sIGluY2x1ZGVTZWxmKSB7XHJcbiAgICBsZXQgbm9kZSA9IGluY2x1ZGVTZWxmID8gdHJlZSA6IHRyZWUucGFyZW50O1xyXG4gICAgd2hpbGUgKG5vZGUgIT09IG51bGwpIHtcclxuICAgICAgICBpZiAoYWN0aW9uKG5vZGUpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBub2RlID0gbm9kZS5wYXJlbnQ7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbn1cclxuLyoqXHJcbiAqIEByZXR1cm5zIFRoZSBwYXRoIG9mIHRoaXMgdHJlZSBub2RlLCBhcyBhIFBhdGguXHJcbiAqL1xyXG5mdW5jdGlvbiB0cmVlR2V0UGF0aCh0cmVlKSB7XHJcbiAgICByZXR1cm4gbmV3IFBhdGgodHJlZS5wYXJlbnQgPT09IG51bGxcclxuICAgICAgICA/IHRyZWUubmFtZVxyXG4gICAgICAgIDogdHJlZUdldFBhdGgodHJlZS5wYXJlbnQpICsgJy8nICsgdHJlZS5uYW1lKTtcclxufVxyXG4vKipcclxuICogQWRkcyBvciByZW1vdmVzIHRoaXMgY2hpbGQgZnJvbSBpdHMgcGFyZW50IGJhc2VkIG9uIHdoZXRoZXIgaXQncyBlbXB0eSBvciBub3QuXHJcbiAqL1xyXG5mdW5jdGlvbiB0cmVlVXBkYXRlUGFyZW50cyh0cmVlKSB7XHJcbiAgICBpZiAodHJlZS5wYXJlbnQgIT09IG51bGwpIHtcclxuICAgICAgICB0cmVlVXBkYXRlQ2hpbGQodHJlZS5wYXJlbnQsIHRyZWUubmFtZSwgdHJlZSk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEFkZHMgb3IgcmVtb3ZlcyB0aGUgcGFzc2VkIGNoaWxkIHRvIHRoaXMgdHJlZSBub2RlLCBkZXBlbmRpbmcgb24gd2hldGhlciBpdCdzIGVtcHR5LlxyXG4gKlxyXG4gKiBAcGFyYW0gY2hpbGROYW1lIC0gVGhlIG5hbWUgb2YgdGhlIGNoaWxkIHRvIHVwZGF0ZS5cclxuICogQHBhcmFtIGNoaWxkIC0gVGhlIGNoaWxkIHRvIHVwZGF0ZS5cclxuICovXHJcbmZ1bmN0aW9uIHRyZWVVcGRhdGVDaGlsZCh0cmVlLCBjaGlsZE5hbWUsIGNoaWxkKSB7XHJcbiAgICBjb25zdCBjaGlsZEVtcHR5ID0gdHJlZUlzRW1wdHkoY2hpbGQpO1xyXG4gICAgY29uc3QgY2hpbGRFeGlzdHMgPSBjb250YWlucyh0cmVlLm5vZGUuY2hpbGRyZW4sIGNoaWxkTmFtZSk7XHJcbiAgICBpZiAoY2hpbGRFbXB0eSAmJiBjaGlsZEV4aXN0cykge1xyXG4gICAgICAgIGRlbGV0ZSB0cmVlLm5vZGUuY2hpbGRyZW5bY2hpbGROYW1lXTtcclxuICAgICAgICB0cmVlLm5vZGUuY2hpbGRDb3VudC0tO1xyXG4gICAgICAgIHRyZWVVcGRhdGVQYXJlbnRzKHRyZWUpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoIWNoaWxkRW1wdHkgJiYgIWNoaWxkRXhpc3RzKSB7XHJcbiAgICAgICAgdHJlZS5ub2RlLmNoaWxkcmVuW2NoaWxkTmFtZV0gPSBjaGlsZC5ub2RlO1xyXG4gICAgICAgIHRyZWUubm9kZS5jaGlsZENvdW50Kys7XHJcbiAgICAgICAgdHJlZVVwZGF0ZVBhcmVudHModHJlZSk7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIFRydWUgZm9yIGludmFsaWQgRmlyZWJhc2Uga2V5c1xyXG4gKi9cclxuY29uc3QgSU5WQUxJRF9LRVlfUkVHRVhfID0gL1tcXFtcXF0uIyRcXC9cXHUwMDAwLVxcdTAwMUZcXHUwMDdGXS87XHJcbi8qKlxyXG4gKiBUcnVlIGZvciBpbnZhbGlkIEZpcmViYXNlIHBhdGhzLlxyXG4gKiBBbGxvd3MgJy8nIGluIHBhdGhzLlxyXG4gKi9cclxuY29uc3QgSU5WQUxJRF9QQVRIX1JFR0VYXyA9IC9bXFxbXFxdLiMkXFx1MDAwMC1cXHUwMDFGXFx1MDA3Rl0vO1xyXG4vKipcclxuICogTWF4aW11bSBudW1iZXIgb2YgY2hhcmFjdGVycyB0byBhbGxvdyBpbiBsZWFmIHZhbHVlXHJcbiAqL1xyXG5jb25zdCBNQVhfTEVBRl9TSVpFXyA9IDEwICogMTAyNCAqIDEwMjQ7XHJcbmNvbnN0IGlzVmFsaWRLZXkgPSBmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICByZXR1cm4gKHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnICYmIGtleS5sZW5ndGggIT09IDAgJiYgIUlOVkFMSURfS0VZX1JFR0VYXy50ZXN0KGtleSkpO1xyXG59O1xyXG5jb25zdCBpc1ZhbGlkUGF0aFN0cmluZyA9IGZ1bmN0aW9uIChwYXRoU3RyaW5nKSB7XHJcbiAgICByZXR1cm4gKHR5cGVvZiBwYXRoU3RyaW5nID09PSAnc3RyaW5nJyAmJlxyXG4gICAgICAgIHBhdGhTdHJpbmcubGVuZ3RoICE9PSAwICYmXHJcbiAgICAgICAgIUlOVkFMSURfUEFUSF9SRUdFWF8udGVzdChwYXRoU3RyaW5nKSk7XHJcbn07XHJcbmNvbnN0IGlzVmFsaWRSb290UGF0aFN0cmluZyA9IGZ1bmN0aW9uIChwYXRoU3RyaW5nKSB7XHJcbiAgICBpZiAocGF0aFN0cmluZykge1xyXG4gICAgICAgIC8vIEFsbG93ICcvLmluZm8vJyBhdCB0aGUgYmVnaW5uaW5nLlxyXG4gICAgICAgIHBhdGhTdHJpbmcgPSBwYXRoU3RyaW5nLnJlcGxhY2UoL15cXC8qXFwuaW5mbyhcXC98JCkvLCAnLycpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGlzVmFsaWRQYXRoU3RyaW5nKHBhdGhTdHJpbmcpO1xyXG59O1xyXG5jb25zdCBpc1ZhbGlkUHJpb3JpdHkgPSBmdW5jdGlvbiAocHJpb3JpdHkpIHtcclxuICAgIHJldHVybiAocHJpb3JpdHkgPT09IG51bGwgfHxcclxuICAgICAgICB0eXBlb2YgcHJpb3JpdHkgPT09ICdzdHJpbmcnIHx8XHJcbiAgICAgICAgKHR5cGVvZiBwcmlvcml0eSA9PT0gJ251bWJlcicgJiYgIWlzSW52YWxpZEpTT05OdW1iZXIocHJpb3JpdHkpKSB8fFxyXG4gICAgICAgIChwcmlvcml0eSAmJlxyXG4gICAgICAgICAgICB0eXBlb2YgcHJpb3JpdHkgPT09ICdvYmplY3QnICYmXHJcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XHJcbiAgICAgICAgICAgIGNvbnRhaW5zKHByaW9yaXR5LCAnLnN2JykpKTtcclxufTtcclxuLyoqXHJcbiAqIFByZS12YWxpZGF0ZSBhIGRhdHVtIHBhc3NlZCBhcyBhbiBhcmd1bWVudCB0byBGaXJlYmFzZSBmdW5jdGlvbi5cclxuICovXHJcbmNvbnN0IHZhbGlkYXRlRmlyZWJhc2VEYXRhQXJnID0gZnVuY3Rpb24gKGZuTmFtZSwgdmFsdWUsIHBhdGgsIG9wdGlvbmFsKSB7XHJcbiAgICBpZiAob3B0aW9uYWwgJiYgdmFsdWUgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIHZhbGlkYXRlRmlyZWJhc2VEYXRhKGVycm9yUHJlZml4KGZuTmFtZSwgJ3ZhbHVlJyksIHZhbHVlLCBwYXRoKTtcclxufTtcclxuLyoqXHJcbiAqIFZhbGlkYXRlIGEgZGF0YSBvYmplY3QgY2xpZW50LXNpZGUgYmVmb3JlIHNlbmRpbmcgdG8gc2VydmVyLlxyXG4gKi9cclxuY29uc3QgdmFsaWRhdGVGaXJlYmFzZURhdGEgPSBmdW5jdGlvbiAoZXJyb3JQcmVmaXgsIGRhdGEsIHBhdGhfKSB7XHJcbiAgICBjb25zdCBwYXRoID0gcGF0aF8gaW5zdGFuY2VvZiBQYXRoID8gbmV3IFZhbGlkYXRpb25QYXRoKHBhdGhfLCBlcnJvclByZWZpeCkgOiBwYXRoXztcclxuICAgIGlmIChkYXRhID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JQcmVmaXggKyAnY29udGFpbnMgdW5kZWZpbmVkICcgKyB2YWxpZGF0aW9uUGF0aFRvRXJyb3JTdHJpbmcocGF0aCkpO1xyXG4gICAgfVxyXG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yUHJlZml4ICtcclxuICAgICAgICAgICAgJ2NvbnRhaW5zIGEgZnVuY3Rpb24gJyArXHJcbiAgICAgICAgICAgIHZhbGlkYXRpb25QYXRoVG9FcnJvclN0cmluZyhwYXRoKSArXHJcbiAgICAgICAgICAgICcgd2l0aCBjb250ZW50cyA9ICcgK1xyXG4gICAgICAgICAgICBkYXRhLnRvU3RyaW5nKCkpO1xyXG4gICAgfVxyXG4gICAgaWYgKGlzSW52YWxpZEpTT05OdW1iZXIoZGF0YSkpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JQcmVmaXggK1xyXG4gICAgICAgICAgICAnY29udGFpbnMgJyArXHJcbiAgICAgICAgICAgIGRhdGEudG9TdHJpbmcoKSArXHJcbiAgICAgICAgICAgICcgJyArXHJcbiAgICAgICAgICAgIHZhbGlkYXRpb25QYXRoVG9FcnJvclN0cmluZyhwYXRoKSk7XHJcbiAgICB9XHJcbiAgICAvLyBDaGVjayBtYXggbGVhZiBzaXplLCBidXQgdHJ5IHRvIGF2b2lkIHRoZSB1dGY4IGNvbnZlcnNpb24gaWYgd2UgY2FuLlxyXG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJyAmJlxyXG4gICAgICAgIGRhdGEubGVuZ3RoID4gTUFYX0xFQUZfU0laRV8gLyAzICYmXHJcbiAgICAgICAgc3RyaW5nTGVuZ3RoKGRhdGEpID4gTUFYX0xFQUZfU0laRV8pIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JQcmVmaXggK1xyXG4gICAgICAgICAgICAnY29udGFpbnMgYSBzdHJpbmcgZ3JlYXRlciB0aGFuICcgK1xyXG4gICAgICAgICAgICBNQVhfTEVBRl9TSVpFXyArXHJcbiAgICAgICAgICAgICcgdXRmOCBieXRlcyAnICtcclxuICAgICAgICAgICAgdmFsaWRhdGlvblBhdGhUb0Vycm9yU3RyaW5nKHBhdGgpICtcclxuICAgICAgICAgICAgXCIgKCdcIiArXHJcbiAgICAgICAgICAgIGRhdGEuc3Vic3RyaW5nKDAsIDUwKSArXHJcbiAgICAgICAgICAgIFwiLi4uJylcIik7XHJcbiAgICB9XHJcbiAgICAvLyBUT0RPID0gUGVyZiA9IENvbnNpZGVyIGNvbWJpbmluZyB0aGUgcmVjdXJzaXZlIHZhbGlkYXRpb24gb2Yga2V5cyBpbnRvIE5vZGVGcm9tSlNPTlxyXG4gICAgLy8gdG8gc2F2ZSBleHRyYSB3YWxraW5nIG9mIGxhcmdlIG9iamVjdHMuXHJcbiAgICBpZiAoZGF0YSAmJiB0eXBlb2YgZGF0YSA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgICBsZXQgaGFzRG90VmFsdWUgPSBmYWxzZTtcclxuICAgICAgICBsZXQgaGFzQWN0dWFsQ2hpbGQgPSBmYWxzZTtcclxuICAgICAgICBlYWNoKGRhdGEsIChrZXksIHZhbHVlKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChrZXkgPT09ICcudmFsdWUnKSB7XHJcbiAgICAgICAgICAgICAgICBoYXNEb3RWYWx1ZSA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ICE9PSAnLnByaW9yaXR5JyAmJiBrZXkgIT09ICcuc3YnKSB7XHJcbiAgICAgICAgICAgICAgICBoYXNBY3R1YWxDaGlsZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWlzVmFsaWRLZXkoa2V5KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvclByZWZpeCArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICcgY29udGFpbnMgYW4gaW52YWxpZCBrZXkgKCcgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBrZXkgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAnKSAnICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvblBhdGhUb0Vycm9yU3RyaW5nKHBhdGgpICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgJy4gIEtleXMgbXVzdCBiZSBub24tZW1wdHkgc3RyaW5ncyAnICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgJ2FuZCBjYW5cXCd0IGNvbnRhaW4gXCIuXCIsIFwiI1wiLCBcIiRcIiwgXCIvXCIsIFwiW1wiLCBvciBcIl1cIicpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhbGlkYXRpb25QYXRoUHVzaChwYXRoLCBrZXkpO1xyXG4gICAgICAgICAgICB2YWxpZGF0ZUZpcmViYXNlRGF0YShlcnJvclByZWZpeCwgdmFsdWUsIHBhdGgpO1xyXG4gICAgICAgICAgICB2YWxpZGF0aW9uUGF0aFBvcChwYXRoKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAoaGFzRG90VmFsdWUgJiYgaGFzQWN0dWFsQ2hpbGQpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yUHJlZml4ICtcclxuICAgICAgICAgICAgICAgICcgY29udGFpbnMgXCIudmFsdWVcIiBjaGlsZCAnICtcclxuICAgICAgICAgICAgICAgIHZhbGlkYXRpb25QYXRoVG9FcnJvclN0cmluZyhwYXRoKSArXHJcbiAgICAgICAgICAgICAgICAnIGluIGFkZGl0aW9uIHRvIGFjdHVhbCBjaGlsZHJlbi4nKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcbi8qKlxyXG4gKiBQcmUtdmFsaWRhdGUgcGF0aHMgcGFzc2VkIGluIHRoZSBmaXJlYmFzZSBmdW5jdGlvbi5cclxuICovXHJcbmNvbnN0IHZhbGlkYXRlRmlyZWJhc2VNZXJnZVBhdGhzID0gZnVuY3Rpb24gKGVycm9yUHJlZml4LCBtZXJnZVBhdGhzKSB7XHJcbiAgICBsZXQgaSwgY3VyUGF0aDtcclxuICAgIGZvciAoaSA9IDA7IGkgPCBtZXJnZVBhdGhzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY3VyUGF0aCA9IG1lcmdlUGF0aHNbaV07XHJcbiAgICAgICAgY29uc3Qga2V5cyA9IHBhdGhTbGljZShjdXJQYXRoKTtcclxuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGtleXMubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgaWYgKGtleXNbal0gPT09ICcucHJpb3JpdHknICYmIGogPT09IGtleXMubGVuZ3RoIC0gMSkgO1xyXG4gICAgICAgICAgICBlbHNlIGlmICghaXNWYWxpZEtleShrZXlzW2pdKSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yUHJlZml4ICtcclxuICAgICAgICAgICAgICAgICAgICAnY29udGFpbnMgYW4gaW52YWxpZCBrZXkgKCcgK1xyXG4gICAgICAgICAgICAgICAgICAgIGtleXNbal0gK1xyXG4gICAgICAgICAgICAgICAgICAgICcpIGluIHBhdGggJyArXHJcbiAgICAgICAgICAgICAgICAgICAgY3VyUGF0aC50b1N0cmluZygpICtcclxuICAgICAgICAgICAgICAgICAgICAnLiBLZXlzIG11c3QgYmUgbm9uLWVtcHR5IHN0cmluZ3MgJyArXHJcbiAgICAgICAgICAgICAgICAgICAgJ2FuZCBjYW5cXCd0IGNvbnRhaW4gXCIuXCIsIFwiI1wiLCBcIiRcIiwgXCIvXCIsIFwiW1wiLCBvciBcIl1cIicpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gQ2hlY2sgdGhhdCB1cGRhdGUga2V5cyBhcmUgbm90IGRlc2NlbmRhbnRzIG9mIGVhY2ggb3RoZXIuXHJcbiAgICAvLyBXZSByZWx5IG9uIHRoZSBwcm9wZXJ0eSB0aGF0IHNvcnRpbmcgZ3VhcmFudGVlcyB0aGF0IGFuY2VzdG9ycyBjb21lXHJcbiAgICAvLyByaWdodCBiZWZvcmUgZGVzY2VuZGFudHMuXHJcbiAgICBtZXJnZVBhdGhzLnNvcnQocGF0aENvbXBhcmUpO1xyXG4gICAgbGV0IHByZXZQYXRoID0gbnVsbDtcclxuICAgIGZvciAoaSA9IDA7IGkgPCBtZXJnZVBhdGhzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY3VyUGF0aCA9IG1lcmdlUGF0aHNbaV07XHJcbiAgICAgICAgaWYgKHByZXZQYXRoICE9PSBudWxsICYmIHBhdGhDb250YWlucyhwcmV2UGF0aCwgY3VyUGF0aCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yUHJlZml4ICtcclxuICAgICAgICAgICAgICAgICdjb250YWlucyBhIHBhdGggJyArXHJcbiAgICAgICAgICAgICAgICBwcmV2UGF0aC50b1N0cmluZygpICtcclxuICAgICAgICAgICAgICAgICcgdGhhdCBpcyBhbmNlc3RvciBvZiBhbm90aGVyIHBhdGggJyArXHJcbiAgICAgICAgICAgICAgICBjdXJQYXRoLnRvU3RyaW5nKCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBwcmV2UGF0aCA9IGN1clBhdGg7XHJcbiAgICB9XHJcbn07XHJcbi8qKlxyXG4gKiBwcmUtdmFsaWRhdGUgYW4gb2JqZWN0IHBhc3NlZCBhcyBhbiBhcmd1bWVudCB0byBmaXJlYmFzZSBmdW5jdGlvbiAoXHJcbiAqIG11c3QgYmUgYW4gb2JqZWN0IC0gZS5nLiBmb3IgZmlyZWJhc2UudXBkYXRlKCkpLlxyXG4gKi9cclxuY29uc3QgdmFsaWRhdGVGaXJlYmFzZU1lcmdlRGF0YUFyZyA9IGZ1bmN0aW9uIChmbk5hbWUsIGRhdGEsIHBhdGgsIG9wdGlvbmFsKSB7XHJcbiAgICBpZiAob3B0aW9uYWwgJiYgZGF0YSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgY29uc3QgZXJyb3JQcmVmaXgkMSA9IGVycm9yUHJlZml4KGZuTmFtZSwgJ3ZhbHVlcycpO1xyXG4gICAgaWYgKCEoZGF0YSAmJiB0eXBlb2YgZGF0YSA9PT0gJ29iamVjdCcpIHx8IEFycmF5LmlzQXJyYXkoZGF0YSkpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JQcmVmaXgkMSArICcgbXVzdCBiZSBhbiBvYmplY3QgY29udGFpbmluZyB0aGUgY2hpbGRyZW4gdG8gcmVwbGFjZS4nKTtcclxuICAgIH1cclxuICAgIGNvbnN0IG1lcmdlUGF0aHMgPSBbXTtcclxuICAgIGVhY2goZGF0YSwgKGtleSwgdmFsdWUpID0+IHtcclxuICAgICAgICBjb25zdCBjdXJQYXRoID0gbmV3IFBhdGgoa2V5KTtcclxuICAgICAgICB2YWxpZGF0ZUZpcmViYXNlRGF0YShlcnJvclByZWZpeCQxLCB2YWx1ZSwgcGF0aENoaWxkKHBhdGgsIGN1clBhdGgpKTtcclxuICAgICAgICBpZiAocGF0aEdldEJhY2soY3VyUGF0aCkgPT09ICcucHJpb3JpdHknKSB7XHJcbiAgICAgICAgICAgIGlmICghaXNWYWxpZFByaW9yaXR5KHZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yUHJlZml4JDEgK1xyXG4gICAgICAgICAgICAgICAgICAgIFwiY29udGFpbnMgYW4gaW52YWxpZCB2YWx1ZSBmb3IgJ1wiICtcclxuICAgICAgICAgICAgICAgICAgICBjdXJQYXRoLnRvU3RyaW5nKCkgK1xyXG4gICAgICAgICAgICAgICAgICAgIFwiJywgd2hpY2ggbXVzdCBiZSBhIHZhbGlkIFwiICtcclxuICAgICAgICAgICAgICAgICAgICAnRmlyZWJhc2UgcHJpb3JpdHkgKGEgc3RyaW5nLCBmaW5pdGUgbnVtYmVyLCBzZXJ2ZXIgdmFsdWUsIG9yIG51bGwpLicpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG1lcmdlUGF0aHMucHVzaChjdXJQYXRoKTtcclxuICAgIH0pO1xyXG4gICAgdmFsaWRhdGVGaXJlYmFzZU1lcmdlUGF0aHMoZXJyb3JQcmVmaXgkMSwgbWVyZ2VQYXRocyk7XHJcbn07XHJcbmNvbnN0IHZhbGlkYXRlUHJpb3JpdHkgPSBmdW5jdGlvbiAoZm5OYW1lLCBwcmlvcml0eSwgb3B0aW9uYWwpIHtcclxuICAgIGlmIChvcHRpb25hbCAmJiBwcmlvcml0eSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgaWYgKGlzSW52YWxpZEpTT05OdW1iZXIocHJpb3JpdHkpKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yUHJlZml4KGZuTmFtZSwgJ3ByaW9yaXR5JykgK1xyXG4gICAgICAgICAgICAnaXMgJyArXHJcbiAgICAgICAgICAgIHByaW9yaXR5LnRvU3RyaW5nKCkgK1xyXG4gICAgICAgICAgICAnLCBidXQgbXVzdCBiZSBhIHZhbGlkIEZpcmViYXNlIHByaW9yaXR5IChhIHN0cmluZywgZmluaXRlIG51bWJlciwgJyArXHJcbiAgICAgICAgICAgICdzZXJ2ZXIgdmFsdWUsIG9yIG51bGwpLicpO1xyXG4gICAgfVxyXG4gICAgLy8gU3BlY2lhbCBjYXNlIHRvIGFsbG93IGltcG9ydGluZyBkYXRhIHdpdGggYSAuc3YuXHJcbiAgICBpZiAoIWlzVmFsaWRQcmlvcml0eShwcmlvcml0eSkpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JQcmVmaXgoZm5OYW1lLCAncHJpb3JpdHknKSArXHJcbiAgICAgICAgICAgICdtdXN0IGJlIGEgdmFsaWQgRmlyZWJhc2UgcHJpb3JpdHkgJyArXHJcbiAgICAgICAgICAgICcoYSBzdHJpbmcsIGZpbml0ZSBudW1iZXIsIHNlcnZlciB2YWx1ZSwgb3IgbnVsbCkuJyk7XHJcbiAgICB9XHJcbn07XHJcbmNvbnN0IHZhbGlkYXRlS2V5ID0gZnVuY3Rpb24gKGZuTmFtZSwgYXJndW1lbnROYW1lLCBrZXksIG9wdGlvbmFsKSB7XHJcbiAgICBpZiAob3B0aW9uYWwgJiYga2V5ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBpZiAoIWlzVmFsaWRLZXkoa2V5KSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvclByZWZpeChmbk5hbWUsIGFyZ3VtZW50TmFtZSkgK1xyXG4gICAgICAgICAgICAnd2FzIGFuIGludmFsaWQga2V5ID0gXCInICtcclxuICAgICAgICAgICAga2V5ICtcclxuICAgICAgICAgICAgJ1wiLiAgRmlyZWJhc2Uga2V5cyBtdXN0IGJlIG5vbi1lbXB0eSBzdHJpbmdzIGFuZCAnICtcclxuICAgICAgICAgICAgJ2NhblxcJ3QgY29udGFpbiBcIi5cIiwgXCIjXCIsIFwiJFwiLCBcIi9cIiwgXCJbXCIsIG9yIFwiXVwiKS4nKTtcclxuICAgIH1cclxufTtcclxuLyoqXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cclxuY29uc3QgdmFsaWRhdGVQYXRoU3RyaW5nID0gZnVuY3Rpb24gKGZuTmFtZSwgYXJndW1lbnROYW1lLCBwYXRoU3RyaW5nLCBvcHRpb25hbCkge1xyXG4gICAgaWYgKG9wdGlvbmFsICYmIHBhdGhTdHJpbmcgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGlmICghaXNWYWxpZFBhdGhTdHJpbmcocGF0aFN0cmluZykpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JQcmVmaXgoZm5OYW1lLCBhcmd1bWVudE5hbWUpICtcclxuICAgICAgICAgICAgJ3dhcyBhbiBpbnZhbGlkIHBhdGggPSBcIicgK1xyXG4gICAgICAgICAgICBwYXRoU3RyaW5nICtcclxuICAgICAgICAgICAgJ1wiLiBQYXRocyBtdXN0IGJlIG5vbi1lbXB0eSBzdHJpbmdzIGFuZCAnICtcclxuICAgICAgICAgICAgJ2NhblxcJ3QgY29udGFpbiBcIi5cIiwgXCIjXCIsIFwiJFwiLCBcIltcIiwgb3IgXCJdXCInKTtcclxuICAgIH1cclxufTtcclxuY29uc3QgdmFsaWRhdGVSb290UGF0aFN0cmluZyA9IGZ1bmN0aW9uIChmbk5hbWUsIGFyZ3VtZW50TmFtZSwgcGF0aFN0cmluZywgb3B0aW9uYWwpIHtcclxuICAgIGlmIChwYXRoU3RyaW5nKSB7XHJcbiAgICAgICAgLy8gQWxsb3cgJy8uaW5mby8nIGF0IHRoZSBiZWdpbm5pbmcuXHJcbiAgICAgICAgcGF0aFN0cmluZyA9IHBhdGhTdHJpbmcucmVwbGFjZSgvXlxcLypcXC5pbmZvKFxcL3wkKS8sICcvJyk7XHJcbiAgICB9XHJcbiAgICB2YWxpZGF0ZVBhdGhTdHJpbmcoZm5OYW1lLCBhcmd1bWVudE5hbWUsIHBhdGhTdHJpbmcsIG9wdGlvbmFsKTtcclxufTtcclxuLyoqXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cclxuY29uc3QgdmFsaWRhdGVXcml0YWJsZVBhdGggPSBmdW5jdGlvbiAoZm5OYW1lLCBwYXRoKSB7XHJcbiAgICBpZiAocGF0aEdldEZyb250KHBhdGgpID09PSAnLmluZm8nKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGZuTmFtZSArIFwiIGZhaWxlZCA9IENhbid0IG1vZGlmeSBkYXRhIHVuZGVyIC8uaW5mby9cIik7XHJcbiAgICB9XHJcbn07XHJcbmNvbnN0IHZhbGlkYXRlVXJsID0gZnVuY3Rpb24gKGZuTmFtZSwgcGFyc2VkVXJsKSB7XHJcbiAgICAvLyBUT0RPID0gVmFsaWRhdGUgc2VydmVyIGJldHRlci5cclxuICAgIGNvbnN0IHBhdGhTdHJpbmcgPSBwYXJzZWRVcmwucGF0aC50b1N0cmluZygpO1xyXG4gICAgaWYgKCEodHlwZW9mIHBhcnNlZFVybC5yZXBvSW5mby5ob3N0ID09PSAnc3RyaW5nJykgfHxcclxuICAgICAgICBwYXJzZWRVcmwucmVwb0luZm8uaG9zdC5sZW5ndGggPT09IDAgfHxcclxuICAgICAgICAoIWlzVmFsaWRLZXkocGFyc2VkVXJsLnJlcG9JbmZvLm5hbWVzcGFjZSkgJiZcclxuICAgICAgICAgICAgcGFyc2VkVXJsLnJlcG9JbmZvLmhvc3Quc3BsaXQoJzonKVswXSAhPT0gJ2xvY2FsaG9zdCcpIHx8XHJcbiAgICAgICAgKHBhdGhTdHJpbmcubGVuZ3RoICE9PSAwICYmICFpc1ZhbGlkUm9vdFBhdGhTdHJpbmcocGF0aFN0cmluZykpKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yUHJlZml4KGZuTmFtZSwgJ3VybCcpICtcclxuICAgICAgICAgICAgJ211c3QgYmUgYSB2YWxpZCBmaXJlYmFzZSBVUkwgYW5kICcgK1xyXG4gICAgICAgICAgICAndGhlIHBhdGggY2FuXFwndCBjb250YWluIFwiLlwiLCBcIiNcIiwgXCIkXCIsIFwiW1wiLCBvciBcIl1cIi4nKTtcclxuICAgIH1cclxufTtcblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIFRoZSBldmVudCBxdWV1ZSBzZXJ2ZXMgYSBmZXcgcHVycG9zZXM6XHJcbiAqIDEuIEl0IGVuc3VyZXMgd2UgbWFpbnRhaW4gZXZlbnQgb3JkZXIgaW4gdGhlIGZhY2Ugb2YgZXZlbnQgY2FsbGJhY2tzIGRvaW5nIG9wZXJhdGlvbnMgdGhhdCByZXN1bHQgaW4gbW9yZVxyXG4gKiAgICBldmVudHMgYmVpbmcgcXVldWVkLlxyXG4gKiAyLiByYWlzZVF1ZXVlZEV2ZW50cygpIGhhbmRsZXMgYmVpbmcgY2FsbGVkIHJlZW50cmFudGx5IG5pY2VseS4gIFRoYXQgaXMsIGlmIGluIHRoZSBjb3Vyc2Ugb2YgcmFpc2luZyBldmVudHMsXHJcbiAqICAgIHJhaXNlUXVldWVkRXZlbnRzKCkgaXMgY2FsbGVkIGFnYWluLCB0aGUgXCJpbm5lclwiIGNhbGwgd2lsbCBwaWNrIHVwIHJhaXNpbmcgZXZlbnRzIHdoZXJlIHRoZSBcIm91dGVyXCIgY2FsbFxyXG4gKiAgICBsZWZ0IG9mZiwgZW5zdXJpbmcgdGhhdCB0aGUgZXZlbnRzIGFyZSBzdGlsbCByYWlzZWQgc3luY2hyb25vdXNseSBhbmQgaW4gb3JkZXIuXHJcbiAqIDMuIFlvdSBjYW4gdXNlIHJhaXNlRXZlbnRzQXRQYXRoIGFuZCByYWlzZUV2ZW50c0ZvckNoYW5nZWRQYXRoIHRvIGVuc3VyZSBvbmx5IHJlbGV2YW50IHByZXZpb3VzbHktcXVldWVkXHJcbiAqICAgIGV2ZW50cyBhcmUgcmFpc2VkIHN5bmNocm9ub3VzbHkuXHJcbiAqXHJcbiAqIE5PVEU6IFRoaXMgY2FuIGFsbCBnbyBhd2F5IGlmL3doZW4gd2UgbW92ZSB0byBhc3luYyBldmVudHMuXHJcbiAqXHJcbiAqL1xyXG5jbGFzcyBFdmVudFF1ZXVlIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMuZXZlbnRMaXN0c18gPSBbXTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUcmFja3MgcmVjdXJzaW9uIGRlcHRoIG9mIHJhaXNlUXVldWVkRXZlbnRzXywgZm9yIGRlYnVnZ2luZyBwdXJwb3Nlcy5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnJlY3Vyc2lvbkRlcHRoXyA9IDA7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEBwYXJhbSBldmVudERhdGFMaXN0IC0gVGhlIG5ldyBldmVudHMgdG8gcXVldWUuXHJcbiAqL1xyXG5mdW5jdGlvbiBldmVudFF1ZXVlUXVldWVFdmVudHMoZXZlbnRRdWV1ZSwgZXZlbnREYXRhTGlzdCkge1xyXG4gICAgLy8gV2UgZ3JvdXAgZXZlbnRzIGJ5IHBhdGgsIHN0b3JpbmcgdGhlbSBpbiBhIHNpbmdsZSBFdmVudExpc3QsIHRvIG1ha2UgaXQgZWFzaWVyIHRvIHNraXAgb3ZlciB0aGVtIHF1aWNrbHkuXHJcbiAgICBsZXQgY3Vyckxpc3QgPSBudWxsO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBldmVudERhdGFMaXN0Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY29uc3QgZGF0YSA9IGV2ZW50RGF0YUxpc3RbaV07XHJcbiAgICAgICAgY29uc3QgcGF0aCA9IGRhdGEuZ2V0UGF0aCgpO1xyXG4gICAgICAgIGlmIChjdXJyTGlzdCAhPT0gbnVsbCAmJiAhcGF0aEVxdWFscyhwYXRoLCBjdXJyTGlzdC5wYXRoKSkge1xyXG4gICAgICAgICAgICBldmVudFF1ZXVlLmV2ZW50TGlzdHNfLnB1c2goY3Vyckxpc3QpO1xyXG4gICAgICAgICAgICBjdXJyTGlzdCA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjdXJyTGlzdCA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICBjdXJyTGlzdCA9IHsgZXZlbnRzOiBbXSwgcGF0aCB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBjdXJyTGlzdC5ldmVudHMucHVzaChkYXRhKTtcclxuICAgIH1cclxuICAgIGlmIChjdXJyTGlzdCkge1xyXG4gICAgICAgIGV2ZW50UXVldWUuZXZlbnRMaXN0c18ucHVzaChjdXJyTGlzdCk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFF1ZXVlcyB0aGUgc3BlY2lmaWVkIGV2ZW50cyBhbmQgc3luY2hyb25vdXNseSByYWlzZXMgYWxsIGV2ZW50cyAoaW5jbHVkaW5nIHByZXZpb3VzbHkgcXVldWVkIG9uZXMpXHJcbiAqIGZvciB0aGUgc3BlY2lmaWVkIHBhdGguXHJcbiAqXHJcbiAqIEl0IGlzIGFzc3VtZWQgdGhhdCB0aGUgbmV3IGV2ZW50cyBhcmUgYWxsIGZvciB0aGUgc3BlY2lmaWVkIHBhdGguXHJcbiAqXHJcbiAqIEBwYXJhbSBwYXRoIC0gVGhlIHBhdGggdG8gcmFpc2UgZXZlbnRzIGZvci5cclxuICogQHBhcmFtIGV2ZW50RGF0YUxpc3QgLSBUaGUgbmV3IGV2ZW50cyB0byByYWlzZS5cclxuICovXHJcbmZ1bmN0aW9uIGV2ZW50UXVldWVSYWlzZUV2ZW50c0F0UGF0aChldmVudFF1ZXVlLCBwYXRoLCBldmVudERhdGFMaXN0KSB7XHJcbiAgICBldmVudFF1ZXVlUXVldWVFdmVudHMoZXZlbnRRdWV1ZSwgZXZlbnREYXRhTGlzdCk7XHJcbiAgICBldmVudFF1ZXVlUmFpc2VRdWV1ZWRFdmVudHNNYXRjaGluZ1ByZWRpY2F0ZShldmVudFF1ZXVlLCBldmVudFBhdGggPT4gcGF0aEVxdWFscyhldmVudFBhdGgsIHBhdGgpKTtcclxufVxyXG4vKipcclxuICogUXVldWVzIHRoZSBzcGVjaWZpZWQgZXZlbnRzIGFuZCBzeW5jaHJvbm91c2x5IHJhaXNlcyBhbGwgZXZlbnRzIChpbmNsdWRpbmcgcHJldmlvdXNseSBxdWV1ZWQgb25lcykgZm9yXHJcbiAqIGxvY2F0aW9ucyByZWxhdGVkIHRvIHRoZSBzcGVjaWZpZWQgY2hhbmdlIHBhdGggKGkuZS4gYWxsIGFuY2VzdG9ycyBhbmQgZGVzY2VuZGFudHMpLlxyXG4gKlxyXG4gKiBJdCBpcyBhc3N1bWVkIHRoYXQgdGhlIG5ldyBldmVudHMgYXJlIGFsbCByZWxhdGVkIChhbmNlc3RvciBvciBkZXNjZW5kYW50KSB0byB0aGUgc3BlY2lmaWVkIHBhdGguXHJcbiAqXHJcbiAqIEBwYXJhbSBjaGFuZ2VkUGF0aCAtIFRoZSBwYXRoIHRvIHJhaXNlIGV2ZW50cyBmb3IuXHJcbiAqIEBwYXJhbSBldmVudERhdGFMaXN0IC0gVGhlIGV2ZW50cyB0byByYWlzZVxyXG4gKi9cclxuZnVuY3Rpb24gZXZlbnRRdWV1ZVJhaXNlRXZlbnRzRm9yQ2hhbmdlZFBhdGgoZXZlbnRRdWV1ZSwgY2hhbmdlZFBhdGgsIGV2ZW50RGF0YUxpc3QpIHtcclxuICAgIGV2ZW50UXVldWVRdWV1ZUV2ZW50cyhldmVudFF1ZXVlLCBldmVudERhdGFMaXN0KTtcclxuICAgIGV2ZW50UXVldWVSYWlzZVF1ZXVlZEV2ZW50c01hdGNoaW5nUHJlZGljYXRlKGV2ZW50UXVldWUsIGV2ZW50UGF0aCA9PiBwYXRoQ29udGFpbnMoZXZlbnRQYXRoLCBjaGFuZ2VkUGF0aCkgfHxcclxuICAgICAgICBwYXRoQ29udGFpbnMoY2hhbmdlZFBhdGgsIGV2ZW50UGF0aCkpO1xyXG59XHJcbmZ1bmN0aW9uIGV2ZW50UXVldWVSYWlzZVF1ZXVlZEV2ZW50c01hdGNoaW5nUHJlZGljYXRlKGV2ZW50UXVldWUsIHByZWRpY2F0ZSkge1xyXG4gICAgZXZlbnRRdWV1ZS5yZWN1cnNpb25EZXB0aF8rKztcclxuICAgIGxldCBzZW50QWxsID0gdHJ1ZTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZXZlbnRRdWV1ZS5ldmVudExpc3RzXy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IGV2ZW50TGlzdCA9IGV2ZW50UXVldWUuZXZlbnRMaXN0c19baV07XHJcbiAgICAgICAgaWYgKGV2ZW50TGlzdCkge1xyXG4gICAgICAgICAgICBjb25zdCBldmVudFBhdGggPSBldmVudExpc3QucGF0aDtcclxuICAgICAgICAgICAgaWYgKHByZWRpY2F0ZShldmVudFBhdGgpKSB7XHJcbiAgICAgICAgICAgICAgICBldmVudExpc3RSYWlzZShldmVudFF1ZXVlLmV2ZW50TGlzdHNfW2ldKTtcclxuICAgICAgICAgICAgICAgIGV2ZW50UXVldWUuZXZlbnRMaXN0c19baV0gPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgc2VudEFsbCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKHNlbnRBbGwpIHtcclxuICAgICAgICBldmVudFF1ZXVlLmV2ZW50TGlzdHNfID0gW107XHJcbiAgICB9XHJcbiAgICBldmVudFF1ZXVlLnJlY3Vyc2lvbkRlcHRoXy0tO1xyXG59XHJcbi8qKlxyXG4gKiBJdGVyYXRlcyB0aHJvdWdoIHRoZSBsaXN0IGFuZCByYWlzZXMgZWFjaCBldmVudFxyXG4gKi9cclxuZnVuY3Rpb24gZXZlbnRMaXN0UmFpc2UoZXZlbnRMaXN0KSB7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGV2ZW50TGlzdC5ldmVudHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjb25zdCBldmVudERhdGEgPSBldmVudExpc3QuZXZlbnRzW2ldO1xyXG4gICAgICAgIGlmIChldmVudERhdGEgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgZXZlbnRMaXN0LmV2ZW50c1tpXSA9IG51bGw7XHJcbiAgICAgICAgICAgIGNvbnN0IGV2ZW50Rm4gPSBldmVudERhdGEuZ2V0RXZlbnRSdW5uZXIoKTtcclxuICAgICAgICAgICAgaWYgKGxvZ2dlcikge1xyXG4gICAgICAgICAgICAgICAgbG9nKCdldmVudDogJyArIGV2ZW50RGF0YS50b1N0cmluZygpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBleGNlcHRpb25HdWFyZChldmVudEZuKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuY29uc3QgSU5URVJSVVBUX1JFQVNPTiA9ICdyZXBvX2ludGVycnVwdCc7XHJcbi8qKlxyXG4gKiBJZiBhIHRyYW5zYWN0aW9uIGRvZXMgbm90IHN1Y2NlZWQgYWZ0ZXIgMjUgcmV0cmllcywgd2UgYWJvcnQgaXQuIEFtb25nIG90aGVyXHJcbiAqIHRoaW5ncyB0aGlzIGVuc3VyZSB0aGF0IGlmIHRoZXJlJ3MgZXZlciBhIGJ1ZyBjYXVzaW5nIGEgbWlzbWF0Y2ggYmV0d2VlblxyXG4gKiBjbGllbnQgLyBzZXJ2ZXIgaGFzaGVzIGZvciBzb21lIGRhdGEsIHdlIHdvbid0IHJldHJ5IGluZGVmaW5pdGVseS5cclxuICovXHJcbmNvbnN0IE1BWF9UUkFOU0FDVElPTl9SRVRSSUVTID0gMjU7XHJcbi8qKlxyXG4gKiBBIGNvbm5lY3Rpb24gdG8gYSBzaW5nbGUgZGF0YSByZXBvc2l0b3J5LlxyXG4gKi9cclxuY2xhc3MgUmVwbyB7XHJcbiAgICBjb25zdHJ1Y3RvcihyZXBvSW5mb18sIGZvcmNlUmVzdENsaWVudF8sIGF1dGhUb2tlblByb3ZpZGVyXywgYXBwQ2hlY2tQcm92aWRlcl8pIHtcclxuICAgICAgICB0aGlzLnJlcG9JbmZvXyA9IHJlcG9JbmZvXztcclxuICAgICAgICB0aGlzLmZvcmNlUmVzdENsaWVudF8gPSBmb3JjZVJlc3RDbGllbnRfO1xyXG4gICAgICAgIHRoaXMuYXV0aFRva2VuUHJvdmlkZXJfID0gYXV0aFRva2VuUHJvdmlkZXJfO1xyXG4gICAgICAgIHRoaXMuYXBwQ2hlY2tQcm92aWRlcl8gPSBhcHBDaGVja1Byb3ZpZGVyXztcclxuICAgICAgICB0aGlzLmRhdGFVcGRhdGVDb3VudCA9IDA7XHJcbiAgICAgICAgdGhpcy5zdGF0c0xpc3RlbmVyXyA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5ldmVudFF1ZXVlXyA9IG5ldyBFdmVudFF1ZXVlKCk7XHJcbiAgICAgICAgdGhpcy5uZXh0V3JpdGVJZF8gPSAxO1xyXG4gICAgICAgIHRoaXMuaW50ZXJjZXB0U2VydmVyRGF0YUNhbGxiYWNrXyA9IG51bGw7XHJcbiAgICAgICAgLyoqIEEgbGlzdCBvZiBkYXRhIHBpZWNlcyBhbmQgcGF0aHMgdG8gYmUgc2V0IHdoZW4gdGhpcyBjbGllbnQgZGlzY29ubmVjdHMuICovXHJcbiAgICAgICAgdGhpcy5vbkRpc2Nvbm5lY3RfID0gbmV3U3BhcnNlU25hcHNob3RUcmVlKCk7XHJcbiAgICAgICAgLyoqIFN0b3JlcyBxdWV1ZXMgb2Ygb3V0c3RhbmRpbmcgdHJhbnNhY3Rpb25zIGZvciBGaXJlYmFzZSBsb2NhdGlvbnMuICovXHJcbiAgICAgICAgdGhpcy50cmFuc2FjdGlvblF1ZXVlVHJlZV8gPSBuZXcgVHJlZSgpO1xyXG4gICAgICAgIC8vIFRPRE86IFRoaXMgc2hvdWxkIGJlIEBwcml2YXRlIGJ1dCBpdCdzIHVzZWQgYnkgdGVzdF9hY2Nlc3MuanMgYW5kIGludGVybmFsLmpzXHJcbiAgICAgICAgdGhpcy5wZXJzaXN0ZW50Q29ubmVjdGlvbl8gPSBudWxsO1xyXG4gICAgICAgIC8vIFRoaXMga2V5IGlzIGludGVudGlvbmFsbHkgbm90IHVwZGF0ZWQgaWYgUmVwb0luZm8gaXMgbGF0ZXIgY2hhbmdlZCBvciByZXBsYWNlZFxyXG4gICAgICAgIHRoaXMua2V5ID0gdGhpcy5yZXBvSW5mb18udG9VUkxTdHJpbmcoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybnMgVGhlIFVSTCBjb3JyZXNwb25kaW5nIHRvIHRoZSByb290IG9mIHRoaXMgRmlyZWJhc2UuXHJcbiAgICAgKi9cclxuICAgIHRvU3RyaW5nKCkge1xyXG4gICAgICAgIHJldHVybiAoKHRoaXMucmVwb0luZm9fLnNlY3VyZSA/ICdodHRwczovLycgOiAnaHR0cDovLycpICsgdGhpcy5yZXBvSW5mb18uaG9zdCk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gcmVwb1N0YXJ0KHJlcG8sIGFwcElkLCBhdXRoT3ZlcnJpZGUpIHtcclxuICAgIHJlcG8uc3RhdHNfID0gc3RhdHNNYW5hZ2VyR2V0Q29sbGVjdGlvbihyZXBvLnJlcG9JbmZvXyk7XHJcbiAgICBpZiAocmVwby5mb3JjZVJlc3RDbGllbnRfIHx8IGJlaW5nQ3Jhd2xlZCgpKSB7XHJcbiAgICAgICAgcmVwby5zZXJ2ZXJfID0gbmV3IFJlYWRvbmx5UmVzdENsaWVudChyZXBvLnJlcG9JbmZvXywgKHBhdGhTdHJpbmcsIGRhdGEsIGlzTWVyZ2UsIHRhZykgPT4ge1xyXG4gICAgICAgICAgICByZXBvT25EYXRhVXBkYXRlKHJlcG8sIHBhdGhTdHJpbmcsIGRhdGEsIGlzTWVyZ2UsIHRhZyk7XHJcbiAgICAgICAgfSwgcmVwby5hdXRoVG9rZW5Qcm92aWRlcl8sIHJlcG8uYXBwQ2hlY2tQcm92aWRlcl8pO1xyXG4gICAgICAgIC8vIE1pbm9yIGhhY2s6IEZpcmUgb25Db25uZWN0IGltbWVkaWF0ZWx5LCBzaW5jZSB0aGVyZSdzIG5vIGFjdHVhbCBjb25uZWN0aW9uLlxyXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4gcmVwb09uQ29ubmVjdFN0YXR1cyhyZXBvLCAvKiBjb25uZWN0U3RhdHVzPSAqLyB0cnVlKSwgMCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICAvLyBWYWxpZGF0ZSBhdXRoT3ZlcnJpZGVcclxuICAgICAgICBpZiAodHlwZW9mIGF1dGhPdmVycmlkZSAhPT0gJ3VuZGVmaW5lZCcgJiYgYXV0aE92ZXJyaWRlICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgYXV0aE92ZXJyaWRlICE9PSAnb2JqZWN0Jykge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdPbmx5IG9iamVjdHMgYXJlIHN1cHBvcnRlZCBmb3Igb3B0aW9uIGRhdGFiYXNlQXV0aFZhcmlhYmxlT3ZlcnJpZGUnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KGF1dGhPdmVycmlkZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBhdXRoT3ZlcnJpZGUgcHJvdmlkZWQ6ICcgKyBlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXBvLnBlcnNpc3RlbnRDb25uZWN0aW9uXyA9IG5ldyBQZXJzaXN0ZW50Q29ubmVjdGlvbihyZXBvLnJlcG9JbmZvXywgYXBwSWQsIChwYXRoU3RyaW5nLCBkYXRhLCBpc01lcmdlLCB0YWcpID0+IHtcclxuICAgICAgICAgICAgcmVwb09uRGF0YVVwZGF0ZShyZXBvLCBwYXRoU3RyaW5nLCBkYXRhLCBpc01lcmdlLCB0YWcpO1xyXG4gICAgICAgIH0sIChjb25uZWN0U3RhdHVzKSA9PiB7XHJcbiAgICAgICAgICAgIHJlcG9PbkNvbm5lY3RTdGF0dXMocmVwbywgY29ubmVjdFN0YXR1cyk7XHJcbiAgICAgICAgfSwgKHVwZGF0ZXMpID0+IHtcclxuICAgICAgICAgICAgcmVwb09uU2VydmVySW5mb1VwZGF0ZShyZXBvLCB1cGRhdGVzKTtcclxuICAgICAgICB9LCByZXBvLmF1dGhUb2tlblByb3ZpZGVyXywgcmVwby5hcHBDaGVja1Byb3ZpZGVyXywgYXV0aE92ZXJyaWRlKTtcclxuICAgICAgICByZXBvLnNlcnZlcl8gPSByZXBvLnBlcnNpc3RlbnRDb25uZWN0aW9uXztcclxuICAgIH1cclxuICAgIHJlcG8uYXV0aFRva2VuUHJvdmlkZXJfLmFkZFRva2VuQ2hhbmdlTGlzdGVuZXIodG9rZW4gPT4ge1xyXG4gICAgICAgIHJlcG8uc2VydmVyXy5yZWZyZXNoQXV0aFRva2VuKHRva2VuKTtcclxuICAgIH0pO1xyXG4gICAgcmVwby5hcHBDaGVja1Byb3ZpZGVyXy5hZGRUb2tlbkNoYW5nZUxpc3RlbmVyKHJlc3VsdCA9PiB7XHJcbiAgICAgICAgcmVwby5zZXJ2ZXJfLnJlZnJlc2hBcHBDaGVja1Rva2VuKHJlc3VsdC50b2tlbik7XHJcbiAgICB9KTtcclxuICAgIC8vIEluIHRoZSBjYXNlIG9mIG11bHRpcGxlIFJlcG9zIGZvciB0aGUgc2FtZSByZXBvSW5mbyAoaS5lLiB0aGVyZSBhcmUgbXVsdGlwbGUgRmlyZWJhc2UuQ29udGV4dHMgYmVpbmcgdXNlZCksXHJcbiAgICAvLyB3ZSBvbmx5IHdhbnQgdG8gY3JlYXRlIG9uZSBTdGF0c1JlcG9ydGVyLiAgQXMgc3VjaCwgd2UnbGwgcmVwb3J0IHN0YXRzIG92ZXIgdGhlIGZpcnN0IFJlcG8gY3JlYXRlZC5cclxuICAgIHJlcG8uc3RhdHNSZXBvcnRlcl8gPSBzdGF0c01hbmFnZXJHZXRPckNyZWF0ZVJlcG9ydGVyKHJlcG8ucmVwb0luZm9fLCAoKSA9PiBuZXcgU3RhdHNSZXBvcnRlcihyZXBvLnN0YXRzXywgcmVwby5zZXJ2ZXJfKSk7XHJcbiAgICAvLyBVc2VkIGZvciAuaW5mby5cclxuICAgIHJlcG8uaW5mb0RhdGFfID0gbmV3IFNuYXBzaG90SG9sZGVyKCk7XHJcbiAgICByZXBvLmluZm9TeW5jVHJlZV8gPSBuZXcgU3luY1RyZWUoe1xyXG4gICAgICAgIHN0YXJ0TGlzdGVuaW5nOiAocXVlcnksIHRhZywgY3VycmVudEhhc2hGbiwgb25Db21wbGV0ZSkgPT4ge1xyXG4gICAgICAgICAgICBsZXQgaW5mb0V2ZW50cyA9IFtdO1xyXG4gICAgICAgICAgICBjb25zdCBub2RlID0gcmVwby5pbmZvRGF0YV8uZ2V0Tm9kZShxdWVyeS5fcGF0aCk7XHJcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgcG9zc2libHkgYSBoYWNrLCBidXQgd2UgaGF2ZSBkaWZmZXJlbnQgc2VtYW50aWNzIGZvciAuaW5mbyBlbmRwb2ludHMuIFdlIGRvbid0IHJhaXNlIG51bGwgZXZlbnRzXHJcbiAgICAgICAgICAgIC8vIG9uIGluaXRpYWwgZGF0YS4uLlxyXG4gICAgICAgICAgICBpZiAoIW5vZGUuaXNFbXB0eSgpKSB7XHJcbiAgICAgICAgICAgICAgICBpbmZvRXZlbnRzID0gc3luY1RyZWVBcHBseVNlcnZlck92ZXJ3cml0ZShyZXBvLmluZm9TeW5jVHJlZV8sIHF1ZXJ5Ll9wYXRoLCBub2RlKTtcclxuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIG9uQ29tcGxldGUoJ29rJyk7XHJcbiAgICAgICAgICAgICAgICB9LCAwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gaW5mb0V2ZW50cztcclxuICAgICAgICB9LFxyXG4gICAgICAgIHN0b3BMaXN0ZW5pbmc6ICgpID0+IHsgfVxyXG4gICAgfSk7XHJcbiAgICByZXBvVXBkYXRlSW5mbyhyZXBvLCAnY29ubmVjdGVkJywgZmFsc2UpO1xyXG4gICAgcmVwby5zZXJ2ZXJTeW5jVHJlZV8gPSBuZXcgU3luY1RyZWUoe1xyXG4gICAgICAgIHN0YXJ0TGlzdGVuaW5nOiAocXVlcnksIHRhZywgY3VycmVudEhhc2hGbiwgb25Db21wbGV0ZSkgPT4ge1xyXG4gICAgICAgICAgICByZXBvLnNlcnZlcl8ubGlzdGVuKHF1ZXJ5LCBjdXJyZW50SGFzaEZuLCB0YWcsIChzdGF0dXMsIGRhdGEpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGV2ZW50cyA9IG9uQ29tcGxldGUoc3RhdHVzLCBkYXRhKTtcclxuICAgICAgICAgICAgICAgIGV2ZW50UXVldWVSYWlzZUV2ZW50c0ZvckNoYW5nZWRQYXRoKHJlcG8uZXZlbnRRdWV1ZV8sIHF1ZXJ5Ll9wYXRoLCBldmVudHMpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgLy8gTm8gc3luY2hyb25vdXMgZXZlbnRzIGZvciBuZXR3b3JrLWJhY2tlZCBzeW5jIHRyZWVzXHJcbiAgICAgICAgICAgIHJldHVybiBbXTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHN0b3BMaXN0ZW5pbmc6IChxdWVyeSwgdGFnKSA9PiB7XHJcbiAgICAgICAgICAgIHJlcG8uc2VydmVyXy51bmxpc3RlbihxdWVyeSwgdGFnKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxufVxyXG4vKipcclxuICogQHJldHVybnMgVGhlIHRpbWUgaW4gbWlsbGlzZWNvbmRzLCB0YWtpbmcgdGhlIHNlcnZlciBvZmZzZXQgaW50byBhY2NvdW50IGlmIHdlIGhhdmUgb25lLlxyXG4gKi9cclxuZnVuY3Rpb24gcmVwb1NlcnZlclRpbWUocmVwbykge1xyXG4gICAgY29uc3Qgb2Zmc2V0Tm9kZSA9IHJlcG8uaW5mb0RhdGFfLmdldE5vZGUobmV3IFBhdGgoJy5pbmZvL3NlcnZlclRpbWVPZmZzZXQnKSk7XHJcbiAgICBjb25zdCBvZmZzZXQgPSBvZmZzZXROb2RlLnZhbCgpIHx8IDA7XHJcbiAgICByZXR1cm4gbmV3IERhdGUoKS5nZXRUaW1lKCkgKyBvZmZzZXQ7XHJcbn1cclxuLyoqXHJcbiAqIEdlbmVyYXRlIFNlcnZlclZhbHVlcyB1c2luZyBzb21lIHZhcmlhYmxlcyBmcm9tIHRoZSByZXBvIG9iamVjdC5cclxuICovXHJcbmZ1bmN0aW9uIHJlcG9HZW5lcmF0ZVNlcnZlclZhbHVlcyhyZXBvKSB7XHJcbiAgICByZXR1cm4gZ2VuZXJhdGVXaXRoVmFsdWVzKHtcclxuICAgICAgICB0aW1lc3RhbXA6IHJlcG9TZXJ2ZXJUaW1lKHJlcG8pXHJcbiAgICB9KTtcclxufVxyXG4vKipcclxuICogQ2FsbGVkIGJ5IHJlYWx0aW1lIHdoZW4gd2UgZ2V0IG5ldyBtZXNzYWdlcyBmcm9tIHRoZSBzZXJ2ZXIuXHJcbiAqL1xyXG5mdW5jdGlvbiByZXBvT25EYXRhVXBkYXRlKHJlcG8sIHBhdGhTdHJpbmcsIGRhdGEsIGlzTWVyZ2UsIHRhZykge1xyXG4gICAgLy8gRm9yIHRlc3RpbmcuXHJcbiAgICByZXBvLmRhdGFVcGRhdGVDb3VudCsrO1xyXG4gICAgY29uc3QgcGF0aCA9IG5ldyBQYXRoKHBhdGhTdHJpbmcpO1xyXG4gICAgZGF0YSA9IHJlcG8uaW50ZXJjZXB0U2VydmVyRGF0YUNhbGxiYWNrX1xyXG4gICAgICAgID8gcmVwby5pbnRlcmNlcHRTZXJ2ZXJEYXRhQ2FsbGJhY2tfKHBhdGhTdHJpbmcsIGRhdGEpXHJcbiAgICAgICAgOiBkYXRhO1xyXG4gICAgbGV0IGV2ZW50cyA9IFtdO1xyXG4gICAgaWYgKHRhZykge1xyXG4gICAgICAgIGlmIChpc01lcmdlKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHRhZ2dlZENoaWxkcmVuID0gbWFwKGRhdGEsIChyYXcpID0+IG5vZGVGcm9tSlNPTihyYXcpKTtcclxuICAgICAgICAgICAgZXZlbnRzID0gc3luY1RyZWVBcHBseVRhZ2dlZFF1ZXJ5TWVyZ2UocmVwby5zZXJ2ZXJTeW5jVHJlZV8sIHBhdGgsIHRhZ2dlZENoaWxkcmVuLCB0YWcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3QgdGFnZ2VkU25hcCA9IG5vZGVGcm9tSlNPTihkYXRhKTtcclxuICAgICAgICAgICAgZXZlbnRzID0gc3luY1RyZWVBcHBseVRhZ2dlZFF1ZXJ5T3ZlcndyaXRlKHJlcG8uc2VydmVyU3luY1RyZWVfLCBwYXRoLCB0YWdnZWRTbmFwLCB0YWcpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGlzTWVyZ2UpIHtcclxuICAgICAgICBjb25zdCBjaGFuZ2VkQ2hpbGRyZW4gPSBtYXAoZGF0YSwgKHJhdykgPT4gbm9kZUZyb21KU09OKHJhdykpO1xyXG4gICAgICAgIGV2ZW50cyA9IHN5bmNUcmVlQXBwbHlTZXJ2ZXJNZXJnZShyZXBvLnNlcnZlclN5bmNUcmVlXywgcGF0aCwgY2hhbmdlZENoaWxkcmVuKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGNvbnN0IHNuYXAgPSBub2RlRnJvbUpTT04oZGF0YSk7XHJcbiAgICAgICAgZXZlbnRzID0gc3luY1RyZWVBcHBseVNlcnZlck92ZXJ3cml0ZShyZXBvLnNlcnZlclN5bmNUcmVlXywgcGF0aCwgc25hcCk7XHJcbiAgICB9XHJcbiAgICBsZXQgYWZmZWN0ZWRQYXRoID0gcGF0aDtcclxuICAgIGlmIChldmVudHMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgIC8vIFNpbmNlIHdlIGhhdmUgYSBsaXN0ZW5lciBvdXRzdGFuZGluZyBmb3IgZWFjaCB0cmFuc2FjdGlvbiwgcmVjZWl2aW5nIGFueSBldmVudHNcclxuICAgICAgICAvLyBpcyBhIHByb3h5IGZvciBzb21lIGNoYW5nZSBoYXZpbmcgb2NjdXJyZWQuXHJcbiAgICAgICAgYWZmZWN0ZWRQYXRoID0gcmVwb1JlcnVuVHJhbnNhY3Rpb25zKHJlcG8sIHBhdGgpO1xyXG4gICAgfVxyXG4gICAgZXZlbnRRdWV1ZVJhaXNlRXZlbnRzRm9yQ2hhbmdlZFBhdGgocmVwby5ldmVudFF1ZXVlXywgYWZmZWN0ZWRQYXRoLCBldmVudHMpO1xyXG59XHJcbmZ1bmN0aW9uIHJlcG9PbkNvbm5lY3RTdGF0dXMocmVwbywgY29ubmVjdFN0YXR1cykge1xyXG4gICAgcmVwb1VwZGF0ZUluZm8ocmVwbywgJ2Nvbm5lY3RlZCcsIGNvbm5lY3RTdGF0dXMpO1xyXG4gICAgaWYgKGNvbm5lY3RTdGF0dXMgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgcmVwb1J1bk9uRGlzY29ubmVjdEV2ZW50cyhyZXBvKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiByZXBvT25TZXJ2ZXJJbmZvVXBkYXRlKHJlcG8sIHVwZGF0ZXMpIHtcclxuICAgIGVhY2godXBkYXRlcywgKGtleSwgdmFsdWUpID0+IHtcclxuICAgICAgICByZXBvVXBkYXRlSW5mbyhyZXBvLCBrZXksIHZhbHVlKTtcclxuICAgIH0pO1xyXG59XHJcbmZ1bmN0aW9uIHJlcG9VcGRhdGVJbmZvKHJlcG8sIHBhdGhTdHJpbmcsIHZhbHVlKSB7XHJcbiAgICBjb25zdCBwYXRoID0gbmV3IFBhdGgoJy8uaW5mby8nICsgcGF0aFN0cmluZyk7XHJcbiAgICBjb25zdCBuZXdOb2RlID0gbm9kZUZyb21KU09OKHZhbHVlKTtcclxuICAgIHJlcG8uaW5mb0RhdGFfLnVwZGF0ZVNuYXBzaG90KHBhdGgsIG5ld05vZGUpO1xyXG4gICAgY29uc3QgZXZlbnRzID0gc3luY1RyZWVBcHBseVNlcnZlck92ZXJ3cml0ZShyZXBvLmluZm9TeW5jVHJlZV8sIHBhdGgsIG5ld05vZGUpO1xyXG4gICAgZXZlbnRRdWV1ZVJhaXNlRXZlbnRzRm9yQ2hhbmdlZFBhdGgocmVwby5ldmVudFF1ZXVlXywgcGF0aCwgZXZlbnRzKTtcclxufVxyXG5mdW5jdGlvbiByZXBvR2V0TmV4dFdyaXRlSWQocmVwbykge1xyXG4gICAgcmV0dXJuIHJlcG8ubmV4dFdyaXRlSWRfKys7XHJcbn1cclxuLyoqXHJcbiAqIFRoZSBwdXJwb3NlIG9mIGBnZXRWYWx1ZWAgaXMgdG8gcmV0dXJuIHRoZSBsYXRlc3Qga25vd24gdmFsdWVcclxuICogc2F0aXNmeWluZyBgcXVlcnlgLlxyXG4gKlxyXG4gKiBUaGlzIG1ldGhvZCB3aWxsIGZpcnN0IGNoZWNrIGZvciBpbi1tZW1vcnkgY2FjaGVkIHZhbHVlc1xyXG4gKiBiZWxvbmdpbmcgdG8gYWN0aXZlIGxpc3RlbmVycy4gSWYgdGhleSBhcmUgZm91bmQsIHN1Y2ggdmFsdWVzXHJcbiAqIGFyZSBjb25zaWRlcmVkIHRvIGJlIHRoZSBtb3N0IHVwLXRvLWRhdGUuXHJcbiAqXHJcbiAqIElmIHRoZSBjbGllbnQgaXMgbm90IGNvbm5lY3RlZCwgdGhpcyBtZXRob2Qgd2lsbCB0cnkgdG9cclxuICogZXN0YWJsaXNoIGEgY29ubmVjdGlvbiBhbmQgcmVxdWVzdCB0aGUgdmFsdWUgZm9yIGBxdWVyeWAuIElmXHJcbiAqIHRoZSBjbGllbnQgaXMgbm90IGFibGUgdG8gcmV0cmlldmUgdGhlIHF1ZXJ5IHJlc3VsdCwgaXQgcmVwb3J0c1xyXG4gKiBhbiBlcnJvci5cclxuICpcclxuICogQHBhcmFtIHF1ZXJ5IC0gVGhlIHF1ZXJ5IHRvIHN1cmZhY2UgYSB2YWx1ZSBmb3IuXHJcbiAqL1xyXG5mdW5jdGlvbiByZXBvR2V0VmFsdWUocmVwbywgcXVlcnkpIHtcclxuICAgIC8vIE9ubHkgYWN0aXZlIHF1ZXJpZXMgYXJlIGNhY2hlZC4gVGhlcmUgaXMgbm8gcGVyc2lzdGVkIGNhY2hlLlxyXG4gICAgY29uc3QgY2FjaGVkID0gc3luY1RyZWVHZXRTZXJ2ZXJWYWx1ZShyZXBvLnNlcnZlclN5bmNUcmVlXywgcXVlcnkpO1xyXG4gICAgaWYgKGNhY2hlZCAhPSBudWxsKSB7XHJcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShjYWNoZWQpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlcG8uc2VydmVyXy5nZXQocXVlcnkpLnRoZW4ocGF5bG9hZCA9PiB7XHJcbiAgICAgICAgY29uc3Qgbm9kZSA9IG5vZGVGcm9tSlNPTihwYXlsb2FkKS53aXRoSW5kZXgocXVlcnkuX3F1ZXJ5UGFyYW1zLmdldEluZGV4KCkpO1xyXG4gICAgICAgIGNvbnN0IGV2ZW50cyA9IHN5bmNUcmVlQXBwbHlTZXJ2ZXJPdmVyd3JpdGUocmVwby5zZXJ2ZXJTeW5jVHJlZV8sIHF1ZXJ5Ll9wYXRoLCBub2RlKTtcclxuICAgICAgICBldmVudFF1ZXVlUmFpc2VFdmVudHNBdFBhdGgocmVwby5ldmVudFF1ZXVlXywgcXVlcnkuX3BhdGgsIGV2ZW50cyk7XHJcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShub2RlKTtcclxuICAgIH0sIGVyciA9PiB7XHJcbiAgICAgICAgcmVwb0xvZyhyZXBvLCAnZ2V0IGZvciBxdWVyeSAnICsgc3RyaW5naWZ5KHF1ZXJ5KSArICcgZmFpbGVkOiAnICsgZXJyKTtcclxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKGVycikpO1xyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gcmVwb1NldFdpdGhQcmlvcml0eShyZXBvLCBwYXRoLCBuZXdWYWwsIG5ld1ByaW9yaXR5LCBvbkNvbXBsZXRlKSB7XHJcbiAgICByZXBvTG9nKHJlcG8sICdzZXQnLCB7XHJcbiAgICAgICAgcGF0aDogcGF0aC50b1N0cmluZygpLFxyXG4gICAgICAgIHZhbHVlOiBuZXdWYWwsXHJcbiAgICAgICAgcHJpb3JpdHk6IG5ld1ByaW9yaXR5XHJcbiAgICB9KTtcclxuICAgIC8vIFRPRE86IE9wdGltaXplIHRoaXMgYmVoYXZpb3IgdG8gZWl0aGVyIChhKSBzdG9yZSBmbGFnIHRvIHNraXAgcmVzb2x2aW5nIHdoZXJlIHBvc3NpYmxlIGFuZCAvIG9yXHJcbiAgICAvLyAoYikgc3RvcmUgdW5yZXNvbHZlZCBwYXRocyBvbiBKU09OIHBhcnNlXHJcbiAgICBjb25zdCBzZXJ2ZXJWYWx1ZXMgPSByZXBvR2VuZXJhdGVTZXJ2ZXJWYWx1ZXMocmVwbyk7XHJcbiAgICBjb25zdCBuZXdOb2RlVW5yZXNvbHZlZCA9IG5vZGVGcm9tSlNPTihuZXdWYWwsIG5ld1ByaW9yaXR5KTtcclxuICAgIGNvbnN0IGV4aXN0aW5nID0gc3luY1RyZWVDYWxjQ29tcGxldGVFdmVudENhY2hlKHJlcG8uc2VydmVyU3luY1RyZWVfLCBwYXRoKTtcclxuICAgIGNvbnN0IG5ld05vZGUgPSByZXNvbHZlRGVmZXJyZWRWYWx1ZVNuYXBzaG90KG5ld05vZGVVbnJlc29sdmVkLCBleGlzdGluZywgc2VydmVyVmFsdWVzKTtcclxuICAgIGNvbnN0IHdyaXRlSWQgPSByZXBvR2V0TmV4dFdyaXRlSWQocmVwbyk7XHJcbiAgICBjb25zdCBldmVudHMgPSBzeW5jVHJlZUFwcGx5VXNlck92ZXJ3cml0ZShyZXBvLnNlcnZlclN5bmNUcmVlXywgcGF0aCwgbmV3Tm9kZSwgd3JpdGVJZCwgdHJ1ZSk7XHJcbiAgICBldmVudFF1ZXVlUXVldWVFdmVudHMocmVwby5ldmVudFF1ZXVlXywgZXZlbnRzKTtcclxuICAgIHJlcG8uc2VydmVyXy5wdXQocGF0aC50b1N0cmluZygpLCBuZXdOb2RlVW5yZXNvbHZlZC52YWwoLypleHBvcnQ9Ki8gdHJ1ZSksIChzdGF0dXMsIGVycm9yUmVhc29uKSA9PiB7XHJcbiAgICAgICAgY29uc3Qgc3VjY2VzcyA9IHN0YXR1cyA9PT0gJ29rJztcclxuICAgICAgICBpZiAoIXN1Y2Nlc3MpIHtcclxuICAgICAgICAgICAgd2Fybignc2V0IGF0ICcgKyBwYXRoICsgJyBmYWlsZWQ6ICcgKyBzdGF0dXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBjbGVhckV2ZW50cyA9IHN5bmNUcmVlQWNrVXNlcldyaXRlKHJlcG8uc2VydmVyU3luY1RyZWVfLCB3cml0ZUlkLCAhc3VjY2Vzcyk7XHJcbiAgICAgICAgZXZlbnRRdWV1ZVJhaXNlRXZlbnRzRm9yQ2hhbmdlZFBhdGgocmVwby5ldmVudFF1ZXVlXywgcGF0aCwgY2xlYXJFdmVudHMpO1xyXG4gICAgICAgIHJlcG9DYWxsT25Db21wbGV0ZUNhbGxiYWNrKHJlcG8sIG9uQ29tcGxldGUsIHN0YXR1cywgZXJyb3JSZWFzb24pO1xyXG4gICAgfSk7XHJcbiAgICBjb25zdCBhZmZlY3RlZFBhdGggPSByZXBvQWJvcnRUcmFuc2FjdGlvbnMocmVwbywgcGF0aCk7XHJcbiAgICByZXBvUmVydW5UcmFuc2FjdGlvbnMocmVwbywgYWZmZWN0ZWRQYXRoKTtcclxuICAgIC8vIFdlIHF1ZXVlZCB0aGUgZXZlbnRzIGFib3ZlLCBzbyBqdXN0IGZsdXNoIHRoZSBxdWV1ZSBoZXJlXHJcbiAgICBldmVudFF1ZXVlUmFpc2VFdmVudHNGb3JDaGFuZ2VkUGF0aChyZXBvLmV2ZW50UXVldWVfLCBhZmZlY3RlZFBhdGgsIFtdKTtcclxufVxyXG5mdW5jdGlvbiByZXBvVXBkYXRlKHJlcG8sIHBhdGgsIGNoaWxkcmVuVG9NZXJnZSwgb25Db21wbGV0ZSkge1xyXG4gICAgcmVwb0xvZyhyZXBvLCAndXBkYXRlJywgeyBwYXRoOiBwYXRoLnRvU3RyaW5nKCksIHZhbHVlOiBjaGlsZHJlblRvTWVyZ2UgfSk7XHJcbiAgICAvLyBTdGFydCB3aXRoIG91ciBleGlzdGluZyBkYXRhIGFuZCBtZXJnZSBlYWNoIGNoaWxkIGludG8gaXQuXHJcbiAgICBsZXQgZW1wdHkgPSB0cnVlO1xyXG4gICAgY29uc3Qgc2VydmVyVmFsdWVzID0gcmVwb0dlbmVyYXRlU2VydmVyVmFsdWVzKHJlcG8pO1xyXG4gICAgY29uc3QgY2hhbmdlZENoaWxkcmVuID0ge307XHJcbiAgICBlYWNoKGNoaWxkcmVuVG9NZXJnZSwgKGNoYW5nZWRLZXksIGNoYW5nZWRWYWx1ZSkgPT4ge1xyXG4gICAgICAgIGVtcHR5ID0gZmFsc2U7XHJcbiAgICAgICAgY2hhbmdlZENoaWxkcmVuW2NoYW5nZWRLZXldID0gcmVzb2x2ZURlZmVycmVkVmFsdWVUcmVlKHBhdGhDaGlsZChwYXRoLCBjaGFuZ2VkS2V5KSwgbm9kZUZyb21KU09OKGNoYW5nZWRWYWx1ZSksIHJlcG8uc2VydmVyU3luY1RyZWVfLCBzZXJ2ZXJWYWx1ZXMpO1xyXG4gICAgfSk7XHJcbiAgICBpZiAoIWVtcHR5KSB7XHJcbiAgICAgICAgY29uc3Qgd3JpdGVJZCA9IHJlcG9HZXROZXh0V3JpdGVJZChyZXBvKTtcclxuICAgICAgICBjb25zdCBldmVudHMgPSBzeW5jVHJlZUFwcGx5VXNlck1lcmdlKHJlcG8uc2VydmVyU3luY1RyZWVfLCBwYXRoLCBjaGFuZ2VkQ2hpbGRyZW4sIHdyaXRlSWQpO1xyXG4gICAgICAgIGV2ZW50UXVldWVRdWV1ZUV2ZW50cyhyZXBvLmV2ZW50UXVldWVfLCBldmVudHMpO1xyXG4gICAgICAgIHJlcG8uc2VydmVyXy5tZXJnZShwYXRoLnRvU3RyaW5nKCksIGNoaWxkcmVuVG9NZXJnZSwgKHN0YXR1cywgZXJyb3JSZWFzb24pID0+IHtcclxuICAgICAgICAgICAgY29uc3Qgc3VjY2VzcyA9IHN0YXR1cyA9PT0gJ29rJztcclxuICAgICAgICAgICAgaWYgKCFzdWNjZXNzKSB7XHJcbiAgICAgICAgICAgICAgICB3YXJuKCd1cGRhdGUgYXQgJyArIHBhdGggKyAnIGZhaWxlZDogJyArIHN0YXR1cyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgY2xlYXJFdmVudHMgPSBzeW5jVHJlZUFja1VzZXJXcml0ZShyZXBvLnNlcnZlclN5bmNUcmVlXywgd3JpdGVJZCwgIXN1Y2Nlc3MpO1xyXG4gICAgICAgICAgICBjb25zdCBhZmZlY3RlZFBhdGggPSBjbGVhckV2ZW50cy5sZW5ndGggPiAwID8gcmVwb1JlcnVuVHJhbnNhY3Rpb25zKHJlcG8sIHBhdGgpIDogcGF0aDtcclxuICAgICAgICAgICAgZXZlbnRRdWV1ZVJhaXNlRXZlbnRzRm9yQ2hhbmdlZFBhdGgocmVwby5ldmVudFF1ZXVlXywgYWZmZWN0ZWRQYXRoLCBjbGVhckV2ZW50cyk7XHJcbiAgICAgICAgICAgIHJlcG9DYWxsT25Db21wbGV0ZUNhbGxiYWNrKHJlcG8sIG9uQ29tcGxldGUsIHN0YXR1cywgZXJyb3JSZWFzb24pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGVhY2goY2hpbGRyZW5Ub01lcmdlLCAoY2hhbmdlZFBhdGgpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgYWZmZWN0ZWRQYXRoID0gcmVwb0Fib3J0VHJhbnNhY3Rpb25zKHJlcG8sIHBhdGhDaGlsZChwYXRoLCBjaGFuZ2VkUGF0aCkpO1xyXG4gICAgICAgICAgICByZXBvUmVydW5UcmFuc2FjdGlvbnMocmVwbywgYWZmZWN0ZWRQYXRoKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICAvLyBXZSBxdWV1ZWQgdGhlIGV2ZW50cyBhYm92ZSwgc28ganVzdCBmbHVzaCB0aGUgcXVldWUgaGVyZVxyXG4gICAgICAgIGV2ZW50UXVldWVSYWlzZUV2ZW50c0ZvckNoYW5nZWRQYXRoKHJlcG8uZXZlbnRRdWV1ZV8sIHBhdGgsIFtdKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGxvZyhcInVwZGF0ZSgpIGNhbGxlZCB3aXRoIGVtcHR5IGRhdGEuICBEb24ndCBkbyBhbnl0aGluZy5cIik7XHJcbiAgICAgICAgcmVwb0NhbGxPbkNvbXBsZXRlQ2FsbGJhY2socmVwbywgb25Db21wbGV0ZSwgJ29rJywgdW5kZWZpbmVkKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQXBwbGllcyBhbGwgb2YgdGhlIGNoYW5nZXMgc3RvcmVkIHVwIGluIHRoZSBvbkRpc2Nvbm5lY3RfIHRyZWUuXHJcbiAqL1xyXG5mdW5jdGlvbiByZXBvUnVuT25EaXNjb25uZWN0RXZlbnRzKHJlcG8pIHtcclxuICAgIHJlcG9Mb2cocmVwbywgJ29uRGlzY29ubmVjdEV2ZW50cycpO1xyXG4gICAgY29uc3Qgc2VydmVyVmFsdWVzID0gcmVwb0dlbmVyYXRlU2VydmVyVmFsdWVzKHJlcG8pO1xyXG4gICAgY29uc3QgcmVzb2x2ZWRPbkRpc2Nvbm5lY3RUcmVlID0gbmV3U3BhcnNlU25hcHNob3RUcmVlKCk7XHJcbiAgICBzcGFyc2VTbmFwc2hvdFRyZWVGb3JFYWNoVHJlZShyZXBvLm9uRGlzY29ubmVjdF8sIG5ld0VtcHR5UGF0aCgpLCAocGF0aCwgbm9kZSkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHJlc29sdmVkID0gcmVzb2x2ZURlZmVycmVkVmFsdWVUcmVlKHBhdGgsIG5vZGUsIHJlcG8uc2VydmVyU3luY1RyZWVfLCBzZXJ2ZXJWYWx1ZXMpO1xyXG4gICAgICAgIHNwYXJzZVNuYXBzaG90VHJlZVJlbWVtYmVyKHJlc29sdmVkT25EaXNjb25uZWN0VHJlZSwgcGF0aCwgcmVzb2x2ZWQpO1xyXG4gICAgfSk7XHJcbiAgICBsZXQgZXZlbnRzID0gW107XHJcbiAgICBzcGFyc2VTbmFwc2hvdFRyZWVGb3JFYWNoVHJlZShyZXNvbHZlZE9uRGlzY29ubmVjdFRyZWUsIG5ld0VtcHR5UGF0aCgpLCAocGF0aCwgc25hcCkgPT4ge1xyXG4gICAgICAgIGV2ZW50cyA9IGV2ZW50cy5jb25jYXQoc3luY1RyZWVBcHBseVNlcnZlck92ZXJ3cml0ZShyZXBvLnNlcnZlclN5bmNUcmVlXywgcGF0aCwgc25hcCkpO1xyXG4gICAgICAgIGNvbnN0IGFmZmVjdGVkUGF0aCA9IHJlcG9BYm9ydFRyYW5zYWN0aW9ucyhyZXBvLCBwYXRoKTtcclxuICAgICAgICByZXBvUmVydW5UcmFuc2FjdGlvbnMocmVwbywgYWZmZWN0ZWRQYXRoKTtcclxuICAgIH0pO1xyXG4gICAgcmVwby5vbkRpc2Nvbm5lY3RfID0gbmV3U3BhcnNlU25hcHNob3RUcmVlKCk7XHJcbiAgICBldmVudFF1ZXVlUmFpc2VFdmVudHNGb3JDaGFuZ2VkUGF0aChyZXBvLmV2ZW50UXVldWVfLCBuZXdFbXB0eVBhdGgoKSwgZXZlbnRzKTtcclxufVxyXG5mdW5jdGlvbiByZXBvT25EaXNjb25uZWN0Q2FuY2VsKHJlcG8sIHBhdGgsIG9uQ29tcGxldGUpIHtcclxuICAgIHJlcG8uc2VydmVyXy5vbkRpc2Nvbm5lY3RDYW5jZWwocGF0aC50b1N0cmluZygpLCAoc3RhdHVzLCBlcnJvclJlYXNvbikgPT4ge1xyXG4gICAgICAgIGlmIChzdGF0dXMgPT09ICdvaycpIHtcclxuICAgICAgICAgICAgc3BhcnNlU25hcHNob3RUcmVlRm9yZ2V0KHJlcG8ub25EaXNjb25uZWN0XywgcGF0aCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlcG9DYWxsT25Db21wbGV0ZUNhbGxiYWNrKHJlcG8sIG9uQ29tcGxldGUsIHN0YXR1cywgZXJyb3JSZWFzb24pO1xyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gcmVwb09uRGlzY29ubmVjdFNldChyZXBvLCBwYXRoLCB2YWx1ZSwgb25Db21wbGV0ZSkge1xyXG4gICAgY29uc3QgbmV3Tm9kZSA9IG5vZGVGcm9tSlNPTih2YWx1ZSk7XHJcbiAgICByZXBvLnNlcnZlcl8ub25EaXNjb25uZWN0UHV0KHBhdGgudG9TdHJpbmcoKSwgbmV3Tm9kZS52YWwoLypleHBvcnQ9Ki8gdHJ1ZSksIChzdGF0dXMsIGVycm9yUmVhc29uKSA9PiB7XHJcbiAgICAgICAgaWYgKHN0YXR1cyA9PT0gJ29rJykge1xyXG4gICAgICAgICAgICBzcGFyc2VTbmFwc2hvdFRyZWVSZW1lbWJlcihyZXBvLm9uRGlzY29ubmVjdF8sIHBhdGgsIG5ld05vZGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXBvQ2FsbE9uQ29tcGxldGVDYWxsYmFjayhyZXBvLCBvbkNvbXBsZXRlLCBzdGF0dXMsIGVycm9yUmVhc29uKTtcclxuICAgIH0pO1xyXG59XHJcbmZ1bmN0aW9uIHJlcG9PbkRpc2Nvbm5lY3RTZXRXaXRoUHJpb3JpdHkocmVwbywgcGF0aCwgdmFsdWUsIHByaW9yaXR5LCBvbkNvbXBsZXRlKSB7XHJcbiAgICBjb25zdCBuZXdOb2RlID0gbm9kZUZyb21KU09OKHZhbHVlLCBwcmlvcml0eSk7XHJcbiAgICByZXBvLnNlcnZlcl8ub25EaXNjb25uZWN0UHV0KHBhdGgudG9TdHJpbmcoKSwgbmV3Tm9kZS52YWwoLypleHBvcnQ9Ki8gdHJ1ZSksIChzdGF0dXMsIGVycm9yUmVhc29uKSA9PiB7XHJcbiAgICAgICAgaWYgKHN0YXR1cyA9PT0gJ29rJykge1xyXG4gICAgICAgICAgICBzcGFyc2VTbmFwc2hvdFRyZWVSZW1lbWJlcihyZXBvLm9uRGlzY29ubmVjdF8sIHBhdGgsIG5ld05vZGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXBvQ2FsbE9uQ29tcGxldGVDYWxsYmFjayhyZXBvLCBvbkNvbXBsZXRlLCBzdGF0dXMsIGVycm9yUmVhc29uKTtcclxuICAgIH0pO1xyXG59XHJcbmZ1bmN0aW9uIHJlcG9PbkRpc2Nvbm5lY3RVcGRhdGUocmVwbywgcGF0aCwgY2hpbGRyZW5Ub01lcmdlLCBvbkNvbXBsZXRlKSB7XHJcbiAgICBpZiAoaXNFbXB0eShjaGlsZHJlblRvTWVyZ2UpKSB7XHJcbiAgICAgICAgbG9nKFwib25EaXNjb25uZWN0KCkudXBkYXRlKCkgY2FsbGVkIHdpdGggZW1wdHkgZGF0YS4gIERvbid0IGRvIGFueXRoaW5nLlwiKTtcclxuICAgICAgICByZXBvQ2FsbE9uQ29tcGxldGVDYWxsYmFjayhyZXBvLCBvbkNvbXBsZXRlLCAnb2snLCB1bmRlZmluZWQpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIHJlcG8uc2VydmVyXy5vbkRpc2Nvbm5lY3RNZXJnZShwYXRoLnRvU3RyaW5nKCksIGNoaWxkcmVuVG9NZXJnZSwgKHN0YXR1cywgZXJyb3JSZWFzb24pID0+IHtcclxuICAgICAgICBpZiAoc3RhdHVzID09PSAnb2snKSB7XHJcbiAgICAgICAgICAgIGVhY2goY2hpbGRyZW5Ub01lcmdlLCAoY2hpbGROYW1lLCBjaGlsZE5vZGUpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG5ld0NoaWxkTm9kZSA9IG5vZGVGcm9tSlNPTihjaGlsZE5vZGUpO1xyXG4gICAgICAgICAgICAgICAgc3BhcnNlU25hcHNob3RUcmVlUmVtZW1iZXIocmVwby5vbkRpc2Nvbm5lY3RfLCBwYXRoQ2hpbGQocGF0aCwgY2hpbGROYW1lKSwgbmV3Q2hpbGROb2RlKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlcG9DYWxsT25Db21wbGV0ZUNhbGxiYWNrKHJlcG8sIG9uQ29tcGxldGUsIHN0YXR1cywgZXJyb3JSZWFzb24pO1xyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gcmVwb0FkZEV2ZW50Q2FsbGJhY2tGb3JRdWVyeShyZXBvLCBxdWVyeSwgZXZlbnRSZWdpc3RyYXRpb24pIHtcclxuICAgIGxldCBldmVudHM7XHJcbiAgICBpZiAocGF0aEdldEZyb250KHF1ZXJ5Ll9wYXRoKSA9PT0gJy5pbmZvJykge1xyXG4gICAgICAgIGV2ZW50cyA9IHN5bmNUcmVlQWRkRXZlbnRSZWdpc3RyYXRpb24ocmVwby5pbmZvU3luY1RyZWVfLCBxdWVyeSwgZXZlbnRSZWdpc3RyYXRpb24pO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgZXZlbnRzID0gc3luY1RyZWVBZGRFdmVudFJlZ2lzdHJhdGlvbihyZXBvLnNlcnZlclN5bmNUcmVlXywgcXVlcnksIGV2ZW50UmVnaXN0cmF0aW9uKTtcclxuICAgIH1cclxuICAgIGV2ZW50UXVldWVSYWlzZUV2ZW50c0F0UGF0aChyZXBvLmV2ZW50UXVldWVfLCBxdWVyeS5fcGF0aCwgZXZlbnRzKTtcclxufVxyXG5mdW5jdGlvbiByZXBvUmVtb3ZlRXZlbnRDYWxsYmFja0ZvclF1ZXJ5KHJlcG8sIHF1ZXJ5LCBldmVudFJlZ2lzdHJhdGlvbikge1xyXG4gICAgLy8gVGhlc2UgYXJlIGd1YXJhbnRlZWQgbm90IHRvIHJhaXNlIGV2ZW50cywgc2luY2Ugd2UncmUgbm90IHBhc3NpbmcgaW4gYSBjYW5jZWxFcnJvci4gSG93ZXZlciwgd2UgY2FuIGZ1dHVyZS1wcm9vZlxyXG4gICAgLy8gYSBsaXR0bGUgYml0IGJ5IGhhbmRsaW5nIHRoZSByZXR1cm4gdmFsdWVzIGFueXdheXMuXHJcbiAgICBsZXQgZXZlbnRzO1xyXG4gICAgaWYgKHBhdGhHZXRGcm9udChxdWVyeS5fcGF0aCkgPT09ICcuaW5mbycpIHtcclxuICAgICAgICBldmVudHMgPSBzeW5jVHJlZVJlbW92ZUV2ZW50UmVnaXN0cmF0aW9uKHJlcG8uaW5mb1N5bmNUcmVlXywgcXVlcnksIGV2ZW50UmVnaXN0cmF0aW9uKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGV2ZW50cyA9IHN5bmNUcmVlUmVtb3ZlRXZlbnRSZWdpc3RyYXRpb24ocmVwby5zZXJ2ZXJTeW5jVHJlZV8sIHF1ZXJ5LCBldmVudFJlZ2lzdHJhdGlvbik7XHJcbiAgICB9XHJcbiAgICBldmVudFF1ZXVlUmFpc2VFdmVudHNBdFBhdGgocmVwby5ldmVudFF1ZXVlXywgcXVlcnkuX3BhdGgsIGV2ZW50cyk7XHJcbn1cclxuZnVuY3Rpb24gcmVwb0ludGVycnVwdChyZXBvKSB7XHJcbiAgICBpZiAocmVwby5wZXJzaXN0ZW50Q29ubmVjdGlvbl8pIHtcclxuICAgICAgICByZXBvLnBlcnNpc3RlbnRDb25uZWN0aW9uXy5pbnRlcnJ1cHQoSU5URVJSVVBUX1JFQVNPTik7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gcmVwb1Jlc3VtZShyZXBvKSB7XHJcbiAgICBpZiAocmVwby5wZXJzaXN0ZW50Q29ubmVjdGlvbl8pIHtcclxuICAgICAgICByZXBvLnBlcnNpc3RlbnRDb25uZWN0aW9uXy5yZXN1bWUoSU5URVJSVVBUX1JFQVNPTik7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gcmVwb0xvZyhyZXBvLCAuLi52YXJBcmdzKSB7XHJcbiAgICBsZXQgcHJlZml4ID0gJyc7XHJcbiAgICBpZiAocmVwby5wZXJzaXN0ZW50Q29ubmVjdGlvbl8pIHtcclxuICAgICAgICBwcmVmaXggPSByZXBvLnBlcnNpc3RlbnRDb25uZWN0aW9uXy5pZCArICc6JztcclxuICAgIH1cclxuICAgIGxvZyhwcmVmaXgsIC4uLnZhckFyZ3MpO1xyXG59XHJcbmZ1bmN0aW9uIHJlcG9DYWxsT25Db21wbGV0ZUNhbGxiYWNrKHJlcG8sIGNhbGxiYWNrLCBzdGF0dXMsIGVycm9yUmVhc29uKSB7XHJcbiAgICBpZiAoY2FsbGJhY2spIHtcclxuICAgICAgICBleGNlcHRpb25HdWFyZCgoKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChzdGF0dXMgPT09ICdvaycpIHtcclxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY29kZSA9IChzdGF0dXMgfHwgJ2Vycm9yJykudG9VcHBlckNhc2UoKTtcclxuICAgICAgICAgICAgICAgIGxldCBtZXNzYWdlID0gY29kZTtcclxuICAgICAgICAgICAgICAgIGlmIChlcnJvclJlYXNvbikge1xyXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgKz0gJzogJyArIGVycm9yUmVhc29uO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IobWVzc2FnZSk7XHJcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxyXG4gICAgICAgICAgICAgICAgZXJyb3IuY29kZSA9IGNvZGU7XHJcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnJvcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQ3JlYXRlcyBhIG5ldyB0cmFuc2FjdGlvbiwgYWRkcyBpdCB0byB0aGUgdHJhbnNhY3Rpb25zIHdlJ3JlIHRyYWNraW5nLCBhbmRcclxuICogc2VuZHMgaXQgdG8gdGhlIHNlcnZlciBpZiBwb3NzaWJsZS5cclxuICpcclxuICogQHBhcmFtIHBhdGggLSBQYXRoIGF0IHdoaWNoIHRvIGRvIHRyYW5zYWN0aW9uLlxyXG4gKiBAcGFyYW0gdHJhbnNhY3Rpb25VcGRhdGUgLSBVcGRhdGUgY2FsbGJhY2suXHJcbiAqIEBwYXJhbSBvbkNvbXBsZXRlIC0gQ29tcGxldGlvbiBjYWxsYmFjay5cclxuICogQHBhcmFtIHVud2F0Y2hlciAtIEZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBjYWxsZWQgd2hlbiB0aGUgdHJhbnNhY3Rpb24gbm8gbG9uZ2VyXHJcbiAqIG5lZWQgZGF0YSB1cGRhdGVzIGZvciBgcGF0aGAuXHJcbiAqIEBwYXJhbSBhcHBseUxvY2FsbHkgLSBXaGV0aGVyIG9yIG5vdCB0byBtYWtlIGludGVybWVkaWF0ZSByZXN1bHRzIHZpc2libGVcclxuICovXHJcbmZ1bmN0aW9uIHJlcG9TdGFydFRyYW5zYWN0aW9uKHJlcG8sIHBhdGgsIHRyYW5zYWN0aW9uVXBkYXRlLCBvbkNvbXBsZXRlLCB1bndhdGNoZXIsIGFwcGx5TG9jYWxseSkge1xyXG4gICAgcmVwb0xvZyhyZXBvLCAndHJhbnNhY3Rpb24gb24gJyArIHBhdGgpO1xyXG4gICAgLy8gSW5pdGlhbGl6ZSB0cmFuc2FjdGlvbi5cclxuICAgIGNvbnN0IHRyYW5zYWN0aW9uID0ge1xyXG4gICAgICAgIHBhdGgsXHJcbiAgICAgICAgdXBkYXRlOiB0cmFuc2FjdGlvblVwZGF0ZSxcclxuICAgICAgICBvbkNvbXBsZXRlLFxyXG4gICAgICAgIC8vIE9uZSBvZiBUcmFuc2FjdGlvblN0YXR1cyBlbnVtcy5cclxuICAgICAgICBzdGF0dXM6IG51bGwsXHJcbiAgICAgICAgLy8gVXNlZCB3aGVuIGNvbWJpbmluZyB0cmFuc2FjdGlvbnMgYXQgZGlmZmVyZW50IGxvY2F0aW9ucyB0byBmaWd1cmUgb3V0XHJcbiAgICAgICAgLy8gd2hpY2ggb25lIGdvZXMgZmlyc3QuXHJcbiAgICAgICAgb3JkZXI6IExVSURHZW5lcmF0b3IoKSxcclxuICAgICAgICAvLyBXaGV0aGVyIHRvIHJhaXNlIGxvY2FsIGV2ZW50cyBmb3IgdGhpcyB0cmFuc2FjdGlvbi5cclxuICAgICAgICBhcHBseUxvY2FsbHksXHJcbiAgICAgICAgLy8gQ291bnQgb2YgaG93IG1hbnkgdGltZXMgd2UndmUgcmV0cmllZCB0aGUgdHJhbnNhY3Rpb24uXHJcbiAgICAgICAgcmV0cnlDb3VudDogMCxcclxuICAgICAgICAvLyBGdW5jdGlvbiB0byBjYWxsIHRvIGNsZWFuIHVwIG91ciAub24oKSBsaXN0ZW5lci5cclxuICAgICAgICB1bndhdGNoZXIsXHJcbiAgICAgICAgLy8gU3RvcmVzIHdoeSBhIHRyYW5zYWN0aW9uIHdhcyBhYm9ydGVkLlxyXG4gICAgICAgIGFib3J0UmVhc29uOiBudWxsLFxyXG4gICAgICAgIGN1cnJlbnRXcml0ZUlkOiBudWxsLFxyXG4gICAgICAgIGN1cnJlbnRJbnB1dFNuYXBzaG90OiBudWxsLFxyXG4gICAgICAgIGN1cnJlbnRPdXRwdXRTbmFwc2hvdFJhdzogbnVsbCxcclxuICAgICAgICBjdXJyZW50T3V0cHV0U25hcHNob3RSZXNvbHZlZDogbnVsbFxyXG4gICAgfTtcclxuICAgIC8vIFJ1biB0cmFuc2FjdGlvbiBpbml0aWFsbHkuXHJcbiAgICBjb25zdCBjdXJyZW50U3RhdGUgPSByZXBvR2V0TGF0ZXN0U3RhdGUocmVwbywgcGF0aCwgdW5kZWZpbmVkKTtcclxuICAgIHRyYW5zYWN0aW9uLmN1cnJlbnRJbnB1dFNuYXBzaG90ID0gY3VycmVudFN0YXRlO1xyXG4gICAgY29uc3QgbmV3VmFsID0gdHJhbnNhY3Rpb24udXBkYXRlKGN1cnJlbnRTdGF0ZS52YWwoKSk7XHJcbiAgICBpZiAobmV3VmFsID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAvLyBBYm9ydCB0cmFuc2FjdGlvbi5cclxuICAgICAgICB0cmFuc2FjdGlvbi51bndhdGNoZXIoKTtcclxuICAgICAgICB0cmFuc2FjdGlvbi5jdXJyZW50T3V0cHV0U25hcHNob3RSYXcgPSBudWxsO1xyXG4gICAgICAgIHRyYW5zYWN0aW9uLmN1cnJlbnRPdXRwdXRTbmFwc2hvdFJlc29sdmVkID0gbnVsbDtcclxuICAgICAgICBpZiAodHJhbnNhY3Rpb24ub25Db21wbGV0ZSkge1xyXG4gICAgICAgICAgICB0cmFuc2FjdGlvbi5vbkNvbXBsZXRlKG51bGwsIGZhbHNlLCB0cmFuc2FjdGlvbi5jdXJyZW50SW5wdXRTbmFwc2hvdCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgdmFsaWRhdGVGaXJlYmFzZURhdGEoJ3RyYW5zYWN0aW9uIGZhaWxlZDogRGF0YSByZXR1cm5lZCAnLCBuZXdWYWwsIHRyYW5zYWN0aW9uLnBhdGgpO1xyXG4gICAgICAgIC8vIE1hcmsgYXMgcnVuIGFuZCBhZGQgdG8gb3VyIHF1ZXVlLlxyXG4gICAgICAgIHRyYW5zYWN0aW9uLnN0YXR1cyA9IDAgLyogUlVOICovO1xyXG4gICAgICAgIGNvbnN0IHF1ZXVlTm9kZSA9IHRyZWVTdWJUcmVlKHJlcG8udHJhbnNhY3Rpb25RdWV1ZVRyZWVfLCBwYXRoKTtcclxuICAgICAgICBjb25zdCBub2RlUXVldWUgPSB0cmVlR2V0VmFsdWUocXVldWVOb2RlKSB8fCBbXTtcclxuICAgICAgICBub2RlUXVldWUucHVzaCh0cmFuc2FjdGlvbik7XHJcbiAgICAgICAgdHJlZVNldFZhbHVlKHF1ZXVlTm9kZSwgbm9kZVF1ZXVlKTtcclxuICAgICAgICAvLyBVcGRhdGUgdmlzaWJsZURhdGEgYW5kIHJhaXNlIGV2ZW50c1xyXG4gICAgICAgIC8vIE5vdGU6IFdlIGludGVudGlvbmFsbHkgcmFpc2UgZXZlbnRzIGFmdGVyIHVwZGF0aW5nIGFsbCBvZiBvdXJcclxuICAgICAgICAvLyB0cmFuc2FjdGlvbiBzdGF0ZSwgc2luY2UgdGhlIHVzZXIgY291bGQgc3RhcnQgbmV3IHRyYW5zYWN0aW9ucyBmcm9tIHRoZVxyXG4gICAgICAgIC8vIGV2ZW50IGNhbGxiYWNrcy5cclxuICAgICAgICBsZXQgcHJpb3JpdHlGb3JOb2RlO1xyXG4gICAgICAgIGlmICh0eXBlb2YgbmV3VmFsID09PSAnb2JqZWN0JyAmJlxyXG4gICAgICAgICAgICBuZXdWYWwgIT09IG51bGwgJiZcclxuICAgICAgICAgICAgY29udGFpbnMobmV3VmFsLCAnLnByaW9yaXR5JykpIHtcclxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcclxuICAgICAgICAgICAgcHJpb3JpdHlGb3JOb2RlID0gc2FmZUdldChuZXdWYWwsICcucHJpb3JpdHknKTtcclxuICAgICAgICAgICAgYXNzZXJ0KGlzVmFsaWRQcmlvcml0eShwcmlvcml0eUZvck5vZGUpLCAnSW52YWxpZCBwcmlvcml0eSByZXR1cm5lZCBieSB0cmFuc2FjdGlvbi4gJyArXHJcbiAgICAgICAgICAgICAgICAnUHJpb3JpdHkgbXVzdCBiZSBhIHZhbGlkIHN0cmluZywgZmluaXRlIG51bWJlciwgc2VydmVyIHZhbHVlLCBvciBudWxsLicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3QgY3VycmVudE5vZGUgPSBzeW5jVHJlZUNhbGNDb21wbGV0ZUV2ZW50Q2FjaGUocmVwby5zZXJ2ZXJTeW5jVHJlZV8sIHBhdGgpIHx8XHJcbiAgICAgICAgICAgICAgICBDaGlsZHJlbk5vZGUuRU1QVFlfTk9ERTtcclxuICAgICAgICAgICAgcHJpb3JpdHlGb3JOb2RlID0gY3VycmVudE5vZGUuZ2V0UHJpb3JpdHkoKS52YWwoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3Qgc2VydmVyVmFsdWVzID0gcmVwb0dlbmVyYXRlU2VydmVyVmFsdWVzKHJlcG8pO1xyXG4gICAgICAgIGNvbnN0IG5ld05vZGVVbnJlc29sdmVkID0gbm9kZUZyb21KU09OKG5ld1ZhbCwgcHJpb3JpdHlGb3JOb2RlKTtcclxuICAgICAgICBjb25zdCBuZXdOb2RlID0gcmVzb2x2ZURlZmVycmVkVmFsdWVTbmFwc2hvdChuZXdOb2RlVW5yZXNvbHZlZCwgY3VycmVudFN0YXRlLCBzZXJ2ZXJWYWx1ZXMpO1xyXG4gICAgICAgIHRyYW5zYWN0aW9uLmN1cnJlbnRPdXRwdXRTbmFwc2hvdFJhdyA9IG5ld05vZGVVbnJlc29sdmVkO1xyXG4gICAgICAgIHRyYW5zYWN0aW9uLmN1cnJlbnRPdXRwdXRTbmFwc2hvdFJlc29sdmVkID0gbmV3Tm9kZTtcclxuICAgICAgICB0cmFuc2FjdGlvbi5jdXJyZW50V3JpdGVJZCA9IHJlcG9HZXROZXh0V3JpdGVJZChyZXBvKTtcclxuICAgICAgICBjb25zdCBldmVudHMgPSBzeW5jVHJlZUFwcGx5VXNlck92ZXJ3cml0ZShyZXBvLnNlcnZlclN5bmNUcmVlXywgcGF0aCwgbmV3Tm9kZSwgdHJhbnNhY3Rpb24uY3VycmVudFdyaXRlSWQsIHRyYW5zYWN0aW9uLmFwcGx5TG9jYWxseSk7XHJcbiAgICAgICAgZXZlbnRRdWV1ZVJhaXNlRXZlbnRzRm9yQ2hhbmdlZFBhdGgocmVwby5ldmVudFF1ZXVlXywgcGF0aCwgZXZlbnRzKTtcclxuICAgICAgICByZXBvU2VuZFJlYWR5VHJhbnNhY3Rpb25zKHJlcG8sIHJlcG8udHJhbnNhY3Rpb25RdWV1ZVRyZWVfKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQHBhcmFtIGV4Y2x1ZGVTZXRzIC0gQSBzcGVjaWZpYyBzZXQgdG8gZXhjbHVkZVxyXG4gKi9cclxuZnVuY3Rpb24gcmVwb0dldExhdGVzdFN0YXRlKHJlcG8sIHBhdGgsIGV4Y2x1ZGVTZXRzKSB7XHJcbiAgICByZXR1cm4gKHN5bmNUcmVlQ2FsY0NvbXBsZXRlRXZlbnRDYWNoZShyZXBvLnNlcnZlclN5bmNUcmVlXywgcGF0aCwgZXhjbHVkZVNldHMpIHx8XHJcbiAgICAgICAgQ2hpbGRyZW5Ob2RlLkVNUFRZX05PREUpO1xyXG59XHJcbi8qKlxyXG4gKiBTZW5kcyBhbnkgYWxyZWFkeS1ydW4gdHJhbnNhY3Rpb25zIHRoYXQgYXJlbid0IHdhaXRpbmcgZm9yIG91dHN0YW5kaW5nXHJcbiAqIHRyYW5zYWN0aW9ucyB0byBjb21wbGV0ZS5cclxuICpcclxuICogRXh0ZXJuYWxseSBpdCdzIGNhbGxlZCB3aXRoIG5vIGFyZ3VtZW50cywgYnV0IGl0IGNhbGxzIGl0c2VsZiByZWN1cnNpdmVseVxyXG4gKiB3aXRoIGEgcGFydGljdWxhciB0cmFuc2FjdGlvblF1ZXVlVHJlZSBub2RlIHRvIHJlY3Vyc2UgdGhyb3VnaCB0aGUgdHJlZS5cclxuICpcclxuICogQHBhcmFtIG5vZGUgLSB0cmFuc2FjdGlvblF1ZXVlVHJlZSBub2RlIHRvIHN0YXJ0IGF0LlxyXG4gKi9cclxuZnVuY3Rpb24gcmVwb1NlbmRSZWFkeVRyYW5zYWN0aW9ucyhyZXBvLCBub2RlID0gcmVwby50cmFuc2FjdGlvblF1ZXVlVHJlZV8pIHtcclxuICAgIC8vIEJlZm9yZSByZWN1cnNpbmcsIG1ha2Ugc3VyZSBhbnkgY29tcGxldGVkIHRyYW5zYWN0aW9ucyBhcmUgcmVtb3ZlZC5cclxuICAgIGlmICghbm9kZSkge1xyXG4gICAgICAgIHJlcG9QcnVuZUNvbXBsZXRlZFRyYW5zYWN0aW9uc0JlbG93Tm9kZShyZXBvLCBub2RlKTtcclxuICAgIH1cclxuICAgIGlmICh0cmVlR2V0VmFsdWUobm9kZSkpIHtcclxuICAgICAgICBjb25zdCBxdWV1ZSA9IHJlcG9CdWlsZFRyYW5zYWN0aW9uUXVldWUocmVwbywgbm9kZSk7XHJcbiAgICAgICAgYXNzZXJ0KHF1ZXVlLmxlbmd0aCA+IDAsICdTZW5kaW5nIHplcm8gbGVuZ3RoIHRyYW5zYWN0aW9uIHF1ZXVlJyk7XHJcbiAgICAgICAgY29uc3QgYWxsUnVuID0gcXVldWUuZXZlcnkoKHRyYW5zYWN0aW9uKSA9PiB0cmFuc2FjdGlvbi5zdGF0dXMgPT09IDAgLyogUlVOICovKTtcclxuICAgICAgICAvLyBJZiB0aGV5J3JlIGFsbCBydW4gKGFuZCBub3Qgc2VudCksIHdlIGNhbiBzZW5kIHRoZW0uICBFbHNlLCB3ZSBtdXN0IHdhaXQuXHJcbiAgICAgICAgaWYgKGFsbFJ1bikge1xyXG4gICAgICAgICAgICByZXBvU2VuZFRyYW5zYWN0aW9uUXVldWUocmVwbywgdHJlZUdldFBhdGgobm9kZSksIHF1ZXVlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh0cmVlSGFzQ2hpbGRyZW4obm9kZSkpIHtcclxuICAgICAgICB0cmVlRm9yRWFjaENoaWxkKG5vZGUsIGNoaWxkTm9kZSA9PiB7XHJcbiAgICAgICAgICAgIHJlcG9TZW5kUmVhZHlUcmFuc2FjdGlvbnMocmVwbywgY2hpbGROb2RlKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogR2l2ZW4gYSBsaXN0IG9mIHJ1biB0cmFuc2FjdGlvbnMsIHNlbmQgdGhlbSB0byB0aGUgc2VydmVyIGFuZCB0aGVuIGhhbmRsZVxyXG4gKiB0aGUgcmVzdWx0IChzdWNjZXNzIG9yIGZhaWx1cmUpLlxyXG4gKlxyXG4gKiBAcGFyYW0gcGF0aCAtIFRoZSBsb2NhdGlvbiBvZiB0aGUgcXVldWUuXHJcbiAqIEBwYXJhbSBxdWV1ZSAtIFF1ZXVlIG9mIHRyYW5zYWN0aW9ucyB1bmRlciB0aGUgc3BlY2lmaWVkIGxvY2F0aW9uLlxyXG4gKi9cclxuZnVuY3Rpb24gcmVwb1NlbmRUcmFuc2FjdGlvblF1ZXVlKHJlcG8sIHBhdGgsIHF1ZXVlKSB7XHJcbiAgICAvLyBNYXJrIHRyYW5zYWN0aW9ucyBhcyBzZW50IGFuZCBpbmNyZW1lbnQgcmV0cnkgY291bnQhXHJcbiAgICBjb25zdCBzZXRzVG9JZ25vcmUgPSBxdWV1ZS5tYXAodHhuID0+IHtcclxuICAgICAgICByZXR1cm4gdHhuLmN1cnJlbnRXcml0ZUlkO1xyXG4gICAgfSk7XHJcbiAgICBjb25zdCBsYXRlc3RTdGF0ZSA9IHJlcG9HZXRMYXRlc3RTdGF0ZShyZXBvLCBwYXRoLCBzZXRzVG9JZ25vcmUpO1xyXG4gICAgbGV0IHNuYXBUb1NlbmQgPSBsYXRlc3RTdGF0ZTtcclxuICAgIGNvbnN0IGxhdGVzdEhhc2ggPSBsYXRlc3RTdGF0ZS5oYXNoKCk7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHF1ZXVlLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY29uc3QgdHhuID0gcXVldWVbaV07XHJcbiAgICAgICAgYXNzZXJ0KHR4bi5zdGF0dXMgPT09IDAgLyogUlVOICovLCAndHJ5VG9TZW5kVHJhbnNhY3Rpb25RdWV1ZV86IGl0ZW1zIGluIHF1ZXVlIHNob3VsZCBhbGwgYmUgcnVuLicpO1xyXG4gICAgICAgIHR4bi5zdGF0dXMgPSAxIC8qIFNFTlQgKi87XHJcbiAgICAgICAgdHhuLnJldHJ5Q291bnQrKztcclxuICAgICAgICBjb25zdCByZWxhdGl2ZVBhdGggPSBuZXdSZWxhdGl2ZVBhdGgocGF0aCwgdHhuLnBhdGgpO1xyXG4gICAgICAgIC8vIElmIHdlJ3ZlIGdvdHRlbiB0byB0aGlzIHBvaW50LCB0aGUgb3V0cHV0IHNuYXBzaG90IG11c3QgYmUgZGVmaW5lZC5cclxuICAgICAgICBzbmFwVG9TZW5kID0gc25hcFRvU2VuZC51cGRhdGVDaGlsZChyZWxhdGl2ZVBhdGggLyoqIEB0eXBlIHshTm9kZX0gKi8sIHR4bi5jdXJyZW50T3V0cHV0U25hcHNob3RSYXcpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgZGF0YVRvU2VuZCA9IHNuYXBUb1NlbmQudmFsKHRydWUpO1xyXG4gICAgY29uc3QgcGF0aFRvU2VuZCA9IHBhdGg7XHJcbiAgICAvLyBTZW5kIHRoZSBwdXQuXHJcbiAgICByZXBvLnNlcnZlcl8ucHV0KHBhdGhUb1NlbmQudG9TdHJpbmcoKSwgZGF0YVRvU2VuZCwgKHN0YXR1cykgPT4ge1xyXG4gICAgICAgIHJlcG9Mb2cocmVwbywgJ3RyYW5zYWN0aW9uIHB1dCByZXNwb25zZScsIHtcclxuICAgICAgICAgICAgcGF0aDogcGF0aFRvU2VuZC50b1N0cmluZygpLFxyXG4gICAgICAgICAgICBzdGF0dXNcclxuICAgICAgICB9KTtcclxuICAgICAgICBsZXQgZXZlbnRzID0gW107XHJcbiAgICAgICAgaWYgKHN0YXR1cyA9PT0gJ29rJykge1xyXG4gICAgICAgICAgICAvLyBRdWV1ZSB1cCB0aGUgY2FsbGJhY2tzIGFuZCBmaXJlIHRoZW0gYWZ0ZXIgY2xlYW5pbmcgdXAgYWxsIG9mIG91clxyXG4gICAgICAgICAgICAvLyB0cmFuc2FjdGlvbiBzdGF0ZSwgc2luY2UgdGhlIGNhbGxiYWNrIGNvdWxkIHRyaWdnZXIgbW9yZVxyXG4gICAgICAgICAgICAvLyB0cmFuc2FjdGlvbnMgb3Igc2V0cy5cclxuICAgICAgICAgICAgY29uc3QgY2FsbGJhY2tzID0gW107XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHF1ZXVlW2ldLnN0YXR1cyA9IDIgLyogQ09NUExFVEVEICovO1xyXG4gICAgICAgICAgICAgICAgZXZlbnRzID0gZXZlbnRzLmNvbmNhdChzeW5jVHJlZUFja1VzZXJXcml0ZShyZXBvLnNlcnZlclN5bmNUcmVlXywgcXVldWVbaV0uY3VycmVudFdyaXRlSWQpKTtcclxuICAgICAgICAgICAgICAgIGlmIChxdWV1ZVtpXS5vbkNvbXBsZXRlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgbmV2ZXIgdW5zZXQgdGhlIG91dHB1dCBzbmFwc2hvdCwgYW5kIGdpdmVuIHRoYXQgdGhpc1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHRyYW5zYWN0aW9uIGlzIGNvbXBsZXRlLCBpdCBzaG91bGQgYmUgc2V0XHJcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2tzLnB1c2goKCkgPT4gcXVldWVbaV0ub25Db21wbGV0ZShudWxsLCB0cnVlLCBxdWV1ZVtpXS5jdXJyZW50T3V0cHV0U25hcHNob3RSZXNvbHZlZCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcXVldWVbaV0udW53YXRjaGVyKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gTm93IHJlbW92ZSB0aGUgY29tcGxldGVkIHRyYW5zYWN0aW9ucy5cclxuICAgICAgICAgICAgcmVwb1BydW5lQ29tcGxldGVkVHJhbnNhY3Rpb25zQmVsb3dOb2RlKHJlcG8sIHRyZWVTdWJUcmVlKHJlcG8udHJhbnNhY3Rpb25RdWV1ZVRyZWVfLCBwYXRoKSk7XHJcbiAgICAgICAgICAgIC8vIFRoZXJlIG1heSBiZSBwZW5kaW5nIHRyYW5zYWN0aW9ucyB0aGF0IHdlIGNhbiBub3cgc2VuZC5cclxuICAgICAgICAgICAgcmVwb1NlbmRSZWFkeVRyYW5zYWN0aW9ucyhyZXBvLCByZXBvLnRyYW5zYWN0aW9uUXVldWVUcmVlXyk7XHJcbiAgICAgICAgICAgIGV2ZW50UXVldWVSYWlzZUV2ZW50c0ZvckNoYW5nZWRQYXRoKHJlcG8uZXZlbnRRdWV1ZV8sIHBhdGgsIGV2ZW50cyk7XHJcbiAgICAgICAgICAgIC8vIEZpbmFsbHksIHRyaWdnZXIgb25Db21wbGV0ZSBjYWxsYmFja3MuXHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2FsbGJhY2tzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBleGNlcHRpb25HdWFyZChjYWxsYmFja3NbaV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyB0cmFuc2FjdGlvbnMgYXJlIG5vIGxvbmdlciBzZW50LiAgVXBkYXRlIHRoZWlyIHN0YXR1cyBhcHByb3ByaWF0ZWx5LlxyXG4gICAgICAgICAgICBpZiAoc3RhdHVzID09PSAnZGF0YXN0YWxlJykge1xyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBxdWV1ZS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChxdWV1ZVtpXS5zdGF0dXMgPT09IDMgLyogU0VOVF9ORUVEU19BQk9SVCAqLykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBxdWV1ZVtpXS5zdGF0dXMgPSA0IC8qIE5FRURTX0FCT1JUICovO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcXVldWVbaV0uc3RhdHVzID0gMCAvKiBSVU4gKi87XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgd2FybigndHJhbnNhY3Rpb24gYXQgJyArIHBhdGhUb1NlbmQudG9TdHJpbmcoKSArICcgZmFpbGVkOiAnICsgc3RhdHVzKTtcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBxdWV1ZVtpXS5zdGF0dXMgPSA0IC8qIE5FRURTX0FCT1JUICovO1xyXG4gICAgICAgICAgICAgICAgICAgIHF1ZXVlW2ldLmFib3J0UmVhc29uID0gc3RhdHVzO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJlcG9SZXJ1blRyYW5zYWN0aW9ucyhyZXBvLCBwYXRoKTtcclxuICAgICAgICB9XHJcbiAgICB9LCBsYXRlc3RIYXNoKTtcclxufVxyXG4vKipcclxuICogRmluZHMgYWxsIHRyYW5zYWN0aW9ucyBkZXBlbmRlbnQgb24gdGhlIGRhdGEgYXQgY2hhbmdlZFBhdGggYW5kIHJlcnVucyB0aGVtLlxyXG4gKlxyXG4gKiBTaG91bGQgYmUgY2FsbGVkIGFueSB0aW1lIGNhY2hlZCBkYXRhIGNoYW5nZXMuXHJcbiAqXHJcbiAqIFJldHVybiB0aGUgaGlnaGVzdCBwYXRoIHRoYXQgd2FzIGFmZmVjdGVkIGJ5IHJlcnVubmluZyB0cmFuc2FjdGlvbnMuIFRoaXNcclxuICogaXMgdGhlIHBhdGggYXQgd2hpY2ggZXZlbnRzIG5lZWQgdG8gYmUgcmFpc2VkIGZvci5cclxuICpcclxuICogQHBhcmFtIGNoYW5nZWRQYXRoIC0gVGhlIHBhdGggaW4gbWVyZ2VkRGF0YSB0aGF0IGNoYW5nZWQuXHJcbiAqIEByZXR1cm5zIFRoZSByb290bW9zdCBwYXRoIHRoYXQgd2FzIGFmZmVjdGVkIGJ5IHJlcnVubmluZyB0cmFuc2FjdGlvbnMuXHJcbiAqL1xyXG5mdW5jdGlvbiByZXBvUmVydW5UcmFuc2FjdGlvbnMocmVwbywgY2hhbmdlZFBhdGgpIHtcclxuICAgIGNvbnN0IHJvb3RNb3N0VHJhbnNhY3Rpb25Ob2RlID0gcmVwb0dldEFuY2VzdG9yVHJhbnNhY3Rpb25Ob2RlKHJlcG8sIGNoYW5nZWRQYXRoKTtcclxuICAgIGNvbnN0IHBhdGggPSB0cmVlR2V0UGF0aChyb290TW9zdFRyYW5zYWN0aW9uTm9kZSk7XHJcbiAgICBjb25zdCBxdWV1ZSA9IHJlcG9CdWlsZFRyYW5zYWN0aW9uUXVldWUocmVwbywgcm9vdE1vc3RUcmFuc2FjdGlvbk5vZGUpO1xyXG4gICAgcmVwb1JlcnVuVHJhbnNhY3Rpb25RdWV1ZShyZXBvLCBxdWV1ZSwgcGF0aCk7XHJcbiAgICByZXR1cm4gcGF0aDtcclxufVxyXG4vKipcclxuICogRG9lcyBhbGwgdGhlIHdvcmsgb2YgcmVydW5uaW5nIHRyYW5zYWN0aW9ucyAoYXMgd2VsbCBhcyBjbGVhbnMgdXAgYWJvcnRlZFxyXG4gKiB0cmFuc2FjdGlvbnMgYW5kIHdoYXRub3QpLlxyXG4gKlxyXG4gKiBAcGFyYW0gcXVldWUgLSBUaGUgcXVldWUgb2YgdHJhbnNhY3Rpb25zIHRvIHJ1bi5cclxuICogQHBhcmFtIHBhdGggLSBUaGUgcGF0aCB0aGUgcXVldWUgaXMgZm9yLlxyXG4gKi9cclxuZnVuY3Rpb24gcmVwb1JlcnVuVHJhbnNhY3Rpb25RdWV1ZShyZXBvLCBxdWV1ZSwgcGF0aCkge1xyXG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgIHJldHVybjsgLy8gTm90aGluZyB0byBkbyFcclxuICAgIH1cclxuICAgIC8vIFF1ZXVlIHVwIHRoZSBjYWxsYmFja3MgYW5kIGZpcmUgdGhlbSBhZnRlciBjbGVhbmluZyB1cCBhbGwgb2Ygb3VyXHJcbiAgICAvLyB0cmFuc2FjdGlvbiBzdGF0ZSwgc2luY2UgdGhlIGNhbGxiYWNrIGNvdWxkIHRyaWdnZXIgbW9yZSB0cmFuc2FjdGlvbnMgb3JcclxuICAgIC8vIHNldHMuXHJcbiAgICBjb25zdCBjYWxsYmFja3MgPSBbXTtcclxuICAgIGxldCBldmVudHMgPSBbXTtcclxuICAgIC8vIElnbm9yZSBhbGwgb2YgdGhlIHNldHMgd2UncmUgZ29pbmcgdG8gcmUtcnVuLlxyXG4gICAgY29uc3QgdHhuc1RvUmVydW4gPSBxdWV1ZS5maWx0ZXIocSA9PiB7XHJcbiAgICAgICAgcmV0dXJuIHEuc3RhdHVzID09PSAwIC8qIFJVTiAqLztcclxuICAgIH0pO1xyXG4gICAgY29uc3Qgc2V0c1RvSWdub3JlID0gdHhuc1RvUmVydW4ubWFwKHEgPT4ge1xyXG4gICAgICAgIHJldHVybiBxLmN1cnJlbnRXcml0ZUlkO1xyXG4gICAgfSk7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHF1ZXVlLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY29uc3QgdHJhbnNhY3Rpb24gPSBxdWV1ZVtpXTtcclxuICAgICAgICBjb25zdCByZWxhdGl2ZVBhdGggPSBuZXdSZWxhdGl2ZVBhdGgocGF0aCwgdHJhbnNhY3Rpb24ucGF0aCk7XHJcbiAgICAgICAgbGV0IGFib3J0VHJhbnNhY3Rpb24gPSBmYWxzZSwgYWJvcnRSZWFzb247XHJcbiAgICAgICAgYXNzZXJ0KHJlbGF0aXZlUGF0aCAhPT0gbnVsbCwgJ3JlcnVuVHJhbnNhY3Rpb25zVW5kZXJOb2RlXzogcmVsYXRpdmVQYXRoIHNob3VsZCBub3QgYmUgbnVsbC4nKTtcclxuICAgICAgICBpZiAodHJhbnNhY3Rpb24uc3RhdHVzID09PSA0IC8qIE5FRURTX0FCT1JUICovKSB7XHJcbiAgICAgICAgICAgIGFib3J0VHJhbnNhY3Rpb24gPSB0cnVlO1xyXG4gICAgICAgICAgICBhYm9ydFJlYXNvbiA9IHRyYW5zYWN0aW9uLmFib3J0UmVhc29uO1xyXG4gICAgICAgICAgICBldmVudHMgPSBldmVudHMuY29uY2F0KHN5bmNUcmVlQWNrVXNlcldyaXRlKHJlcG8uc2VydmVyU3luY1RyZWVfLCB0cmFuc2FjdGlvbi5jdXJyZW50V3JpdGVJZCwgdHJ1ZSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0cmFuc2FjdGlvbi5zdGF0dXMgPT09IDAgLyogUlVOICovKSB7XHJcbiAgICAgICAgICAgIGlmICh0cmFuc2FjdGlvbi5yZXRyeUNvdW50ID49IE1BWF9UUkFOU0FDVElPTl9SRVRSSUVTKSB7XHJcbiAgICAgICAgICAgICAgICBhYm9ydFRyYW5zYWN0aW9uID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGFib3J0UmVhc29uID0gJ21heHJldHJ5JztcclxuICAgICAgICAgICAgICAgIGV2ZW50cyA9IGV2ZW50cy5jb25jYXQoc3luY1RyZWVBY2tVc2VyV3JpdGUocmVwby5zZXJ2ZXJTeW5jVHJlZV8sIHRyYW5zYWN0aW9uLmN1cnJlbnRXcml0ZUlkLCB0cnVlKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGNvZGUgcmVydW5zIGEgdHJhbnNhY3Rpb25cclxuICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnROb2RlID0gcmVwb0dldExhdGVzdFN0YXRlKHJlcG8sIHRyYW5zYWN0aW9uLnBhdGgsIHNldHNUb0lnbm9yZSk7XHJcbiAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbi5jdXJyZW50SW5wdXRTbmFwc2hvdCA9IGN1cnJlbnROb2RlO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbmV3RGF0YSA9IHF1ZXVlW2ldLnVwZGF0ZShjdXJyZW50Tm9kZS52YWwoKSk7XHJcbiAgICAgICAgICAgICAgICBpZiAobmV3RGF0YSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGVGaXJlYmFzZURhdGEoJ3RyYW5zYWN0aW9uIGZhaWxlZDogRGF0YSByZXR1cm5lZCAnLCBuZXdEYXRhLCB0cmFuc2FjdGlvbi5wYXRoKTtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgbmV3RGF0YU5vZGUgPSBub2RlRnJvbUpTT04obmV3RGF0YSk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaGFzRXhwbGljaXRQcmlvcml0eSA9IHR5cGVvZiBuZXdEYXRhID09PSAnb2JqZWN0JyAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdEYXRhICE9IG51bGwgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGFpbnMobmV3RGF0YSwgJy5wcmlvcml0eScpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghaGFzRXhwbGljaXRQcmlvcml0eSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBLZWVwIHRoZSBvbGQgcHJpb3JpdHkgaWYgdGhlcmUgd2Fzbid0IGEgcHJpb3JpdHkgZXhwbGljaXRseSBzcGVjaWZpZWQuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld0RhdGFOb2RlID0gbmV3RGF0YU5vZGUudXBkYXRlUHJpb3JpdHkoY3VycmVudE5vZGUuZ2V0UHJpb3JpdHkoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG9sZFdyaXRlSWQgPSB0cmFuc2FjdGlvbi5jdXJyZW50V3JpdGVJZDtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzZXJ2ZXJWYWx1ZXMgPSByZXBvR2VuZXJhdGVTZXJ2ZXJWYWx1ZXMocmVwbyk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV3Tm9kZVJlc29sdmVkID0gcmVzb2x2ZURlZmVycmVkVmFsdWVTbmFwc2hvdChuZXdEYXRhTm9kZSwgY3VycmVudE5vZGUsIHNlcnZlclZhbHVlcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb24uY3VycmVudE91dHB1dFNuYXBzaG90UmF3ID0gbmV3RGF0YU5vZGU7XHJcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb24uY3VycmVudE91dHB1dFNuYXBzaG90UmVzb2x2ZWQgPSBuZXdOb2RlUmVzb2x2ZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb24uY3VycmVudFdyaXRlSWQgPSByZXBvR2V0TmV4dFdyaXRlSWQocmVwbyk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gTXV0YXRlcyBzZXRzVG9JZ25vcmUgaW4gcGxhY2VcclxuICAgICAgICAgICAgICAgICAgICBzZXRzVG9JZ25vcmUuc3BsaWNlKHNldHNUb0lnbm9yZS5pbmRleE9mKG9sZFdyaXRlSWQpLCAxKTtcclxuICAgICAgICAgICAgICAgICAgICBldmVudHMgPSBldmVudHMuY29uY2F0KHN5bmNUcmVlQXBwbHlVc2VyT3ZlcndyaXRlKHJlcG8uc2VydmVyU3luY1RyZWVfLCB0cmFuc2FjdGlvbi5wYXRoLCBuZXdOb2RlUmVzb2x2ZWQsIHRyYW5zYWN0aW9uLmN1cnJlbnRXcml0ZUlkLCB0cmFuc2FjdGlvbi5hcHBseUxvY2FsbHkpKTtcclxuICAgICAgICAgICAgICAgICAgICBldmVudHMgPSBldmVudHMuY29uY2F0KHN5bmNUcmVlQWNrVXNlcldyaXRlKHJlcG8uc2VydmVyU3luY1RyZWVfLCBvbGRXcml0ZUlkLCB0cnVlKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBhYm9ydFRyYW5zYWN0aW9uID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICBhYm9ydFJlYXNvbiA9ICdub2RhdGEnO1xyXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50cyA9IGV2ZW50cy5jb25jYXQoc3luY1RyZWVBY2tVc2VyV3JpdGUocmVwby5zZXJ2ZXJTeW5jVHJlZV8sIHRyYW5zYWN0aW9uLmN1cnJlbnRXcml0ZUlkLCB0cnVlKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZXZlbnRRdWV1ZVJhaXNlRXZlbnRzRm9yQ2hhbmdlZFBhdGgocmVwby5ldmVudFF1ZXVlXywgcGF0aCwgZXZlbnRzKTtcclxuICAgICAgICBldmVudHMgPSBbXTtcclxuICAgICAgICBpZiAoYWJvcnRUcmFuc2FjdGlvbikge1xyXG4gICAgICAgICAgICAvLyBBYm9ydC5cclxuICAgICAgICAgICAgcXVldWVbaV0uc3RhdHVzID0gMiAvKiBDT01QTEVURUQgKi87XHJcbiAgICAgICAgICAgIC8vIFJlbW92aW5nIGEgbGlzdGVuZXIgY2FuIHRyaWdnZXIgcHJ1bmluZyB3aGljaCBjYW4gbXVjayB3aXRoXHJcbiAgICAgICAgICAgIC8vIG1lcmdlZERhdGEvdmlzaWJsZURhdGEgKGFzIGl0IHBydW5lcyBkYXRhKS4gU28gZGVmZXIgdGhlIHVud2F0Y2hlclxyXG4gICAgICAgICAgICAvLyB1bnRpbCB3ZSdyZSBkb25lLlxyXG4gICAgICAgICAgICAoZnVuY3Rpb24gKHVud2F0Y2hlcikge1xyXG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCh1bndhdGNoZXIsIE1hdGguZmxvb3IoMCkpO1xyXG4gICAgICAgICAgICB9KShxdWV1ZVtpXS51bndhdGNoZXIpO1xyXG4gICAgICAgICAgICBpZiAocXVldWVbaV0ub25Db21wbGV0ZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGFib3J0UmVhc29uID09PSAnbm9kYXRhJykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrcy5wdXNoKCgpID0+IHF1ZXVlW2ldLm9uQ29tcGxldGUobnVsbCwgZmFsc2UsIHF1ZXVlW2ldLmN1cnJlbnRJbnB1dFNuYXBzaG90KSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFja3MucHVzaCgoKSA9PiBxdWV1ZVtpXS5vbkNvbXBsZXRlKG5ldyBFcnJvcihhYm9ydFJlYXNvbiksIGZhbHNlLCBudWxsKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBDbGVhbiB1cCBjb21wbGV0ZWQgdHJhbnNhY3Rpb25zLlxyXG4gICAgcmVwb1BydW5lQ29tcGxldGVkVHJhbnNhY3Rpb25zQmVsb3dOb2RlKHJlcG8sIHJlcG8udHJhbnNhY3Rpb25RdWV1ZVRyZWVfKTtcclxuICAgIC8vIE5vdyBmaXJlIGNhbGxiYWNrcywgbm93IHRoYXQgd2UncmUgaW4gYSBnb29kLCBrbm93biBzdGF0ZS5cclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2FsbGJhY2tzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgZXhjZXB0aW9uR3VhcmQoY2FsbGJhY2tzW2ldKTtcclxuICAgIH1cclxuICAgIC8vIFRyeSB0byBzZW5kIHRoZSB0cmFuc2FjdGlvbiByZXN1bHQgdG8gdGhlIHNlcnZlci5cclxuICAgIHJlcG9TZW5kUmVhZHlUcmFuc2FjdGlvbnMocmVwbywgcmVwby50cmFuc2FjdGlvblF1ZXVlVHJlZV8pO1xyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSByb290bW9zdCBhbmNlc3RvciBub2RlIG9mIHRoZSBzcGVjaWZpZWQgcGF0aCB0aGF0IGhhcyBhIHBlbmRpbmdcclxuICogdHJhbnNhY3Rpb24gb24gaXQsIG9yIGp1c3QgcmV0dXJucyB0aGUgbm9kZSBmb3IgdGhlIGdpdmVuIHBhdGggaWYgdGhlcmUgYXJlXHJcbiAqIG5vIHBlbmRpbmcgdHJhbnNhY3Rpb25zIG9uIGFueSBhbmNlc3Rvci5cclxuICpcclxuICogQHBhcmFtIHBhdGggLSBUaGUgbG9jYXRpb24gdG8gc3RhcnQgYXQuXHJcbiAqIEByZXR1cm5zIFRoZSByb290bW9zdCBub2RlIHdpdGggYSB0cmFuc2FjdGlvbi5cclxuICovXHJcbmZ1bmN0aW9uIHJlcG9HZXRBbmNlc3RvclRyYW5zYWN0aW9uTm9kZShyZXBvLCBwYXRoKSB7XHJcbiAgICBsZXQgZnJvbnQ7XHJcbiAgICAvLyBTdGFydCBhdCB0aGUgcm9vdCBhbmQgd2FsayBkZWVwZXIgaW50byB0aGUgdHJlZSB0b3dhcmRzIHBhdGggdW50aWwgd2VcclxuICAgIC8vIGZpbmQgYSBub2RlIHdpdGggcGVuZGluZyB0cmFuc2FjdGlvbnMuXHJcbiAgICBsZXQgdHJhbnNhY3Rpb25Ob2RlID0gcmVwby50cmFuc2FjdGlvblF1ZXVlVHJlZV87XHJcbiAgICBmcm9udCA9IHBhdGhHZXRGcm9udChwYXRoKTtcclxuICAgIHdoaWxlIChmcm9udCAhPT0gbnVsbCAmJiB0cmVlR2V0VmFsdWUodHJhbnNhY3Rpb25Ob2RlKSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgdHJhbnNhY3Rpb25Ob2RlID0gdHJlZVN1YlRyZWUodHJhbnNhY3Rpb25Ob2RlLCBmcm9udCk7XHJcbiAgICAgICAgcGF0aCA9IHBhdGhQb3BGcm9udChwYXRoKTtcclxuICAgICAgICBmcm9udCA9IHBhdGhHZXRGcm9udChwYXRoKTtcclxuICAgIH1cclxuICAgIHJldHVybiB0cmFuc2FjdGlvbk5vZGU7XHJcbn1cclxuLyoqXHJcbiAqIEJ1aWxkcyB0aGUgcXVldWUgb2YgYWxsIHRyYW5zYWN0aW9ucyBhdCBvciBiZWxvdyB0aGUgc3BlY2lmaWVkXHJcbiAqIHRyYW5zYWN0aW9uTm9kZS5cclxuICpcclxuICogQHBhcmFtIHRyYW5zYWN0aW9uTm9kZVxyXG4gKiBAcmV0dXJucyBUaGUgZ2VuZXJhdGVkIHF1ZXVlLlxyXG4gKi9cclxuZnVuY3Rpb24gcmVwb0J1aWxkVHJhbnNhY3Rpb25RdWV1ZShyZXBvLCB0cmFuc2FjdGlvbk5vZGUpIHtcclxuICAgIC8vIFdhbGsgYW55IGNoaWxkIHRyYW5zYWN0aW9uIHF1ZXVlcyBhbmQgYWdncmVnYXRlIHRoZW0gaW50byBhIHNpbmdsZSBxdWV1ZS5cclxuICAgIGNvbnN0IHRyYW5zYWN0aW9uUXVldWUgPSBbXTtcclxuICAgIHJlcG9BZ2dyZWdhdGVUcmFuc2FjdGlvblF1ZXVlc0Zvck5vZGUocmVwbywgdHJhbnNhY3Rpb25Ob2RlLCB0cmFuc2FjdGlvblF1ZXVlKTtcclxuICAgIC8vIFNvcnQgdGhlbSBieSB0aGUgb3JkZXIgdGhlIHRyYW5zYWN0aW9ucyB3ZXJlIGNyZWF0ZWQuXHJcbiAgICB0cmFuc2FjdGlvblF1ZXVlLnNvcnQoKGEsIGIpID0+IGEub3JkZXIgLSBiLm9yZGVyKTtcclxuICAgIHJldHVybiB0cmFuc2FjdGlvblF1ZXVlO1xyXG59XHJcbmZ1bmN0aW9uIHJlcG9BZ2dyZWdhdGVUcmFuc2FjdGlvblF1ZXVlc0Zvck5vZGUocmVwbywgbm9kZSwgcXVldWUpIHtcclxuICAgIGNvbnN0IG5vZGVRdWV1ZSA9IHRyZWVHZXRWYWx1ZShub2RlKTtcclxuICAgIGlmIChub2RlUXVldWUpIHtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGVRdWV1ZS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBxdWV1ZS5wdXNoKG5vZGVRdWV1ZVtpXSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgdHJlZUZvckVhY2hDaGlsZChub2RlLCBjaGlsZCA9PiB7XHJcbiAgICAgICAgcmVwb0FnZ3JlZ2F0ZVRyYW5zYWN0aW9uUXVldWVzRm9yTm9kZShyZXBvLCBjaGlsZCwgcXVldWUpO1xyXG4gICAgfSk7XHJcbn1cclxuLyoqXHJcbiAqIFJlbW92ZSBDT01QTEVURUQgdHJhbnNhY3Rpb25zIGF0IG9yIGJlbG93IHRoaXMgbm9kZSBpbiB0aGUgdHJhbnNhY3Rpb25RdWV1ZVRyZWVfLlxyXG4gKi9cclxuZnVuY3Rpb24gcmVwb1BydW5lQ29tcGxldGVkVHJhbnNhY3Rpb25zQmVsb3dOb2RlKHJlcG8sIG5vZGUpIHtcclxuICAgIGNvbnN0IHF1ZXVlID0gdHJlZUdldFZhbHVlKG5vZGUpO1xyXG4gICAgaWYgKHF1ZXVlKSB7XHJcbiAgICAgICAgbGV0IHRvID0gMDtcclxuICAgICAgICBmb3IgKGxldCBmcm9tID0gMDsgZnJvbSA8IHF1ZXVlLmxlbmd0aDsgZnJvbSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChxdWV1ZVtmcm9tXS5zdGF0dXMgIT09IDIgLyogQ09NUExFVEVEICovKSB7XHJcbiAgICAgICAgICAgICAgICBxdWV1ZVt0b10gPSBxdWV1ZVtmcm9tXTtcclxuICAgICAgICAgICAgICAgIHRvKys7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcXVldWUubGVuZ3RoID0gdG87XHJcbiAgICAgICAgdHJlZVNldFZhbHVlKG5vZGUsIHF1ZXVlLmxlbmd0aCA+IDAgPyBxdWV1ZSA6IHVuZGVmaW5lZCk7XHJcbiAgICB9XHJcbiAgICB0cmVlRm9yRWFjaENoaWxkKG5vZGUsIGNoaWxkTm9kZSA9PiB7XHJcbiAgICAgICAgcmVwb1BydW5lQ29tcGxldGVkVHJhbnNhY3Rpb25zQmVsb3dOb2RlKHJlcG8sIGNoaWxkTm9kZSk7XHJcbiAgICB9KTtcclxufVxyXG4vKipcclxuICogQWJvcnRzIGFsbCB0cmFuc2FjdGlvbnMgb24gYW5jZXN0b3JzIG9yIGRlc2NlbmRhbnRzIG9mIHRoZSBzcGVjaWZpZWQgcGF0aC5cclxuICogQ2FsbGVkIHdoZW4gZG9pbmcgYSBzZXQoKSBvciB1cGRhdGUoKSBzaW5jZSB3ZSBjb25zaWRlciB0aGVtIGluY29tcGF0aWJsZVxyXG4gKiB3aXRoIHRyYW5zYWN0aW9ucy5cclxuICpcclxuICogQHBhcmFtIHBhdGggLSBQYXRoIGZvciB3aGljaCB3ZSB3YW50IHRvIGFib3J0IHJlbGF0ZWQgdHJhbnNhY3Rpb25zLlxyXG4gKi9cclxuZnVuY3Rpb24gcmVwb0Fib3J0VHJhbnNhY3Rpb25zKHJlcG8sIHBhdGgpIHtcclxuICAgIGNvbnN0IGFmZmVjdGVkUGF0aCA9IHRyZWVHZXRQYXRoKHJlcG9HZXRBbmNlc3RvclRyYW5zYWN0aW9uTm9kZShyZXBvLCBwYXRoKSk7XHJcbiAgICBjb25zdCB0cmFuc2FjdGlvbk5vZGUgPSB0cmVlU3ViVHJlZShyZXBvLnRyYW5zYWN0aW9uUXVldWVUcmVlXywgcGF0aCk7XHJcbiAgICB0cmVlRm9yRWFjaEFuY2VzdG9yKHRyYW5zYWN0aW9uTm9kZSwgKG5vZGUpID0+IHtcclxuICAgICAgICByZXBvQWJvcnRUcmFuc2FjdGlvbnNPbk5vZGUocmVwbywgbm9kZSk7XHJcbiAgICB9KTtcclxuICAgIHJlcG9BYm9ydFRyYW5zYWN0aW9uc09uTm9kZShyZXBvLCB0cmFuc2FjdGlvbk5vZGUpO1xyXG4gICAgdHJlZUZvckVhY2hEZXNjZW5kYW50KHRyYW5zYWN0aW9uTm9kZSwgKG5vZGUpID0+IHtcclxuICAgICAgICByZXBvQWJvcnRUcmFuc2FjdGlvbnNPbk5vZGUocmVwbywgbm9kZSk7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBhZmZlY3RlZFBhdGg7XHJcbn1cclxuLyoqXHJcbiAqIEFib3J0IHRyYW5zYWN0aW9ucyBzdG9yZWQgaW4gdGhpcyB0cmFuc2FjdGlvbiBxdWV1ZSBub2RlLlxyXG4gKlxyXG4gKiBAcGFyYW0gbm9kZSAtIE5vZGUgdG8gYWJvcnQgdHJhbnNhY3Rpb25zIGZvci5cclxuICovXHJcbmZ1bmN0aW9uIHJlcG9BYm9ydFRyYW5zYWN0aW9uc09uTm9kZShyZXBvLCBub2RlKSB7XHJcbiAgICBjb25zdCBxdWV1ZSA9IHRyZWVHZXRWYWx1ZShub2RlKTtcclxuICAgIGlmIChxdWV1ZSkge1xyXG4gICAgICAgIC8vIFF1ZXVlIHVwIHRoZSBjYWxsYmFja3MgYW5kIGZpcmUgdGhlbSBhZnRlciBjbGVhbmluZyB1cCBhbGwgb2Ygb3VyXHJcbiAgICAgICAgLy8gdHJhbnNhY3Rpb24gc3RhdGUsIHNpbmNlIHRoZSBjYWxsYmFjayBjb3VsZCB0cmlnZ2VyIG1vcmUgdHJhbnNhY3Rpb25zXHJcbiAgICAgICAgLy8gb3Igc2V0cy5cclxuICAgICAgICBjb25zdCBjYWxsYmFja3MgPSBbXTtcclxuICAgICAgICAvLyBHbyB0aHJvdWdoIHF1ZXVlLiAgQW55IGFscmVhZHktc2VudCB0cmFuc2FjdGlvbnMgbXVzdCBiZSBtYXJrZWQgZm9yXHJcbiAgICAgICAgLy8gYWJvcnQsIHdoaWxlIHRoZSB1bnNlbnQgb25lcyBjYW4gYmUgaW1tZWRpYXRlbHkgYWJvcnRlZCBhbmQgcmVtb3ZlZC5cclxuICAgICAgICBsZXQgZXZlbnRzID0gW107XHJcbiAgICAgICAgbGV0IGxhc3RTZW50ID0gLTE7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBxdWV1ZS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAocXVldWVbaV0uc3RhdHVzID09PSAzIC8qIFNFTlRfTkVFRFNfQUJPUlQgKi8pIDtcclxuICAgICAgICAgICAgZWxzZSBpZiAocXVldWVbaV0uc3RhdHVzID09PSAxIC8qIFNFTlQgKi8pIHtcclxuICAgICAgICAgICAgICAgIGFzc2VydChsYXN0U2VudCA9PT0gaSAtIDEsICdBbGwgU0VOVCBpdGVtcyBzaG91bGQgYmUgYXQgYmVnaW5uaW5nIG9mIHF1ZXVlLicpO1xyXG4gICAgICAgICAgICAgICAgbGFzdFNlbnQgPSBpO1xyXG4gICAgICAgICAgICAgICAgLy8gTWFyayB0cmFuc2FjdGlvbiBmb3IgYWJvcnQgd2hlbiBpdCBjb21lcyBiYWNrLlxyXG4gICAgICAgICAgICAgICAgcXVldWVbaV0uc3RhdHVzID0gMyAvKiBTRU5UX05FRURTX0FCT1JUICovO1xyXG4gICAgICAgICAgICAgICAgcXVldWVbaV0uYWJvcnRSZWFzb24gPSAnc2V0JztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGFzc2VydChxdWV1ZVtpXS5zdGF0dXMgPT09IDAgLyogUlVOICovLCAnVW5leHBlY3RlZCB0cmFuc2FjdGlvbiBzdGF0dXMgaW4gYWJvcnQnKTtcclxuICAgICAgICAgICAgICAgIC8vIFdlIGNhbiBhYm9ydCBpdCBpbW1lZGlhdGVseS5cclxuICAgICAgICAgICAgICAgIHF1ZXVlW2ldLnVud2F0Y2hlcigpO1xyXG4gICAgICAgICAgICAgICAgZXZlbnRzID0gZXZlbnRzLmNvbmNhdChzeW5jVHJlZUFja1VzZXJXcml0ZShyZXBvLnNlcnZlclN5bmNUcmVlXywgcXVldWVbaV0uY3VycmVudFdyaXRlSWQsIHRydWUpKTtcclxuICAgICAgICAgICAgICAgIGlmIChxdWV1ZVtpXS5vbkNvbXBsZXRlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2tzLnB1c2gocXVldWVbaV0ub25Db21wbGV0ZS5iaW5kKG51bGwsIG5ldyBFcnJvcignc2V0JyksIGZhbHNlLCBudWxsKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGxhc3RTZW50ID09PSAtMSkge1xyXG4gICAgICAgICAgICAvLyBXZSdyZSBub3Qgd2FpdGluZyBmb3IgYW55IHNlbnQgdHJhbnNhY3Rpb25zLiAgV2UgY2FuIGNsZWFyIHRoZSBxdWV1ZS5cclxuICAgICAgICAgICAgdHJlZVNldFZhbHVlKG5vZGUsIHVuZGVmaW5lZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBSZW1vdmUgdGhlIHRyYW5zYWN0aW9ucyB3ZSBhYm9ydGVkLlxyXG4gICAgICAgICAgICBxdWV1ZS5sZW5ndGggPSBsYXN0U2VudCArIDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIE5vdyBmaXJlIHRoZSBjYWxsYmFja3MuXHJcbiAgICAgICAgZXZlbnRRdWV1ZVJhaXNlRXZlbnRzRm9yQ2hhbmdlZFBhdGgocmVwby5ldmVudFF1ZXVlXywgdHJlZUdldFBhdGgobm9kZSksIGV2ZW50cyk7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjYWxsYmFja3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgZXhjZXB0aW9uR3VhcmQoY2FsbGJhY2tzW2ldKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuZnVuY3Rpb24gZGVjb2RlUGF0aChwYXRoU3RyaW5nKSB7XHJcbiAgICBsZXQgcGF0aFN0cmluZ0RlY29kZWQgPSAnJztcclxuICAgIGNvbnN0IHBpZWNlcyA9IHBhdGhTdHJpbmcuc3BsaXQoJy8nKTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGllY2VzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgaWYgKHBpZWNlc1tpXS5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIGxldCBwaWVjZSA9IHBpZWNlc1tpXTtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIHBpZWNlID0gZGVjb2RlVVJJQ29tcG9uZW50KHBpZWNlLnJlcGxhY2UoL1xcKy9nLCAnICcpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoZSkgeyB9XHJcbiAgICAgICAgICAgIHBhdGhTdHJpbmdEZWNvZGVkICs9ICcvJyArIHBpZWNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBwYXRoU3RyaW5nRGVjb2RlZDtcclxufVxyXG4vKipcclxuICogQHJldHVybnMga2V5IHZhbHVlIGhhc2hcclxuICovXHJcbmZ1bmN0aW9uIGRlY29kZVF1ZXJ5KHF1ZXJ5U3RyaW5nKSB7XHJcbiAgICBjb25zdCByZXN1bHRzID0ge307XHJcbiAgICBpZiAocXVlcnlTdHJpbmcuY2hhckF0KDApID09PSAnPycpIHtcclxuICAgICAgICBxdWVyeVN0cmluZyA9IHF1ZXJ5U3RyaW5nLnN1YnN0cmluZygxKTtcclxuICAgIH1cclxuICAgIGZvciAoY29uc3Qgc2VnbWVudCBvZiBxdWVyeVN0cmluZy5zcGxpdCgnJicpKSB7XHJcbiAgICAgICAgaWYgKHNlZ21lbnQubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBrdiA9IHNlZ21lbnQuc3BsaXQoJz0nKTtcclxuICAgICAgICBpZiAoa3YubGVuZ3RoID09PSAyKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdHNbZGVjb2RlVVJJQ29tcG9uZW50KGt2WzBdKV0gPSBkZWNvZGVVUklDb21wb25lbnQoa3ZbMV0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgd2FybihgSW52YWxpZCBxdWVyeSBzZWdtZW50ICcke3NlZ21lbnR9JyBpbiBxdWVyeSAnJHtxdWVyeVN0cmluZ30nYCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc3VsdHM7XHJcbn1cclxuY29uc3QgcGFyc2VSZXBvSW5mbyA9IGZ1bmN0aW9uIChkYXRhVVJMLCBub2RlQWRtaW4pIHtcclxuICAgIGNvbnN0IHBhcnNlZFVybCA9IHBhcnNlRGF0YWJhc2VVUkwoZGF0YVVSTCksIG5hbWVzcGFjZSA9IHBhcnNlZFVybC5uYW1lc3BhY2U7XHJcbiAgICBpZiAocGFyc2VkVXJsLmRvbWFpbiA9PT0gJ2ZpcmViYXNlLmNvbScpIHtcclxuICAgICAgICBmYXRhbChwYXJzZWRVcmwuaG9zdCArXHJcbiAgICAgICAgICAgICcgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZC4gJyArXHJcbiAgICAgICAgICAgICdQbGVhc2UgdXNlIDxZT1VSIEZJUkVCQVNFPi5maXJlYmFzZWlvLmNvbSBpbnN0ZWFkJyk7XHJcbiAgICB9XHJcbiAgICAvLyBDYXRjaCBjb21tb24gZXJyb3Igb2YgdW5pbml0aWFsaXplZCBuYW1lc3BhY2UgdmFsdWUuXHJcbiAgICBpZiAoKCFuYW1lc3BhY2UgfHwgbmFtZXNwYWNlID09PSAndW5kZWZpbmVkJykgJiZcclxuICAgICAgICBwYXJzZWRVcmwuZG9tYWluICE9PSAnbG9jYWxob3N0Jykge1xyXG4gICAgICAgIGZhdGFsKCdDYW5ub3QgcGFyc2UgRmlyZWJhc2UgdXJsLiBQbGVhc2UgdXNlIGh0dHBzOi8vPFlPVVIgRklSRUJBU0U+LmZpcmViYXNlaW8uY29tJyk7XHJcbiAgICB9XHJcbiAgICBpZiAoIXBhcnNlZFVybC5zZWN1cmUpIHtcclxuICAgICAgICB3YXJuSWZQYWdlSXNTZWN1cmUoKTtcclxuICAgIH1cclxuICAgIGNvbnN0IHdlYlNvY2tldE9ubHkgPSBwYXJzZWRVcmwuc2NoZW1lID09PSAnd3MnIHx8IHBhcnNlZFVybC5zY2hlbWUgPT09ICd3c3MnO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICByZXBvSW5mbzogbmV3IFJlcG9JbmZvKHBhcnNlZFVybC5ob3N0LCBwYXJzZWRVcmwuc2VjdXJlLCBuYW1lc3BhY2UsIG5vZGVBZG1pbiwgd2ViU29ja2V0T25seSwgXHJcbiAgICAgICAgLypwZXJzaXN0ZW5jZUtleT0qLyAnJywgXHJcbiAgICAgICAgLyppbmNsdWRlTmFtZXNwYWNlSW5RdWVyeVBhcmFtcz0qLyBuYW1lc3BhY2UgIT09IHBhcnNlZFVybC5zdWJkb21haW4pLFxyXG4gICAgICAgIHBhdGg6IG5ldyBQYXRoKHBhcnNlZFVybC5wYXRoU3RyaW5nKVxyXG4gICAgfTtcclxufTtcclxuY29uc3QgcGFyc2VEYXRhYmFzZVVSTCA9IGZ1bmN0aW9uIChkYXRhVVJMKSB7XHJcbiAgICAvLyBEZWZhdWx0IHRvIGVtcHR5IHN0cmluZ3MgaW4gdGhlIGV2ZW50IG9mIGEgbWFsZm9ybWVkIHN0cmluZy5cclxuICAgIGxldCBob3N0ID0gJycsIGRvbWFpbiA9ICcnLCBzdWJkb21haW4gPSAnJywgcGF0aFN0cmluZyA9ICcnLCBuYW1lc3BhY2UgPSAnJztcclxuICAgIC8vIEFsd2F5cyBkZWZhdWx0IHRvIFNTTCwgdW5sZXNzIG90aGVyd2lzZSBzcGVjaWZpZWQuXHJcbiAgICBsZXQgc2VjdXJlID0gdHJ1ZSwgc2NoZW1lID0gJ2h0dHBzJywgcG9ydCA9IDQ0MztcclxuICAgIC8vIERvbid0IGRvIGFueSB2YWxpZGF0aW9uIGhlcmUuIFRoZSBjYWxsZXIgaXMgcmVzcG9uc2libGUgZm9yIHZhbGlkYXRpbmcgdGhlIHJlc3VsdCBvZiBwYXJzaW5nLlxyXG4gICAgaWYgKHR5cGVvZiBkYXRhVVJMID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgIC8vIFBhcnNlIHNjaGVtZS5cclxuICAgICAgICBsZXQgY29sb25JbmQgPSBkYXRhVVJMLmluZGV4T2YoJy8vJyk7XHJcbiAgICAgICAgaWYgKGNvbG9uSW5kID49IDApIHtcclxuICAgICAgICAgICAgc2NoZW1lID0gZGF0YVVSTC5zdWJzdHJpbmcoMCwgY29sb25JbmQgLSAxKTtcclxuICAgICAgICAgICAgZGF0YVVSTCA9IGRhdGFVUkwuc3Vic3RyaW5nKGNvbG9uSW5kICsgMik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFBhcnNlIGhvc3QsIHBhdGgsIGFuZCBxdWVyeSBzdHJpbmcuXHJcbiAgICAgICAgbGV0IHNsYXNoSW5kID0gZGF0YVVSTC5pbmRleE9mKCcvJyk7XHJcbiAgICAgICAgaWYgKHNsYXNoSW5kID09PSAtMSkge1xyXG4gICAgICAgICAgICBzbGFzaEluZCA9IGRhdGFVUkwubGVuZ3RoO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgcXVlc3Rpb25NYXJrSW5kID0gZGF0YVVSTC5pbmRleE9mKCc/Jyk7XHJcbiAgICAgICAgaWYgKHF1ZXN0aW9uTWFya0luZCA9PT0gLTEpIHtcclxuICAgICAgICAgICAgcXVlc3Rpb25NYXJrSW5kID0gZGF0YVVSTC5sZW5ndGg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGhvc3QgPSBkYXRhVVJMLnN1YnN0cmluZygwLCBNYXRoLm1pbihzbGFzaEluZCwgcXVlc3Rpb25NYXJrSW5kKSk7XHJcbiAgICAgICAgaWYgKHNsYXNoSW5kIDwgcXVlc3Rpb25NYXJrSW5kKSB7XHJcbiAgICAgICAgICAgIC8vIEZvciBwYXRoU3RyaW5nLCBxdWVzdGlvbk1hcmtJbmQgd2lsbCBhbHdheXMgY29tZSBhZnRlciBzbGFzaEluZFxyXG4gICAgICAgICAgICBwYXRoU3RyaW5nID0gZGVjb2RlUGF0aChkYXRhVVJMLnN1YnN0cmluZyhzbGFzaEluZCwgcXVlc3Rpb25NYXJrSW5kKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1zID0gZGVjb2RlUXVlcnkoZGF0YVVSTC5zdWJzdHJpbmcoTWF0aC5taW4oZGF0YVVSTC5sZW5ndGgsIHF1ZXN0aW9uTWFya0luZCkpKTtcclxuICAgICAgICAvLyBJZiB3ZSBoYXZlIGEgcG9ydCwgdXNlIHNjaGVtZSBmb3IgZGV0ZXJtaW5pbmcgaWYgaXQncyBzZWN1cmUuXHJcbiAgICAgICAgY29sb25JbmQgPSBob3N0LmluZGV4T2YoJzonKTtcclxuICAgICAgICBpZiAoY29sb25JbmQgPj0gMCkge1xyXG4gICAgICAgICAgICBzZWN1cmUgPSBzY2hlbWUgPT09ICdodHRwcycgfHwgc2NoZW1lID09PSAnd3NzJztcclxuICAgICAgICAgICAgcG9ydCA9IHBhcnNlSW50KGhvc3Quc3Vic3RyaW5nKGNvbG9uSW5kICsgMSksIDEwKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbG9uSW5kID0gaG9zdC5sZW5ndGg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGhvc3RXaXRob3V0UG9ydCA9IGhvc3Quc2xpY2UoMCwgY29sb25JbmQpO1xyXG4gICAgICAgIGlmIChob3N0V2l0aG91dFBvcnQudG9Mb3dlckNhc2UoKSA9PT0gJ2xvY2FsaG9zdCcpIHtcclxuICAgICAgICAgICAgZG9tYWluID0gJ2xvY2FsaG9zdCc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGhvc3RXaXRob3V0UG9ydC5zcGxpdCgnLicpLmxlbmd0aCA8PSAyKSB7XHJcbiAgICAgICAgICAgIGRvbWFpbiA9IGhvc3RXaXRob3V0UG9ydDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIEludGVycHJldCB0aGUgc3ViZG9tYWluIG9mIGEgMyBvciBtb3JlIGNvbXBvbmVudCBVUkwgYXMgdGhlIG5hbWVzcGFjZSBuYW1lLlxyXG4gICAgICAgICAgICBjb25zdCBkb3RJbmQgPSBob3N0LmluZGV4T2YoJy4nKTtcclxuICAgICAgICAgICAgc3ViZG9tYWluID0gaG9zdC5zdWJzdHJpbmcoMCwgZG90SW5kKS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgICAgICBkb21haW4gPSBob3N0LnN1YnN0cmluZyhkb3RJbmQgKyAxKTtcclxuICAgICAgICAgICAgLy8gTm9ybWFsaXplIG5hbWVzcGFjZXMgdG8gbG93ZXJjYXNlIHRvIHNoYXJlIHN0b3JhZ2UgLyBjb25uZWN0aW9uLlxyXG4gICAgICAgICAgICBuYW1lc3BhY2UgPSBzdWJkb21haW47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEFsd2F5cyB0cmVhdCB0aGUgdmFsdWUgb2YgdGhlIGBuc2AgYXMgdGhlIG5hbWVzcGFjZSBuYW1lIGlmIGl0IGlzIHByZXNlbnQuXHJcbiAgICAgICAgaWYgKCducycgaW4gcXVlcnlQYXJhbXMpIHtcclxuICAgICAgICAgICAgbmFtZXNwYWNlID0gcXVlcnlQYXJhbXNbJ25zJ107XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBob3N0LFxyXG4gICAgICAgIHBvcnQsXHJcbiAgICAgICAgZG9tYWluLFxyXG4gICAgICAgIHN1YmRvbWFpbixcclxuICAgICAgICBzZWN1cmUsXHJcbiAgICAgICAgc2NoZW1lLFxyXG4gICAgICAgIHBhdGhTdHJpbmcsXHJcbiAgICAgICAgbmFtZXNwYWNlXHJcbiAgICB9O1xyXG59O1xuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogRW5jYXBzdWxhdGVzIHRoZSBkYXRhIG5lZWRlZCB0byByYWlzZSBhbiBldmVudFxyXG4gKi9cclxuY2xhc3MgRGF0YUV2ZW50IHtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIGV2ZW50VHlwZSAtIE9uZSBvZjogdmFsdWUsIGNoaWxkX2FkZGVkLCBjaGlsZF9jaGFuZ2VkLCBjaGlsZF9tb3ZlZCwgY2hpbGRfcmVtb3ZlZFxyXG4gICAgICogQHBhcmFtIGV2ZW50UmVnaXN0cmF0aW9uIC0gVGhlIGZ1bmN0aW9uIHRvIGNhbGwgdG8gd2l0aCB0aGUgZXZlbnQgZGF0YS4gVXNlciBwcm92aWRlZFxyXG4gICAgICogQHBhcmFtIHNuYXBzaG90IC0gVGhlIGRhdGEgYmFja2luZyB0aGUgZXZlbnRcclxuICAgICAqIEBwYXJhbSBwcmV2TmFtZSAtIE9wdGlvbmFsLCB0aGUgbmFtZSBvZiB0aGUgcHJldmlvdXMgY2hpbGQgZm9yIGNoaWxkXyogZXZlbnRzLlxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihldmVudFR5cGUsIGV2ZW50UmVnaXN0cmF0aW9uLCBzbmFwc2hvdCwgcHJldk5hbWUpIHtcclxuICAgICAgICB0aGlzLmV2ZW50VHlwZSA9IGV2ZW50VHlwZTtcclxuICAgICAgICB0aGlzLmV2ZW50UmVnaXN0cmF0aW9uID0gZXZlbnRSZWdpc3RyYXRpb247XHJcbiAgICAgICAgdGhpcy5zbmFwc2hvdCA9IHNuYXBzaG90O1xyXG4gICAgICAgIHRoaXMucHJldk5hbWUgPSBwcmV2TmFtZTtcclxuICAgIH1cclxuICAgIGdldFBhdGgoKSB7XHJcbiAgICAgICAgY29uc3QgcmVmID0gdGhpcy5zbmFwc2hvdC5yZWY7XHJcbiAgICAgICAgaWYgKHRoaXMuZXZlbnRUeXBlID09PSAndmFsdWUnKSB7XHJcbiAgICAgICAgICAgIHJldHVybiByZWYuX3BhdGg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gcmVmLnBhcmVudC5fcGF0aDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBnZXRFdmVudFR5cGUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZXZlbnRUeXBlO1xyXG4gICAgfVxyXG4gICAgZ2V0RXZlbnRSdW5uZXIoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZXZlbnRSZWdpc3RyYXRpb24uZ2V0RXZlbnRSdW5uZXIodGhpcyk7XHJcbiAgICB9XHJcbiAgICB0b1N0cmluZygpIHtcclxuICAgICAgICByZXR1cm4gKHRoaXMuZ2V0UGF0aCgpLnRvU3RyaW5nKCkgK1xyXG4gICAgICAgICAgICAnOicgK1xyXG4gICAgICAgICAgICB0aGlzLmV2ZW50VHlwZSArXHJcbiAgICAgICAgICAgICc6JyArXHJcbiAgICAgICAgICAgIHN0cmluZ2lmeSh0aGlzLnNuYXBzaG90LmV4cG9ydFZhbCgpKSk7XHJcbiAgICB9XHJcbn1cclxuY2xhc3MgQ2FuY2VsRXZlbnQge1xyXG4gICAgY29uc3RydWN0b3IoZXZlbnRSZWdpc3RyYXRpb24sIGVycm9yLCBwYXRoKSB7XHJcbiAgICAgICAgdGhpcy5ldmVudFJlZ2lzdHJhdGlvbiA9IGV2ZW50UmVnaXN0cmF0aW9uO1xyXG4gICAgICAgIHRoaXMuZXJyb3IgPSBlcnJvcjtcclxuICAgICAgICB0aGlzLnBhdGggPSBwYXRoO1xyXG4gICAgfVxyXG4gICAgZ2V0UGF0aCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5wYXRoO1xyXG4gICAgfVxyXG4gICAgZ2V0RXZlbnRUeXBlKCkge1xyXG4gICAgICAgIHJldHVybiAnY2FuY2VsJztcclxuICAgIH1cclxuICAgIGdldEV2ZW50UnVubmVyKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmV2ZW50UmVnaXN0cmF0aW9uLmdldEV2ZW50UnVubmVyKHRoaXMpO1xyXG4gICAgfVxyXG4gICAgdG9TdHJpbmcoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucGF0aC50b1N0cmluZygpICsgJzpjYW5jZWwnO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBBIHdyYXBwZXIgY2xhc3MgdGhhdCBjb252ZXJ0cyBldmVudHMgZnJvbSB0aGUgZGF0YWJhc2VAZXhwIFNESyB0byB0aGUgbGVnYWN5XHJcbiAqIERhdGFiYXNlIFNESy4gRXZlbnRzIGFyZSBub3QgY29udmVydGVkIGRpcmVjdGx5IGFzIGV2ZW50IHJlZ2lzdHJhdGlvbiByZWxpZXNcclxuICogb24gcmVmZXJlbmNlIGNvbXBhcmlzb24gb2YgdGhlIG9yaWdpbmFsIHVzZXIgY2FsbGJhY2sgKHNlZSBgbWF0Y2hlcygpYCkgYW5kXHJcbiAqIHJlbGllcyBvbiBlcXVhbGl0eSBvZiB0aGUgbGVnYWN5IFNESydzIGBjb250ZXh0YCBvYmplY3QuXHJcbiAqL1xyXG5jbGFzcyBDYWxsYmFja0NvbnRleHQge1xyXG4gICAgY29uc3RydWN0b3Ioc25hcHNob3RDYWxsYmFjaywgY2FuY2VsQ2FsbGJhY2spIHtcclxuICAgICAgICB0aGlzLnNuYXBzaG90Q2FsbGJhY2sgPSBzbmFwc2hvdENhbGxiYWNrO1xyXG4gICAgICAgIHRoaXMuY2FuY2VsQ2FsbGJhY2sgPSBjYW5jZWxDYWxsYmFjaztcclxuICAgIH1cclxuICAgIG9uVmFsdWUoZXhwRGF0YVNuYXBzaG90LCBwcmV2aW91c0NoaWxkTmFtZSkge1xyXG4gICAgICAgIHRoaXMuc25hcHNob3RDYWxsYmFjay5jYWxsKG51bGwsIGV4cERhdGFTbmFwc2hvdCwgcHJldmlvdXNDaGlsZE5hbWUpO1xyXG4gICAgfVxyXG4gICAgb25DYW5jZWwoZXJyb3IpIHtcclxuICAgICAgICBhc3NlcnQodGhpcy5oYXNDYW5jZWxDYWxsYmFjaywgJ1JhaXNpbmcgYSBjYW5jZWwgZXZlbnQgb24gYSBsaXN0ZW5lciB3aXRoIG5vIGNhbmNlbCBjYWxsYmFjaycpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNhbmNlbENhbGxiYWNrLmNhbGwobnVsbCwgZXJyb3IpO1xyXG4gICAgfVxyXG4gICAgZ2V0IGhhc0NhbmNlbENhbGxiYWNrKCkge1xyXG4gICAgICAgIHJldHVybiAhIXRoaXMuY2FuY2VsQ2FsbGJhY2s7XHJcbiAgICB9XHJcbiAgICBtYXRjaGVzKG90aGVyKSB7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLnNuYXBzaG90Q2FsbGJhY2sgPT09IG90aGVyLnNuYXBzaG90Q2FsbGJhY2sgfHxcclxuICAgICAgICAgICAgKHRoaXMuc25hcHNob3RDYWxsYmFjay51c2VyQ2FsbGJhY2sgIT09IHVuZGVmaW5lZCAmJlxyXG4gICAgICAgICAgICAgICAgdGhpcy5zbmFwc2hvdENhbGxiYWNrLnVzZXJDYWxsYmFjayA9PT1cclxuICAgICAgICAgICAgICAgICAgICBvdGhlci5zbmFwc2hvdENhbGxiYWNrLnVzZXJDYWxsYmFjayAmJlxyXG4gICAgICAgICAgICAgICAgdGhpcy5zbmFwc2hvdENhbGxiYWNrLmNvbnRleHQgPT09IG90aGVyLnNuYXBzaG90Q2FsbGJhY2suY29udGV4dCkpO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMSBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBUaGUgYG9uRGlzY29ubmVjdGAgY2xhc3MgYWxsb3dzIHlvdSB0byB3cml0ZSBvciBjbGVhciBkYXRhIHdoZW4geW91ciBjbGllbnRcclxuICogZGlzY29ubmVjdHMgZnJvbSB0aGUgRGF0YWJhc2Ugc2VydmVyLiBUaGVzZSB1cGRhdGVzIG9jY3VyIHdoZXRoZXIgeW91clxyXG4gKiBjbGllbnQgZGlzY29ubmVjdHMgY2xlYW5seSBvciBub3QsIHNvIHlvdSBjYW4gcmVseSBvbiB0aGVtIHRvIGNsZWFuIHVwIGRhdGFcclxuICogZXZlbiBpZiBhIGNvbm5lY3Rpb24gaXMgZHJvcHBlZCBvciBhIGNsaWVudCBjcmFzaGVzLlxyXG4gKlxyXG4gKiBUaGUgYG9uRGlzY29ubmVjdGAgY2xhc3MgaXMgbW9zdCBjb21tb25seSB1c2VkIHRvIG1hbmFnZSBwcmVzZW5jZSBpblxyXG4gKiBhcHBsaWNhdGlvbnMgd2hlcmUgaXQgaXMgdXNlZnVsIHRvIGRldGVjdCBob3cgbWFueSBjbGllbnRzIGFyZSBjb25uZWN0ZWQgYW5kXHJcbiAqIHdoZW4gb3RoZXIgY2xpZW50cyBkaXNjb25uZWN0LiBTZWVcclxuICoge0BsaW5rIGh0dHBzOi8vZmlyZWJhc2UuZ29vZ2xlLmNvbS9kb2NzL2RhdGFiYXNlL3dlYi9vZmZsaW5lLWNhcGFiaWxpdGllcyB8IEVuYWJsaW5nIE9mZmxpbmUgQ2FwYWJpbGl0aWVzIGluIEphdmFTY3JpcHR9XHJcbiAqIGZvciBtb3JlIGluZm9ybWF0aW9uLlxyXG4gKlxyXG4gKiBUbyBhdm9pZCBwcm9ibGVtcyB3aGVuIGEgY29ubmVjdGlvbiBpcyBkcm9wcGVkIGJlZm9yZSB0aGUgcmVxdWVzdHMgY2FuIGJlXHJcbiAqIHRyYW5zZmVycmVkIHRvIHRoZSBEYXRhYmFzZSBzZXJ2ZXIsIHRoZXNlIGZ1bmN0aW9ucyBzaG91bGQgYmUgY2FsbGVkIGJlZm9yZVxyXG4gKiB3cml0aW5nIGFueSBkYXRhLlxyXG4gKlxyXG4gKiBOb3RlIHRoYXQgYG9uRGlzY29ubmVjdGAgb3BlcmF0aW9ucyBhcmUgb25seSB0cmlnZ2VyZWQgb25jZS4gSWYgeW91IHdhbnQgYW5cclxuICogb3BlcmF0aW9uIHRvIG9jY3VyIGVhY2ggdGltZSBhIGRpc2Nvbm5lY3Qgb2NjdXJzLCB5b3UnbGwgbmVlZCB0byByZS1lc3RhYmxpc2hcclxuICogdGhlIGBvbkRpc2Nvbm5lY3RgIG9wZXJhdGlvbnMgZWFjaCB0aW1lIHlvdSByZWNvbm5lY3QuXHJcbiAqL1xyXG5jbGFzcyBPbkRpc2Nvbm5lY3Qge1xyXG4gICAgLyoqIEBoaWRlY29uc3RydWN0b3IgKi9cclxuICAgIGNvbnN0cnVjdG9yKF9yZXBvLCBfcGF0aCkge1xyXG4gICAgICAgIHRoaXMuX3JlcG8gPSBfcmVwbztcclxuICAgICAgICB0aGlzLl9wYXRoID0gX3BhdGg7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENhbmNlbHMgYWxsIHByZXZpb3VzbHkgcXVldWVkIGBvbkRpc2Nvbm5lY3QoKWAgc2V0IG9yIHVwZGF0ZSBldmVudHMgZm9yIHRoaXNcclxuICAgICAqIGxvY2F0aW9uIGFuZCBhbGwgY2hpbGRyZW4uXHJcbiAgICAgKlxyXG4gICAgICogSWYgYSB3cml0ZSBoYXMgYmVlbiBxdWV1ZWQgZm9yIHRoaXMgbG9jYXRpb24gdmlhIGEgYHNldCgpYCBvciBgdXBkYXRlKClgIGF0IGFcclxuICAgICAqIHBhcmVudCBsb2NhdGlvbiwgdGhlIHdyaXRlIGF0IHRoaXMgbG9jYXRpb24gd2lsbCBiZSBjYW5jZWxlZCwgdGhvdWdoIHdyaXRlc1xyXG4gICAgICogdG8gc2libGluZyBsb2NhdGlvbnMgd2lsbCBzdGlsbCBvY2N1ci5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyBSZXNvbHZlcyB3aGVuIHN5bmNocm9uaXphdGlvbiB0byB0aGUgc2VydmVyIGlzIGNvbXBsZXRlLlxyXG4gICAgICovXHJcbiAgICBjYW5jZWwoKSB7XHJcbiAgICAgICAgY29uc3QgZGVmZXJyZWQgPSBuZXcgRGVmZXJyZWQoKTtcclxuICAgICAgICByZXBvT25EaXNjb25uZWN0Q2FuY2VsKHRoaXMuX3JlcG8sIHRoaXMuX3BhdGgsIGRlZmVycmVkLndyYXBDYWxsYmFjaygoKSA9PiB7IH0pKTtcclxuICAgICAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRW5zdXJlcyB0aGUgZGF0YSBhdCB0aGlzIGxvY2F0aW9uIGlzIGRlbGV0ZWQgd2hlbiB0aGUgY2xpZW50IGlzIGRpc2Nvbm5lY3RlZFxyXG4gICAgICogKGR1ZSB0byBjbG9zaW5nIHRoZSBicm93c2VyLCBuYXZpZ2F0aW5nIHRvIGEgbmV3IHBhZ2UsIG9yIG5ldHdvcmsgaXNzdWVzKS5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyBSZXNvbHZlcyB3aGVuIHN5bmNocm9uaXphdGlvbiB0byB0aGUgc2VydmVyIGlzIGNvbXBsZXRlLlxyXG4gICAgICovXHJcbiAgICByZW1vdmUoKSB7XHJcbiAgICAgICAgdmFsaWRhdGVXcml0YWJsZVBhdGgoJ09uRGlzY29ubmVjdC5yZW1vdmUnLCB0aGlzLl9wYXRoKTtcclxuICAgICAgICBjb25zdCBkZWZlcnJlZCA9IG5ldyBEZWZlcnJlZCgpO1xyXG4gICAgICAgIHJlcG9PbkRpc2Nvbm5lY3RTZXQodGhpcy5fcmVwbywgdGhpcy5fcGF0aCwgbnVsbCwgZGVmZXJyZWQud3JhcENhbGxiYWNrKCgpID0+IHsgfSkpO1xyXG4gICAgICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBFbnN1cmVzIHRoZSBkYXRhIGF0IHRoaXMgbG9jYXRpb24gaXMgc2V0IHRvIHRoZSBzcGVjaWZpZWQgdmFsdWUgd2hlbiB0aGVcclxuICAgICAqIGNsaWVudCBpcyBkaXNjb25uZWN0ZWQgKGR1ZSB0byBjbG9zaW5nIHRoZSBicm93c2VyLCBuYXZpZ2F0aW5nIHRvIGEgbmV3IHBhZ2UsXHJcbiAgICAgKiBvciBuZXR3b3JrIGlzc3VlcykuXHJcbiAgICAgKlxyXG4gICAgICogYHNldCgpYCBpcyBlc3BlY2lhbGx5IHVzZWZ1bCBmb3IgaW1wbGVtZW50aW5nIFwicHJlc2VuY2VcIiBzeXN0ZW1zLCB3aGVyZSBhXHJcbiAgICAgKiB2YWx1ZSBzaG91bGQgYmUgY2hhbmdlZCBvciBjbGVhcmVkIHdoZW4gYSB1c2VyIGRpc2Nvbm5lY3RzIHNvIHRoYXQgdGhleVxyXG4gICAgICogYXBwZWFyIFwib2ZmbGluZVwiIHRvIG90aGVyIHVzZXJzLiBTZWVcclxuICAgICAqIHtAbGluayBodHRwczovL2ZpcmViYXNlLmdvb2dsZS5jb20vZG9jcy9kYXRhYmFzZS93ZWIvb2ZmbGluZS1jYXBhYmlsaXRpZXMgfCBFbmFibGluZyBPZmZsaW5lIENhcGFiaWxpdGllcyBpbiBKYXZhU2NyaXB0fVxyXG4gICAgICogZm9yIG1vcmUgaW5mb3JtYXRpb24uXHJcbiAgICAgKlxyXG4gICAgICogTm90ZSB0aGF0IGBvbkRpc2Nvbm5lY3RgIG9wZXJhdGlvbnMgYXJlIG9ubHkgdHJpZ2dlcmVkIG9uY2UuIElmIHlvdSB3YW50IGFuXHJcbiAgICAgKiBvcGVyYXRpb24gdG8gb2NjdXIgZWFjaCB0aW1lIGEgZGlzY29ubmVjdCBvY2N1cnMsIHlvdSdsbCBuZWVkIHRvIHJlLWVzdGFibGlzaFxyXG4gICAgICogdGhlIGBvbkRpc2Nvbm5lY3RgIG9wZXJhdGlvbnMgZWFjaCB0aW1lLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBiZSB3cml0dGVuIHRvIHRoaXMgbG9jYXRpb24gb24gZGlzY29ubmVjdCAoY2FuXHJcbiAgICAgKiBiZSBhbiBvYmplY3QsIGFycmF5LCBzdHJpbmcsIG51bWJlciwgYm9vbGVhbiwgb3IgbnVsbCkuXHJcbiAgICAgKiBAcmV0dXJucyBSZXNvbHZlcyB3aGVuIHN5bmNocm9uaXphdGlvbiB0byB0aGUgRGF0YWJhc2UgaXMgY29tcGxldGUuXHJcbiAgICAgKi9cclxuICAgIHNldCh2YWx1ZSkge1xyXG4gICAgICAgIHZhbGlkYXRlV3JpdGFibGVQYXRoKCdPbkRpc2Nvbm5lY3Quc2V0JywgdGhpcy5fcGF0aCk7XHJcbiAgICAgICAgdmFsaWRhdGVGaXJlYmFzZURhdGFBcmcoJ09uRGlzY29ubmVjdC5zZXQnLCB2YWx1ZSwgdGhpcy5fcGF0aCwgZmFsc2UpO1xyXG4gICAgICAgIGNvbnN0IGRlZmVycmVkID0gbmV3IERlZmVycmVkKCk7XHJcbiAgICAgICAgcmVwb09uRGlzY29ubmVjdFNldCh0aGlzLl9yZXBvLCB0aGlzLl9wYXRoLCB2YWx1ZSwgZGVmZXJyZWQud3JhcENhbGxiYWNrKCgpID0+IHsgfSkpO1xyXG4gICAgICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBFbnN1cmVzIHRoZSBkYXRhIGF0IHRoaXMgbG9jYXRpb24gaXMgc2V0IHRvIHRoZSBzcGVjaWZpZWQgdmFsdWUgYW5kIHByaW9yaXR5XHJcbiAgICAgKiB3aGVuIHRoZSBjbGllbnQgaXMgZGlzY29ubmVjdGVkIChkdWUgdG8gY2xvc2luZyB0aGUgYnJvd3NlciwgbmF2aWdhdGluZyB0byBhXHJcbiAgICAgKiBuZXcgcGFnZSwgb3IgbmV0d29yayBpc3N1ZXMpLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBiZSB3cml0dGVuIHRvIHRoaXMgbG9jYXRpb24gb24gZGlzY29ubmVjdCAoY2FuXHJcbiAgICAgKiBiZSBhbiBvYmplY3QsIGFycmF5LCBzdHJpbmcsIG51bWJlciwgYm9vbGVhbiwgb3IgbnVsbCkuXHJcbiAgICAgKiBAcGFyYW0gcHJpb3JpdHkgLSBUaGUgcHJpb3JpdHkgdG8gYmUgd3JpdHRlbiAoc3RyaW5nLCBudW1iZXIsIG9yIG51bGwpLlxyXG4gICAgICogQHJldHVybnMgUmVzb2x2ZXMgd2hlbiBzeW5jaHJvbml6YXRpb24gdG8gdGhlIERhdGFiYXNlIGlzIGNvbXBsZXRlLlxyXG4gICAgICovXHJcbiAgICBzZXRXaXRoUHJpb3JpdHkodmFsdWUsIHByaW9yaXR5KSB7XHJcbiAgICAgICAgdmFsaWRhdGVXcml0YWJsZVBhdGgoJ09uRGlzY29ubmVjdC5zZXRXaXRoUHJpb3JpdHknLCB0aGlzLl9wYXRoKTtcclxuICAgICAgICB2YWxpZGF0ZUZpcmViYXNlRGF0YUFyZygnT25EaXNjb25uZWN0LnNldFdpdGhQcmlvcml0eScsIHZhbHVlLCB0aGlzLl9wYXRoLCBmYWxzZSk7XHJcbiAgICAgICAgdmFsaWRhdGVQcmlvcml0eSgnT25EaXNjb25uZWN0LnNldFdpdGhQcmlvcml0eScsIHByaW9yaXR5LCBmYWxzZSk7XHJcbiAgICAgICAgY29uc3QgZGVmZXJyZWQgPSBuZXcgRGVmZXJyZWQoKTtcclxuICAgICAgICByZXBvT25EaXNjb25uZWN0U2V0V2l0aFByaW9yaXR5KHRoaXMuX3JlcG8sIHRoaXMuX3BhdGgsIHZhbHVlLCBwcmlvcml0eSwgZGVmZXJyZWQud3JhcENhbGxiYWNrKCgpID0+IHsgfSkpO1xyXG4gICAgICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBXcml0ZXMgbXVsdGlwbGUgdmFsdWVzIGF0IHRoaXMgbG9jYXRpb24gd2hlbiB0aGUgY2xpZW50IGlzIGRpc2Nvbm5lY3RlZCAoZHVlXHJcbiAgICAgKiB0byBjbG9zaW5nIHRoZSBicm93c2VyLCBuYXZpZ2F0aW5nIHRvIGEgbmV3IHBhZ2UsIG9yIG5ldHdvcmsgaXNzdWVzKS5cclxuICAgICAqXHJcbiAgICAgKiBUaGUgYHZhbHVlc2AgYXJndW1lbnQgY29udGFpbnMgbXVsdGlwbGUgcHJvcGVydHktdmFsdWUgcGFpcnMgdGhhdCB3aWxsIGJlXHJcbiAgICAgKiB3cml0dGVuIHRvIHRoZSBEYXRhYmFzZSB0b2dldGhlci4gRWFjaCBjaGlsZCBwcm9wZXJ0eSBjYW4gZWl0aGVyIGJlIGEgc2ltcGxlXHJcbiAgICAgKiBwcm9wZXJ0eSAoZm9yIGV4YW1wbGUsIFwibmFtZVwiKSBvciBhIHJlbGF0aXZlIHBhdGggKGZvciBleGFtcGxlLCBcIm5hbWUvZmlyc3RcIilcclxuICAgICAqIGZyb20gdGhlIGN1cnJlbnQgbG9jYXRpb24gdG8gdGhlIGRhdGEgdG8gdXBkYXRlLlxyXG4gICAgICpcclxuICAgICAqIEFzIG9wcG9zZWQgdG8gdGhlIGBzZXQoKWAgbWV0aG9kLCBgdXBkYXRlKClgIGNhbiBiZSB1c2UgdG8gc2VsZWN0aXZlbHkgdXBkYXRlXHJcbiAgICAgKiBvbmx5IHRoZSByZWZlcmVuY2VkIHByb3BlcnRpZXMgYXQgdGhlIGN1cnJlbnQgbG9jYXRpb24gKGluc3RlYWQgb2YgcmVwbGFjaW5nXHJcbiAgICAgKiBhbGwgdGhlIGNoaWxkIHByb3BlcnRpZXMgYXQgdGhlIGN1cnJlbnQgbG9jYXRpb24pLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB2YWx1ZXMgLSBPYmplY3QgY29udGFpbmluZyBtdWx0aXBsZSB2YWx1ZXMuXHJcbiAgICAgKiBAcmV0dXJucyBSZXNvbHZlcyB3aGVuIHN5bmNocm9uaXphdGlvbiB0byB0aGUgRGF0YWJhc2UgaXMgY29tcGxldGUuXHJcbiAgICAgKi9cclxuICAgIHVwZGF0ZSh2YWx1ZXMpIHtcclxuICAgICAgICB2YWxpZGF0ZVdyaXRhYmxlUGF0aCgnT25EaXNjb25uZWN0LnVwZGF0ZScsIHRoaXMuX3BhdGgpO1xyXG4gICAgICAgIHZhbGlkYXRlRmlyZWJhc2VNZXJnZURhdGFBcmcoJ09uRGlzY29ubmVjdC51cGRhdGUnLCB2YWx1ZXMsIHRoaXMuX3BhdGgsIGZhbHNlKTtcclxuICAgICAgICBjb25zdCBkZWZlcnJlZCA9IG5ldyBEZWZlcnJlZCgpO1xyXG4gICAgICAgIHJlcG9PbkRpc2Nvbm5lY3RVcGRhdGUodGhpcy5fcmVwbywgdGhpcy5fcGF0aCwgdmFsdWVzLCBkZWZlcnJlZC53cmFwQ2FsbGJhY2soKCkgPT4geyB9KSk7XHJcbiAgICAgICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cclxuY2xhc3MgUXVlcnlJbXBsIHtcclxuICAgIC8qKlxyXG4gICAgICogQGhpZGVjb25zdHJ1Y3RvclxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihfcmVwbywgX3BhdGgsIF9xdWVyeVBhcmFtcywgX29yZGVyQnlDYWxsZWQpIHtcclxuICAgICAgICB0aGlzLl9yZXBvID0gX3JlcG87XHJcbiAgICAgICAgdGhpcy5fcGF0aCA9IF9wYXRoO1xyXG4gICAgICAgIHRoaXMuX3F1ZXJ5UGFyYW1zID0gX3F1ZXJ5UGFyYW1zO1xyXG4gICAgICAgIHRoaXMuX29yZGVyQnlDYWxsZWQgPSBfb3JkZXJCeUNhbGxlZDtcclxuICAgIH1cclxuICAgIGdldCBrZXkoKSB7XHJcbiAgICAgICAgaWYgKHBhdGhJc0VtcHR5KHRoaXMuX3BhdGgpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHBhdGhHZXRCYWNrKHRoaXMuX3BhdGgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGdldCByZWYoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBSZWZlcmVuY2VJbXBsKHRoaXMuX3JlcG8sIHRoaXMuX3BhdGgpO1xyXG4gICAgfVxyXG4gICAgZ2V0IF9xdWVyeUlkZW50aWZpZXIoKSB7XHJcbiAgICAgICAgY29uc3Qgb2JqID0gcXVlcnlQYXJhbXNHZXRRdWVyeU9iamVjdCh0aGlzLl9xdWVyeVBhcmFtcyk7XHJcbiAgICAgICAgY29uc3QgaWQgPSBPYmplY3RUb1VuaXF1ZUtleShvYmopO1xyXG4gICAgICAgIHJldHVybiBpZCA9PT0gJ3t9JyA/ICdkZWZhdWx0JyA6IGlkO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBbiBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgdGhlIHF1ZXJ5IHBhcmFtZXRlcnMgdXNlZCBieSB0aGlzIFF1ZXJ5LlxyXG4gICAgICovXHJcbiAgICBnZXQgX3F1ZXJ5T2JqZWN0KCkge1xyXG4gICAgICAgIHJldHVybiBxdWVyeVBhcmFtc0dldFF1ZXJ5T2JqZWN0KHRoaXMuX3F1ZXJ5UGFyYW1zKTtcclxuICAgIH1cclxuICAgIGlzRXF1YWwob3RoZXIpIHtcclxuICAgICAgICBvdGhlciA9IGdldE1vZHVsYXJJbnN0YW5jZShvdGhlcik7XHJcbiAgICAgICAgaWYgKCEob3RoZXIgaW5zdGFuY2VvZiBRdWVyeUltcGwpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3Qgc2FtZVJlcG8gPSB0aGlzLl9yZXBvID09PSBvdGhlci5fcmVwbztcclxuICAgICAgICBjb25zdCBzYW1lUGF0aCA9IHBhdGhFcXVhbHModGhpcy5fcGF0aCwgb3RoZXIuX3BhdGgpO1xyXG4gICAgICAgIGNvbnN0IHNhbWVRdWVyeUlkZW50aWZpZXIgPSB0aGlzLl9xdWVyeUlkZW50aWZpZXIgPT09IG90aGVyLl9xdWVyeUlkZW50aWZpZXI7XHJcbiAgICAgICAgcmV0dXJuIHNhbWVSZXBvICYmIHNhbWVQYXRoICYmIHNhbWVRdWVyeUlkZW50aWZpZXI7XHJcbiAgICB9XHJcbiAgICB0b0pTT04oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudG9TdHJpbmcoKTtcclxuICAgIH1cclxuICAgIHRvU3RyaW5nKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9yZXBvLnRvU3RyaW5nKCkgKyBwYXRoVG9VcmxFbmNvZGVkU3RyaW5nKHRoaXMuX3BhdGgpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBWYWxpZGF0ZXMgdGhhdCBubyBvdGhlciBvcmRlciBieSBjYWxsIGhhcyBiZWVuIG1hZGVcclxuICovXHJcbmZ1bmN0aW9uIHZhbGlkYXRlTm9QcmV2aW91c09yZGVyQnlDYWxsKHF1ZXJ5LCBmbk5hbWUpIHtcclxuICAgIGlmIChxdWVyeS5fb3JkZXJCeUNhbGxlZCA9PT0gdHJ1ZSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihmbk5hbWUgKyBcIjogWW91IGNhbid0IGNvbWJpbmUgbXVsdGlwbGUgb3JkZXJCeSBjYWxscy5cIik7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFZhbGlkYXRlcyBzdGFydC9lbmQgdmFsdWVzIGZvciBxdWVyaWVzLlxyXG4gKi9cclxuZnVuY3Rpb24gdmFsaWRhdGVRdWVyeUVuZHBvaW50cyhwYXJhbXMpIHtcclxuICAgIGxldCBzdGFydE5vZGUgPSBudWxsO1xyXG4gICAgbGV0IGVuZE5vZGUgPSBudWxsO1xyXG4gICAgaWYgKHBhcmFtcy5oYXNTdGFydCgpKSB7XHJcbiAgICAgICAgc3RhcnROb2RlID0gcGFyYW1zLmdldEluZGV4U3RhcnRWYWx1ZSgpO1xyXG4gICAgfVxyXG4gICAgaWYgKHBhcmFtcy5oYXNFbmQoKSkge1xyXG4gICAgICAgIGVuZE5vZGUgPSBwYXJhbXMuZ2V0SW5kZXhFbmRWYWx1ZSgpO1xyXG4gICAgfVxyXG4gICAgaWYgKHBhcmFtcy5nZXRJbmRleCgpID09PSBLRVlfSU5ERVgpIHtcclxuICAgICAgICBjb25zdCB0b29NYW55QXJnc0Vycm9yID0gJ1F1ZXJ5OiBXaGVuIG9yZGVyaW5nIGJ5IGtleSwgeW91IG1heSBvbmx5IHBhc3Mgb25lIGFyZ3VtZW50IHRvICcgK1xyXG4gICAgICAgICAgICAnc3RhcnRBdCgpLCBlbmRBdCgpLCBvciBlcXVhbFRvKCkuJztcclxuICAgICAgICBjb25zdCB3cm9uZ0FyZ1R5cGVFcnJvciA9ICdRdWVyeTogV2hlbiBvcmRlcmluZyBieSBrZXksIHRoZSBhcmd1bWVudCBwYXNzZWQgdG8gc3RhcnRBdCgpLCBzdGFydEFmdGVyKCksICcgK1xyXG4gICAgICAgICAgICAnZW5kQXQoKSwgZW5kQmVmb3JlKCksIG9yIGVxdWFsVG8oKSBtdXN0IGJlIGEgc3RyaW5nLic7XHJcbiAgICAgICAgaWYgKHBhcmFtcy5oYXNTdGFydCgpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0TmFtZSA9IHBhcmFtcy5nZXRJbmRleFN0YXJ0TmFtZSgpO1xyXG4gICAgICAgICAgICBpZiAoc3RhcnROYW1lICE9PSBNSU5fTkFNRSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHRvb01hbnlBcmdzRXJyb3IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBzdGFydE5vZGUgIT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3Iod3JvbmdBcmdUeXBlRXJyb3IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChwYXJhbXMuaGFzRW5kKCkpIHtcclxuICAgICAgICAgICAgY29uc3QgZW5kTmFtZSA9IHBhcmFtcy5nZXRJbmRleEVuZE5hbWUoKTtcclxuICAgICAgICAgICAgaWYgKGVuZE5hbWUgIT09IE1BWF9OQU1FKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IodG9vTWFueUFyZ3NFcnJvcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGVuZE5vZGUgIT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3Iod3JvbmdBcmdUeXBlRXJyb3IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAocGFyYW1zLmdldEluZGV4KCkgPT09IFBSSU9SSVRZX0lOREVYKSB7XHJcbiAgICAgICAgaWYgKChzdGFydE5vZGUgIT0gbnVsbCAmJiAhaXNWYWxpZFByaW9yaXR5KHN0YXJ0Tm9kZSkpIHx8XHJcbiAgICAgICAgICAgIChlbmROb2RlICE9IG51bGwgJiYgIWlzVmFsaWRQcmlvcml0eShlbmROb2RlKSkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdRdWVyeTogV2hlbiBvcmRlcmluZyBieSBwcmlvcml0eSwgdGhlIGZpcnN0IGFyZ3VtZW50IHBhc3NlZCB0byBzdGFydEF0KCksICcgK1xyXG4gICAgICAgICAgICAgICAgJ3N0YXJ0QWZ0ZXIoKSBlbmRBdCgpLCBlbmRCZWZvcmUoKSwgb3IgZXF1YWxUbygpIG11c3QgYmUgYSB2YWxpZCBwcmlvcml0eSB2YWx1ZSAnICtcclxuICAgICAgICAgICAgICAgICcobnVsbCwgYSBudW1iZXIsIG9yIGEgc3RyaW5nKS4nKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBhc3NlcnQocGFyYW1zLmdldEluZGV4KCkgaW5zdGFuY2VvZiBQYXRoSW5kZXggfHxcclxuICAgICAgICAgICAgcGFyYW1zLmdldEluZGV4KCkgPT09IFZBTFVFX0lOREVYLCAndW5rbm93biBpbmRleCB0eXBlLicpO1xyXG4gICAgICAgIGlmICgoc3RhcnROb2RlICE9IG51bGwgJiYgdHlwZW9mIHN0YXJ0Tm9kZSA9PT0gJ29iamVjdCcpIHx8XHJcbiAgICAgICAgICAgIChlbmROb2RlICE9IG51bGwgJiYgdHlwZW9mIGVuZE5vZGUgPT09ICdvYmplY3QnKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1F1ZXJ5OiBGaXJzdCBhcmd1bWVudCBwYXNzZWQgdG8gc3RhcnRBdCgpLCBzdGFydEFmdGVyKCksIGVuZEF0KCksIGVuZEJlZm9yZSgpLCBvciAnICtcclxuICAgICAgICAgICAgICAgICdlcXVhbFRvKCkgY2Fubm90IGJlIGFuIG9iamVjdC4nKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFZhbGlkYXRlcyB0aGF0IGxpbWl0KiBoYXMgYmVlbiBjYWxsZWQgd2l0aCB0aGUgY29ycmVjdCBjb21iaW5hdGlvbiBvZiBwYXJhbWV0ZXJzXHJcbiAqL1xyXG5mdW5jdGlvbiB2YWxpZGF0ZUxpbWl0KHBhcmFtcykge1xyXG4gICAgaWYgKHBhcmFtcy5oYXNTdGFydCgpICYmXHJcbiAgICAgICAgcGFyYW1zLmhhc0VuZCgpICYmXHJcbiAgICAgICAgcGFyYW1zLmhhc0xpbWl0KCkgJiZcclxuICAgICAgICAhcGFyYW1zLmhhc0FuY2hvcmVkTGltaXQoKSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlF1ZXJ5OiBDYW4ndCBjb21iaW5lIHN0YXJ0QXQoKSwgc3RhcnRBZnRlcigpLCBlbmRBdCgpLCBlbmRCZWZvcmUoKSwgYW5kIGxpbWl0KCkuIFVzZSBcIiArXHJcbiAgICAgICAgICAgICdsaW1pdFRvRmlyc3QoKSBvciBsaW1pdFRvTGFzdCgpIGluc3RlYWQuJyk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cclxuY2xhc3MgUmVmZXJlbmNlSW1wbCBleHRlbmRzIFF1ZXJ5SW1wbCB7XHJcbiAgICAvKiogQGhpZGVjb25zdHJ1Y3RvciAqL1xyXG4gICAgY29uc3RydWN0b3IocmVwbywgcGF0aCkge1xyXG4gICAgICAgIHN1cGVyKHJlcG8sIHBhdGgsIG5ldyBRdWVyeVBhcmFtcygpLCBmYWxzZSk7XHJcbiAgICB9XHJcbiAgICBnZXQgcGFyZW50KCkge1xyXG4gICAgICAgIGNvbnN0IHBhcmVudFBhdGggPSBwYXRoUGFyZW50KHRoaXMuX3BhdGgpO1xyXG4gICAgICAgIHJldHVybiBwYXJlbnRQYXRoID09PSBudWxsXHJcbiAgICAgICAgICAgID8gbnVsbFxyXG4gICAgICAgICAgICA6IG5ldyBSZWZlcmVuY2VJbXBsKHRoaXMuX3JlcG8sIHBhcmVudFBhdGgpO1xyXG4gICAgfVxyXG4gICAgZ2V0IHJvb3QoKSB7XHJcbiAgICAgICAgbGV0IHJlZiA9IHRoaXM7XHJcbiAgICAgICAgd2hpbGUgKHJlZi5wYXJlbnQgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgcmVmID0gcmVmLnBhcmVudDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlZjtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQSBgRGF0YVNuYXBzaG90YCBjb250YWlucyBkYXRhIGZyb20gYSBEYXRhYmFzZSBsb2NhdGlvbi5cclxuICpcclxuICogQW55IHRpbWUgeW91IHJlYWQgZGF0YSBmcm9tIHRoZSBEYXRhYmFzZSwgeW91IHJlY2VpdmUgdGhlIGRhdGEgYXMgYVxyXG4gKiBgRGF0YVNuYXBzaG90YC4gQSBgRGF0YVNuYXBzaG90YCBpcyBwYXNzZWQgdG8gdGhlIGV2ZW50IGNhbGxiYWNrcyB5b3UgYXR0YWNoXHJcbiAqIHdpdGggYG9uKClgIG9yIGBvbmNlKClgLiBZb3UgY2FuIGV4dHJhY3QgdGhlIGNvbnRlbnRzIG9mIHRoZSBzbmFwc2hvdCBhcyBhXHJcbiAqIEphdmFTY3JpcHQgb2JqZWN0IGJ5IGNhbGxpbmcgdGhlIGB2YWwoKWAgbWV0aG9kLiBBbHRlcm5hdGl2ZWx5LCB5b3UgY2FuXHJcbiAqIHRyYXZlcnNlIGludG8gdGhlIHNuYXBzaG90IGJ5IGNhbGxpbmcgYGNoaWxkKClgIHRvIHJldHVybiBjaGlsZCBzbmFwc2hvdHNcclxuICogKHdoaWNoIHlvdSBjb3VsZCB0aGVuIGNhbGwgYHZhbCgpYCBvbikuXHJcbiAqXHJcbiAqIEEgYERhdGFTbmFwc2hvdGAgaXMgYW4gZWZmaWNpZW50bHkgZ2VuZXJhdGVkLCBpbW11dGFibGUgY29weSBvZiB0aGUgZGF0YSBhdFxyXG4gKiBhIERhdGFiYXNlIGxvY2F0aW9uLiBJdCBjYW5ub3QgYmUgbW9kaWZpZWQgYW5kIHdpbGwgbmV2ZXIgY2hhbmdlICh0byBtb2RpZnlcclxuICogZGF0YSwgeW91IGFsd2F5cyBjYWxsIHRoZSBgc2V0KClgIG1ldGhvZCBvbiBhIGBSZWZlcmVuY2VgIGRpcmVjdGx5KS5cclxuICovXHJcbmNsYXNzIERhdGFTbmFwc2hvdCB7XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSBfbm9kZSAtIEEgU25hcHNob3ROb2RlIHRvIHdyYXAuXHJcbiAgICAgKiBAcGFyYW0gcmVmIC0gVGhlIGxvY2F0aW9uIHRoaXMgc25hcHNob3QgY2FtZSBmcm9tLlxyXG4gICAgICogQHBhcmFtIF9pbmRleCAtIFRoZSBpdGVyYXRpb24gb3JkZXIgZm9yIHRoaXMgc25hcHNob3RcclxuICAgICAqIEBoaWRlY29uc3RydWN0b3JcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoX25vZGUsIFxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgbG9jYXRpb24gb2YgdGhpcyBEYXRhU25hcHNob3QuXHJcbiAgICAgKi9cclxuICAgIHJlZiwgX2luZGV4KSB7XHJcbiAgICAgICAgdGhpcy5fbm9kZSA9IF9ub2RlO1xyXG4gICAgICAgIHRoaXMucmVmID0gcmVmO1xyXG4gICAgICAgIHRoaXMuX2luZGV4ID0gX2luZGV4O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBwcmlvcml0eSB2YWx1ZSBvZiB0aGUgZGF0YSBpbiB0aGlzIGBEYXRhU25hcHNob3RgLlxyXG4gICAgICpcclxuICAgICAqIEFwcGxpY2F0aW9ucyBuZWVkIG5vdCB1c2UgcHJpb3JpdHkgYnV0IGNhbiBvcmRlciBjb2xsZWN0aW9ucyBieVxyXG4gICAgICogb3JkaW5hcnkgcHJvcGVydGllcyAoc2VlXHJcbiAgICAgKiB7QGxpbmsgaHR0cHM6Ly9maXJlYmFzZS5nb29nbGUuY29tL2RvY3MvZGF0YWJhc2Uvd2ViL2xpc3RzLW9mLWRhdGEjc29ydGluZ19hbmRfZmlsdGVyaW5nX2RhdGEgfFNvcnRpbmcgYW5kIGZpbHRlcmluZyBkYXRhfVxyXG4gICAgICogKS5cclxuICAgICAqL1xyXG4gICAgZ2V0IHByaW9yaXR5KCkge1xyXG4gICAgICAgIC8vIHR5cGVjYXN0IGhlcmUgYmVjYXVzZSB3ZSBuZXZlciByZXR1cm4gZGVmZXJyZWQgdmFsdWVzIG9yIGludGVybmFsIHByaW9yaXRpZXMgKE1BWF9QUklPUklUWSlcclxuICAgICAgICByZXR1cm4gdGhpcy5fbm9kZS5nZXRQcmlvcml0eSgpLnZhbCgpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUga2V5IChsYXN0IHBhcnQgb2YgdGhlIHBhdGgpIG9mIHRoZSBsb2NhdGlvbiBvZiB0aGlzIGBEYXRhU25hcHNob3RgLlxyXG4gICAgICpcclxuICAgICAqIFRoZSBsYXN0IHRva2VuIGluIGEgRGF0YWJhc2UgbG9jYXRpb24gaXMgY29uc2lkZXJlZCBpdHMga2V5LiBGb3IgZXhhbXBsZSxcclxuICAgICAqIFwiYWRhXCIgaXMgdGhlIGtleSBmb3IgdGhlIC91c2Vycy9hZGEvIG5vZGUuIEFjY2Vzc2luZyB0aGUga2V5IG9uIGFueVxyXG4gICAgICogYERhdGFTbmFwc2hvdGAgd2lsbCByZXR1cm4gdGhlIGtleSBmb3IgdGhlIGxvY2F0aW9uIHRoYXQgZ2VuZXJhdGVkIGl0LlxyXG4gICAgICogSG93ZXZlciwgYWNjZXNzaW5nIHRoZSBrZXkgb24gdGhlIHJvb3QgVVJMIG9mIGEgRGF0YWJhc2Ugd2lsbCByZXR1cm5cclxuICAgICAqIGBudWxsYC5cclxuICAgICAqL1xyXG4gICAgZ2V0IGtleSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5yZWYua2V5O1xyXG4gICAgfVxyXG4gICAgLyoqIFJldHVybnMgdGhlIG51bWJlciBvZiBjaGlsZCBwcm9wZXJ0aWVzIG9mIHRoaXMgYERhdGFTbmFwc2hvdGAuICovXHJcbiAgICBnZXQgc2l6ZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fbm9kZS5udW1DaGlsZHJlbigpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIGFub3RoZXIgYERhdGFTbmFwc2hvdGAgZm9yIHRoZSBsb2NhdGlvbiBhdCB0aGUgc3BlY2lmaWVkIHJlbGF0aXZlIHBhdGguXHJcbiAgICAgKlxyXG4gICAgICogUGFzc2luZyBhIHJlbGF0aXZlIHBhdGggdG8gdGhlIGBjaGlsZCgpYCBtZXRob2Qgb2YgYSBEYXRhU25hcHNob3QgcmV0dXJuc1xyXG4gICAgICogYW5vdGhlciBgRGF0YVNuYXBzaG90YCBmb3IgdGhlIGxvY2F0aW9uIGF0IHRoZSBzcGVjaWZpZWQgcmVsYXRpdmUgcGF0aC4gVGhlXHJcbiAgICAgKiByZWxhdGl2ZSBwYXRoIGNhbiBlaXRoZXIgYmUgYSBzaW1wbGUgY2hpbGQgbmFtZSAoZm9yIGV4YW1wbGUsIFwiYWRhXCIpIG9yIGFcclxuICAgICAqIGRlZXBlciwgc2xhc2gtc2VwYXJhdGVkIHBhdGggKGZvciBleGFtcGxlLCBcImFkYS9uYW1lL2ZpcnN0XCIpLiBJZiB0aGUgY2hpbGRcclxuICAgICAqIGxvY2F0aW9uIGhhcyBubyBkYXRhLCBhbiBlbXB0eSBgRGF0YVNuYXBzaG90YCAodGhhdCBpcywgYSBgRGF0YVNuYXBzaG90YFxyXG4gICAgICogd2hvc2UgdmFsdWUgaXMgYG51bGxgKSBpcyByZXR1cm5lZC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gcGF0aCAtIEEgcmVsYXRpdmUgcGF0aCB0byB0aGUgbG9jYXRpb24gb2YgY2hpbGQgZGF0YS5cclxuICAgICAqL1xyXG4gICAgY2hpbGQocGF0aCkge1xyXG4gICAgICAgIGNvbnN0IGNoaWxkUGF0aCA9IG5ldyBQYXRoKHBhdGgpO1xyXG4gICAgICAgIGNvbnN0IGNoaWxkUmVmID0gY2hpbGQodGhpcy5yZWYsIHBhdGgpO1xyXG4gICAgICAgIHJldHVybiBuZXcgRGF0YVNuYXBzaG90KHRoaXMuX25vZGUuZ2V0Q2hpbGQoY2hpbGRQYXRoKSwgY2hpbGRSZWYsIFBSSU9SSVRZX0lOREVYKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoaXMgYERhdGFTbmFwc2hvdGAgY29udGFpbnMgYW55IGRhdGEuIEl0IGlzIHNsaWdodGx5IG1vcmVcclxuICAgICAqIGVmZmljaWVudCB0aGFuIHVzaW5nIGBzbmFwc2hvdC52YWwoKSAhPT0gbnVsbGAuXHJcbiAgICAgKi9cclxuICAgIGV4aXN0cygpIHtcclxuICAgICAgICByZXR1cm4gIXRoaXMuX25vZGUuaXNFbXB0eSgpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBFeHBvcnRzIHRoZSBlbnRpcmUgY29udGVudHMgb2YgdGhlIERhdGFTbmFwc2hvdCBhcyBhIEphdmFTY3JpcHQgb2JqZWN0LlxyXG4gICAgICpcclxuICAgICAqIFRoZSBgZXhwb3J0VmFsKClgIG1ldGhvZCBpcyBzaW1pbGFyIHRvIGB2YWwoKWAsIGV4Y2VwdCBwcmlvcml0eSBpbmZvcm1hdGlvblxyXG4gICAgICogaXMgaW5jbHVkZWQgKGlmIGF2YWlsYWJsZSksIG1ha2luZyBpdCBzdWl0YWJsZSBmb3IgYmFja2luZyB1cCB5b3VyIGRhdGEuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgVGhlIERhdGFTbmFwc2hvdCdzIGNvbnRlbnRzIGFzIGEgSmF2YVNjcmlwdCB2YWx1ZSAoT2JqZWN0LFxyXG4gICAgICogICBBcnJheSwgc3RyaW5nLCBudW1iZXIsIGJvb2xlYW4sIG9yIGBudWxsYCkuXHJcbiAgICAgKi9cclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XHJcbiAgICBleHBvcnRWYWwoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX25vZGUudmFsKHRydWUpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBFbnVtZXJhdGVzIHRoZSB0b3AtbGV2ZWwgY2hpbGRyZW4gaW4gdGhlIGBEYXRhU25hcHNob3RgLlxyXG4gICAgICpcclxuICAgICAqIEJlY2F1c2Ugb2YgdGhlIHdheSBKYXZhU2NyaXB0IG9iamVjdHMgd29yaywgdGhlIG9yZGVyaW5nIG9mIGRhdGEgaW4gdGhlXHJcbiAgICAgKiBKYXZhU2NyaXB0IG9iamVjdCByZXR1cm5lZCBieSBgdmFsKClgIGlzIG5vdCBndWFyYW50ZWVkIHRvIG1hdGNoIHRoZVxyXG4gICAgICogb3JkZXJpbmcgb24gdGhlIHNlcnZlciBub3IgdGhlIG9yZGVyaW5nIG9mIGBvbkNoaWxkQWRkZWQoKWAgZXZlbnRzLiBUaGF0IGlzXHJcbiAgICAgKiB3aGVyZSBgZm9yRWFjaCgpYCBjb21lcyBpbiBoYW5keS4gSXQgZ3VhcmFudGVlcyB0aGUgY2hpbGRyZW4gb2YgYVxyXG4gICAgICogYERhdGFTbmFwc2hvdGAgd2lsbCBiZSBpdGVyYXRlZCBpbiB0aGVpciBxdWVyeSBvcmRlci5cclxuICAgICAqXHJcbiAgICAgKiBJZiBubyBleHBsaWNpdCBgb3JkZXJCeSooKWAgbWV0aG9kIGlzIHVzZWQsIHJlc3VsdHMgYXJlIHJldHVybmVkXHJcbiAgICAgKiBvcmRlcmVkIGJ5IGtleSAodW5sZXNzIHByaW9yaXRpZXMgYXJlIHVzZWQsIGluIHdoaWNoIGNhc2UsIHJlc3VsdHMgYXJlXHJcbiAgICAgKiByZXR1cm5lZCBieSBwcmlvcml0eSkuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGFjdGlvbiAtIEEgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGNhbGxlZCBmb3IgZWFjaCBjaGlsZCBEYXRhU25hcHNob3QuXHJcbiAgICAgKiBUaGUgY2FsbGJhY2sgY2FuIHJldHVybiB0cnVlIHRvIGNhbmNlbCBmdXJ0aGVyIGVudW1lcmF0aW9uLlxyXG4gICAgICogQHJldHVybnMgdHJ1ZSBpZiBlbnVtZXJhdGlvbiB3YXMgY2FuY2VsZWQgZHVlIHRvIHlvdXIgY2FsbGJhY2sgcmV0dXJuaW5nXHJcbiAgICAgKiB0cnVlLlxyXG4gICAgICovXHJcbiAgICBmb3JFYWNoKGFjdGlvbikge1xyXG4gICAgICAgIGlmICh0aGlzLl9ub2RlLmlzTGVhZk5vZGUoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGNoaWxkcmVuTm9kZSA9IHRoaXMuX25vZGU7XHJcbiAgICAgICAgLy8gU2FuaXRpemUgdGhlIHJldHVybiB2YWx1ZSB0byBhIGJvb2xlYW4uIENoaWxkcmVuTm9kZS5mb3JFYWNoQ2hpbGQgaGFzIGEgd2VpcmQgcmV0dXJuIHR5cGUuLi5cclxuICAgICAgICByZXR1cm4gISFjaGlsZHJlbk5vZGUuZm9yRWFjaENoaWxkKHRoaXMuX2luZGV4LCAoa2V5LCBub2RlKSA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiBhY3Rpb24obmV3IERhdGFTbmFwc2hvdChub2RlLCBjaGlsZCh0aGlzLnJlZiwga2V5KSwgUFJJT1JJVFlfSU5ERVgpKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBzcGVjaWZpZWQgY2hpbGQgcGF0aCBoYXMgKG5vbi1udWxsKSBkYXRhLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBwYXRoIC0gQSByZWxhdGl2ZSBwYXRoIHRvIHRoZSBsb2NhdGlvbiBvZiBhIHBvdGVudGlhbCBjaGlsZC5cclxuICAgICAqIEByZXR1cm5zIGB0cnVlYCBpZiBkYXRhIGV4aXN0cyBhdCB0aGUgc3BlY2lmaWVkIGNoaWxkIHBhdGg7IGVsc2VcclxuICAgICAqICBgZmFsc2VgLlxyXG4gICAgICovXHJcbiAgICBoYXNDaGlsZChwYXRoKSB7XHJcbiAgICAgICAgY29uc3QgY2hpbGRQYXRoID0gbmV3IFBhdGgocGF0aCk7XHJcbiAgICAgICAgcmV0dXJuICF0aGlzLl9ub2RlLmdldENoaWxkKGNoaWxkUGF0aCkuaXNFbXB0eSgpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBgRGF0YVNuYXBzaG90YCBoYXMgYW55IG5vbi1gbnVsbGAgY2hpbGRcclxuICAgICAqIHByb3BlcnRpZXMuXHJcbiAgICAgKlxyXG4gICAgICogWW91IGNhbiB1c2UgYGhhc0NoaWxkcmVuKClgIHRvIGRldGVybWluZSBpZiBhIGBEYXRhU25hcHNob3RgIGhhcyBhbnlcclxuICAgICAqIGNoaWxkcmVuLiBJZiBpdCBkb2VzLCB5b3UgY2FuIGVudW1lcmF0ZSB0aGVtIHVzaW5nIGBmb3JFYWNoKClgLiBJZiBpdFxyXG4gICAgICogZG9lc24ndCwgdGhlbiBlaXRoZXIgdGhpcyBzbmFwc2hvdCBjb250YWlucyBhIHByaW1pdGl2ZSB2YWx1ZSAod2hpY2ggY2FuIGJlXHJcbiAgICAgKiByZXRyaWV2ZWQgd2l0aCBgdmFsKClgKSBvciBpdCBpcyBlbXB0eSAoaW4gd2hpY2ggY2FzZSwgYHZhbCgpYCB3aWxsIHJldHVyblxyXG4gICAgICogYG51bGxgKS5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyB0cnVlIGlmIHRoaXMgc25hcHNob3QgaGFzIGFueSBjaGlsZHJlbjsgZWxzZSBmYWxzZS5cclxuICAgICAqL1xyXG4gICAgaGFzQ2hpbGRyZW4oKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX25vZGUuaXNMZWFmTm9kZSgpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiAhdGhpcy5fbm9kZS5pc0VtcHR5KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgSlNPTi1zZXJpYWxpemFibGUgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBvYmplY3QuXHJcbiAgICAgKi9cclxuICAgIHRvSlNPTigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5leHBvcnRWYWwoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRXh0cmFjdHMgYSBKYXZhU2NyaXB0IHZhbHVlIGZyb20gYSBgRGF0YVNuYXBzaG90YC5cclxuICAgICAqXHJcbiAgICAgKiBEZXBlbmRpbmcgb24gdGhlIGRhdGEgaW4gYSBgRGF0YVNuYXBzaG90YCwgdGhlIGB2YWwoKWAgbWV0aG9kIG1heSByZXR1cm4gYVxyXG4gICAgICogc2NhbGFyIHR5cGUgKHN0cmluZywgbnVtYmVyLCBvciBib29sZWFuKSwgYW4gYXJyYXksIG9yIGFuIG9iamVjdC4gSXQgbWF5XHJcbiAgICAgKiBhbHNvIHJldHVybiBudWxsLCBpbmRpY2F0aW5nIHRoYXQgdGhlIGBEYXRhU25hcHNob3RgIGlzIGVtcHR5IChjb250YWlucyBub1xyXG4gICAgICogZGF0YSkuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgVGhlIERhdGFTbmFwc2hvdCdzIGNvbnRlbnRzIGFzIGEgSmF2YVNjcmlwdCB2YWx1ZSAoT2JqZWN0LFxyXG4gICAgICogICBBcnJheSwgc3RyaW5nLCBudW1iZXIsIGJvb2xlYW4sIG9yIGBudWxsYCkuXHJcbiAgICAgKi9cclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XHJcbiAgICB2YWwoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX25vZGUudmFsKCk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqXHJcbiAqIFJldHVybnMgYSBgUmVmZXJlbmNlYCByZXByZXNlbnRpbmcgdGhlIGxvY2F0aW9uIGluIHRoZSBEYXRhYmFzZVxyXG4gKiBjb3JyZXNwb25kaW5nIHRvIHRoZSBwcm92aWRlZCBwYXRoLiBJZiBubyBwYXRoIGlzIHByb3ZpZGVkLCB0aGUgYFJlZmVyZW5jZWBcclxuICogd2lsbCBwb2ludCB0byB0aGUgcm9vdCBvZiB0aGUgRGF0YWJhc2UuXHJcbiAqXHJcbiAqIEBwYXJhbSBkYiAtIFRoZSBkYXRhYmFzZSBpbnN0YW5jZSB0byBvYnRhaW4gYSByZWZlcmVuY2UgZm9yLlxyXG4gKiBAcGFyYW0gcGF0aCAtIE9wdGlvbmFsIHBhdGggcmVwcmVzZW50aW5nIHRoZSBsb2NhdGlvbiB0aGUgcmV0dXJuZWRcclxuICogICBgUmVmZXJlbmNlYCB3aWxsIHBvaW50LiBJZiBub3QgcHJvdmlkZWQsIHRoZSByZXR1cm5lZCBgUmVmZXJlbmNlYCB3aWxsXHJcbiAqICAgcG9pbnQgdG8gdGhlIHJvb3Qgb2YgdGhlIERhdGFiYXNlLlxyXG4gKiBAcmV0dXJucyBJZiBhIHBhdGggaXMgcHJvdmlkZWQsIGEgYFJlZmVyZW5jZWBcclxuICogICBwb2ludGluZyB0byB0aGUgcHJvdmlkZWQgcGF0aC4gT3RoZXJ3aXNlLCBhIGBSZWZlcmVuY2VgIHBvaW50aW5nIHRvIHRoZVxyXG4gKiAgIHJvb3Qgb2YgdGhlIERhdGFiYXNlLlxyXG4gKi9cclxuZnVuY3Rpb24gcmVmKGRiLCBwYXRoKSB7XHJcbiAgICBkYiA9IGdldE1vZHVsYXJJbnN0YW5jZShkYik7XHJcbiAgICBkYi5fY2hlY2tOb3REZWxldGVkKCdyZWYnKTtcclxuICAgIHJldHVybiBwYXRoICE9PSB1bmRlZmluZWQgPyBjaGlsZChkYi5fcm9vdCwgcGF0aCkgOiBkYi5fcm9vdDtcclxufVxyXG4vKipcclxuICogUmV0dXJucyBhIGBSZWZlcmVuY2VgIHJlcHJlc2VudGluZyB0aGUgbG9jYXRpb24gaW4gdGhlIERhdGFiYXNlXHJcbiAqIGNvcnJlc3BvbmRpbmcgdG8gdGhlIHByb3ZpZGVkIEZpcmViYXNlIFVSTC5cclxuICpcclxuICogQW4gZXhjZXB0aW9uIGlzIHRocm93biBpZiB0aGUgVVJMIGlzIG5vdCBhIHZhbGlkIEZpcmViYXNlIERhdGFiYXNlIFVSTCBvciBpdFxyXG4gKiBoYXMgYSBkaWZmZXJlbnQgZG9tYWluIHRoYW4gdGhlIGN1cnJlbnQgYERhdGFiYXNlYCBpbnN0YW5jZS5cclxuICpcclxuICogTm90ZSB0aGF0IGFsbCBxdWVyeSBwYXJhbWV0ZXJzIChgb3JkZXJCeWAsIGBsaW1pdFRvTGFzdGAsIGV0Yy4pIGFyZSBpZ25vcmVkXHJcbiAqIGFuZCBhcmUgbm90IGFwcGxpZWQgdG8gdGhlIHJldHVybmVkIGBSZWZlcmVuY2VgLlxyXG4gKlxyXG4gKiBAcGFyYW0gZGIgLSBUaGUgZGF0YWJhc2UgaW5zdGFuY2UgdG8gb2J0YWluIGEgcmVmZXJlbmNlIGZvci5cclxuICogQHBhcmFtIHVybCAtIFRoZSBGaXJlYmFzZSBVUkwgYXQgd2hpY2ggdGhlIHJldHVybmVkIGBSZWZlcmVuY2VgIHdpbGxcclxuICogICBwb2ludC5cclxuICogQHJldHVybnMgQSBgUmVmZXJlbmNlYCBwb2ludGluZyB0byB0aGUgcHJvdmlkZWRcclxuICogICBGaXJlYmFzZSBVUkwuXHJcbiAqL1xyXG5mdW5jdGlvbiByZWZGcm9tVVJMKGRiLCB1cmwpIHtcclxuICAgIGRiID0gZ2V0TW9kdWxhckluc3RhbmNlKGRiKTtcclxuICAgIGRiLl9jaGVja05vdERlbGV0ZWQoJ3JlZkZyb21VUkwnKTtcclxuICAgIGNvbnN0IHBhcnNlZFVSTCA9IHBhcnNlUmVwb0luZm8odXJsLCBkYi5fcmVwby5yZXBvSW5mb18ubm9kZUFkbWluKTtcclxuICAgIHZhbGlkYXRlVXJsKCdyZWZGcm9tVVJMJywgcGFyc2VkVVJMKTtcclxuICAgIGNvbnN0IHJlcG9JbmZvID0gcGFyc2VkVVJMLnJlcG9JbmZvO1xyXG4gICAgaWYgKCFkYi5fcmVwby5yZXBvSW5mb18uaXNDdXN0b21Ib3N0KCkgJiZcclxuICAgICAgICByZXBvSW5mby5ob3N0ICE9PSBkYi5fcmVwby5yZXBvSW5mb18uaG9zdCkge1xyXG4gICAgICAgIGZhdGFsKCdyZWZGcm9tVVJMJyArXHJcbiAgICAgICAgICAgICc6IEhvc3QgbmFtZSBkb2VzIG5vdCBtYXRjaCB0aGUgY3VycmVudCBkYXRhYmFzZTogJyArXHJcbiAgICAgICAgICAgICcoZm91bmQgJyArXHJcbiAgICAgICAgICAgIHJlcG9JbmZvLmhvc3QgK1xyXG4gICAgICAgICAgICAnIGJ1dCBleHBlY3RlZCAnICtcclxuICAgICAgICAgICAgZGIuX3JlcG8ucmVwb0luZm9fLmhvc3QgK1xyXG4gICAgICAgICAgICAnKScpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlZihkYiwgcGFyc2VkVVJMLnBhdGgudG9TdHJpbmcoKSk7XHJcbn1cclxuLyoqXHJcbiAqIEdldHMgYSBgUmVmZXJlbmNlYCBmb3IgdGhlIGxvY2F0aW9uIGF0IHRoZSBzcGVjaWZpZWQgcmVsYXRpdmUgcGF0aC5cclxuICpcclxuICogVGhlIHJlbGF0aXZlIHBhdGggY2FuIGVpdGhlciBiZSBhIHNpbXBsZSBjaGlsZCBuYW1lIChmb3IgZXhhbXBsZSwgXCJhZGFcIikgb3JcclxuICogYSBkZWVwZXIgc2xhc2gtc2VwYXJhdGVkIHBhdGggKGZvciBleGFtcGxlLCBcImFkYS9uYW1lL2ZpcnN0XCIpLlxyXG4gKlxyXG4gKiBAcGFyYW0gcGFyZW50IC0gVGhlIHBhcmVudCBsb2NhdGlvbi5cclxuICogQHBhcmFtIHBhdGggLSBBIHJlbGF0aXZlIHBhdGggZnJvbSB0aGlzIGxvY2F0aW9uIHRvIHRoZSBkZXNpcmVkIGNoaWxkXHJcbiAqICAgbG9jYXRpb24uXHJcbiAqIEByZXR1cm5zIFRoZSBzcGVjaWZpZWQgY2hpbGQgbG9jYXRpb24uXHJcbiAqL1xyXG5mdW5jdGlvbiBjaGlsZChwYXJlbnQsIHBhdGgpIHtcclxuICAgIHBhcmVudCA9IGdldE1vZHVsYXJJbnN0YW5jZShwYXJlbnQpO1xyXG4gICAgaWYgKHBhdGhHZXRGcm9udChwYXJlbnQuX3BhdGgpID09PSBudWxsKSB7XHJcbiAgICAgICAgdmFsaWRhdGVSb290UGF0aFN0cmluZygnY2hpbGQnLCAncGF0aCcsIHBhdGgsIGZhbHNlKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHZhbGlkYXRlUGF0aFN0cmluZygnY2hpbGQnLCAncGF0aCcsIHBhdGgsIGZhbHNlKTtcclxuICAgIH1cclxuICAgIHJldHVybiBuZXcgUmVmZXJlbmNlSW1wbChwYXJlbnQuX3JlcG8sIHBhdGhDaGlsZChwYXJlbnQuX3BhdGgsIHBhdGgpKTtcclxufVxyXG4vKipcclxuICogUmV0dXJucyBhbiBgT25EaXNjb25uZWN0YCBvYmplY3QgLSBzZWVcclxuICoge0BsaW5rIGh0dHBzOi8vZmlyZWJhc2UuZ29vZ2xlLmNvbS9kb2NzL2RhdGFiYXNlL3dlYi9vZmZsaW5lLWNhcGFiaWxpdGllcyB8IEVuYWJsaW5nIE9mZmxpbmUgQ2FwYWJpbGl0aWVzIGluIEphdmFTY3JpcHR9XHJcbiAqIGZvciBtb3JlIGluZm9ybWF0aW9uIG9uIGhvdyB0byB1c2UgaXQuXHJcbiAqXHJcbiAqIEBwYXJhbSByZWYgLSBUaGUgcmVmZXJlbmNlIHRvIGFkZCBPbkRpc2Nvbm5lY3QgdHJpZ2dlcnMgZm9yLlxyXG4gKi9cclxuZnVuY3Rpb24gb25EaXNjb25uZWN0KHJlZikge1xyXG4gICAgcmVmID0gZ2V0TW9kdWxhckluc3RhbmNlKHJlZik7XHJcbiAgICByZXR1cm4gbmV3IE9uRGlzY29ubmVjdChyZWYuX3JlcG8sIHJlZi5fcGF0aCk7XHJcbn1cclxuLyoqXHJcbiAqIEdlbmVyYXRlcyBhIG5ldyBjaGlsZCBsb2NhdGlvbiB1c2luZyBhIHVuaXF1ZSBrZXkgYW5kIHJldHVybnMgaXRzXHJcbiAqIGBSZWZlcmVuY2VgLlxyXG4gKlxyXG4gKiBUaGlzIGlzIHRoZSBtb3N0IGNvbW1vbiBwYXR0ZXJuIGZvciBhZGRpbmcgZGF0YSB0byBhIGNvbGxlY3Rpb24gb2YgaXRlbXMuXHJcbiAqXHJcbiAqIElmIHlvdSBwcm92aWRlIGEgdmFsdWUgdG8gYHB1c2goKWAsIHRoZSB2YWx1ZSBpcyB3cml0dGVuIHRvIHRoZVxyXG4gKiBnZW5lcmF0ZWQgbG9jYXRpb24uIElmIHlvdSBkb24ndCBwYXNzIGEgdmFsdWUsIG5vdGhpbmcgaXMgd3JpdHRlbiB0byB0aGVcclxuICogZGF0YWJhc2UgYW5kIHRoZSBjaGlsZCByZW1haW5zIGVtcHR5IChidXQgeW91IGNhbiB1c2UgdGhlIGBSZWZlcmVuY2VgXHJcbiAqIGVsc2V3aGVyZSkuXHJcbiAqXHJcbiAqIFRoZSB1bmlxdWUga2V5cyBnZW5lcmF0ZWQgYnkgYHB1c2goKWAgYXJlIG9yZGVyZWQgYnkgdGhlIGN1cnJlbnQgdGltZSwgc28gdGhlXHJcbiAqIHJlc3VsdGluZyBsaXN0IG9mIGl0ZW1zIGlzIGNocm9ub2xvZ2ljYWxseSBzb3J0ZWQuIFRoZSBrZXlzIGFyZSBhbHNvXHJcbiAqIGRlc2lnbmVkIHRvIGJlIHVuZ3Vlc3NhYmxlICh0aGV5IGNvbnRhaW4gNzIgcmFuZG9tIGJpdHMgb2YgZW50cm9weSkuXHJcbiAqXHJcbiAqIFNlZSB7QGxpbmsgaHR0cHM6Ly9maXJlYmFzZS5nb29nbGUuY29tL2RvY3MvZGF0YWJhc2Uvd2ViL2xpc3RzLW9mLWRhdGEjYXBwZW5kX3RvX2FfbGlzdF9vZl9kYXRhIHwgQXBwZW5kIHRvIGEgbGlzdCBvZiBkYXRhfVxyXG4gKiA8L2JyPlNlZSB7QGxpbmsgdHRwczovL2ZpcmViYXNlLmdvb2dsZWJsb2cuY29tLzIwMTUvMDIvdGhlLTIxMjAtd2F5cy10by1lbnN1cmUtdW5pcXVlXzY4Lmh0bWwgfCBUaGUgMl4xMjAgV2F5cyB0byBFbnN1cmUgVW5pcXVlIElkZW50aWZpZXJzfVxyXG4gKlxyXG4gKiBAcGFyYW0gcGFyZW50IC0gVGhlIHBhcmVudCBsb2NhdGlvbi5cclxuICogQHBhcmFtIHZhbHVlIC0gT3B0aW9uYWwgdmFsdWUgdG8gYmUgd3JpdHRlbiBhdCB0aGUgZ2VuZXJhdGVkIGxvY2F0aW9uLlxyXG4gKiBAcmV0dXJucyBDb21iaW5lZCBgUHJvbWlzZWAgYW5kIGBSZWZlcmVuY2VgOyByZXNvbHZlcyB3aGVuIHdyaXRlIGlzIGNvbXBsZXRlLFxyXG4gKiBidXQgY2FuIGJlIHVzZWQgaW1tZWRpYXRlbHkgYXMgdGhlIGBSZWZlcmVuY2VgIHRvIHRoZSBjaGlsZCBsb2NhdGlvbi5cclxuICovXHJcbmZ1bmN0aW9uIHB1c2gocGFyZW50LCB2YWx1ZSkge1xyXG4gICAgcGFyZW50ID0gZ2V0TW9kdWxhckluc3RhbmNlKHBhcmVudCk7XHJcbiAgICB2YWxpZGF0ZVdyaXRhYmxlUGF0aCgncHVzaCcsIHBhcmVudC5fcGF0aCk7XHJcbiAgICB2YWxpZGF0ZUZpcmViYXNlRGF0YUFyZygncHVzaCcsIHZhbHVlLCBwYXJlbnQuX3BhdGgsIHRydWUpO1xyXG4gICAgY29uc3Qgbm93ID0gcmVwb1NlcnZlclRpbWUocGFyZW50Ll9yZXBvKTtcclxuICAgIGNvbnN0IG5hbWUgPSBuZXh0UHVzaElkKG5vdyk7XHJcbiAgICAvLyBwdXNoKCkgcmV0dXJucyBhIFRoZW5uYWJsZVJlZmVyZW5jZSB3aG9zZSBwcm9taXNlIGlzIGZ1bGZpbGxlZCB3aXRoIGFcclxuICAgIC8vIHJlZ3VsYXIgUmVmZXJlbmNlLiBXZSB1c2UgY2hpbGQoKSB0byBjcmVhdGUgaGFuZGxlcyB0byB0d28gZGlmZmVyZW50XHJcbiAgICAvLyByZWZlcmVuY2VzLiBUaGUgZmlyc3QgaXMgdHVybmVkIGludG8gYSBUaGVubmFibGVSZWZlcmVuY2UgYmVsb3cgYnkgYWRkaW5nXHJcbiAgICAvLyB0aGVuKCkgYW5kIGNhdGNoKCkgbWV0aG9kcyBhbmQgaXMgdXNlZCBhcyB0aGUgcmV0dXJuIHZhbHVlIG9mIHB1c2goKS4gVGhlXHJcbiAgICAvLyBzZWNvbmQgcmVtYWlucyBhIHJlZ3VsYXIgUmVmZXJlbmNlIGFuZCBpcyB1c2VkIGFzIHRoZSBmdWxmaWxsZWQgdmFsdWUgb2ZcclxuICAgIC8vIHRoZSBmaXJzdCBUaGVubmFibGVSZWZlcmVuY2UuXHJcbiAgICBjb25zdCB0aGVubmFibGVQdXNoUmVmID0gY2hpbGQocGFyZW50LCBuYW1lKTtcclxuICAgIGNvbnN0IHB1c2hSZWYgPSBjaGlsZChwYXJlbnQsIG5hbWUpO1xyXG4gICAgbGV0IHByb21pc2U7XHJcbiAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xyXG4gICAgICAgIHByb21pc2UgPSBzZXQocHVzaFJlZiwgdmFsdWUpLnRoZW4oKCkgPT4gcHVzaFJlZik7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKHB1c2hSZWYpO1xyXG4gICAgfVxyXG4gICAgdGhlbm5hYmxlUHVzaFJlZi50aGVuID0gcHJvbWlzZS50aGVuLmJpbmQocHJvbWlzZSk7XHJcbiAgICB0aGVubmFibGVQdXNoUmVmLmNhdGNoID0gcHJvbWlzZS50aGVuLmJpbmQocHJvbWlzZSwgdW5kZWZpbmVkKTtcclxuICAgIHJldHVybiB0aGVubmFibGVQdXNoUmVmO1xyXG59XHJcbi8qKlxyXG4gKiBSZW1vdmVzIHRoZSBkYXRhIGF0IHRoaXMgRGF0YWJhc2UgbG9jYXRpb24uXHJcbiAqXHJcbiAqIEFueSBkYXRhIGF0IGNoaWxkIGxvY2F0aW9ucyB3aWxsIGFsc28gYmUgZGVsZXRlZC5cclxuICpcclxuICogVGhlIGVmZmVjdCBvZiB0aGUgcmVtb3ZlIHdpbGwgYmUgdmlzaWJsZSBpbW1lZGlhdGVseSBhbmQgdGhlIGNvcnJlc3BvbmRpbmdcclxuICogZXZlbnQgJ3ZhbHVlJyB3aWxsIGJlIHRyaWdnZXJlZC4gU3luY2hyb25pemF0aW9uIG9mIHRoZSByZW1vdmUgdG8gdGhlXHJcbiAqIEZpcmViYXNlIHNlcnZlcnMgd2lsbCBhbHNvIGJlIHN0YXJ0ZWQsIGFuZCB0aGUgcmV0dXJuZWQgUHJvbWlzZSB3aWxsIHJlc29sdmVcclxuICogd2hlbiBjb21wbGV0ZS4gSWYgcHJvdmlkZWQsIHRoZSBvbkNvbXBsZXRlIGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkXHJcbiAqIGFzeW5jaHJvbm91c2x5IGFmdGVyIHN5bmNocm9uaXphdGlvbiBoYXMgZmluaXNoZWQuXHJcbiAqXHJcbiAqIEBwYXJhbSByZWYgLSBUaGUgbG9jYXRpb24gdG8gcmVtb3ZlLlxyXG4gKiBAcmV0dXJucyBSZXNvbHZlcyB3aGVuIHJlbW92ZSBvbiBzZXJ2ZXIgaXMgY29tcGxldGUuXHJcbiAqL1xyXG5mdW5jdGlvbiByZW1vdmUocmVmKSB7XHJcbiAgICB2YWxpZGF0ZVdyaXRhYmxlUGF0aCgncmVtb3ZlJywgcmVmLl9wYXRoKTtcclxuICAgIHJldHVybiBzZXQocmVmLCBudWxsKTtcclxufVxyXG4vKipcclxuICogV3JpdGVzIGRhdGEgdG8gdGhpcyBEYXRhYmFzZSBsb2NhdGlvbi5cclxuICpcclxuICogVGhpcyB3aWxsIG92ZXJ3cml0ZSBhbnkgZGF0YSBhdCB0aGlzIGxvY2F0aW9uIGFuZCBhbGwgY2hpbGQgbG9jYXRpb25zLlxyXG4gKlxyXG4gKiBUaGUgZWZmZWN0IG9mIHRoZSB3cml0ZSB3aWxsIGJlIHZpc2libGUgaW1tZWRpYXRlbHksIGFuZCB0aGUgY29ycmVzcG9uZGluZ1xyXG4gKiBldmVudHMgKFwidmFsdWVcIiwgXCJjaGlsZF9hZGRlZFwiLCBldGMuKSB3aWxsIGJlIHRyaWdnZXJlZC4gU3luY2hyb25pemF0aW9uIG9mXHJcbiAqIHRoZSBkYXRhIHRvIHRoZSBGaXJlYmFzZSBzZXJ2ZXJzIHdpbGwgYWxzbyBiZSBzdGFydGVkLCBhbmQgdGhlIHJldHVybmVkXHJcbiAqIFByb21pc2Ugd2lsbCByZXNvbHZlIHdoZW4gY29tcGxldGUuIElmIHByb3ZpZGVkLCB0aGUgYG9uQ29tcGxldGVgIGNhbGxiYWNrXHJcbiAqIHdpbGwgYmUgY2FsbGVkIGFzeW5jaHJvbm91c2x5IGFmdGVyIHN5bmNocm9uaXphdGlvbiBoYXMgZmluaXNoZWQuXHJcbiAqXHJcbiAqIFBhc3NpbmcgYG51bGxgIGZvciB0aGUgbmV3IHZhbHVlIGlzIGVxdWl2YWxlbnQgdG8gY2FsbGluZyBgcmVtb3ZlKClgOyBuYW1lbHksXHJcbiAqIGFsbCBkYXRhIGF0IHRoaXMgbG9jYXRpb24gYW5kIGFsbCBjaGlsZCBsb2NhdGlvbnMgd2lsbCBiZSBkZWxldGVkLlxyXG4gKlxyXG4gKiBgc2V0KClgIHdpbGwgcmVtb3ZlIGFueSBwcmlvcml0eSBzdG9yZWQgYXQgdGhpcyBsb2NhdGlvbiwgc28gaWYgcHJpb3JpdHkgaXNcclxuICogbWVhbnQgdG8gYmUgcHJlc2VydmVkLCB5b3UgbmVlZCB0byB1c2UgYHNldFdpdGhQcmlvcml0eSgpYCBpbnN0ZWFkLlxyXG4gKlxyXG4gKiBOb3RlIHRoYXQgbW9kaWZ5aW5nIGRhdGEgd2l0aCBgc2V0KClgIHdpbGwgY2FuY2VsIGFueSBwZW5kaW5nIHRyYW5zYWN0aW9uc1xyXG4gKiBhdCB0aGF0IGxvY2F0aW9uLCBzbyBleHRyZW1lIGNhcmUgc2hvdWxkIGJlIHRha2VuIGlmIG1peGluZyBgc2V0KClgIGFuZFxyXG4gKiBgdHJhbnNhY3Rpb24oKWAgdG8gbW9kaWZ5IHRoZSBzYW1lIGRhdGEuXHJcbiAqXHJcbiAqIEEgc2luZ2xlIGBzZXQoKWAgd2lsbCBnZW5lcmF0ZSBhIHNpbmdsZSBcInZhbHVlXCIgZXZlbnQgYXQgdGhlIGxvY2F0aW9uIHdoZXJlXHJcbiAqIHRoZSBgc2V0KClgIHdhcyBwZXJmb3JtZWQuXHJcbiAqXHJcbiAqIEBwYXJhbSByZWYgLSBUaGUgbG9jYXRpb24gdG8gd3JpdGUgdG8uXHJcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBiZSB3cml0dGVuIChzdHJpbmcsIG51bWJlciwgYm9vbGVhbiwgb2JqZWN0LFxyXG4gKiAgIGFycmF5LCBvciBudWxsKS5cclxuICogQHJldHVybnMgUmVzb2x2ZXMgd2hlbiB3cml0ZSB0byBzZXJ2ZXIgaXMgY29tcGxldGUuXHJcbiAqL1xyXG5mdW5jdGlvbiBzZXQocmVmLCB2YWx1ZSkge1xyXG4gICAgcmVmID0gZ2V0TW9kdWxhckluc3RhbmNlKHJlZik7XHJcbiAgICB2YWxpZGF0ZVdyaXRhYmxlUGF0aCgnc2V0JywgcmVmLl9wYXRoKTtcclxuICAgIHZhbGlkYXRlRmlyZWJhc2VEYXRhQXJnKCdzZXQnLCB2YWx1ZSwgcmVmLl9wYXRoLCBmYWxzZSk7XHJcbiAgICBjb25zdCBkZWZlcnJlZCA9IG5ldyBEZWZlcnJlZCgpO1xyXG4gICAgcmVwb1NldFdpdGhQcmlvcml0eShyZWYuX3JlcG8sIHJlZi5fcGF0aCwgdmFsdWUsIFxyXG4gICAgLypwcmlvcml0eT0qLyBudWxsLCBkZWZlcnJlZC53cmFwQ2FsbGJhY2soKCkgPT4geyB9KSk7XHJcbiAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcclxufVxyXG4vKipcclxuICogU2V0cyBhIHByaW9yaXR5IGZvciB0aGUgZGF0YSBhdCB0aGlzIERhdGFiYXNlIGxvY2F0aW9uLlxyXG4gKlxyXG4gKiBBcHBsaWNhdGlvbnMgbmVlZCBub3QgdXNlIHByaW9yaXR5IGJ1dCBjYW4gb3JkZXIgY29sbGVjdGlvbnMgYnlcclxuICogb3JkaW5hcnkgcHJvcGVydGllcyAoc2VlXHJcbiAqIHtAbGluayBodHRwczovL2ZpcmViYXNlLmdvb2dsZS5jb20vZG9jcy9kYXRhYmFzZS93ZWIvbGlzdHMtb2YtZGF0YSNzb3J0aW5nX2FuZF9maWx0ZXJpbmdfZGF0YSB8IFNvcnRpbmcgYW5kIGZpbHRlcmluZyBkYXRhfVxyXG4gKiApLlxyXG4gKlxyXG4gKiBAcGFyYW0gcmVmIC0gVGhlIGxvY2F0aW9uIHRvIHdyaXRlIHRvLlxyXG4gKiBAcGFyYW0gcHJpb3JpdHkgLSBUaGUgcHJpb3JpdHkgdG8gYmUgd3JpdHRlbiAoc3RyaW5nLCBudW1iZXIsIG9yIG51bGwpLlxyXG4gKiBAcmV0dXJucyBSZXNvbHZlcyB3aGVuIHdyaXRlIHRvIHNlcnZlciBpcyBjb21wbGV0ZS5cclxuICovXHJcbmZ1bmN0aW9uIHNldFByaW9yaXR5KHJlZiwgcHJpb3JpdHkpIHtcclxuICAgIHJlZiA9IGdldE1vZHVsYXJJbnN0YW5jZShyZWYpO1xyXG4gICAgdmFsaWRhdGVXcml0YWJsZVBhdGgoJ3NldFByaW9yaXR5JywgcmVmLl9wYXRoKTtcclxuICAgIHZhbGlkYXRlUHJpb3JpdHkoJ3NldFByaW9yaXR5JywgcHJpb3JpdHksIGZhbHNlKTtcclxuICAgIGNvbnN0IGRlZmVycmVkID0gbmV3IERlZmVycmVkKCk7XHJcbiAgICByZXBvU2V0V2l0aFByaW9yaXR5KHJlZi5fcmVwbywgcGF0aENoaWxkKHJlZi5fcGF0aCwgJy5wcmlvcml0eScpLCBwcmlvcml0eSwgbnVsbCwgZGVmZXJyZWQud3JhcENhbGxiYWNrKCgpID0+IHsgfSkpO1xyXG4gICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XHJcbn1cclxuLyoqXHJcbiAqIFdyaXRlcyBkYXRhIHRoZSBEYXRhYmFzZSBsb2NhdGlvbi4gTGlrZSBgc2V0KClgIGJ1dCBhbHNvIHNwZWNpZmllcyB0aGVcclxuICogcHJpb3JpdHkgZm9yIHRoYXQgZGF0YS5cclxuICpcclxuICogQXBwbGljYXRpb25zIG5lZWQgbm90IHVzZSBwcmlvcml0eSBidXQgY2FuIG9yZGVyIGNvbGxlY3Rpb25zIGJ5XHJcbiAqIG9yZGluYXJ5IHByb3BlcnRpZXMgKHNlZVxyXG4gKiB7QGxpbmsgaHR0cHM6Ly9maXJlYmFzZS5nb29nbGUuY29tL2RvY3MvZGF0YWJhc2Uvd2ViL2xpc3RzLW9mLWRhdGEjc29ydGluZ19hbmRfZmlsdGVyaW5nX2RhdGEgfCBTb3J0aW5nIGFuZCBmaWx0ZXJpbmcgZGF0YX1cclxuICogKS5cclxuICpcclxuICogQHBhcmFtIHJlZiAtIFRoZSBsb2NhdGlvbiB0byB3cml0ZSB0by5cclxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGJlIHdyaXR0ZW4gKHN0cmluZywgbnVtYmVyLCBib29sZWFuLCBvYmplY3QsXHJcbiAqICAgYXJyYXksIG9yIG51bGwpLlxyXG4gKiBAcGFyYW0gcHJpb3JpdHkgLSBUaGUgcHJpb3JpdHkgdG8gYmUgd3JpdHRlbiAoc3RyaW5nLCBudW1iZXIsIG9yIG51bGwpLlxyXG4gKiBAcmV0dXJucyBSZXNvbHZlcyB3aGVuIHdyaXRlIHRvIHNlcnZlciBpcyBjb21wbGV0ZS5cclxuICovXHJcbmZ1bmN0aW9uIHNldFdpdGhQcmlvcml0eShyZWYsIHZhbHVlLCBwcmlvcml0eSkge1xyXG4gICAgdmFsaWRhdGVXcml0YWJsZVBhdGgoJ3NldFdpdGhQcmlvcml0eScsIHJlZi5fcGF0aCk7XHJcbiAgICB2YWxpZGF0ZUZpcmViYXNlRGF0YUFyZygnc2V0V2l0aFByaW9yaXR5JywgdmFsdWUsIHJlZi5fcGF0aCwgZmFsc2UpO1xyXG4gICAgdmFsaWRhdGVQcmlvcml0eSgnc2V0V2l0aFByaW9yaXR5JywgcHJpb3JpdHksIGZhbHNlKTtcclxuICAgIGlmIChyZWYua2V5ID09PSAnLmxlbmd0aCcgfHwgcmVmLmtleSA9PT0gJy5rZXlzJykge1xyXG4gICAgICAgIHRocm93ICdzZXRXaXRoUHJpb3JpdHkgZmFpbGVkOiAnICsgcmVmLmtleSArICcgaXMgYSByZWFkLW9ubHkgb2JqZWN0Lic7XHJcbiAgICB9XHJcbiAgICBjb25zdCBkZWZlcnJlZCA9IG5ldyBEZWZlcnJlZCgpO1xyXG4gICAgcmVwb1NldFdpdGhQcmlvcml0eShyZWYuX3JlcG8sIHJlZi5fcGF0aCwgdmFsdWUsIHByaW9yaXR5LCBkZWZlcnJlZC53cmFwQ2FsbGJhY2soKCkgPT4geyB9KSk7XHJcbiAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcclxufVxyXG4vKipcclxuICogV3JpdGVzIG11bHRpcGxlIHZhbHVlcyB0byB0aGUgRGF0YWJhc2UgYXQgb25jZS5cclxuICpcclxuICogVGhlIGB2YWx1ZXNgIGFyZ3VtZW50IGNvbnRhaW5zIG11bHRpcGxlIHByb3BlcnR5LXZhbHVlIHBhaXJzIHRoYXQgd2lsbCBiZVxyXG4gKiB3cml0dGVuIHRvIHRoZSBEYXRhYmFzZSB0b2dldGhlci4gRWFjaCBjaGlsZCBwcm9wZXJ0eSBjYW4gZWl0aGVyIGJlIGEgc2ltcGxlXHJcbiAqIHByb3BlcnR5IChmb3IgZXhhbXBsZSwgXCJuYW1lXCIpIG9yIGEgcmVsYXRpdmUgcGF0aCAoZm9yIGV4YW1wbGUsXHJcbiAqIFwibmFtZS9maXJzdFwiKSBmcm9tIHRoZSBjdXJyZW50IGxvY2F0aW9uIHRvIHRoZSBkYXRhIHRvIHVwZGF0ZS5cclxuICpcclxuICogQXMgb3Bwb3NlZCB0byB0aGUgYHNldCgpYCBtZXRob2QsIGB1cGRhdGUoKWAgY2FuIGJlIHVzZSB0byBzZWxlY3RpdmVseSB1cGRhdGVcclxuICogb25seSB0aGUgcmVmZXJlbmNlZCBwcm9wZXJ0aWVzIGF0IHRoZSBjdXJyZW50IGxvY2F0aW9uIChpbnN0ZWFkIG9mIHJlcGxhY2luZ1xyXG4gKiBhbGwgdGhlIGNoaWxkIHByb3BlcnRpZXMgYXQgdGhlIGN1cnJlbnQgbG9jYXRpb24pLlxyXG4gKlxyXG4gKiBUaGUgZWZmZWN0IG9mIHRoZSB3cml0ZSB3aWxsIGJlIHZpc2libGUgaW1tZWRpYXRlbHksIGFuZCB0aGUgY29ycmVzcG9uZGluZ1xyXG4gKiBldmVudHMgKCd2YWx1ZScsICdjaGlsZF9hZGRlZCcsIGV0Yy4pIHdpbGwgYmUgdHJpZ2dlcmVkLiBTeW5jaHJvbml6YXRpb24gb2ZcclxuICogdGhlIGRhdGEgdG8gdGhlIEZpcmViYXNlIHNlcnZlcnMgd2lsbCBhbHNvIGJlIHN0YXJ0ZWQsIGFuZCB0aGUgcmV0dXJuZWRcclxuICogUHJvbWlzZSB3aWxsIHJlc29sdmUgd2hlbiBjb21wbGV0ZS4gSWYgcHJvdmlkZWQsIHRoZSBgb25Db21wbGV0ZWAgY2FsbGJhY2tcclxuICogd2lsbCBiZSBjYWxsZWQgYXN5bmNocm9ub3VzbHkgYWZ0ZXIgc3luY2hyb25pemF0aW9uIGhhcyBmaW5pc2hlZC5cclxuICpcclxuICogQSBzaW5nbGUgYHVwZGF0ZSgpYCB3aWxsIGdlbmVyYXRlIGEgc2luZ2xlIFwidmFsdWVcIiBldmVudCBhdCB0aGUgbG9jYXRpb25cclxuICogd2hlcmUgdGhlIGB1cGRhdGUoKWAgd2FzIHBlcmZvcm1lZCwgcmVnYXJkbGVzcyBvZiBob3cgbWFueSBjaGlsZHJlbiB3ZXJlXHJcbiAqIG1vZGlmaWVkLlxyXG4gKlxyXG4gKiBOb3RlIHRoYXQgbW9kaWZ5aW5nIGRhdGEgd2l0aCBgdXBkYXRlKClgIHdpbGwgY2FuY2VsIGFueSBwZW5kaW5nXHJcbiAqIHRyYW5zYWN0aW9ucyBhdCB0aGF0IGxvY2F0aW9uLCBzbyBleHRyZW1lIGNhcmUgc2hvdWxkIGJlIHRha2VuIGlmIG1peGluZ1xyXG4gKiBgdXBkYXRlKClgIGFuZCBgdHJhbnNhY3Rpb24oKWAgdG8gbW9kaWZ5IHRoZSBzYW1lIGRhdGEuXHJcbiAqXHJcbiAqIFBhc3NpbmcgYG51bGxgIHRvIGB1cGRhdGUoKWAgd2lsbCByZW1vdmUgdGhlIGRhdGEgYXQgdGhpcyBsb2NhdGlvbi5cclxuICpcclxuICogU2VlXHJcbiAqIHtAbGluayBodHRwczovL2ZpcmViYXNlLmdvb2dsZWJsb2cuY29tLzIwMTUvMDkvaW50cm9kdWNpbmctbXVsdGktbG9jYXRpb24tdXBkYXRlcy1hbmRfODYuaHRtbCB8IEludHJvZHVjaW5nIG11bHRpLWxvY2F0aW9uIHVwZGF0ZXMgYW5kIG1vcmV9LlxyXG4gKlxyXG4gKiBAcGFyYW0gcmVmIC0gVGhlIGxvY2F0aW9uIHRvIHdyaXRlIHRvLlxyXG4gKiBAcGFyYW0gdmFsdWVzIC0gT2JqZWN0IGNvbnRhaW5pbmcgbXVsdGlwbGUgdmFsdWVzLlxyXG4gKiBAcmV0dXJucyBSZXNvbHZlcyB3aGVuIHVwZGF0ZSBvbiBzZXJ2ZXIgaXMgY29tcGxldGUuXHJcbiAqL1xyXG5mdW5jdGlvbiB1cGRhdGUocmVmLCB2YWx1ZXMpIHtcclxuICAgIHZhbGlkYXRlRmlyZWJhc2VNZXJnZURhdGFBcmcoJ3VwZGF0ZScsIHZhbHVlcywgcmVmLl9wYXRoLCBmYWxzZSk7XHJcbiAgICBjb25zdCBkZWZlcnJlZCA9IG5ldyBEZWZlcnJlZCgpO1xyXG4gICAgcmVwb1VwZGF0ZShyZWYuX3JlcG8sIHJlZi5fcGF0aCwgdmFsdWVzLCBkZWZlcnJlZC53cmFwQ2FsbGJhY2soKCkgPT4geyB9KSk7XHJcbiAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcclxufVxyXG4vKipcclxuICogR2V0cyB0aGUgbW9zdCB1cC10by1kYXRlIHJlc3VsdCBmb3IgdGhpcyBxdWVyeS5cclxuICpcclxuICogQHBhcmFtIHF1ZXJ5IC0gVGhlIHF1ZXJ5IHRvIHJ1bi5cclxuICogQHJldHVybnMgQSBgUHJvbWlzZWAgd2hpY2ggcmVzb2x2ZXMgdG8gdGhlIHJlc3VsdGluZyBEYXRhU25hcHNob3QgaWYgYSB2YWx1ZSBpc1xyXG4gKiBhdmFpbGFibGUsIG9yIHJlamVjdHMgaWYgdGhlIGNsaWVudCBpcyB1bmFibGUgdG8gcmV0dXJuIGEgdmFsdWUgKGUuZy4sIGlmIHRoZVxyXG4gKiBzZXJ2ZXIgaXMgdW5yZWFjaGFibGUgYW5kIHRoZXJlIGlzIG5vdGhpbmcgY2FjaGVkKS5cclxuICovXHJcbmZ1bmN0aW9uIGdldChxdWVyeSkge1xyXG4gICAgcXVlcnkgPSBnZXRNb2R1bGFySW5zdGFuY2UocXVlcnkpO1xyXG4gICAgcmV0dXJuIHJlcG9HZXRWYWx1ZShxdWVyeS5fcmVwbywgcXVlcnkpLnRoZW4obm9kZSA9PiB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRhU25hcHNob3Qobm9kZSwgbmV3IFJlZmVyZW5jZUltcGwocXVlcnkuX3JlcG8sIHF1ZXJ5Ll9wYXRoKSwgcXVlcnkuX3F1ZXJ5UGFyYW1zLmdldEluZGV4KCkpO1xyXG4gICAgfSk7XHJcbn1cclxuLyoqXHJcbiAqIFJlcHJlc2VudHMgcmVnaXN0cmF0aW9uIGZvciAndmFsdWUnIGV2ZW50cy5cclxuICovXHJcbmNsYXNzIFZhbHVlRXZlbnRSZWdpc3RyYXRpb24ge1xyXG4gICAgY29uc3RydWN0b3IoY2FsbGJhY2tDb250ZXh0KSB7XHJcbiAgICAgICAgdGhpcy5jYWxsYmFja0NvbnRleHQgPSBjYWxsYmFja0NvbnRleHQ7XHJcbiAgICB9XHJcbiAgICByZXNwb25kc1RvKGV2ZW50VHlwZSkge1xyXG4gICAgICAgIHJldHVybiBldmVudFR5cGUgPT09ICd2YWx1ZSc7XHJcbiAgICB9XHJcbiAgICBjcmVhdGVFdmVudChjaGFuZ2UsIHF1ZXJ5KSB7XHJcbiAgICAgICAgY29uc3QgaW5kZXggPSBxdWVyeS5fcXVlcnlQYXJhbXMuZ2V0SW5kZXgoKTtcclxuICAgICAgICByZXR1cm4gbmV3IERhdGFFdmVudCgndmFsdWUnLCB0aGlzLCBuZXcgRGF0YVNuYXBzaG90KGNoYW5nZS5zbmFwc2hvdE5vZGUsIG5ldyBSZWZlcmVuY2VJbXBsKHF1ZXJ5Ll9yZXBvLCBxdWVyeS5fcGF0aCksIGluZGV4KSk7XHJcbiAgICB9XHJcbiAgICBnZXRFdmVudFJ1bm5lcihldmVudERhdGEpIHtcclxuICAgICAgICBpZiAoZXZlbnREYXRhLmdldEV2ZW50VHlwZSgpID09PSAnY2FuY2VsJykge1xyXG4gICAgICAgICAgICByZXR1cm4gKCkgPT4gdGhpcy5jYWxsYmFja0NvbnRleHQub25DYW5jZWwoZXZlbnREYXRhLmVycm9yKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiB0aGlzLmNhbGxiYWNrQ29udGV4dC5vblZhbHVlKGV2ZW50RGF0YS5zbmFwc2hvdCwgbnVsbCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY3JlYXRlQ2FuY2VsRXZlbnQoZXJyb3IsIHBhdGgpIHtcclxuICAgICAgICBpZiAodGhpcy5jYWxsYmFja0NvbnRleHQuaGFzQ2FuY2VsQ2FsbGJhY2spIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBDYW5jZWxFdmVudCh0aGlzLCBlcnJvciwgcGF0aCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBtYXRjaGVzKG90aGVyKSB7XHJcbiAgICAgICAgaWYgKCEob3RoZXIgaW5zdGFuY2VvZiBWYWx1ZUV2ZW50UmVnaXN0cmF0aW9uKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKCFvdGhlci5jYWxsYmFja0NvbnRleHQgfHwgIXRoaXMuY2FsbGJhY2tDb250ZXh0KSB7XHJcbiAgICAgICAgICAgIC8vIElmIG5vIGNhbGxiYWNrIHNwZWNpZmllZCwgd2UgY29uc2lkZXIgaXQgdG8gbWF0Y2ggYW55IGNhbGxiYWNrLlxyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBvdGhlci5jYWxsYmFja0NvbnRleHQubWF0Y2hlcyh0aGlzLmNhbGxiYWNrQ29udGV4dCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaGFzQW55Q2FsbGJhY2soKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsbGJhY2tDb250ZXh0ICE9PSBudWxsO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBSZXByZXNlbnRzIHRoZSByZWdpc3RyYXRpb24gb2YgYSBjaGlsZF94IGV2ZW50LlxyXG4gKi9cclxuY2xhc3MgQ2hpbGRFdmVudFJlZ2lzdHJhdGlvbiB7XHJcbiAgICBjb25zdHJ1Y3RvcihldmVudFR5cGUsIGNhbGxiYWNrQ29udGV4dCkge1xyXG4gICAgICAgIHRoaXMuZXZlbnRUeXBlID0gZXZlbnRUeXBlO1xyXG4gICAgICAgIHRoaXMuY2FsbGJhY2tDb250ZXh0ID0gY2FsbGJhY2tDb250ZXh0O1xyXG4gICAgfVxyXG4gICAgcmVzcG9uZHNUbyhldmVudFR5cGUpIHtcclxuICAgICAgICBsZXQgZXZlbnRUb0NoZWNrID0gZXZlbnRUeXBlID09PSAnY2hpbGRyZW5fYWRkZWQnID8gJ2NoaWxkX2FkZGVkJyA6IGV2ZW50VHlwZTtcclxuICAgICAgICBldmVudFRvQ2hlY2sgPVxyXG4gICAgICAgICAgICBldmVudFRvQ2hlY2sgPT09ICdjaGlsZHJlbl9yZW1vdmVkJyA/ICdjaGlsZF9yZW1vdmVkJyA6IGV2ZW50VG9DaGVjaztcclxuICAgICAgICByZXR1cm4gdGhpcy5ldmVudFR5cGUgPT09IGV2ZW50VG9DaGVjaztcclxuICAgIH1cclxuICAgIGNyZWF0ZUNhbmNlbEV2ZW50KGVycm9yLCBwYXRoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuY2FsbGJhY2tDb250ZXh0Lmhhc0NhbmNlbENhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ2FuY2VsRXZlbnQodGhpcywgZXJyb3IsIHBhdGgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY3JlYXRlRXZlbnQoY2hhbmdlLCBxdWVyeSkge1xyXG4gICAgICAgIGFzc2VydChjaGFuZ2UuY2hpbGROYW1lICE9IG51bGwsICdDaGlsZCBldmVudHMgc2hvdWxkIGhhdmUgYSBjaGlsZE5hbWUuJyk7XHJcbiAgICAgICAgY29uc3QgY2hpbGRSZWYgPSBjaGlsZChuZXcgUmVmZXJlbmNlSW1wbChxdWVyeS5fcmVwbywgcXVlcnkuX3BhdGgpLCBjaGFuZ2UuY2hpbGROYW1lKTtcclxuICAgICAgICBjb25zdCBpbmRleCA9IHF1ZXJ5Ll9xdWVyeVBhcmFtcy5nZXRJbmRleCgpO1xyXG4gICAgICAgIHJldHVybiBuZXcgRGF0YUV2ZW50KGNoYW5nZS50eXBlLCB0aGlzLCBuZXcgRGF0YVNuYXBzaG90KGNoYW5nZS5zbmFwc2hvdE5vZGUsIGNoaWxkUmVmLCBpbmRleCksIGNoYW5nZS5wcmV2TmFtZSk7XHJcbiAgICB9XHJcbiAgICBnZXRFdmVudFJ1bm5lcihldmVudERhdGEpIHtcclxuICAgICAgICBpZiAoZXZlbnREYXRhLmdldEV2ZW50VHlwZSgpID09PSAnY2FuY2VsJykge1xyXG4gICAgICAgICAgICByZXR1cm4gKCkgPT4gdGhpcy5jYWxsYmFja0NvbnRleHQub25DYW5jZWwoZXZlbnREYXRhLmVycm9yKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiB0aGlzLmNhbGxiYWNrQ29udGV4dC5vblZhbHVlKGV2ZW50RGF0YS5zbmFwc2hvdCwgZXZlbnREYXRhLnByZXZOYW1lKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBtYXRjaGVzKG90aGVyKSB7XHJcbiAgICAgICAgaWYgKG90aGVyIGluc3RhbmNlb2YgQ2hpbGRFdmVudFJlZ2lzdHJhdGlvbikge1xyXG4gICAgICAgICAgICByZXR1cm4gKHRoaXMuZXZlbnRUeXBlID09PSBvdGhlci5ldmVudFR5cGUgJiZcclxuICAgICAgICAgICAgICAgICghdGhpcy5jYWxsYmFja0NvbnRleHQgfHxcclxuICAgICAgICAgICAgICAgICAgICAhb3RoZXIuY2FsbGJhY2tDb250ZXh0IHx8XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jYWxsYmFja0NvbnRleHQubWF0Y2hlcyhvdGhlci5jYWxsYmFja0NvbnRleHQpKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIGhhc0FueUNhbGxiYWNrKCkge1xyXG4gICAgICAgIHJldHVybiAhIXRoaXMuY2FsbGJhY2tDb250ZXh0O1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGFkZEV2ZW50TGlzdGVuZXIocXVlcnksIGV2ZW50VHlwZSwgY2FsbGJhY2ssIGNhbmNlbENhbGxiYWNrT3JMaXN0ZW5PcHRpb25zLCBvcHRpb25zKSB7XHJcbiAgICBsZXQgY2FuY2VsQ2FsbGJhY2s7XHJcbiAgICBpZiAodHlwZW9mIGNhbmNlbENhbGxiYWNrT3JMaXN0ZW5PcHRpb25zID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgIGNhbmNlbENhbGxiYWNrID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIG9wdGlvbnMgPSBjYW5jZWxDYWxsYmFja09yTGlzdGVuT3B0aW9ucztcclxuICAgIH1cclxuICAgIGlmICh0eXBlb2YgY2FuY2VsQ2FsbGJhY2tPckxpc3Rlbk9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICBjYW5jZWxDYWxsYmFjayA9IGNhbmNlbENhbGxiYWNrT3JMaXN0ZW5PcHRpb25zO1xyXG4gICAgfVxyXG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5vbmx5T25jZSkge1xyXG4gICAgICAgIGNvbnN0IHVzZXJDYWxsYmFjayA9IGNhbGxiYWNrO1xyXG4gICAgICAgIGNvbnN0IG9uY2VDYWxsYmFjayA9IChkYXRhU25hcHNob3QsIHByZXZpb3VzQ2hpbGROYW1lKSA9PiB7XHJcbiAgICAgICAgICAgIHJlcG9SZW1vdmVFdmVudENhbGxiYWNrRm9yUXVlcnkocXVlcnkuX3JlcG8sIHF1ZXJ5LCBjb250YWluZXIpO1xyXG4gICAgICAgICAgICB1c2VyQ2FsbGJhY2soZGF0YVNuYXBzaG90LCBwcmV2aW91c0NoaWxkTmFtZSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBvbmNlQ2FsbGJhY2sudXNlckNhbGxiYWNrID0gY2FsbGJhY2sudXNlckNhbGxiYWNrO1xyXG4gICAgICAgIG9uY2VDYWxsYmFjay5jb250ZXh0ID0gY2FsbGJhY2suY29udGV4dDtcclxuICAgICAgICBjYWxsYmFjayA9IG9uY2VDYWxsYmFjaztcclxuICAgIH1cclxuICAgIGNvbnN0IGNhbGxiYWNrQ29udGV4dCA9IG5ldyBDYWxsYmFja0NvbnRleHQoY2FsbGJhY2ssIGNhbmNlbENhbGxiYWNrIHx8IHVuZGVmaW5lZCk7XHJcbiAgICBjb25zdCBjb250YWluZXIgPSBldmVudFR5cGUgPT09ICd2YWx1ZSdcclxuICAgICAgICA/IG5ldyBWYWx1ZUV2ZW50UmVnaXN0cmF0aW9uKGNhbGxiYWNrQ29udGV4dClcclxuICAgICAgICA6IG5ldyBDaGlsZEV2ZW50UmVnaXN0cmF0aW9uKGV2ZW50VHlwZSwgY2FsbGJhY2tDb250ZXh0KTtcclxuICAgIHJlcG9BZGRFdmVudENhbGxiYWNrRm9yUXVlcnkocXVlcnkuX3JlcG8sIHF1ZXJ5LCBjb250YWluZXIpO1xyXG4gICAgcmV0dXJuICgpID0+IHJlcG9SZW1vdmVFdmVudENhbGxiYWNrRm9yUXVlcnkocXVlcnkuX3JlcG8sIHF1ZXJ5LCBjb250YWluZXIpO1xyXG59XHJcbmZ1bmN0aW9uIG9uVmFsdWUocXVlcnksIGNhbGxiYWNrLCBjYW5jZWxDYWxsYmFja09yTGlzdGVuT3B0aW9ucywgb3B0aW9ucykge1xyXG4gICAgcmV0dXJuIGFkZEV2ZW50TGlzdGVuZXIocXVlcnksICd2YWx1ZScsIGNhbGxiYWNrLCBjYW5jZWxDYWxsYmFja09yTGlzdGVuT3B0aW9ucywgb3B0aW9ucyk7XHJcbn1cclxuZnVuY3Rpb24gb25DaGlsZEFkZGVkKHF1ZXJ5LCBjYWxsYmFjaywgY2FuY2VsQ2FsbGJhY2tPckxpc3Rlbk9wdGlvbnMsIG9wdGlvbnMpIHtcclxuICAgIHJldHVybiBhZGRFdmVudExpc3RlbmVyKHF1ZXJ5LCAnY2hpbGRfYWRkZWQnLCBjYWxsYmFjaywgY2FuY2VsQ2FsbGJhY2tPckxpc3Rlbk9wdGlvbnMsIG9wdGlvbnMpO1xyXG59XHJcbmZ1bmN0aW9uIG9uQ2hpbGRDaGFuZ2VkKHF1ZXJ5LCBjYWxsYmFjaywgY2FuY2VsQ2FsbGJhY2tPckxpc3Rlbk9wdGlvbnMsIG9wdGlvbnMpIHtcclxuICAgIHJldHVybiBhZGRFdmVudExpc3RlbmVyKHF1ZXJ5LCAnY2hpbGRfY2hhbmdlZCcsIGNhbGxiYWNrLCBjYW5jZWxDYWxsYmFja09yTGlzdGVuT3B0aW9ucywgb3B0aW9ucyk7XHJcbn1cclxuZnVuY3Rpb24gb25DaGlsZE1vdmVkKHF1ZXJ5LCBjYWxsYmFjaywgY2FuY2VsQ2FsbGJhY2tPckxpc3Rlbk9wdGlvbnMsIG9wdGlvbnMpIHtcclxuICAgIHJldHVybiBhZGRFdmVudExpc3RlbmVyKHF1ZXJ5LCAnY2hpbGRfbW92ZWQnLCBjYWxsYmFjaywgY2FuY2VsQ2FsbGJhY2tPckxpc3Rlbk9wdGlvbnMsIG9wdGlvbnMpO1xyXG59XHJcbmZ1bmN0aW9uIG9uQ2hpbGRSZW1vdmVkKHF1ZXJ5LCBjYWxsYmFjaywgY2FuY2VsQ2FsbGJhY2tPckxpc3Rlbk9wdGlvbnMsIG9wdGlvbnMpIHtcclxuICAgIHJldHVybiBhZGRFdmVudExpc3RlbmVyKHF1ZXJ5LCAnY2hpbGRfcmVtb3ZlZCcsIGNhbGxiYWNrLCBjYW5jZWxDYWxsYmFja09yTGlzdGVuT3B0aW9ucywgb3B0aW9ucyk7XHJcbn1cclxuLyoqXHJcbiAqIERldGFjaGVzIGEgY2FsbGJhY2sgcHJldmlvdXNseSBhdHRhY2hlZCB3aXRoIGBvbigpYC5cclxuICpcclxuICogRGV0YWNoIGEgY2FsbGJhY2sgcHJldmlvdXNseSBhdHRhY2hlZCB3aXRoIGBvbigpYC4gTm90ZSB0aGF0IGlmIGBvbigpYCB3YXNcclxuICogY2FsbGVkIG11bHRpcGxlIHRpbWVzIHdpdGggdGhlIHNhbWUgZXZlbnRUeXBlIGFuZCBjYWxsYmFjaywgdGhlIGNhbGxiYWNrXHJcbiAqIHdpbGwgYmUgY2FsbGVkIG11bHRpcGxlIHRpbWVzIGZvciBlYWNoIGV2ZW50LCBhbmQgYG9mZigpYCBtdXN0IGJlIGNhbGxlZFxyXG4gKiBtdWx0aXBsZSB0aW1lcyB0byByZW1vdmUgdGhlIGNhbGxiYWNrLiBDYWxsaW5nIGBvZmYoKWAgb24gYSBwYXJlbnQgbGlzdGVuZXJcclxuICogd2lsbCBub3QgYXV0b21hdGljYWxseSByZW1vdmUgbGlzdGVuZXJzIHJlZ2lzdGVyZWQgb24gY2hpbGQgbm9kZXMsIGBvZmYoKWBcclxuICogbXVzdCBhbHNvIGJlIGNhbGxlZCBvbiBhbnkgY2hpbGQgbGlzdGVuZXJzIHRvIHJlbW92ZSB0aGUgY2FsbGJhY2suXHJcbiAqXHJcbiAqIElmIGEgY2FsbGJhY2sgaXMgbm90IHNwZWNpZmllZCwgYWxsIGNhbGxiYWNrcyBmb3IgdGhlIHNwZWNpZmllZCBldmVudFR5cGVcclxuICogd2lsbCBiZSByZW1vdmVkLiBTaW1pbGFybHksIGlmIG5vIGV2ZW50VHlwZSBpcyBzcGVjaWZpZWQsIGFsbCBjYWxsYmFja3NcclxuICogZm9yIHRoZSBgUmVmZXJlbmNlYCB3aWxsIGJlIHJlbW92ZWQuXHJcbiAqXHJcbiAqIEluZGl2aWR1YWwgbGlzdGVuZXJzIGNhbiBhbHNvIGJlIHJlbW92ZWQgYnkgaW52b2tpbmcgdGhlaXIgdW5zdWJzY3JpYmVcclxuICogY2FsbGJhY2tzLlxyXG4gKlxyXG4gKiBAcGFyYW0gcXVlcnkgLSBUaGUgcXVlcnkgdGhhdCB0aGUgbGlzdGVuZXIgd2FzIHJlZ2lzdGVyZWQgd2l0aC5cclxuICogQHBhcmFtIGV2ZW50VHlwZSAtIE9uZSBvZiB0aGUgZm9sbG93aW5nIHN0cmluZ3M6IFwidmFsdWVcIiwgXCJjaGlsZF9hZGRlZFwiLFxyXG4gKiBcImNoaWxkX2NoYW5nZWRcIiwgXCJjaGlsZF9yZW1vdmVkXCIsIG9yIFwiY2hpbGRfbW92ZWQuXCIgSWYgb21pdHRlZCwgYWxsIGNhbGxiYWNrc1xyXG4gKiBmb3IgdGhlIGBSZWZlcmVuY2VgIHdpbGwgYmUgcmVtb3ZlZC5cclxuICogQHBhcmFtIGNhbGxiYWNrIC0gVGhlIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgd2FzIHBhc3NlZCB0byBgb24oKWAgb3JcclxuICogYHVuZGVmaW5lZGAgdG8gcmVtb3ZlIGFsbCBjYWxsYmFja3MuXHJcbiAqL1xyXG5mdW5jdGlvbiBvZmYocXVlcnksIGV2ZW50VHlwZSwgY2FsbGJhY2spIHtcclxuICAgIGxldCBjb250YWluZXIgPSBudWxsO1xyXG4gICAgY29uc3QgZXhwQ2FsbGJhY2sgPSBjYWxsYmFjayA/IG5ldyBDYWxsYmFja0NvbnRleHQoY2FsbGJhY2spIDogbnVsbDtcclxuICAgIGlmIChldmVudFR5cGUgPT09ICd2YWx1ZScpIHtcclxuICAgICAgICBjb250YWluZXIgPSBuZXcgVmFsdWVFdmVudFJlZ2lzdHJhdGlvbihleHBDYWxsYmFjayk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChldmVudFR5cGUpIHtcclxuICAgICAgICBjb250YWluZXIgPSBuZXcgQ2hpbGRFdmVudFJlZ2lzdHJhdGlvbihldmVudFR5cGUsIGV4cENhbGxiYWNrKTtcclxuICAgIH1cclxuICAgIHJlcG9SZW1vdmVFdmVudENhbGxiYWNrRm9yUXVlcnkocXVlcnkuX3JlcG8sIHF1ZXJ5LCBjb250YWluZXIpO1xyXG59XHJcbi8qKlxyXG4gKiBBIGBRdWVyeUNvbnN0cmFpbnRgIGlzIHVzZWQgdG8gbmFycm93IHRoZSBzZXQgb2YgZG9jdW1lbnRzIHJldHVybmVkIGJ5IGFcclxuICogRGF0YWJhc2UgcXVlcnkuIGBRdWVyeUNvbnN0cmFpbnRgcyBhcmUgY3JlYXRlZCBieSBpbnZva2luZyB7QGxpbmsgZW5kQXR9LFxyXG4gKiB7QGxpbmsgZW5kQmVmb3JlfSwge0BsaW5rIHN0YXJ0QXR9LCB7QGxpbmsgc3RhcnRBZnRlcn0sIHtAbGlua1xyXG4gKiBsaW1pdFRvRmlyc3R9LCB7QGxpbmsgbGltaXRUb0xhc3R9LCB7QGxpbmsgb3JkZXJCeUNoaWxkfSxcclxuICoge0BsaW5rIG9yZGVyQnlDaGlsZH0sIHtAbGluayBvcmRlckJ5S2V5fSAsIHtAbGluayBvcmRlckJ5UHJpb3JpdHl9ICxcclxuICoge0BsaW5rIG9yZGVyQnlWYWx1ZX0gIG9yIHtAbGluayBlcXVhbFRvfSBhbmRcclxuICogY2FuIHRoZW4gYmUgcGFzc2VkIHRvIHtAbGluayBxdWVyeX0gdG8gY3JlYXRlIGEgbmV3IHF1ZXJ5IGluc3RhbmNlIHRoYXRcclxuICogYWxzbyBjb250YWlucyB0aGlzIGBRdWVyeUNvbnN0cmFpbnRgLlxyXG4gKi9cclxuY2xhc3MgUXVlcnlDb25zdHJhaW50IHtcclxufVxyXG5jbGFzcyBRdWVyeUVuZEF0Q29uc3RyYWludCBleHRlbmRzIFF1ZXJ5Q29uc3RyYWludCB7XHJcbiAgICBjb25zdHJ1Y3RvcihfdmFsdWUsIF9rZXkpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMuX3ZhbHVlID0gX3ZhbHVlO1xyXG4gICAgICAgIHRoaXMuX2tleSA9IF9rZXk7XHJcbiAgICB9XHJcbiAgICBfYXBwbHkocXVlcnkpIHtcclxuICAgICAgICB2YWxpZGF0ZUZpcmViYXNlRGF0YUFyZygnZW5kQXQnLCB0aGlzLl92YWx1ZSwgcXVlcnkuX3BhdGgsIHRydWUpO1xyXG4gICAgICAgIGNvbnN0IG5ld1BhcmFtcyA9IHF1ZXJ5UGFyYW1zRW5kQXQocXVlcnkuX3F1ZXJ5UGFyYW1zLCB0aGlzLl92YWx1ZSwgdGhpcy5fa2V5KTtcclxuICAgICAgICB2YWxpZGF0ZUxpbWl0KG5ld1BhcmFtcyk7XHJcbiAgICAgICAgdmFsaWRhdGVRdWVyeUVuZHBvaW50cyhuZXdQYXJhbXMpO1xyXG4gICAgICAgIGlmIChxdWVyeS5fcXVlcnlQYXJhbXMuaGFzRW5kKCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdlbmRBdDogU3RhcnRpbmcgcG9pbnQgd2FzIGFscmVhZHkgc2V0IChieSBhbm90aGVyIGNhbGwgdG8gZW5kQXQsICcgK1xyXG4gICAgICAgICAgICAgICAgJ2VuZEJlZm9yZSBvciBlcXVhbFRvKS4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBRdWVyeUltcGwocXVlcnkuX3JlcG8sIHF1ZXJ5Ll9wYXRoLCBuZXdQYXJhbXMsIHF1ZXJ5Ll9vcmRlckJ5Q2FsbGVkKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQ3JlYXRlcyBhIGBRdWVyeUNvbnN0cmFpbnRgIHdpdGggdGhlIHNwZWNpZmllZCBlbmRpbmcgcG9pbnQuXHJcbiAqXHJcbiAqIFVzaW5nIGBzdGFydEF0KClgLCBgc3RhcnRBZnRlcigpYCwgYGVuZEJlZm9yZSgpYCwgYGVuZEF0KClgIGFuZCBgZXF1YWxUbygpYFxyXG4gKiBhbGxvd3MgeW91IHRvIGNob29zZSBhcmJpdHJhcnkgc3RhcnRpbmcgYW5kIGVuZGluZyBwb2ludHMgZm9yIHlvdXIgcXVlcmllcy5cclxuICpcclxuICogVGhlIGVuZGluZyBwb2ludCBpcyBpbmNsdXNpdmUsIHNvIGNoaWxkcmVuIHdpdGggZXhhY3RseSB0aGUgc3BlY2lmaWVkIHZhbHVlXHJcbiAqIHdpbGwgYmUgaW5jbHVkZWQgaW4gdGhlIHF1ZXJ5LiBUaGUgb3B0aW9uYWwga2V5IGFyZ3VtZW50IGNhbiBiZSB1c2VkIHRvXHJcbiAqIGZ1cnRoZXIgbGltaXQgdGhlIHJhbmdlIG9mIHRoZSBxdWVyeS4gSWYgaXQgaXMgc3BlY2lmaWVkLCB0aGVuIGNoaWxkcmVuIHRoYXRcclxuICogaGF2ZSBleGFjdGx5IHRoZSBzcGVjaWZpZWQgdmFsdWUgbXVzdCBhbHNvIGhhdmUgYSBrZXkgbmFtZSBsZXNzIHRoYW4gb3IgZXF1YWxcclxuICogdG8gdGhlIHNwZWNpZmllZCBrZXkuXHJcbiAqXHJcbiAqIFlvdSBjYW4gcmVhZCBtb3JlIGFib3V0IGBlbmRBdCgpYCBpblxyXG4gKiB7QGxpbmsgaHR0cHM6Ly9maXJlYmFzZS5nb29nbGUuY29tL2RvY3MvZGF0YWJhc2Uvd2ViL2xpc3RzLW9mLWRhdGEjZmlsdGVyaW5nX2RhdGEgfCBGaWx0ZXJpbmcgZGF0YX0uXHJcbiAqXHJcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBlbmQgYXQuIFRoZSBhcmd1bWVudCB0eXBlIGRlcGVuZHMgb24gd2hpY2hcclxuICogYG9yZGVyQnkqKClgIGZ1bmN0aW9uIHdhcyB1c2VkIGluIHRoaXMgcXVlcnkuIFNwZWNpZnkgYSB2YWx1ZSB0aGF0IG1hdGNoZXNcclxuICogdGhlIGBvcmRlckJ5KigpYCB0eXBlLiBXaGVuIHVzZWQgaW4gY29tYmluYXRpb24gd2l0aCBgb3JkZXJCeUtleSgpYCwgdGhlXHJcbiAqIHZhbHVlIG11c3QgYmUgYSBzdHJpbmcuXHJcbiAqIEBwYXJhbSBrZXkgLSBUaGUgY2hpbGQga2V5IHRvIGVuZCBhdCwgYW1vbmcgdGhlIGNoaWxkcmVuIHdpdGggdGhlIHByZXZpb3VzbHlcclxuICogc3BlY2lmaWVkIHByaW9yaXR5LiBUaGlzIGFyZ3VtZW50IGlzIG9ubHkgYWxsb3dlZCBpZiBvcmRlcmluZyBieSBjaGlsZCxcclxuICogdmFsdWUsIG9yIHByaW9yaXR5LlxyXG4gKi9cclxuZnVuY3Rpb24gZW5kQXQodmFsdWUsIGtleSkge1xyXG4gICAgdmFsaWRhdGVLZXkoJ2VuZEF0JywgJ2tleScsIGtleSwgdHJ1ZSk7XHJcbiAgICByZXR1cm4gbmV3IFF1ZXJ5RW5kQXRDb25zdHJhaW50KHZhbHVlLCBrZXkpO1xyXG59XHJcbmNsYXNzIFF1ZXJ5RW5kQmVmb3JlQ29uc3RyYWludCBleHRlbmRzIFF1ZXJ5Q29uc3RyYWludCB7XHJcbiAgICBjb25zdHJ1Y3RvcihfdmFsdWUsIF9rZXkpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMuX3ZhbHVlID0gX3ZhbHVlO1xyXG4gICAgICAgIHRoaXMuX2tleSA9IF9rZXk7XHJcbiAgICB9XHJcbiAgICBfYXBwbHkocXVlcnkpIHtcclxuICAgICAgICB2YWxpZGF0ZUZpcmViYXNlRGF0YUFyZygnZW5kQmVmb3JlJywgdGhpcy5fdmFsdWUsIHF1ZXJ5Ll9wYXRoLCBmYWxzZSk7XHJcbiAgICAgICAgY29uc3QgbmV3UGFyYW1zID0gcXVlcnlQYXJhbXNFbmRCZWZvcmUocXVlcnkuX3F1ZXJ5UGFyYW1zLCB0aGlzLl92YWx1ZSwgdGhpcy5fa2V5KTtcclxuICAgICAgICB2YWxpZGF0ZUxpbWl0KG5ld1BhcmFtcyk7XHJcbiAgICAgICAgdmFsaWRhdGVRdWVyeUVuZHBvaW50cyhuZXdQYXJhbXMpO1xyXG4gICAgICAgIGlmIChxdWVyeS5fcXVlcnlQYXJhbXMuaGFzRW5kKCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdlbmRCZWZvcmU6IFN0YXJ0aW5nIHBvaW50IHdhcyBhbHJlYWR5IHNldCAoYnkgYW5vdGhlciBjYWxsIHRvIGVuZEF0LCAnICtcclxuICAgICAgICAgICAgICAgICdlbmRCZWZvcmUgb3IgZXF1YWxUbykuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgUXVlcnlJbXBsKHF1ZXJ5Ll9yZXBvLCBxdWVyeS5fcGF0aCwgbmV3UGFyYW1zLCBxdWVyeS5fb3JkZXJCeUNhbGxlZCk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIENyZWF0ZXMgYSBgUXVlcnlDb25zdHJhaW50YCB3aXRoIHRoZSBzcGVjaWZpZWQgZW5kaW5nIHBvaW50IChleGNsdXNpdmUpLlxyXG4gKlxyXG4gKiBVc2luZyBgc3RhcnRBdCgpYCwgYHN0YXJ0QWZ0ZXIoKWAsIGBlbmRCZWZvcmUoKWAsIGBlbmRBdCgpYCBhbmQgYGVxdWFsVG8oKWBcclxuICogYWxsb3dzIHlvdSB0byBjaG9vc2UgYXJiaXRyYXJ5IHN0YXJ0aW5nIGFuZCBlbmRpbmcgcG9pbnRzIGZvciB5b3VyIHF1ZXJpZXMuXHJcbiAqXHJcbiAqIFRoZSBlbmRpbmcgcG9pbnQgaXMgZXhjbHVzaXZlLiBJZiBvbmx5IGEgdmFsdWUgaXMgcHJvdmlkZWQsIGNoaWxkcmVuXHJcbiAqIHdpdGggYSB2YWx1ZSBsZXNzIHRoYW4gdGhlIHNwZWNpZmllZCB2YWx1ZSB3aWxsIGJlIGluY2x1ZGVkIGluIHRoZSBxdWVyeS5cclxuICogSWYgYSBrZXkgaXMgc3BlY2lmaWVkLCB0aGVuIGNoaWxkcmVuIG11c3QgaGF2ZSBhIHZhbHVlIGxlc3NzIHRoYW4gb3IgZXF1YWxcclxuICogdG8gdGhlIHNwZWNpZmllZCB2YWx1ZSBhbmQgYSBhIGtleSBuYW1lIGxlc3MgdGhhbiB0aGUgc3BlY2lmaWVkIGtleS5cclxuICpcclxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGVuZCBiZWZvcmUuIFRoZSBhcmd1bWVudCB0eXBlIGRlcGVuZHMgb24gd2hpY2hcclxuICogYG9yZGVyQnkqKClgIGZ1bmN0aW9uIHdhcyB1c2VkIGluIHRoaXMgcXVlcnkuIFNwZWNpZnkgYSB2YWx1ZSB0aGF0IG1hdGNoZXNcclxuICogdGhlIGBvcmRlckJ5KigpYCB0eXBlLiBXaGVuIHVzZWQgaW4gY29tYmluYXRpb24gd2l0aCBgb3JkZXJCeUtleSgpYCwgdGhlXHJcbiAqIHZhbHVlIG11c3QgYmUgYSBzdHJpbmcuXHJcbiAqIEBwYXJhbSBrZXkgLSBUaGUgY2hpbGQga2V5IHRvIGVuZCBiZWZvcmUsIGFtb25nIHRoZSBjaGlsZHJlbiB3aXRoIHRoZVxyXG4gKiBwcmV2aW91c2x5IHNwZWNpZmllZCBwcmlvcml0eS4gVGhpcyBhcmd1bWVudCBpcyBvbmx5IGFsbG93ZWQgaWYgb3JkZXJpbmcgYnlcclxuICogY2hpbGQsIHZhbHVlLCBvciBwcmlvcml0eS5cclxuICovXHJcbmZ1bmN0aW9uIGVuZEJlZm9yZSh2YWx1ZSwga2V5KSB7XHJcbiAgICB2YWxpZGF0ZUtleSgnZW5kQmVmb3JlJywgJ2tleScsIGtleSwgdHJ1ZSk7XHJcbiAgICByZXR1cm4gbmV3IFF1ZXJ5RW5kQmVmb3JlQ29uc3RyYWludCh2YWx1ZSwga2V5KTtcclxufVxyXG5jbGFzcyBRdWVyeVN0YXJ0QXRDb25zdHJhaW50IGV4dGVuZHMgUXVlcnlDb25zdHJhaW50IHtcclxuICAgIGNvbnN0cnVjdG9yKF92YWx1ZSwgX2tleSkge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5fdmFsdWUgPSBfdmFsdWU7XHJcbiAgICAgICAgdGhpcy5fa2V5ID0gX2tleTtcclxuICAgIH1cclxuICAgIF9hcHBseShxdWVyeSkge1xyXG4gICAgICAgIHZhbGlkYXRlRmlyZWJhc2VEYXRhQXJnKCdzdGFydEF0JywgdGhpcy5fdmFsdWUsIHF1ZXJ5Ll9wYXRoLCB0cnVlKTtcclxuICAgICAgICBjb25zdCBuZXdQYXJhbXMgPSBxdWVyeVBhcmFtc1N0YXJ0QXQocXVlcnkuX3F1ZXJ5UGFyYW1zLCB0aGlzLl92YWx1ZSwgdGhpcy5fa2V5KTtcclxuICAgICAgICB2YWxpZGF0ZUxpbWl0KG5ld1BhcmFtcyk7XHJcbiAgICAgICAgdmFsaWRhdGVRdWVyeUVuZHBvaW50cyhuZXdQYXJhbXMpO1xyXG4gICAgICAgIGlmIChxdWVyeS5fcXVlcnlQYXJhbXMuaGFzU3RhcnQoKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3N0YXJ0QXQ6IFN0YXJ0aW5nIHBvaW50IHdhcyBhbHJlYWR5IHNldCAoYnkgYW5vdGhlciBjYWxsIHRvIHN0YXJ0QXQsICcgK1xyXG4gICAgICAgICAgICAgICAgJ3N0YXJ0QmVmb3JlIG9yIGVxdWFsVG8pLicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IFF1ZXJ5SW1wbChxdWVyeS5fcmVwbywgcXVlcnkuX3BhdGgsIG5ld1BhcmFtcywgcXVlcnkuX29yZGVyQnlDYWxsZWQpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEgYFF1ZXJ5Q29uc3RyYWludGAgd2l0aCB0aGUgc3BlY2lmaWVkIHN0YXJ0aW5nIHBvaW50LlxyXG4gKlxyXG4gKiBVc2luZyBgc3RhcnRBdCgpYCwgYHN0YXJ0QWZ0ZXIoKWAsIGBlbmRCZWZvcmUoKWAsIGBlbmRBdCgpYCBhbmQgYGVxdWFsVG8oKWBcclxuICogYWxsb3dzIHlvdSB0byBjaG9vc2UgYXJiaXRyYXJ5IHN0YXJ0aW5nIGFuZCBlbmRpbmcgcG9pbnRzIGZvciB5b3VyIHF1ZXJpZXMuXHJcbiAqXHJcbiAqIFRoZSBzdGFydGluZyBwb2ludCBpcyBpbmNsdXNpdmUsIHNvIGNoaWxkcmVuIHdpdGggZXhhY3RseSB0aGUgc3BlY2lmaWVkIHZhbHVlXHJcbiAqIHdpbGwgYmUgaW5jbHVkZWQgaW4gdGhlIHF1ZXJ5LiBUaGUgb3B0aW9uYWwga2V5IGFyZ3VtZW50IGNhbiBiZSB1c2VkIHRvXHJcbiAqIGZ1cnRoZXIgbGltaXQgdGhlIHJhbmdlIG9mIHRoZSBxdWVyeS4gSWYgaXQgaXMgc3BlY2lmaWVkLCB0aGVuIGNoaWxkcmVuIHRoYXRcclxuICogaGF2ZSBleGFjdGx5IHRoZSBzcGVjaWZpZWQgdmFsdWUgbXVzdCBhbHNvIGhhdmUgYSBrZXkgbmFtZSBncmVhdGVyIHRoYW4gb3JcclxuICogZXF1YWwgdG8gdGhlIHNwZWNpZmllZCBrZXkuXHJcbiAqXHJcbiAqIFlvdSBjYW4gcmVhZCBtb3JlIGFib3V0IGBzdGFydEF0KClgIGluXHJcbiAqIHtAbGluayBodHRwczovL2ZpcmViYXNlLmdvb2dsZS5jb20vZG9jcy9kYXRhYmFzZS93ZWIvbGlzdHMtb2YtZGF0YSNmaWx0ZXJpbmdfZGF0YSB8IEZpbHRlcmluZyBkYXRhfS5cclxuICpcclxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIHN0YXJ0IGF0LiBUaGUgYXJndW1lbnQgdHlwZSBkZXBlbmRzIG9uIHdoaWNoXHJcbiAqIGBvcmRlckJ5KigpYCBmdW5jdGlvbiB3YXMgdXNlZCBpbiB0aGlzIHF1ZXJ5LiBTcGVjaWZ5IGEgdmFsdWUgdGhhdCBtYXRjaGVzXHJcbiAqIHRoZSBgb3JkZXJCeSooKWAgdHlwZS4gV2hlbiB1c2VkIGluIGNvbWJpbmF0aW9uIHdpdGggYG9yZGVyQnlLZXkoKWAsIHRoZVxyXG4gKiB2YWx1ZSBtdXN0IGJlIGEgc3RyaW5nLlxyXG4gKiBAcGFyYW0ga2V5IC0gVGhlIGNoaWxkIGtleSB0byBzdGFydCBhdC4gVGhpcyBhcmd1bWVudCBpcyBvbmx5IGFsbG93ZWQgaWZcclxuICogb3JkZXJpbmcgYnkgY2hpbGQsIHZhbHVlLCBvciBwcmlvcml0eS5cclxuICovXHJcbmZ1bmN0aW9uIHN0YXJ0QXQodmFsdWUgPSBudWxsLCBrZXkpIHtcclxuICAgIHZhbGlkYXRlS2V5KCdzdGFydEF0JywgJ2tleScsIGtleSwgdHJ1ZSk7XHJcbiAgICByZXR1cm4gbmV3IFF1ZXJ5U3RhcnRBdENvbnN0cmFpbnQodmFsdWUsIGtleSk7XHJcbn1cclxuY2xhc3MgUXVlcnlTdGFydEFmdGVyQ29uc3RyYWludCBleHRlbmRzIFF1ZXJ5Q29uc3RyYWludCB7XHJcbiAgICBjb25zdHJ1Y3RvcihfdmFsdWUsIF9rZXkpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMuX3ZhbHVlID0gX3ZhbHVlO1xyXG4gICAgICAgIHRoaXMuX2tleSA9IF9rZXk7XHJcbiAgICB9XHJcbiAgICBfYXBwbHkocXVlcnkpIHtcclxuICAgICAgICB2YWxpZGF0ZUZpcmViYXNlRGF0YUFyZygnc3RhcnRBZnRlcicsIHRoaXMuX3ZhbHVlLCBxdWVyeS5fcGF0aCwgZmFsc2UpO1xyXG4gICAgICAgIGNvbnN0IG5ld1BhcmFtcyA9IHF1ZXJ5UGFyYW1zU3RhcnRBZnRlcihxdWVyeS5fcXVlcnlQYXJhbXMsIHRoaXMuX3ZhbHVlLCB0aGlzLl9rZXkpO1xyXG4gICAgICAgIHZhbGlkYXRlTGltaXQobmV3UGFyYW1zKTtcclxuICAgICAgICB2YWxpZGF0ZVF1ZXJ5RW5kcG9pbnRzKG5ld1BhcmFtcyk7XHJcbiAgICAgICAgaWYgKHF1ZXJ5Ll9xdWVyeVBhcmFtcy5oYXNTdGFydCgpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignc3RhcnRBZnRlcjogU3RhcnRpbmcgcG9pbnQgd2FzIGFscmVhZHkgc2V0IChieSBhbm90aGVyIGNhbGwgdG8gc3RhcnRBdCwgJyArXHJcbiAgICAgICAgICAgICAgICAnc3RhcnRBZnRlciwgb3IgZXF1YWxUbykuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgUXVlcnlJbXBsKHF1ZXJ5Ll9yZXBvLCBxdWVyeS5fcGF0aCwgbmV3UGFyYW1zLCBxdWVyeS5fb3JkZXJCeUNhbGxlZCk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIENyZWF0ZXMgYSBgUXVlcnlDb25zdHJhaW50YCB3aXRoIHRoZSBzcGVjaWZpZWQgc3RhcnRpbmcgcG9pbnQgKGV4Y2x1c2l2ZSkuXHJcbiAqXHJcbiAqIFVzaW5nIGBzdGFydEF0KClgLCBgc3RhcnRBZnRlcigpYCwgYGVuZEJlZm9yZSgpYCwgYGVuZEF0KClgIGFuZCBgZXF1YWxUbygpYFxyXG4gKiBhbGxvd3MgeW91IHRvIGNob29zZSBhcmJpdHJhcnkgc3RhcnRpbmcgYW5kIGVuZGluZyBwb2ludHMgZm9yIHlvdXIgcXVlcmllcy5cclxuICpcclxuICogVGhlIHN0YXJ0aW5nIHBvaW50IGlzIGV4Y2x1c2l2ZS4gSWYgb25seSBhIHZhbHVlIGlzIHByb3ZpZGVkLCBjaGlsZHJlblxyXG4gKiB3aXRoIGEgdmFsdWUgZ3JlYXRlciB0aGFuIHRoZSBzcGVjaWZpZWQgdmFsdWUgd2lsbCBiZSBpbmNsdWRlZCBpbiB0aGUgcXVlcnkuXHJcbiAqIElmIGEga2V5IGlzIHNwZWNpZmllZCwgdGhlbiBjaGlsZHJlbiBtdXN0IGhhdmUgYSB2YWx1ZSBncmVhdGVyIHRoYW4gb3IgZXF1YWxcclxuICogdG8gdGhlIHNwZWNpZmllZCB2YWx1ZSBhbmQgYSBhIGtleSBuYW1lIGdyZWF0ZXIgdGhhbiB0aGUgc3BlY2lmaWVkIGtleS5cclxuICpcclxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIHN0YXJ0IGFmdGVyLiBUaGUgYXJndW1lbnQgdHlwZSBkZXBlbmRzIG9uIHdoaWNoXHJcbiAqIGBvcmRlckJ5KigpYCBmdW5jdGlvbiB3YXMgdXNlZCBpbiB0aGlzIHF1ZXJ5LiBTcGVjaWZ5IGEgdmFsdWUgdGhhdCBtYXRjaGVzXHJcbiAqIHRoZSBgb3JkZXJCeSooKWAgdHlwZS4gV2hlbiB1c2VkIGluIGNvbWJpbmF0aW9uIHdpdGggYG9yZGVyQnlLZXkoKWAsIHRoZVxyXG4gKiB2YWx1ZSBtdXN0IGJlIGEgc3RyaW5nLlxyXG4gKiBAcGFyYW0ga2V5IC0gVGhlIGNoaWxkIGtleSB0byBzdGFydCBhZnRlci4gVGhpcyBhcmd1bWVudCBpcyBvbmx5IGFsbG93ZWQgaWZcclxuICogb3JkZXJpbmcgYnkgY2hpbGQsIHZhbHVlLCBvciBwcmlvcml0eS5cclxuICovXHJcbmZ1bmN0aW9uIHN0YXJ0QWZ0ZXIodmFsdWUsIGtleSkge1xyXG4gICAgdmFsaWRhdGVLZXkoJ3N0YXJ0QWZ0ZXInLCAna2V5Jywga2V5LCB0cnVlKTtcclxuICAgIHJldHVybiBuZXcgUXVlcnlTdGFydEFmdGVyQ29uc3RyYWludCh2YWx1ZSwga2V5KTtcclxufVxyXG5jbGFzcyBRdWVyeUxpbWl0VG9GaXJzdENvbnN0cmFpbnQgZXh0ZW5kcyBRdWVyeUNvbnN0cmFpbnQge1xyXG4gICAgY29uc3RydWN0b3IoX2xpbWl0KSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLl9saW1pdCA9IF9saW1pdDtcclxuICAgIH1cclxuICAgIF9hcHBseShxdWVyeSkge1xyXG4gICAgICAgIGlmIChxdWVyeS5fcXVlcnlQYXJhbXMuaGFzTGltaXQoKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2xpbWl0VG9GaXJzdDogTGltaXQgd2FzIGFscmVhZHkgc2V0IChieSBhbm90aGVyIGNhbGwgdG8gbGltaXRUb0ZpcnN0ICcgK1xyXG4gICAgICAgICAgICAgICAgJ29yIGxpbWl0VG9MYXN0KS4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBRdWVyeUltcGwocXVlcnkuX3JlcG8sIHF1ZXJ5Ll9wYXRoLCBxdWVyeVBhcmFtc0xpbWl0VG9GaXJzdChxdWVyeS5fcXVlcnlQYXJhbXMsIHRoaXMuX2xpbWl0KSwgcXVlcnkuX29yZGVyQnlDYWxsZWQpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEgbmV3IGBRdWVyeUNvbnN0cmFpbnRgIHRoYXQgaWYgbGltaXRlZCB0byB0aGUgZmlyc3Qgc3BlY2lmaWMgbnVtYmVyXHJcbiAqIG9mIGNoaWxkcmVuLlxyXG4gKlxyXG4gKiBUaGUgYGxpbWl0VG9GaXJzdCgpYCBtZXRob2QgaXMgdXNlZCB0byBzZXQgYSBtYXhpbXVtIG51bWJlciBvZiBjaGlsZHJlbiB0byBiZVxyXG4gKiBzeW5jZWQgZm9yIGEgZ2l2ZW4gY2FsbGJhY2suIElmIHdlIHNldCBhIGxpbWl0IG9mIDEwMCwgd2Ugd2lsbCBpbml0aWFsbHkgb25seVxyXG4gKiByZWNlaXZlIHVwIHRvIDEwMCBgY2hpbGRfYWRkZWRgIGV2ZW50cy4gSWYgd2UgaGF2ZSBmZXdlciB0aGFuIDEwMCBtZXNzYWdlc1xyXG4gKiBzdG9yZWQgaW4gb3VyIERhdGFiYXNlLCBhIGBjaGlsZF9hZGRlZGAgZXZlbnQgd2lsbCBmaXJlIGZvciBlYWNoIG1lc3NhZ2UuXHJcbiAqIEhvd2V2ZXIsIGlmIHdlIGhhdmUgb3ZlciAxMDAgbWVzc2FnZXMsIHdlIHdpbGwgb25seSByZWNlaXZlIGEgYGNoaWxkX2FkZGVkYFxyXG4gKiBldmVudCBmb3IgdGhlIGZpcnN0IDEwMCBvcmRlcmVkIG1lc3NhZ2VzLiBBcyBpdGVtcyBjaGFuZ2UsIHdlIHdpbGwgcmVjZWl2ZVxyXG4gKiBgY2hpbGRfcmVtb3ZlZGAgZXZlbnRzIGZvciBlYWNoIGl0ZW0gdGhhdCBkcm9wcyBvdXQgb2YgdGhlIGFjdGl2ZSBsaXN0IHNvXHJcbiAqIHRoYXQgdGhlIHRvdGFsIG51bWJlciBzdGF5cyBhdCAxMDAuXHJcbiAqXHJcbiAqIFlvdSBjYW4gcmVhZCBtb3JlIGFib3V0IGBsaW1pdFRvRmlyc3QoKWAgaW5cclxuICoge0BsaW5rIGh0dHBzOi8vZmlyZWJhc2UuZ29vZ2xlLmNvbS9kb2NzL2RhdGFiYXNlL3dlYi9saXN0cy1vZi1kYXRhI2ZpbHRlcmluZ19kYXRhIHwgRmlsdGVyaW5nIGRhdGF9LlxyXG4gKlxyXG4gKiBAcGFyYW0gbGltaXQgLSBUaGUgbWF4aW11bSBudW1iZXIgb2Ygbm9kZXMgdG8gaW5jbHVkZSBpbiB0aGlzIHF1ZXJ5LlxyXG4gKi9cclxuZnVuY3Rpb24gbGltaXRUb0ZpcnN0KGxpbWl0KSB7XHJcbiAgICBpZiAodHlwZW9mIGxpbWl0ICE9PSAnbnVtYmVyJyB8fCBNYXRoLmZsb29yKGxpbWl0KSAhPT0gbGltaXQgfHwgbGltaXQgPD0gMCkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbGltaXRUb0ZpcnN0OiBGaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlci4nKTtcclxuICAgIH1cclxuICAgIHJldHVybiBuZXcgUXVlcnlMaW1pdFRvRmlyc3RDb25zdHJhaW50KGxpbWl0KTtcclxufVxyXG5jbGFzcyBRdWVyeUxpbWl0VG9MYXN0Q29uc3RyYWludCBleHRlbmRzIFF1ZXJ5Q29uc3RyYWludCB7XHJcbiAgICBjb25zdHJ1Y3RvcihfbGltaXQpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMuX2xpbWl0ID0gX2xpbWl0O1xyXG4gICAgfVxyXG4gICAgX2FwcGx5KHF1ZXJ5KSB7XHJcbiAgICAgICAgaWYgKHF1ZXJ5Ll9xdWVyeVBhcmFtcy5oYXNMaW1pdCgpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbGltaXRUb0xhc3Q6IExpbWl0IHdhcyBhbHJlYWR5IHNldCAoYnkgYW5vdGhlciBjYWxsIHRvIGxpbWl0VG9GaXJzdCAnICtcclxuICAgICAgICAgICAgICAgICdvciBsaW1pdFRvTGFzdCkuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgUXVlcnlJbXBsKHF1ZXJ5Ll9yZXBvLCBxdWVyeS5fcGF0aCwgcXVlcnlQYXJhbXNMaW1pdFRvTGFzdChxdWVyeS5fcXVlcnlQYXJhbXMsIHRoaXMuX2xpbWl0KSwgcXVlcnkuX29yZGVyQnlDYWxsZWQpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEgbmV3IGBRdWVyeUNvbnN0cmFpbnRgIHRoYXQgaXMgbGltaXRlZCB0byByZXR1cm4gb25seSB0aGUgbGFzdFxyXG4gKiBzcGVjaWZpZWQgbnVtYmVyIG9mIGNoaWxkcmVuLlxyXG4gKlxyXG4gKiBUaGUgYGxpbWl0VG9MYXN0KClgIG1ldGhvZCBpcyB1c2VkIHRvIHNldCBhIG1heGltdW0gbnVtYmVyIG9mIGNoaWxkcmVuIHRvIGJlXHJcbiAqIHN5bmNlZCBmb3IgYSBnaXZlbiBjYWxsYmFjay4gSWYgd2Ugc2V0IGEgbGltaXQgb2YgMTAwLCB3ZSB3aWxsIGluaXRpYWxseSBvbmx5XHJcbiAqIHJlY2VpdmUgdXAgdG8gMTAwIGBjaGlsZF9hZGRlZGAgZXZlbnRzLiBJZiB3ZSBoYXZlIGZld2VyIHRoYW4gMTAwIG1lc3NhZ2VzXHJcbiAqIHN0b3JlZCBpbiBvdXIgRGF0YWJhc2UsIGEgYGNoaWxkX2FkZGVkYCBldmVudCB3aWxsIGZpcmUgZm9yIGVhY2ggbWVzc2FnZS5cclxuICogSG93ZXZlciwgaWYgd2UgaGF2ZSBvdmVyIDEwMCBtZXNzYWdlcywgd2Ugd2lsbCBvbmx5IHJlY2VpdmUgYSBgY2hpbGRfYWRkZWRgXHJcbiAqIGV2ZW50IGZvciB0aGUgbGFzdCAxMDAgb3JkZXJlZCBtZXNzYWdlcy4gQXMgaXRlbXMgY2hhbmdlLCB3ZSB3aWxsIHJlY2VpdmVcclxuICogYGNoaWxkX3JlbW92ZWRgIGV2ZW50cyBmb3IgZWFjaCBpdGVtIHRoYXQgZHJvcHMgb3V0IG9mIHRoZSBhY3RpdmUgbGlzdCBzb1xyXG4gKiB0aGF0IHRoZSB0b3RhbCBudW1iZXIgc3RheXMgYXQgMTAwLlxyXG4gKlxyXG4gKiBZb3UgY2FuIHJlYWQgbW9yZSBhYm91dCBgbGltaXRUb0xhc3QoKWAgaW5cclxuICoge0BsaW5rIGh0dHBzOi8vZmlyZWJhc2UuZ29vZ2xlLmNvbS9kb2NzL2RhdGFiYXNlL3dlYi9saXN0cy1vZi1kYXRhI2ZpbHRlcmluZ19kYXRhIHwgRmlsdGVyaW5nIGRhdGF9LlxyXG4gKlxyXG4gKiBAcGFyYW0gbGltaXQgLSBUaGUgbWF4aW11bSBudW1iZXIgb2Ygbm9kZXMgdG8gaW5jbHVkZSBpbiB0aGlzIHF1ZXJ5LlxyXG4gKi9cclxuZnVuY3Rpb24gbGltaXRUb0xhc3QobGltaXQpIHtcclxuICAgIGlmICh0eXBlb2YgbGltaXQgIT09ICdudW1iZXInIHx8IE1hdGguZmxvb3IobGltaXQpICE9PSBsaW1pdCB8fCBsaW1pdCA8PSAwKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdsaW1pdFRvTGFzdDogRmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXIuJyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbmV3IFF1ZXJ5TGltaXRUb0xhc3RDb25zdHJhaW50KGxpbWl0KTtcclxufVxyXG5jbGFzcyBRdWVyeU9yZGVyQnlDaGlsZENvbnN0cmFpbnQgZXh0ZW5kcyBRdWVyeUNvbnN0cmFpbnQge1xyXG4gICAgY29uc3RydWN0b3IoX3BhdGgpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMuX3BhdGggPSBfcGF0aDtcclxuICAgIH1cclxuICAgIF9hcHBseShxdWVyeSkge1xyXG4gICAgICAgIHZhbGlkYXRlTm9QcmV2aW91c09yZGVyQnlDYWxsKHF1ZXJ5LCAnb3JkZXJCeUNoaWxkJyk7XHJcbiAgICAgICAgY29uc3QgcGFyc2VkUGF0aCA9IG5ldyBQYXRoKHRoaXMuX3BhdGgpO1xyXG4gICAgICAgIGlmIChwYXRoSXNFbXB0eShwYXJzZWRQYXRoKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ29yZGVyQnlDaGlsZDogY2Fubm90IHBhc3MgaW4gZW1wdHkgcGF0aC4gVXNlIG9yZGVyQnlWYWx1ZSgpIGluc3RlYWQuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGluZGV4ID0gbmV3IFBhdGhJbmRleChwYXJzZWRQYXRoKTtcclxuICAgICAgICBjb25zdCBuZXdQYXJhbXMgPSBxdWVyeVBhcmFtc09yZGVyQnkocXVlcnkuX3F1ZXJ5UGFyYW1zLCBpbmRleCk7XHJcbiAgICAgICAgdmFsaWRhdGVRdWVyeUVuZHBvaW50cyhuZXdQYXJhbXMpO1xyXG4gICAgICAgIHJldHVybiBuZXcgUXVlcnlJbXBsKHF1ZXJ5Ll9yZXBvLCBxdWVyeS5fcGF0aCwgbmV3UGFyYW1zLCBcclxuICAgICAgICAvKm9yZGVyQnlDYWxsZWQ9Ki8gdHJ1ZSk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIENyZWF0ZXMgYSBuZXcgYFF1ZXJ5Q29uc3RyYWludGAgdGhhdCBvcmRlcnMgYnkgdGhlIHNwZWNpZmllZCBjaGlsZCBrZXkuXHJcbiAqXHJcbiAqIFF1ZXJpZXMgY2FuIG9ubHkgb3JkZXIgYnkgb25lIGtleSBhdCBhIHRpbWUuIENhbGxpbmcgYG9yZGVyQnlDaGlsZCgpYFxyXG4gKiBtdWx0aXBsZSB0aW1lcyBvbiB0aGUgc2FtZSBxdWVyeSBpcyBhbiBlcnJvci5cclxuICpcclxuICogRmlyZWJhc2UgcXVlcmllcyBhbGxvdyB5b3UgdG8gb3JkZXIgeW91ciBkYXRhIGJ5IGFueSBjaGlsZCBrZXkgb24gdGhlIGZseS5cclxuICogSG93ZXZlciwgaWYgeW91IGtub3cgaW4gYWR2YW5jZSB3aGF0IHlvdXIgaW5kZXhlcyB3aWxsIGJlLCB5b3UgY2FuIGRlZmluZVxyXG4gKiB0aGVtIHZpYSB0aGUgLmluZGV4T24gcnVsZSBpbiB5b3VyIFNlY3VyaXR5IFJ1bGVzIGZvciBiZXR0ZXIgcGVyZm9ybWFuY2UuIFNlZVxyXG4gKiB0aGV7QGxpbmsgaHR0cHM6Ly9maXJlYmFzZS5nb29nbGUuY29tL2RvY3MvZGF0YWJhc2Uvc2VjdXJpdHkvaW5kZXhpbmctZGF0YX1cclxuICogcnVsZSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cclxuICpcclxuICogWW91IGNhbiByZWFkIG1vcmUgYWJvdXQgYG9yZGVyQnlDaGlsZCgpYCBpblxyXG4gKiB7QGxpbmsgaHR0cHM6Ly9maXJlYmFzZS5nb29nbGUuY29tL2RvY3MvZGF0YWJhc2Uvd2ViL2xpc3RzLW9mLWRhdGEjc29ydF9kYXRhIHwgU29ydCBkYXRhfS5cclxuICpcclxuICogQHBhcmFtIHBhdGggLSBUaGUgcGF0aCB0byBvcmRlciBieS5cclxuICovXHJcbmZ1bmN0aW9uIG9yZGVyQnlDaGlsZChwYXRoKSB7XHJcbiAgICBpZiAocGF0aCA9PT0gJyRrZXknKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdvcmRlckJ5Q2hpbGQ6IFwiJGtleVwiIGlzIGludmFsaWQuICBVc2Ugb3JkZXJCeUtleSgpIGluc3RlYWQuJyk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChwYXRoID09PSAnJHByaW9yaXR5Jykge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignb3JkZXJCeUNoaWxkOiBcIiRwcmlvcml0eVwiIGlzIGludmFsaWQuICBVc2Ugb3JkZXJCeVByaW9yaXR5KCkgaW5zdGVhZC4nKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHBhdGggPT09ICckdmFsdWUnKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdvcmRlckJ5Q2hpbGQ6IFwiJHZhbHVlXCIgaXMgaW52YWxpZC4gIFVzZSBvcmRlckJ5VmFsdWUoKSBpbnN0ZWFkLicpO1xyXG4gICAgfVxyXG4gICAgdmFsaWRhdGVQYXRoU3RyaW5nKCdvcmRlckJ5Q2hpbGQnLCAncGF0aCcsIHBhdGgsIGZhbHNlKTtcclxuICAgIHJldHVybiBuZXcgUXVlcnlPcmRlckJ5Q2hpbGRDb25zdHJhaW50KHBhdGgpO1xyXG59XHJcbmNsYXNzIFF1ZXJ5T3JkZXJCeUtleUNvbnN0cmFpbnQgZXh0ZW5kcyBRdWVyeUNvbnN0cmFpbnQge1xyXG4gICAgX2FwcGx5KHF1ZXJ5KSB7XHJcbiAgICAgICAgdmFsaWRhdGVOb1ByZXZpb3VzT3JkZXJCeUNhbGwocXVlcnksICdvcmRlckJ5S2V5Jyk7XHJcbiAgICAgICAgY29uc3QgbmV3UGFyYW1zID0gcXVlcnlQYXJhbXNPcmRlckJ5KHF1ZXJ5Ll9xdWVyeVBhcmFtcywgS0VZX0lOREVYKTtcclxuICAgICAgICB2YWxpZGF0ZVF1ZXJ5RW5kcG9pbnRzKG5ld1BhcmFtcyk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBRdWVyeUltcGwocXVlcnkuX3JlcG8sIHF1ZXJ5Ll9wYXRoLCBuZXdQYXJhbXMsIFxyXG4gICAgICAgIC8qb3JkZXJCeUNhbGxlZD0qLyB0cnVlKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQ3JlYXRlcyBhIG5ldyBgUXVlcnlDb25zdHJhaW50YCB0aGF0IG9yZGVycyBieSB0aGUga2V5LlxyXG4gKlxyXG4gKiBTb3J0cyB0aGUgcmVzdWx0cyBvZiBhIHF1ZXJ5IGJ5IHRoZWlyIChhc2NlbmRpbmcpIGtleSB2YWx1ZXMuXHJcbiAqXHJcbiAqIFlvdSBjYW4gcmVhZCBtb3JlIGFib3V0IGBvcmRlckJ5S2V5KClgIGluXHJcbiAqIHtAbGluayBodHRwczovL2ZpcmViYXNlLmdvb2dsZS5jb20vZG9jcy9kYXRhYmFzZS93ZWIvbGlzdHMtb2YtZGF0YSNzb3J0X2RhdGEgfCBTb3J0IGRhdGF9LlxyXG4gKi9cclxuZnVuY3Rpb24gb3JkZXJCeUtleSgpIHtcclxuICAgIHJldHVybiBuZXcgUXVlcnlPcmRlckJ5S2V5Q29uc3RyYWludCgpO1xyXG59XHJcbmNsYXNzIFF1ZXJ5T3JkZXJCeVByaW9yaXR5Q29uc3RyYWludCBleHRlbmRzIFF1ZXJ5Q29uc3RyYWludCB7XHJcbiAgICBfYXBwbHkocXVlcnkpIHtcclxuICAgICAgICB2YWxpZGF0ZU5vUHJldmlvdXNPcmRlckJ5Q2FsbChxdWVyeSwgJ29yZGVyQnlQcmlvcml0eScpO1xyXG4gICAgICAgIGNvbnN0IG5ld1BhcmFtcyA9IHF1ZXJ5UGFyYW1zT3JkZXJCeShxdWVyeS5fcXVlcnlQYXJhbXMsIFBSSU9SSVRZX0lOREVYKTtcclxuICAgICAgICB2YWxpZGF0ZVF1ZXJ5RW5kcG9pbnRzKG5ld1BhcmFtcyk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBRdWVyeUltcGwocXVlcnkuX3JlcG8sIHF1ZXJ5Ll9wYXRoLCBuZXdQYXJhbXMsIFxyXG4gICAgICAgIC8qb3JkZXJCeUNhbGxlZD0qLyB0cnVlKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQ3JlYXRlcyBhIG5ldyBgUXVlcnlDb25zdHJhaW50YCB0aGF0IG9yZGVycyBieSBwcmlvcml0eS5cclxuICpcclxuICogQXBwbGljYXRpb25zIG5lZWQgbm90IHVzZSBwcmlvcml0eSBidXQgY2FuIG9yZGVyIGNvbGxlY3Rpb25zIGJ5XHJcbiAqIG9yZGluYXJ5IHByb3BlcnRpZXMgKHNlZVxyXG4gKiB7QGxpbmsgaHR0cHM6Ly9maXJlYmFzZS5nb29nbGUuY29tL2RvY3MvZGF0YWJhc2Uvd2ViL2xpc3RzLW9mLWRhdGEjc29ydF9kYXRhIHwgU29ydCBkYXRhfVxyXG4gKiBmb3IgYWx0ZXJuYXRpdmVzIHRvIHByaW9yaXR5LlxyXG4gKi9cclxuZnVuY3Rpb24gb3JkZXJCeVByaW9yaXR5KCkge1xyXG4gICAgcmV0dXJuIG5ldyBRdWVyeU9yZGVyQnlQcmlvcml0eUNvbnN0cmFpbnQoKTtcclxufVxyXG5jbGFzcyBRdWVyeU9yZGVyQnlWYWx1ZUNvbnN0cmFpbnQgZXh0ZW5kcyBRdWVyeUNvbnN0cmFpbnQge1xyXG4gICAgX2FwcGx5KHF1ZXJ5KSB7XHJcbiAgICAgICAgdmFsaWRhdGVOb1ByZXZpb3VzT3JkZXJCeUNhbGwocXVlcnksICdvcmRlckJ5VmFsdWUnKTtcclxuICAgICAgICBjb25zdCBuZXdQYXJhbXMgPSBxdWVyeVBhcmFtc09yZGVyQnkocXVlcnkuX3F1ZXJ5UGFyYW1zLCBWQUxVRV9JTkRFWCk7XHJcbiAgICAgICAgdmFsaWRhdGVRdWVyeUVuZHBvaW50cyhuZXdQYXJhbXMpO1xyXG4gICAgICAgIHJldHVybiBuZXcgUXVlcnlJbXBsKHF1ZXJ5Ll9yZXBvLCBxdWVyeS5fcGF0aCwgbmV3UGFyYW1zLCBcclxuICAgICAgICAvKm9yZGVyQnlDYWxsZWQ9Ki8gdHJ1ZSk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIENyZWF0ZXMgYSBuZXcgYFF1ZXJ5Q29uc3RyYWludGAgdGhhdCBvcmRlcnMgYnkgdmFsdWUuXHJcbiAqXHJcbiAqIElmIHRoZSBjaGlsZHJlbiBvZiBhIHF1ZXJ5IGFyZSBhbGwgc2NhbGFyIHZhbHVlcyAoc3RyaW5nLCBudW1iZXIsIG9yXHJcbiAqIGJvb2xlYW4pLCB5b3UgY2FuIG9yZGVyIHRoZSByZXN1bHRzIGJ5IHRoZWlyIChhc2NlbmRpbmcpIHZhbHVlcy5cclxuICpcclxuICogWW91IGNhbiByZWFkIG1vcmUgYWJvdXQgYG9yZGVyQnlWYWx1ZSgpYCBpblxyXG4gKiB7QGxpbmsgaHR0cHM6Ly9maXJlYmFzZS5nb29nbGUuY29tL2RvY3MvZGF0YWJhc2Uvd2ViL2xpc3RzLW9mLWRhdGEjc29ydF9kYXRhIHwgU29ydCBkYXRhfS5cclxuICovXHJcbmZ1bmN0aW9uIG9yZGVyQnlWYWx1ZSgpIHtcclxuICAgIHJldHVybiBuZXcgUXVlcnlPcmRlckJ5VmFsdWVDb25zdHJhaW50KCk7XHJcbn1cclxuY2xhc3MgUXVlcnlFcXVhbFRvVmFsdWVDb25zdHJhaW50IGV4dGVuZHMgUXVlcnlDb25zdHJhaW50IHtcclxuICAgIGNvbnN0cnVjdG9yKF92YWx1ZSwgX2tleSkge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5fdmFsdWUgPSBfdmFsdWU7XHJcbiAgICAgICAgdGhpcy5fa2V5ID0gX2tleTtcclxuICAgIH1cclxuICAgIF9hcHBseShxdWVyeSkge1xyXG4gICAgICAgIHZhbGlkYXRlRmlyZWJhc2VEYXRhQXJnKCdlcXVhbFRvJywgdGhpcy5fdmFsdWUsIHF1ZXJ5Ll9wYXRoLCBmYWxzZSk7XHJcbiAgICAgICAgaWYgKHF1ZXJ5Ll9xdWVyeVBhcmFtcy5oYXNTdGFydCgpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZXF1YWxUbzogU3RhcnRpbmcgcG9pbnQgd2FzIGFscmVhZHkgc2V0IChieSBhbm90aGVyIGNhbGwgdG8gc3RhcnRBdC9zdGFydEFmdGVyIG9yICcgK1xyXG4gICAgICAgICAgICAgICAgJ2VxdWFsVG8pLicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocXVlcnkuX3F1ZXJ5UGFyYW1zLmhhc0VuZCgpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZXF1YWxUbzogRW5kaW5nIHBvaW50IHdhcyBhbHJlYWR5IHNldCAoYnkgYW5vdGhlciBjYWxsIHRvIGVuZEF0L2VuZEJlZm9yZSBvciAnICtcclxuICAgICAgICAgICAgICAgICdlcXVhbFRvKS4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBRdWVyeUVuZEF0Q29uc3RyYWludCh0aGlzLl92YWx1ZSwgdGhpcy5fa2V5KS5fYXBwbHkobmV3IFF1ZXJ5U3RhcnRBdENvbnN0cmFpbnQodGhpcy5fdmFsdWUsIHRoaXMuX2tleSkuX2FwcGx5KHF1ZXJ5KSk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIENyZWF0ZXMgYSBgUXVlcnlDb25zdHJhaW50YCB0aGF0IGluY2x1ZGVzIGNoaWxkcmVuIHRoYXQgbWF0Y2ggdGhlIHNwZWNpZmllZFxyXG4gKiB2YWx1ZS5cclxuICpcclxuICogVXNpbmcgYHN0YXJ0QXQoKWAsIGBzdGFydEFmdGVyKClgLCBgZW5kQmVmb3JlKClgLCBgZW5kQXQoKWAgYW5kIGBlcXVhbFRvKClgXHJcbiAqIGFsbG93cyB5b3UgdG8gY2hvb3NlIGFyYml0cmFyeSBzdGFydGluZyBhbmQgZW5kaW5nIHBvaW50cyBmb3IgeW91ciBxdWVyaWVzLlxyXG4gKlxyXG4gKiBUaGUgb3B0aW9uYWwga2V5IGFyZ3VtZW50IGNhbiBiZSB1c2VkIHRvIGZ1cnRoZXIgbGltaXQgdGhlIHJhbmdlIG9mIHRoZVxyXG4gKiBxdWVyeS4gSWYgaXQgaXMgc3BlY2lmaWVkLCB0aGVuIGNoaWxkcmVuIHRoYXQgaGF2ZSBleGFjdGx5IHRoZSBzcGVjaWZpZWRcclxuICogdmFsdWUgbXVzdCBhbHNvIGhhdmUgZXhhY3RseSB0aGUgc3BlY2lmaWVkIGtleSBhcyB0aGVpciBrZXkgbmFtZS4gVGhpcyBjYW4gYmVcclxuICogdXNlZCB0byBmaWx0ZXIgcmVzdWx0IHNldHMgd2l0aCBtYW55IG1hdGNoZXMgZm9yIHRoZSBzYW1lIHZhbHVlLlxyXG4gKlxyXG4gKiBZb3UgY2FuIHJlYWQgbW9yZSBhYm91dCBgZXF1YWxUbygpYCBpblxyXG4gKiB7QGxpbmsgaHR0cHM6Ly9maXJlYmFzZS5nb29nbGUuY29tL2RvY3MvZGF0YWJhc2Uvd2ViL2xpc3RzLW9mLWRhdGEjZmlsdGVyaW5nX2RhdGEgfCBGaWx0ZXJpbmcgZGF0YX0uXHJcbiAqXHJcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBtYXRjaCBmb3IuIFRoZSBhcmd1bWVudCB0eXBlIGRlcGVuZHMgb24gd2hpY2hcclxuICogYG9yZGVyQnkqKClgIGZ1bmN0aW9uIHdhcyB1c2VkIGluIHRoaXMgcXVlcnkuIFNwZWNpZnkgYSB2YWx1ZSB0aGF0IG1hdGNoZXNcclxuICogdGhlIGBvcmRlckJ5KigpYCB0eXBlLiBXaGVuIHVzZWQgaW4gY29tYmluYXRpb24gd2l0aCBgb3JkZXJCeUtleSgpYCwgdGhlXHJcbiAqIHZhbHVlIG11c3QgYmUgYSBzdHJpbmcuXHJcbiAqIEBwYXJhbSBrZXkgLSBUaGUgY2hpbGQga2V5IHRvIHN0YXJ0IGF0LCBhbW9uZyB0aGUgY2hpbGRyZW4gd2l0aCB0aGVcclxuICogcHJldmlvdXNseSBzcGVjaWZpZWQgcHJpb3JpdHkuIFRoaXMgYXJndW1lbnQgaXMgb25seSBhbGxvd2VkIGlmIG9yZGVyaW5nIGJ5XHJcbiAqIGNoaWxkLCB2YWx1ZSwgb3IgcHJpb3JpdHkuXHJcbiAqL1xyXG5mdW5jdGlvbiBlcXVhbFRvKHZhbHVlLCBrZXkpIHtcclxuICAgIHZhbGlkYXRlS2V5KCdlcXVhbFRvJywgJ2tleScsIGtleSwgdHJ1ZSk7XHJcbiAgICByZXR1cm4gbmV3IFF1ZXJ5RXF1YWxUb1ZhbHVlQ29uc3RyYWludCh2YWx1ZSwga2V5KTtcclxufVxyXG4vKipcclxuICogQ3JlYXRlcyBhIG5ldyBpbW11dGFibGUgaW5zdGFuY2Ugb2YgYFF1ZXJ5YCB0aGF0IGlzIGV4dGVuZGVkIHRvIGFsc28gaW5jbHVkZVxyXG4gKiBhZGRpdGlvbmFsIHF1ZXJ5IGNvbnN0cmFpbnRzLlxyXG4gKlxyXG4gKiBAcGFyYW0gcXVlcnkgLSBUaGUgUXVlcnkgaW5zdGFuY2UgdG8gdXNlIGFzIGEgYmFzZSBmb3IgdGhlIG5ldyBjb25zdHJhaW50cy5cclxuICogQHBhcmFtIHF1ZXJ5Q29uc3RyYWludHMgLSBUaGUgbGlzdCBvZiBgUXVlcnlDb25zdHJhaW50YHMgdG8gYXBwbHkuXHJcbiAqIEB0aHJvd3MgaWYgYW55IG9mIHRoZSBwcm92aWRlZCBxdWVyeSBjb25zdHJhaW50cyBjYW5ub3QgYmUgY29tYmluZWQgd2l0aCB0aGVcclxuICogZXhpc3Rpbmcgb3IgbmV3IGNvbnN0cmFpbnRzLlxyXG4gKi9cclxuZnVuY3Rpb24gcXVlcnkocXVlcnksIC4uLnF1ZXJ5Q29uc3RyYWludHMpIHtcclxuICAgIGxldCBxdWVyeUltcGwgPSBnZXRNb2R1bGFySW5zdGFuY2UocXVlcnkpO1xyXG4gICAgZm9yIChjb25zdCBjb25zdHJhaW50IG9mIHF1ZXJ5Q29uc3RyYWludHMpIHtcclxuICAgICAgICBxdWVyeUltcGwgPSBjb25zdHJhaW50Ll9hcHBseShxdWVyeUltcGwpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHF1ZXJ5SW1wbDtcclxufVxyXG4vKipcclxuICogRGVmaW5lIHJlZmVyZW5jZSBjb25zdHJ1Y3RvciBpbiB2YXJpb3VzIG1vZHVsZXNcclxuICpcclxuICogV2UgYXJlIGRvaW5nIHRoaXMgaGVyZSB0byBhdm9pZCBzZXZlcmFsIGNpcmN1bGFyXHJcbiAqIGRlcGVuZGVuY3kgaXNzdWVzXHJcbiAqL1xyXG5zeW5jUG9pbnRTZXRSZWZlcmVuY2VDb25zdHJ1Y3RvcihSZWZlcmVuY2VJbXBsKTtcclxuc3luY1RyZWVTZXRSZWZlcmVuY2VDb25zdHJ1Y3RvcihSZWZlcmVuY2VJbXBsKTtcblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIFRoaXMgdmFyaWFibGUgaXMgYWxzbyBkZWZpbmVkIGluIHRoZSBmaXJlYmFzZSBOb2RlLmpzIEFkbWluIFNESy4gQmVmb3JlXHJcbiAqIG1vZGlmeWluZyB0aGlzIGRlZmluaXRpb24sIGNvbnN1bHQgdGhlIGRlZmluaXRpb24gaW46XHJcbiAqXHJcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9maXJlYmFzZS9maXJlYmFzZS1hZG1pbi1ub2RlXHJcbiAqXHJcbiAqIGFuZCBtYWtlIHN1cmUgdGhlIHR3byBhcmUgY29uc2lzdGVudC5cclxuICovXHJcbmNvbnN0IEZJUkVCQVNFX0RBVEFCQVNFX0VNVUxBVE9SX0hPU1RfVkFSID0gJ0ZJUkVCQVNFX0RBVEFCQVNFX0VNVUxBVE9SX0hPU1QnO1xyXG4vKipcclxuICogQ3JlYXRlcyBhbmQgY2FjaGVzIGBSZXBvYCBpbnN0YW5jZXMuXHJcbiAqL1xyXG5jb25zdCByZXBvcyA9IHt9O1xyXG4vKipcclxuICogSWYgdHJ1ZSwgYW55IG5ldyBgUmVwb2Agd2lsbCBiZSBjcmVhdGVkIHRvIHVzZSBgUmVhZG9ubHlSZXN0Q2xpZW50YCAoZm9yIHRlc3RpbmcgcHVycG9zZXMpLlxyXG4gKi9cclxubGV0IHVzZVJlc3RDbGllbnQgPSBmYWxzZTtcclxuLyoqXHJcbiAqIFVwZGF0ZSBhbiBleGlzdGluZyBgUmVwb2AgaW4gcGxhY2UgdG8gcG9pbnQgdG8gYSBuZXcgaG9zdC9wb3J0LlxyXG4gKi9cclxuZnVuY3Rpb24gcmVwb01hbmFnZXJBcHBseUVtdWxhdG9yU2V0dGluZ3MocmVwbywgaG9zdCwgcG9ydCwgdG9rZW5Qcm92aWRlcikge1xyXG4gICAgcmVwby5yZXBvSW5mb18gPSBuZXcgUmVwb0luZm8oYCR7aG9zdH06JHtwb3J0fWAsIFxyXG4gICAgLyogc2VjdXJlPSAqLyBmYWxzZSwgcmVwby5yZXBvSW5mb18ubmFtZXNwYWNlLCByZXBvLnJlcG9JbmZvXy53ZWJTb2NrZXRPbmx5LCByZXBvLnJlcG9JbmZvXy5ub2RlQWRtaW4sIHJlcG8ucmVwb0luZm9fLnBlcnNpc3RlbmNlS2V5LCByZXBvLnJlcG9JbmZvXy5pbmNsdWRlTmFtZXNwYWNlSW5RdWVyeVBhcmFtcyk7XHJcbiAgICBpZiAodG9rZW5Qcm92aWRlcikge1xyXG4gICAgICAgIHJlcG8uYXV0aFRva2VuUHJvdmlkZXJfID0gdG9rZW5Qcm92aWRlcjtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogVGhpcyBmdW5jdGlvbiBzaG91bGQgb25seSBldmVyIGJlIGNhbGxlZCB0byBDUkVBVEUgYSBuZXcgZGF0YWJhc2UgaW5zdGFuY2UuXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cclxuZnVuY3Rpb24gcmVwb01hbmFnZXJEYXRhYmFzZUZyb21BcHAoYXBwLCBhdXRoUHJvdmlkZXIsIGFwcENoZWNrUHJvdmlkZXIsIHVybCwgbm9kZUFkbWluKSB7XHJcbiAgICBsZXQgZGJVcmwgPSB1cmwgfHwgYXBwLm9wdGlvbnMuZGF0YWJhc2VVUkw7XHJcbiAgICBpZiAoZGJVcmwgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIGlmICghYXBwLm9wdGlvbnMucHJvamVjdElkKSB7XHJcbiAgICAgICAgICAgIGZhdGFsKFwiQ2FuJ3QgZGV0ZXJtaW5lIEZpcmViYXNlIERhdGFiYXNlIFVSTC4gQmUgc3VyZSB0byBpbmNsdWRlIFwiICtcclxuICAgICAgICAgICAgICAgICcgYSBQcm9qZWN0IElEIHdoZW4gY2FsbGluZyBmaXJlYmFzZS5pbml0aWFsaXplQXBwKCkuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxvZygnVXNpbmcgZGVmYXVsdCBob3N0IGZvciBwcm9qZWN0ICcsIGFwcC5vcHRpb25zLnByb2plY3RJZCk7XHJcbiAgICAgICAgZGJVcmwgPSBgJHthcHAub3B0aW9ucy5wcm9qZWN0SWR9LWRlZmF1bHQtcnRkYi5maXJlYmFzZWlvLmNvbWA7XHJcbiAgICB9XHJcbiAgICBsZXQgcGFyc2VkVXJsID0gcGFyc2VSZXBvSW5mbyhkYlVybCwgbm9kZUFkbWluKTtcclxuICAgIGxldCByZXBvSW5mbyA9IHBhcnNlZFVybC5yZXBvSW5mbztcclxuICAgIGxldCBpc0VtdWxhdG9yO1xyXG4gICAgbGV0IGRiRW11bGF0b3JIb3N0ID0gdW5kZWZpbmVkO1xyXG4gICAgaWYgKHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgIGRiRW11bGF0b3JIb3N0ID0gcHJvY2Vzcy5lbnZbRklSRUJBU0VfREFUQUJBU0VfRU1VTEFUT1JfSE9TVF9WQVJdO1xyXG4gICAgfVxyXG4gICAgaWYgKGRiRW11bGF0b3JIb3N0KSB7XHJcbiAgICAgICAgaXNFbXVsYXRvciA9IHRydWU7XHJcbiAgICAgICAgZGJVcmwgPSBgaHR0cDovLyR7ZGJFbXVsYXRvckhvc3R9P25zPSR7cmVwb0luZm8ubmFtZXNwYWNlfWA7XHJcbiAgICAgICAgcGFyc2VkVXJsID0gcGFyc2VSZXBvSW5mbyhkYlVybCwgbm9kZUFkbWluKTtcclxuICAgICAgICByZXBvSW5mbyA9IHBhcnNlZFVybC5yZXBvSW5mbztcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGlzRW11bGF0b3IgPSAhcGFyc2VkVXJsLnJlcG9JbmZvLnNlY3VyZTtcclxuICAgIH1cclxuICAgIGNvbnN0IGF1dGhUb2tlblByb3ZpZGVyID0gbm9kZUFkbWluICYmIGlzRW11bGF0b3JcclxuICAgICAgICA/IG5ldyBFbXVsYXRvclRva2VuUHJvdmlkZXIoRW11bGF0b3JUb2tlblByb3ZpZGVyLk9XTkVSKVxyXG4gICAgICAgIDogbmV3IEZpcmViYXNlQXV0aFRva2VuUHJvdmlkZXIoYXBwLm5hbWUsIGFwcC5vcHRpb25zLCBhdXRoUHJvdmlkZXIpO1xyXG4gICAgdmFsaWRhdGVVcmwoJ0ludmFsaWQgRmlyZWJhc2UgRGF0YWJhc2UgVVJMJywgcGFyc2VkVXJsKTtcclxuICAgIGlmICghcGF0aElzRW1wdHkocGFyc2VkVXJsLnBhdGgpKSB7XHJcbiAgICAgICAgZmF0YWwoJ0RhdGFiYXNlIFVSTCBtdXN0IHBvaW50IHRvIHRoZSByb290IG9mIGEgRmlyZWJhc2UgRGF0YWJhc2UgJyArXHJcbiAgICAgICAgICAgICcobm90IGluY2x1ZGluZyBhIGNoaWxkIHBhdGgpLicpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgcmVwbyA9IHJlcG9NYW5hZ2VyQ3JlYXRlUmVwbyhyZXBvSW5mbywgYXBwLCBhdXRoVG9rZW5Qcm92aWRlciwgbmV3IEFwcENoZWNrVG9rZW5Qcm92aWRlcihhcHAubmFtZSwgYXBwQ2hlY2tQcm92aWRlcikpO1xyXG4gICAgcmV0dXJuIG5ldyBEYXRhYmFzZShyZXBvLCBhcHApO1xyXG59XHJcbi8qKlxyXG4gKiBSZW1vdmUgdGhlIHJlcG8gYW5kIG1ha2Ugc3VyZSBpdCBpcyBkaXNjb25uZWN0ZWQuXHJcbiAqXHJcbiAqL1xyXG5mdW5jdGlvbiByZXBvTWFuYWdlckRlbGV0ZVJlcG8ocmVwbywgYXBwTmFtZSkge1xyXG4gICAgY29uc3QgYXBwUmVwb3MgPSByZXBvc1thcHBOYW1lXTtcclxuICAgIC8vIFRoaXMgc2hvdWxkIG5ldmVyIGhhcHBlbi4uLlxyXG4gICAgaWYgKCFhcHBSZXBvcyB8fCBhcHBSZXBvc1tyZXBvLmtleV0gIT09IHJlcG8pIHtcclxuICAgICAgICBmYXRhbChgRGF0YWJhc2UgJHthcHBOYW1lfSgke3JlcG8ucmVwb0luZm9ffSkgaGFzIGFscmVhZHkgYmVlbiBkZWxldGVkLmApO1xyXG4gICAgfVxyXG4gICAgcmVwb0ludGVycnVwdChyZXBvKTtcclxuICAgIGRlbGV0ZSBhcHBSZXBvc1tyZXBvLmtleV07XHJcbn1cclxuLyoqXHJcbiAqIEVuc3VyZXMgYSByZXBvIGRvZXNuJ3QgYWxyZWFkeSBleGlzdCBhbmQgdGhlbiBjcmVhdGVzIG9uZSB1c2luZyB0aGVcclxuICogcHJvdmlkZWQgYXBwLlxyXG4gKlxyXG4gKiBAcGFyYW0gcmVwb0luZm8gLSBUaGUgbWV0YWRhdGEgYWJvdXQgdGhlIFJlcG9cclxuICogQHJldHVybnMgVGhlIFJlcG8gb2JqZWN0IGZvciB0aGUgc3BlY2lmaWVkIHNlcnZlciAvIHJlcG9OYW1lLlxyXG4gKi9cclxuZnVuY3Rpb24gcmVwb01hbmFnZXJDcmVhdGVSZXBvKHJlcG9JbmZvLCBhcHAsIGF1dGhUb2tlblByb3ZpZGVyLCBhcHBDaGVja1Byb3ZpZGVyKSB7XHJcbiAgICBsZXQgYXBwUmVwb3MgPSByZXBvc1thcHAubmFtZV07XHJcbiAgICBpZiAoIWFwcFJlcG9zKSB7XHJcbiAgICAgICAgYXBwUmVwb3MgPSB7fTtcclxuICAgICAgICByZXBvc1thcHAubmFtZV0gPSBhcHBSZXBvcztcclxuICAgIH1cclxuICAgIGxldCByZXBvID0gYXBwUmVwb3NbcmVwb0luZm8udG9VUkxTdHJpbmcoKV07XHJcbiAgICBpZiAocmVwbykge1xyXG4gICAgICAgIGZhdGFsKCdEYXRhYmFzZSBpbml0aWFsaXplZCBtdWx0aXBsZSB0aW1lcy4gUGxlYXNlIG1ha2Ugc3VyZSB0aGUgZm9ybWF0IG9mIHRoZSBkYXRhYmFzZSBVUkwgbWF0Y2hlcyB3aXRoIGVhY2ggZGF0YWJhc2UoKSBjYWxsLicpO1xyXG4gICAgfVxyXG4gICAgcmVwbyA9IG5ldyBSZXBvKHJlcG9JbmZvLCB1c2VSZXN0Q2xpZW50LCBhdXRoVG9rZW5Qcm92aWRlciwgYXBwQ2hlY2tQcm92aWRlcik7XHJcbiAgICBhcHBSZXBvc1tyZXBvSW5mby50b1VSTFN0cmluZygpXSA9IHJlcG87XHJcbiAgICByZXR1cm4gcmVwbztcclxufVxyXG4vKipcclxuICogRm9yY2VzIHVzIHRvIHVzZSBSZWFkb25seVJlc3RDbGllbnQgaW5zdGVhZCBvZiBQZXJzaXN0ZW50Q29ubmVjdGlvbiBmb3IgbmV3IFJlcG9zLlxyXG4gKi9cclxuZnVuY3Rpb24gcmVwb01hbmFnZXJGb3JjZVJlc3RDbGllbnQoZm9yY2VSZXN0Q2xpZW50KSB7XHJcbiAgICB1c2VSZXN0Q2xpZW50ID0gZm9yY2VSZXN0Q2xpZW50O1xyXG59XHJcbi8qKlxyXG4gKiBDbGFzcyByZXByZXNlbnRpbmcgYSBGaXJlYmFzZSBSZWFsdGltZSBEYXRhYmFzZS5cclxuICovXHJcbmNsYXNzIERhdGFiYXNlIHtcclxuICAgIC8qKiBAaGlkZWNvbnN0cnVjdG9yICovXHJcbiAgICBjb25zdHJ1Y3RvcihfcmVwb0ludGVybmFsLCBcclxuICAgIC8qKiBUaGUge0BsaW5rIEBmaXJlYmFzZS9hcHAjRmlyZWJhc2VBcHB9IGFzc29jaWF0ZWQgd2l0aCB0aGlzIFJlYWx0aW1lIERhdGFiYXNlIGluc3RhbmNlLiAqL1xyXG4gICAgYXBwKSB7XHJcbiAgICAgICAgdGhpcy5fcmVwb0ludGVybmFsID0gX3JlcG9JbnRlcm5hbDtcclxuICAgICAgICB0aGlzLmFwcCA9IGFwcDtcclxuICAgICAgICAvKiogUmVwcmVzZW50cyBhIGBEYXRhYmFzZWAgaW5zdGFuY2UuICovXHJcbiAgICAgICAgdGhpc1sndHlwZSddID0gJ2RhdGFiYXNlJztcclxuICAgICAgICAvKiogVHJhY2sgaWYgdGhlIGluc3RhbmNlIGhhcyBiZWVuIHVzZWQgKHJvb3Qgb3IgcmVwbyBhY2Nlc3NlZCkgKi9cclxuICAgICAgICB0aGlzLl9pbnN0YW5jZVN0YXJ0ZWQgPSBmYWxzZTtcclxuICAgIH1cclxuICAgIGdldCBfcmVwbygpIHtcclxuICAgICAgICBpZiAoIXRoaXMuX2luc3RhbmNlU3RhcnRlZCkge1xyXG4gICAgICAgICAgICByZXBvU3RhcnQodGhpcy5fcmVwb0ludGVybmFsLCB0aGlzLmFwcC5vcHRpb25zLmFwcElkLCB0aGlzLmFwcC5vcHRpb25zWydkYXRhYmFzZUF1dGhWYXJpYWJsZU92ZXJyaWRlJ10pO1xyXG4gICAgICAgICAgICB0aGlzLl9pbnN0YW5jZVN0YXJ0ZWQgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5fcmVwb0ludGVybmFsO1xyXG4gICAgfVxyXG4gICAgZ2V0IF9yb290KCkge1xyXG4gICAgICAgIGlmICghdGhpcy5fcm9vdEludGVybmFsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3Jvb3RJbnRlcm5hbCA9IG5ldyBSZWZlcmVuY2VJbXBsKHRoaXMuX3JlcG8sIG5ld0VtcHR5UGF0aCgpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Jvb3RJbnRlcm5hbDtcclxuICAgIH1cclxuICAgIF9kZWxldGUoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX3Jvb3RJbnRlcm5hbCAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXBvTWFuYWdlckRlbGV0ZVJlcG8odGhpcy5fcmVwbywgdGhpcy5hcHAubmFtZSk7XHJcbiAgICAgICAgICAgIHRoaXMuX3JlcG9JbnRlcm5hbCA9IG51bGw7XHJcbiAgICAgICAgICAgIHRoaXMuX3Jvb3RJbnRlcm5hbCA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcclxuICAgIH1cclxuICAgIF9jaGVja05vdERlbGV0ZWQoYXBpTmFtZSkge1xyXG4gICAgICAgIGlmICh0aGlzLl9yb290SW50ZXJuYWwgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgZmF0YWwoJ0Nhbm5vdCBjYWxsICcgKyBhcGlOYW1lICsgJyBvbiBhIGRlbGV0ZWQgZGF0YWJhc2UuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBpbnN0YW5jZSBvZiB0aGUgUmVhbHRpbWUgRGF0YWJhc2UgU0RLIHRoYXQgaXMgYXNzb2NpYXRlZFxyXG4gKiB3aXRoIHRoZSBwcm92aWRlZCB7QGxpbmsgQGZpcmViYXNlL2FwcCNGaXJlYmFzZUFwcH0uIEluaXRpYWxpemVzIGEgbmV3IGluc3RhbmNlIHdpdGhcclxuICogd2l0aCBkZWZhdWx0IHNldHRpbmdzIGlmIG5vIGluc3RhbmNlIGV4aXN0cyBvciBpZiB0aGUgZXhpc3RpbmcgaW5zdGFuY2UgdXNlc1xyXG4gKiBhIGN1c3RvbSBkYXRhYmFzZSBVUkwuXHJcbiAqXHJcbiAqIEBwYXJhbSBhcHAgLSBUaGUge0BsaW5rIEBmaXJlYmFzZS9hcHAjRmlyZWJhc2VBcHB9IGluc3RhbmNlIHRoYXQgdGhlIHJldHVybmVkIFJlYWx0aW1lXHJcbiAqIERhdGFiYXNlIGluc3RhbmNlIGlzIGFzc29jaWF0ZWQgd2l0aC5cclxuICogQHBhcmFtIHVybCAtIFRoZSBVUkwgb2YgdGhlIFJlYWx0aW1lIERhdGFiYXNlIGluc3RhbmNlIHRvIGNvbm5lY3QgdG8uIElmIG5vdFxyXG4gKiBwcm92aWRlZCwgdGhlIFNESyBjb25uZWN0cyB0byB0aGUgZGVmYXVsdCBpbnN0YW5jZSBvZiB0aGUgRmlyZWJhc2UgQXBwLlxyXG4gKiBAcmV0dXJucyBUaGUgYERhdGFiYXNlYCBpbnN0YW5jZSBvZiB0aGUgcHJvdmlkZWQgYXBwLlxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0RGF0YWJhc2UoYXBwID0gZ2V0QXBwKCksIHVybCkge1xyXG4gICAgcmV0dXJuIF9nZXRQcm92aWRlcihhcHAsICdkYXRhYmFzZScpLmdldEltbWVkaWF0ZSh7XHJcbiAgICAgICAgaWRlbnRpZmllcjogdXJsXHJcbiAgICB9KTtcclxufVxyXG4vKipcclxuICogTW9kaWZ5IHRoZSBwcm92aWRlZCBpbnN0YW5jZSB0byBjb21tdW5pY2F0ZSB3aXRoIHRoZSBSZWFsdGltZSBEYXRhYmFzZVxyXG4gKiBlbXVsYXRvci5cclxuICpcclxuICogPHA+Tm90ZTogVGhpcyBtZXRob2QgbXVzdCBiZSBjYWxsZWQgYmVmb3JlIHBlcmZvcm1pbmcgYW55IG90aGVyIG9wZXJhdGlvbi5cclxuICpcclxuICogQHBhcmFtIGRiIC0gVGhlIGluc3RhbmNlIHRvIG1vZGlmeS5cclxuICogQHBhcmFtIGhvc3QgLSBUaGUgZW11bGF0b3IgaG9zdCAoZXg6IGxvY2FsaG9zdClcclxuICogQHBhcmFtIHBvcnQgLSBUaGUgZW11bGF0b3IgcG9ydCAoZXg6IDgwODApXHJcbiAqIEBwYXJhbSBvcHRpb25zLm1vY2tVc2VyVG9rZW4gLSB0aGUgbW9jayBhdXRoIHRva2VuIHRvIHVzZSBmb3IgdW5pdCB0ZXN0aW5nIFNlY3VyaXR5IFJ1bGVzXHJcbiAqL1xyXG5mdW5jdGlvbiBjb25uZWN0RGF0YWJhc2VFbXVsYXRvcihkYiwgaG9zdCwgcG9ydCwgb3B0aW9ucyA9IHt9KSB7XHJcbiAgICBkYiA9IGdldE1vZHVsYXJJbnN0YW5jZShkYik7XHJcbiAgICBkYi5fY2hlY2tOb3REZWxldGVkKCd1c2VFbXVsYXRvcicpO1xyXG4gICAgaWYgKGRiLl9pbnN0YW5jZVN0YXJ0ZWQpIHtcclxuICAgICAgICBmYXRhbCgnQ2Fubm90IGNhbGwgdXNlRW11bGF0b3IoKSBhZnRlciBpbnN0YW5jZSBoYXMgYWxyZWFkeSBiZWVuIGluaXRpYWxpemVkLicpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgcmVwbyA9IGRiLl9yZXBvSW50ZXJuYWw7XHJcbiAgICBsZXQgdG9rZW5Qcm92aWRlciA9IHVuZGVmaW5lZDtcclxuICAgIGlmIChyZXBvLnJlcG9JbmZvXy5ub2RlQWRtaW4pIHtcclxuICAgICAgICBpZiAob3B0aW9ucy5tb2NrVXNlclRva2VuKSB7XHJcbiAgICAgICAgICAgIGZhdGFsKCdtb2NrVXNlclRva2VuIGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhlIEFkbWluIFNESy4gRm9yIGNsaWVudCBhY2Nlc3Mgd2l0aCBtb2NrIHVzZXJzLCBwbGVhc2UgdXNlIHRoZSBcImZpcmViYXNlXCIgcGFja2FnZSBpbnN0ZWFkIG9mIFwiZmlyZWJhc2UtYWRtaW5cIi4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdG9rZW5Qcm92aWRlciA9IG5ldyBFbXVsYXRvclRva2VuUHJvdmlkZXIoRW11bGF0b3JUb2tlblByb3ZpZGVyLk9XTkVSKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKG9wdGlvbnMubW9ja1VzZXJUb2tlbikge1xyXG4gICAgICAgIGNvbnN0IHRva2VuID0gdHlwZW9mIG9wdGlvbnMubW9ja1VzZXJUb2tlbiA9PT0gJ3N0cmluZydcclxuICAgICAgICAgICAgPyBvcHRpb25zLm1vY2tVc2VyVG9rZW5cclxuICAgICAgICAgICAgOiBjcmVhdGVNb2NrVXNlclRva2VuKG9wdGlvbnMubW9ja1VzZXJUb2tlbiwgZGIuYXBwLm9wdGlvbnMucHJvamVjdElkKTtcclxuICAgICAgICB0b2tlblByb3ZpZGVyID0gbmV3IEVtdWxhdG9yVG9rZW5Qcm92aWRlcih0b2tlbik7XHJcbiAgICB9XHJcbiAgICAvLyBNb2RpZnkgdGhlIHJlcG8gdG8gYXBwbHkgZW11bGF0b3Igc2V0dGluZ3NcclxuICAgIHJlcG9NYW5hZ2VyQXBwbHlFbXVsYXRvclNldHRpbmdzKHJlcG8sIGhvc3QsIHBvcnQsIHRva2VuUHJvdmlkZXIpO1xyXG59XHJcbi8qKlxyXG4gKiBEaXNjb25uZWN0cyBmcm9tIHRoZSBzZXJ2ZXIgKGFsbCBEYXRhYmFzZSBvcGVyYXRpb25zIHdpbGwgYmUgY29tcGxldGVkXHJcbiAqIG9mZmxpbmUpLlxyXG4gKlxyXG4gKiBUaGUgY2xpZW50IGF1dG9tYXRpY2FsbHkgbWFpbnRhaW5zIGEgcGVyc2lzdGVudCBjb25uZWN0aW9uIHRvIHRoZSBEYXRhYmFzZVxyXG4gKiBzZXJ2ZXIsIHdoaWNoIHdpbGwgcmVtYWluIGFjdGl2ZSBpbmRlZmluaXRlbHkgYW5kIHJlY29ubmVjdCB3aGVuXHJcbiAqIGRpc2Nvbm5lY3RlZC4gSG93ZXZlciwgdGhlIGBnb09mZmxpbmUoKWAgYW5kIGBnb09ubGluZSgpYCBtZXRob2RzIG1heSBiZSB1c2VkXHJcbiAqIHRvIGNvbnRyb2wgdGhlIGNsaWVudCBjb25uZWN0aW9uIGluIGNhc2VzIHdoZXJlIGEgcGVyc2lzdGVudCBjb25uZWN0aW9uIGlzXHJcbiAqIHVuZGVzaXJhYmxlLlxyXG4gKlxyXG4gKiBXaGlsZSBvZmZsaW5lLCB0aGUgY2xpZW50IHdpbGwgbm8gbG9uZ2VyIHJlY2VpdmUgZGF0YSB1cGRhdGVzIGZyb20gdGhlXHJcbiAqIERhdGFiYXNlLiBIb3dldmVyLCBhbGwgRGF0YWJhc2Ugb3BlcmF0aW9ucyBwZXJmb3JtZWQgbG9jYWxseSB3aWxsIGNvbnRpbnVlIHRvXHJcbiAqIGltbWVkaWF0ZWx5IGZpcmUgZXZlbnRzLCBhbGxvd2luZyB5b3VyIGFwcGxpY2F0aW9uIHRvIGNvbnRpbnVlIGJlaGF2aW5nXHJcbiAqIG5vcm1hbGx5LiBBZGRpdGlvbmFsbHksIGVhY2ggb3BlcmF0aW9uIHBlcmZvcm1lZCBsb2NhbGx5IHdpbGwgYXV0b21hdGljYWxseVxyXG4gKiBiZSBxdWV1ZWQgYW5kIHJldHJpZWQgdXBvbiByZWNvbm5lY3Rpb24gdG8gdGhlIERhdGFiYXNlIHNlcnZlci5cclxuICpcclxuICogVG8gcmVjb25uZWN0IHRvIHRoZSBEYXRhYmFzZSBhbmQgYmVnaW4gcmVjZWl2aW5nIHJlbW90ZSBldmVudHMsIHNlZVxyXG4gKiBgZ29PbmxpbmUoKWAuXHJcbiAqXHJcbiAqIEBwYXJhbSBkYiAtIFRoZSBpbnN0YW5jZSB0byBkaXNjb25uZWN0LlxyXG4gKi9cclxuZnVuY3Rpb24gZ29PZmZsaW5lKGRiKSB7XHJcbiAgICBkYiA9IGdldE1vZHVsYXJJbnN0YW5jZShkYik7XHJcbiAgICBkYi5fY2hlY2tOb3REZWxldGVkKCdnb09mZmxpbmUnKTtcclxuICAgIHJlcG9JbnRlcnJ1cHQoZGIuX3JlcG8pO1xyXG59XHJcbi8qKlxyXG4gKiBSZWNvbm5lY3RzIHRvIHRoZSBzZXJ2ZXIgYW5kIHN5bmNocm9uaXplcyB0aGUgb2ZmbGluZSBEYXRhYmFzZSBzdGF0ZVxyXG4gKiB3aXRoIHRoZSBzZXJ2ZXIgc3RhdGUuXHJcbiAqXHJcbiAqIFRoaXMgbWV0aG9kIHNob3VsZCBiZSB1c2VkIGFmdGVyIGRpc2FibGluZyB0aGUgYWN0aXZlIGNvbm5lY3Rpb24gd2l0aFxyXG4gKiBgZ29PZmZsaW5lKClgLiBPbmNlIHJlY29ubmVjdGVkLCB0aGUgY2xpZW50IHdpbGwgdHJhbnNtaXQgdGhlIHByb3BlciBkYXRhXHJcbiAqIGFuZCBmaXJlIHRoZSBhcHByb3ByaWF0ZSBldmVudHMgc28gdGhhdCB5b3VyIGNsaWVudCBcImNhdGNoZXMgdXBcIlxyXG4gKiBhdXRvbWF0aWNhbGx5LlxyXG4gKlxyXG4gKiBAcGFyYW0gZGIgLSBUaGUgaW5zdGFuY2UgdG8gcmVjb25uZWN0LlxyXG4gKi9cclxuZnVuY3Rpb24gZ29PbmxpbmUoZGIpIHtcclxuICAgIGRiID0gZ2V0TW9kdWxhckluc3RhbmNlKGRiKTtcclxuICAgIGRiLl9jaGVja05vdERlbGV0ZWQoJ2dvT25saW5lJyk7XHJcbiAgICByZXBvUmVzdW1lKGRiLl9yZXBvKTtcclxufVxyXG5mdW5jdGlvbiBlbmFibGVMb2dnaW5nKGxvZ2dlciwgcGVyc2lzdGVudCkge1xyXG4gICAgZW5hYmxlTG9nZ2luZyQxKGxvZ2dlciwgcGVyc2lzdGVudCk7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIxIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuZnVuY3Rpb24gcmVnaXN0ZXJEYXRhYmFzZSh2YXJpYW50KSB7XHJcbiAgICBzZXRTREtWZXJzaW9uKFNES19WRVJTSU9OJDEpO1xyXG4gICAgX3JlZ2lzdGVyQ29tcG9uZW50KG5ldyBDb21wb25lbnQoJ2RhdGFiYXNlJywgKGNvbnRhaW5lciwgeyBpbnN0YW5jZUlkZW50aWZpZXI6IHVybCB9KSA9PiB7XHJcbiAgICAgICAgY29uc3QgYXBwID0gY29udGFpbmVyLmdldFByb3ZpZGVyKCdhcHAnKS5nZXRJbW1lZGlhdGUoKTtcclxuICAgICAgICBjb25zdCBhdXRoUHJvdmlkZXIgPSBjb250YWluZXIuZ2V0UHJvdmlkZXIoJ2F1dGgtaW50ZXJuYWwnKTtcclxuICAgICAgICBjb25zdCBhcHBDaGVja1Byb3ZpZGVyID0gY29udGFpbmVyLmdldFByb3ZpZGVyKCdhcHAtY2hlY2staW50ZXJuYWwnKTtcclxuICAgICAgICByZXR1cm4gcmVwb01hbmFnZXJEYXRhYmFzZUZyb21BcHAoYXBwLCBhdXRoUHJvdmlkZXIsIGFwcENoZWNrUHJvdmlkZXIsIHVybCk7XHJcbiAgICB9LCBcIlBVQkxJQ1wiIC8qIFBVQkxJQyAqLykuc2V0TXVsdGlwbGVJbnN0YW5jZXModHJ1ZSkpO1xyXG4gICAgcmVnaXN0ZXJWZXJzaW9uKG5hbWUsIHZlcnNpb24sIHZhcmlhbnQpO1xyXG4gICAgLy8gQlVJTERfVEFSR0VUIHdpbGwgYmUgcmVwbGFjZWQgYnkgdmFsdWVzIGxpa2UgZXNtNSwgZXNtMjAxNywgY2pzNSwgZXRjIGR1cmluZyB0aGUgY29tcGlsYXRpb25cclxuICAgIHJlZ2lzdGVyVmVyc2lvbihuYW1lLCB2ZXJzaW9uLCAnZXNtMjAxNycpO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmNvbnN0IFNFUlZFUl9USU1FU1RBTVAgPSB7XHJcbiAgICAnLnN2JzogJ3RpbWVzdGFtcCdcclxufTtcclxuLyoqXHJcbiAqIFJldHVybnMgYSBwbGFjZWhvbGRlciB2YWx1ZSBmb3IgYXV0by1wb3B1bGF0aW5nIHRoZSBjdXJyZW50IHRpbWVzdGFtcCAodGltZVxyXG4gKiBzaW5jZSB0aGUgVW5peCBlcG9jaCwgaW4gbWlsbGlzZWNvbmRzKSBhcyBkZXRlcm1pbmVkIGJ5IHRoZSBGaXJlYmFzZVxyXG4gKiBzZXJ2ZXJzLlxyXG4gKi9cclxuZnVuY3Rpb24gc2VydmVyVGltZXN0YW1wKCkge1xyXG4gICAgcmV0dXJuIFNFUlZFUl9USU1FU1RBTVA7XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybnMgYSBwbGFjZWhvbGRlciB2YWx1ZSB0aGF0IGNhbiBiZSB1c2VkIHRvIGF0b21pY2FsbHkgaW5jcmVtZW50IHRoZVxyXG4gKiBjdXJyZW50IGRhdGFiYXNlIHZhbHVlIGJ5IHRoZSBwcm92aWRlZCBkZWx0YS5cclxuICpcclxuICogQHBhcmFtIGRlbHRhIC0gdGhlIGFtb3VudCB0byBtb2RpZnkgdGhlIGN1cnJlbnQgdmFsdWUgYXRvbWljYWxseS5cclxuICogQHJldHVybnMgQSBwbGFjZWhvbGRlciB2YWx1ZSBmb3IgbW9kaWZ5aW5nIGRhdGEgYXRvbWljYWxseSBzZXJ2ZXItc2lkZS5cclxuICovXHJcbmZ1bmN0aW9uIGluY3JlbWVudChkZWx0YSkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICAnLnN2Jzoge1xyXG4gICAgICAgICAgICAnaW5jcmVtZW50JzogZGVsdGFcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBBIHR5cGUgZm9yIHRoZSByZXNvbHZlIHZhbHVlIG9mIHtAbGluayBydW5UcmFuc2FjdGlvbn0uXHJcbiAqL1xyXG5jbGFzcyBUcmFuc2FjdGlvblJlc3VsdCB7XHJcbiAgICAvKiogQGhpZGVjb25zdHJ1Y3RvciAqL1xyXG4gICAgY29uc3RydWN0b3IoXHJcbiAgICAvKiogV2hldGhlciB0aGUgdHJhbnNhY3Rpb24gd2FzIHN1Y2Nlc3NmdWxseSBjb21taXR0ZWQuICovXHJcbiAgICBjb21taXR0ZWQsIFxyXG4gICAgLyoqIFRoZSByZXN1bHRpbmcgZGF0YSBzbmFwc2hvdC4gKi9cclxuICAgIHNuYXBzaG90KSB7XHJcbiAgICAgICAgdGhpcy5jb21taXR0ZWQgPSBjb21taXR0ZWQ7XHJcbiAgICAgICAgdGhpcy5zbmFwc2hvdCA9IHNuYXBzaG90O1xyXG4gICAgfVxyXG4gICAgLyoqIFJldHVybnMgYSBKU09OLXNlcmlhbGl6YWJsZSByZXByZXNlbnRhdGlvbiBvZiB0aGlzIG9iamVjdC4gKi9cclxuICAgIHRvSlNPTigpIHtcclxuICAgICAgICByZXR1cm4geyBjb21taXR0ZWQ6IHRoaXMuY29tbWl0dGVkLCBzbmFwc2hvdDogdGhpcy5zbmFwc2hvdC50b0pTT04oKSB9O1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBBdG9taWNhbGx5IG1vZGlmaWVzIHRoZSBkYXRhIGF0IHRoaXMgbG9jYXRpb24uXHJcbiAqXHJcbiAqIEF0b21pY2FsbHkgbW9kaWZ5IHRoZSBkYXRhIGF0IHRoaXMgbG9jYXRpb24uIFVubGlrZSBhIG5vcm1hbCBgc2V0KClgLCB3aGljaFxyXG4gKiBqdXN0IG92ZXJ3cml0ZXMgdGhlIGRhdGEgcmVnYXJkbGVzcyBvZiBpdHMgcHJldmlvdXMgdmFsdWUsIGBydW5UcmFuc2FjdGlvbigpYCBpc1xyXG4gKiB1c2VkIHRvIG1vZGlmeSB0aGUgZXhpc3RpbmcgdmFsdWUgdG8gYSBuZXcgdmFsdWUsIGVuc3VyaW5nIHRoZXJlIGFyZSBub1xyXG4gKiBjb25mbGljdHMgd2l0aCBvdGhlciBjbGllbnRzIHdyaXRpbmcgdG8gdGhlIHNhbWUgbG9jYXRpb24gYXQgdGhlIHNhbWUgdGltZS5cclxuICpcclxuICogVG8gYWNjb21wbGlzaCB0aGlzLCB5b3UgcGFzcyBgcnVuVHJhbnNhY3Rpb24oKWAgYW4gdXBkYXRlIGZ1bmN0aW9uIHdoaWNoIGlzXHJcbiAqIHVzZWQgdG8gdHJhbnNmb3JtIHRoZSBjdXJyZW50IHZhbHVlIGludG8gYSBuZXcgdmFsdWUuIElmIGFub3RoZXIgY2xpZW50XHJcbiAqIHdyaXRlcyB0byB0aGUgbG9jYXRpb24gYmVmb3JlIHlvdXIgbmV3IHZhbHVlIGlzIHN1Y2Nlc3NmdWxseSB3cml0dGVuLCB5b3VyXHJcbiAqIHVwZGF0ZSBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCBhZ2FpbiB3aXRoIHRoZSBuZXcgY3VycmVudCB2YWx1ZSwgYW5kIHRoZVxyXG4gKiB3cml0ZSB3aWxsIGJlIHJldHJpZWQuIFRoaXMgd2lsbCBoYXBwZW4gcmVwZWF0ZWRseSB1bnRpbCB5b3VyIHdyaXRlIHN1Y2NlZWRzXHJcbiAqIHdpdGhvdXQgY29uZmxpY3Qgb3IgeW91IGFib3J0IHRoZSB0cmFuc2FjdGlvbiBieSBub3QgcmV0dXJuaW5nIGEgdmFsdWUgZnJvbVxyXG4gKiB5b3VyIHVwZGF0ZSBmdW5jdGlvbi5cclxuICpcclxuICogTm90ZTogTW9kaWZ5aW5nIGRhdGEgd2l0aCBgc2V0KClgIHdpbGwgY2FuY2VsIGFueSBwZW5kaW5nIHRyYW5zYWN0aW9ucyBhdFxyXG4gKiB0aGF0IGxvY2F0aW9uLCBzbyBleHRyZW1lIGNhcmUgc2hvdWxkIGJlIHRha2VuIGlmIG1peGluZyBgc2V0KClgIGFuZFxyXG4gKiBgcnVuVHJhbnNhY3Rpb24oKWAgdG8gdXBkYXRlIHRoZSBzYW1lIGRhdGEuXHJcbiAqXHJcbiAqIE5vdGU6IFdoZW4gdXNpbmcgdHJhbnNhY3Rpb25zIHdpdGggU2VjdXJpdHkgYW5kIEZpcmViYXNlIFJ1bGVzIGluIHBsYWNlLCBiZVxyXG4gKiBhd2FyZSB0aGF0IGEgY2xpZW50IG5lZWRzIGAucmVhZGAgYWNjZXNzIGluIGFkZGl0aW9uIHRvIGAud3JpdGVgIGFjY2VzcyBpblxyXG4gKiBvcmRlciB0byBwZXJmb3JtIGEgdHJhbnNhY3Rpb24uIFRoaXMgaXMgYmVjYXVzZSB0aGUgY2xpZW50LXNpZGUgbmF0dXJlIG9mXHJcbiAqIHRyYW5zYWN0aW9ucyByZXF1aXJlcyB0aGUgY2xpZW50IHRvIHJlYWQgdGhlIGRhdGEgaW4gb3JkZXIgdG8gdHJhbnNhY3Rpb25hbGx5XHJcbiAqIHVwZGF0ZSBpdC5cclxuICpcclxuICogQHBhcmFtIHJlZiAtIFRoZSBsb2NhdGlvbiB0byBhdG9taWNhbGx5IG1vZGlmeS5cclxuICogQHBhcmFtIHRyYW5zYWN0aW9uVXBkYXRlIC0gQSBkZXZlbG9wZXItc3VwcGxpZWQgZnVuY3Rpb24gd2hpY2ggd2lsbCBiZSBwYXNzZWRcclxuICogdGhlIGN1cnJlbnQgZGF0YSBzdG9yZWQgYXQgdGhpcyBsb2NhdGlvbiAoYXMgYSBKYXZhU2NyaXB0IG9iamVjdCkuIFRoZVxyXG4gKiBmdW5jdGlvbiBzaG91bGQgcmV0dXJuIHRoZSBuZXcgdmFsdWUgaXQgd291bGQgbGlrZSB3cml0dGVuIChhcyBhIEphdmFTY3JpcHRcclxuICogb2JqZWN0KS4gSWYgYHVuZGVmaW5lZGAgaXMgcmV0dXJuZWQgKGkuZS4geW91IHJldHVybiB3aXRoIG5vIGFyZ3VtZW50cykgdGhlXHJcbiAqIHRyYW5zYWN0aW9uIHdpbGwgYmUgYWJvcnRlZCBhbmQgdGhlIGRhdGEgYXQgdGhpcyBsb2NhdGlvbiB3aWxsIG5vdCBiZVxyXG4gKiBtb2RpZmllZC5cclxuICogQHBhcmFtIG9wdGlvbnMgLSBBbiBvcHRpb25zIG9iamVjdCB0byBjb25maWd1cmUgdHJhbnNhY3Rpb25zLlxyXG4gKiBAcmV0dXJucyBBIGBQcm9taXNlYCB0aGF0IGNhbiBvcHRpb25hbGx5IGJlIHVzZWQgaW5zdGVhZCBvZiB0aGUgYG9uQ29tcGxldGVgXHJcbiAqIGNhbGxiYWNrIHRvIGhhbmRsZSBzdWNjZXNzIGFuZCBmYWlsdXJlLlxyXG4gKi9cclxuZnVuY3Rpb24gcnVuVHJhbnNhY3Rpb24ocmVmLCBcclxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcclxudHJhbnNhY3Rpb25VcGRhdGUsIG9wdGlvbnMpIHtcclxuICAgIHZhciBfYTtcclxuICAgIHJlZiA9IGdldE1vZHVsYXJJbnN0YW5jZShyZWYpO1xyXG4gICAgdmFsaWRhdGVXcml0YWJsZVBhdGgoJ1JlZmVyZW5jZS50cmFuc2FjdGlvbicsIHJlZi5fcGF0aCk7XHJcbiAgICBpZiAocmVmLmtleSA9PT0gJy5sZW5ndGgnIHx8IHJlZi5rZXkgPT09ICcua2V5cycpIHtcclxuICAgICAgICB0aHJvdyAoJ1JlZmVyZW5jZS50cmFuc2FjdGlvbiBmYWlsZWQ6ICcgKyByZWYua2V5ICsgJyBpcyBhIHJlYWQtb25seSBvYmplY3QuJyk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBhcHBseUxvY2FsbHkgPSAoX2EgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuYXBwbHlMb2NhbGx5KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB0cnVlO1xyXG4gICAgY29uc3QgZGVmZXJyZWQgPSBuZXcgRGVmZXJyZWQoKTtcclxuICAgIGNvbnN0IHByb21pc2VDb21wbGV0ZSA9IChlcnJvciwgY29tbWl0dGVkLCBub2RlKSA9PiB7XHJcbiAgICAgICAgbGV0IGRhdGFTbmFwc2hvdCA9IG51bGw7XHJcbiAgICAgICAgaWYgKGVycm9yKSB7XHJcbiAgICAgICAgICAgIGRlZmVycmVkLnJlamVjdChlcnJvcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBkYXRhU25hcHNob3QgPSBuZXcgRGF0YVNuYXBzaG90KG5vZGUsIG5ldyBSZWZlcmVuY2VJbXBsKHJlZi5fcmVwbywgcmVmLl9wYXRoKSwgUFJJT1JJVFlfSU5ERVgpO1xyXG4gICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKG5ldyBUcmFuc2FjdGlvblJlc3VsdChjb21taXR0ZWQsIGRhdGFTbmFwc2hvdCkpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBBZGQgYSB3YXRjaCB0byBtYWtlIHN1cmUgd2UgZ2V0IHNlcnZlciB1cGRhdGVzLlxyXG4gICAgY29uc3QgdW53YXRjaGVyID0gb25WYWx1ZShyZWYsICgpID0+IHsgfSk7XHJcbiAgICByZXBvU3RhcnRUcmFuc2FjdGlvbihyZWYuX3JlcG8sIHJlZi5fcGF0aCwgdHJhbnNhY3Rpb25VcGRhdGUsIHByb21pc2VDb21wbGV0ZSwgdW53YXRjaGVyLCBhcHBseUxvY2FsbHkpO1xyXG4gICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuUGVyc2lzdGVudENvbm5lY3Rpb247XHJcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XHJcblBlcnNpc3RlbnRDb25uZWN0aW9uLnByb3RvdHlwZS5zaW1wbGVMaXN0ZW4gPSBmdW5jdGlvbiAocGF0aFN0cmluZywgb25Db21wbGV0ZSkge1xyXG4gICAgdGhpcy5zZW5kUmVxdWVzdCgncScsIHsgcDogcGF0aFN0cmluZyB9LCBvbkNvbXBsZXRlKTtcclxufTtcclxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcclxuUGVyc2lzdGVudENvbm5lY3Rpb24ucHJvdG90eXBlLmVjaG8gPSBmdW5jdGlvbiAoZGF0YSwgb25FY2hvKSB7XHJcbiAgICB0aGlzLnNlbmRSZXF1ZXN0KCdlY2hvJywgeyBkOiBkYXRhIH0sIG9uRWNobyk7XHJcbn07XHJcbi8vIFJlYWxUaW1lQ29ubmVjdGlvbiBwcm9wZXJ0aWVzIHRoYXQgd2UgdXNlIGluIHRlc3RzLlxyXG5Db25uZWN0aW9uO1xyXG4vKipcclxuICogQGludGVybmFsXHJcbiAqL1xyXG5jb25zdCBoaWphY2tIYXNoID0gZnVuY3Rpb24gKG5ld0hhc2gpIHtcclxuICAgIGNvbnN0IG9sZFB1dCA9IFBlcnNpc3RlbnRDb25uZWN0aW9uLnByb3RvdHlwZS5wdXQ7XHJcbiAgICBQZXJzaXN0ZW50Q29ubmVjdGlvbi5wcm90b3R5cGUucHV0ID0gZnVuY3Rpb24gKHBhdGhTdHJpbmcsIGRhdGEsIG9uQ29tcGxldGUsIGhhc2gpIHtcclxuICAgICAgICBpZiAoaGFzaCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIGhhc2ggPSBuZXdIYXNoKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG9sZFB1dC5jYWxsKHRoaXMsIHBhdGhTdHJpbmcsIGRhdGEsIG9uQ29tcGxldGUsIGhhc2gpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgUGVyc2lzdGVudENvbm5lY3Rpb24ucHJvdG90eXBlLnB1dCA9IG9sZFB1dDtcclxuICAgIH07XHJcbn07XHJcblJlcG9JbmZvO1xyXG4vKipcclxuICogRm9yY2VzIHRoZSBSZXBvTWFuYWdlciB0byBjcmVhdGUgUmVwb3MgdGhhdCB1c2UgUmVhZG9ubHlSZXN0Q2xpZW50IGluc3RlYWQgb2YgUGVyc2lzdGVudENvbm5lY3Rpb24uXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cclxuY29uc3QgZm9yY2VSZXN0Q2xpZW50ID0gZnVuY3Rpb24gKGZvcmNlUmVzdENsaWVudCkge1xyXG4gICAgcmVwb01hbmFnZXJGb3JjZVJlc3RDbGllbnQoZm9yY2VSZXN0Q2xpZW50KTtcclxufTtcblxuLyoqXHJcbiAqIEZpcmViYXNlIFJlYWx0aW1lIERhdGFiYXNlXHJcbiAqXHJcbiAqIEBwYWNrYWdlRG9jdW1lbnRhdGlvblxyXG4gKi9cclxucmVnaXN0ZXJEYXRhYmFzZSgpO1xuXG5leHBvcnQgeyBEYXRhU25hcHNob3QsIERhdGFiYXNlLCBPbkRpc2Nvbm5lY3QsIFF1ZXJ5Q29uc3RyYWludCwgVHJhbnNhY3Rpb25SZXN1bHQsIFF1ZXJ5SW1wbCBhcyBfUXVlcnlJbXBsLCBRdWVyeVBhcmFtcyBhcyBfUXVlcnlQYXJhbXMsIFJlZmVyZW5jZUltcGwgYXMgX1JlZmVyZW5jZUltcGwsIGZvcmNlUmVzdENsaWVudCBhcyBfVEVTVF9BQ0NFU1NfZm9yY2VSZXN0Q2xpZW50LCBoaWphY2tIYXNoIGFzIF9URVNUX0FDQ0VTU19oaWphY2tIYXNoLCByZXBvTWFuYWdlckRhdGFiYXNlRnJvbUFwcCBhcyBfcmVwb01hbmFnZXJEYXRhYmFzZUZyb21BcHAsIHNldFNES1ZlcnNpb24gYXMgX3NldFNES1ZlcnNpb24sIHZhbGlkYXRlUGF0aFN0cmluZyBhcyBfdmFsaWRhdGVQYXRoU3RyaW5nLCB2YWxpZGF0ZVdyaXRhYmxlUGF0aCBhcyBfdmFsaWRhdGVXcml0YWJsZVBhdGgsIGNoaWxkLCBjb25uZWN0RGF0YWJhc2VFbXVsYXRvciwgZW5hYmxlTG9nZ2luZywgZW5kQXQsIGVuZEJlZm9yZSwgZXF1YWxUbywgZ2V0LCBnZXREYXRhYmFzZSwgZ29PZmZsaW5lLCBnb09ubGluZSwgaW5jcmVtZW50LCBsaW1pdFRvRmlyc3QsIGxpbWl0VG9MYXN0LCBvZmYsIG9uQ2hpbGRBZGRlZCwgb25DaGlsZENoYW5nZWQsIG9uQ2hpbGRNb3ZlZCwgb25DaGlsZFJlbW92ZWQsIG9uRGlzY29ubmVjdCwgb25WYWx1ZSwgb3JkZXJCeUNoaWxkLCBvcmRlckJ5S2V5LCBvcmRlckJ5UHJpb3JpdHksIG9yZGVyQnlWYWx1ZSwgcHVzaCwgcXVlcnksIHJlZiwgcmVmRnJvbVVSTCwgcmVtb3ZlLCBydW5UcmFuc2FjdGlvbiwgc2VydmVyVGltZXN0YW1wLCBzZXQsIHNldFByaW9yaXR5LCBzZXRXaXRoUHJpb3JpdHksIHN0YXJ0QWZ0ZXIsIHN0YXJ0QXQsIHVwZGF0ZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguZXNtMjAxNy5qcy5tYXBcbiIsIi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBAZmlsZW92ZXJ2aWV3IEZpcmViYXNlIGNvbnN0YW50cy4gIFNvbWUgb2YgdGhlc2UgKEBkZWZpbmVzKSBjYW4gYmUgb3ZlcnJpZGRlbiBhdCBjb21waWxlLXRpbWUuXHJcbiAqL1xyXG5jb25zdCBDT05TVEFOVFMgPSB7XHJcbiAgICAvKipcclxuICAgICAqIEBkZWZpbmUge2Jvb2xlYW59IFdoZXRoZXIgdGhpcyBpcyB0aGUgY2xpZW50IE5vZGUuanMgU0RLLlxyXG4gICAgICovXHJcbiAgICBOT0RFX0NMSUVOVDogZmFsc2UsXHJcbiAgICAvKipcclxuICAgICAqIEBkZWZpbmUge2Jvb2xlYW59IFdoZXRoZXIgdGhpcyBpcyB0aGUgQWRtaW4gTm9kZS5qcyBTREsuXHJcbiAgICAgKi9cclxuICAgIE5PREVfQURNSU46IGZhbHNlLFxyXG4gICAgLyoqXHJcbiAgICAgKiBGaXJlYmFzZSBTREsgVmVyc2lvblxyXG4gICAgICovXHJcbiAgICBTREtfVkVSU0lPTjogJyR7SlNDT1JFX1ZFUlNJT059J1xyXG59O1xuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogVGhyb3dzIGFuIGVycm9yIGlmIHRoZSBwcm92aWRlZCBhc3NlcnRpb24gaXMgZmFsc3lcclxuICovXHJcbmNvbnN0IGFzc2VydCA9IGZ1bmN0aW9uIChhc3NlcnRpb24sIG1lc3NhZ2UpIHtcclxuICAgIGlmICghYXNzZXJ0aW9uKSB7XHJcbiAgICAgICAgdGhyb3cgYXNzZXJ0aW9uRXJyb3IobWVzc2FnZSk7XHJcbiAgICB9XHJcbn07XHJcbi8qKlxyXG4gKiBSZXR1cm5zIGFuIEVycm9yIG9iamVjdCBzdWl0YWJsZSBmb3IgdGhyb3dpbmcuXHJcbiAqL1xyXG5jb25zdCBhc3NlcnRpb25FcnJvciA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XHJcbiAgICByZXR1cm4gbmV3IEVycm9yKCdGaXJlYmFzZSBEYXRhYmFzZSAoJyArXHJcbiAgICAgICAgQ09OU1RBTlRTLlNES19WRVJTSU9OICtcclxuICAgICAgICAnKSBJTlRFUk5BTCBBU1NFUlQgRkFJTEVEOiAnICtcclxuICAgICAgICBtZXNzYWdlKTtcclxufTtcblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuY29uc3Qgc3RyaW5nVG9CeXRlQXJyYXkkMSA9IGZ1bmN0aW9uIChzdHIpIHtcclxuICAgIC8vIFRPRE8odXNlcik6IFVzZSBuYXRpdmUgaW1wbGVtZW50YXRpb25zIGlmL3doZW4gYXZhaWxhYmxlXHJcbiAgICBjb25zdCBvdXQgPSBbXTtcclxuICAgIGxldCBwID0gMDtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgbGV0IGMgPSBzdHIuY2hhckNvZGVBdChpKTtcclxuICAgICAgICBpZiAoYyA8IDEyOCkge1xyXG4gICAgICAgICAgICBvdXRbcCsrXSA9IGM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGMgPCAyMDQ4KSB7XHJcbiAgICAgICAgICAgIG91dFtwKytdID0gKGMgPj4gNikgfCAxOTI7XHJcbiAgICAgICAgICAgIG91dFtwKytdID0gKGMgJiA2MykgfCAxMjg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKChjICYgMHhmYzAwKSA9PT0gMHhkODAwICYmXHJcbiAgICAgICAgICAgIGkgKyAxIDwgc3RyLmxlbmd0aCAmJlxyXG4gICAgICAgICAgICAoc3RyLmNoYXJDb2RlQXQoaSArIDEpICYgMHhmYzAwKSA9PT0gMHhkYzAwKSB7XHJcbiAgICAgICAgICAgIC8vIFN1cnJvZ2F0ZSBQYWlyXHJcbiAgICAgICAgICAgIGMgPSAweDEwMDAwICsgKChjICYgMHgwM2ZmKSA8PCAxMCkgKyAoc3RyLmNoYXJDb2RlQXQoKytpKSAmIDB4MDNmZik7XHJcbiAgICAgICAgICAgIG91dFtwKytdID0gKGMgPj4gMTgpIHwgMjQwO1xyXG4gICAgICAgICAgICBvdXRbcCsrXSA9ICgoYyA+PiAxMikgJiA2MykgfCAxMjg7XHJcbiAgICAgICAgICAgIG91dFtwKytdID0gKChjID4+IDYpICYgNjMpIHwgMTI4O1xyXG4gICAgICAgICAgICBvdXRbcCsrXSA9IChjICYgNjMpIHwgMTI4O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgb3V0W3ArK10gPSAoYyA+PiAxMikgfCAyMjQ7XHJcbiAgICAgICAgICAgIG91dFtwKytdID0gKChjID4+IDYpICYgNjMpIHwgMTI4O1xyXG4gICAgICAgICAgICBvdXRbcCsrXSA9IChjICYgNjMpIHwgMTI4O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBvdXQ7XHJcbn07XHJcbi8qKlxyXG4gKiBUdXJucyBhbiBhcnJheSBvZiBudW1iZXJzIGludG8gdGhlIHN0cmluZyBnaXZlbiBieSB0aGUgY29uY2F0ZW5hdGlvbiBvZiB0aGVcclxuICogY2hhcmFjdGVycyB0byB3aGljaCB0aGUgbnVtYmVycyBjb3JyZXNwb25kLlxyXG4gKiBAcGFyYW0gYnl0ZXMgQXJyYXkgb2YgbnVtYmVycyByZXByZXNlbnRpbmcgY2hhcmFjdGVycy5cclxuICogQHJldHVybiBTdHJpbmdpZmljYXRpb24gb2YgdGhlIGFycmF5LlxyXG4gKi9cclxuY29uc3QgYnl0ZUFycmF5VG9TdHJpbmcgPSBmdW5jdGlvbiAoYnl0ZXMpIHtcclxuICAgIC8vIFRPRE8odXNlcik6IFVzZSBuYXRpdmUgaW1wbGVtZW50YXRpb25zIGlmL3doZW4gYXZhaWxhYmxlXHJcbiAgICBjb25zdCBvdXQgPSBbXTtcclxuICAgIGxldCBwb3MgPSAwLCBjID0gMDtcclxuICAgIHdoaWxlIChwb3MgPCBieXRlcy5sZW5ndGgpIHtcclxuICAgICAgICBjb25zdCBjMSA9IGJ5dGVzW3BvcysrXTtcclxuICAgICAgICBpZiAoYzEgPCAxMjgpIHtcclxuICAgICAgICAgICAgb3V0W2MrK10gPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGMxKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoYzEgPiAxOTEgJiYgYzEgPCAyMjQpIHtcclxuICAgICAgICAgICAgY29uc3QgYzIgPSBieXRlc1twb3MrK107XHJcbiAgICAgICAgICAgIG91dFtjKytdID0gU3RyaW5nLmZyb21DaGFyQ29kZSgoKGMxICYgMzEpIDw8IDYpIHwgKGMyICYgNjMpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoYzEgPiAyMzkgJiYgYzEgPCAzNjUpIHtcclxuICAgICAgICAgICAgLy8gU3Vycm9nYXRlIFBhaXJcclxuICAgICAgICAgICAgY29uc3QgYzIgPSBieXRlc1twb3MrK107XHJcbiAgICAgICAgICAgIGNvbnN0IGMzID0gYnl0ZXNbcG9zKytdO1xyXG4gICAgICAgICAgICBjb25zdCBjNCA9IGJ5dGVzW3BvcysrXTtcclxuICAgICAgICAgICAgY29uc3QgdSA9ICgoKGMxICYgNykgPDwgMTgpIHwgKChjMiAmIDYzKSA8PCAxMikgfCAoKGMzICYgNjMpIDw8IDYpIHwgKGM0ICYgNjMpKSAtXHJcbiAgICAgICAgICAgICAgICAweDEwMDAwO1xyXG4gICAgICAgICAgICBvdXRbYysrXSA9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHhkODAwICsgKHUgPj4gMTApKTtcclxuICAgICAgICAgICAgb3V0W2MrK10gPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4ZGMwMCArICh1ICYgMTAyMykpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3QgYzIgPSBieXRlc1twb3MrK107XHJcbiAgICAgICAgICAgIGNvbnN0IGMzID0gYnl0ZXNbcG9zKytdO1xyXG4gICAgICAgICAgICBvdXRbYysrXSA9IFN0cmluZy5mcm9tQ2hhckNvZGUoKChjMSAmIDE1KSA8PCAxMikgfCAoKGMyICYgNjMpIDw8IDYpIHwgKGMzICYgNjMpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gb3V0LmpvaW4oJycpO1xyXG59O1xyXG4vLyBXZSBkZWZpbmUgaXQgYXMgYW4gb2JqZWN0IGxpdGVyYWwgaW5zdGVhZCBvZiBhIGNsYXNzIGJlY2F1c2UgYSBjbGFzcyBjb21waWxlZCBkb3duIHRvIGVzNSBjYW4ndFxyXG4vLyBiZSB0cmVlc2hha2VkLiBodHRwczovL2dpdGh1Yi5jb20vcm9sbHVwL3JvbGx1cC9pc3N1ZXMvMTY5MVxyXG4vLyBTdGF0aWMgbG9va3VwIG1hcHMsIGxhemlseSBwb3B1bGF0ZWQgYnkgaW5pdF8oKVxyXG5jb25zdCBiYXNlNjQgPSB7XHJcbiAgICAvKipcclxuICAgICAqIE1hcHMgYnl0ZXMgdG8gY2hhcmFjdGVycy5cclxuICAgICAqL1xyXG4gICAgYnl0ZVRvQ2hhck1hcF86IG51bGwsXHJcbiAgICAvKipcclxuICAgICAqIE1hcHMgY2hhcmFjdGVycyB0byBieXRlcy5cclxuICAgICAqL1xyXG4gICAgY2hhclRvQnl0ZU1hcF86IG51bGwsXHJcbiAgICAvKipcclxuICAgICAqIE1hcHMgYnl0ZXMgdG8gd2Vic2FmZSBjaGFyYWN0ZXJzLlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgYnl0ZVRvQ2hhck1hcFdlYlNhZmVfOiBudWxsLFxyXG4gICAgLyoqXHJcbiAgICAgKiBNYXBzIHdlYnNhZmUgY2hhcmFjdGVycyB0byBieXRlcy5cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIGNoYXJUb0J5dGVNYXBXZWJTYWZlXzogbnVsbCxcclxuICAgIC8qKlxyXG4gICAgICogT3VyIGRlZmF1bHQgYWxwaGFiZXQsIHNoYXJlZCBiZXR3ZWVuXHJcbiAgICAgKiBFTkNPREVEX1ZBTFMgYW5kIEVOQ09ERURfVkFMU19XRUJTQUZFXHJcbiAgICAgKi9cclxuICAgIEVOQ09ERURfVkFMU19CQVNFOiAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVonICsgJ2FiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6JyArICcwMTIzNDU2Nzg5JyxcclxuICAgIC8qKlxyXG4gICAgICogT3VyIGRlZmF1bHQgYWxwaGFiZXQuIFZhbHVlIDY0ICg9KSBpcyBzcGVjaWFsOyBpdCBtZWFucyBcIm5vdGhpbmcuXCJcclxuICAgICAqL1xyXG4gICAgZ2V0IEVOQ09ERURfVkFMUygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5FTkNPREVEX1ZBTFNfQkFTRSArICcrLz0nO1xyXG4gICAgfSxcclxuICAgIC8qKlxyXG4gICAgICogT3VyIHdlYnNhZmUgYWxwaGFiZXQuXHJcbiAgICAgKi9cclxuICAgIGdldCBFTkNPREVEX1ZBTFNfV0VCU0FGRSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5FTkNPREVEX1ZBTFNfQkFTRSArICctXy4nO1xyXG4gICAgfSxcclxuICAgIC8qKlxyXG4gICAgICogV2hldGhlciB0aGlzIGJyb3dzZXIgc3VwcG9ydHMgdGhlIGF0b2IgYW5kIGJ0b2EgZnVuY3Rpb25zLiBUaGlzIGV4dGVuc2lvblxyXG4gICAgICogc3RhcnRlZCBhdCBNb3ppbGxhIGJ1dCBpcyBub3cgaW1wbGVtZW50ZWQgYnkgbWFueSBicm93c2Vycy4gV2UgdXNlIHRoZVxyXG4gICAgICogQVNTVU1FXyogdmFyaWFibGVzIHRvIGF2b2lkIHB1bGxpbmcgaW4gdGhlIGZ1bGwgdXNlcmFnZW50IGRldGVjdGlvbiBsaWJyYXJ5XHJcbiAgICAgKiBidXQgc3RpbGwgYWxsb3dpbmcgdGhlIHN0YW5kYXJkIHBlci1icm93c2VyIGNvbXBpbGF0aW9ucy5cclxuICAgICAqXHJcbiAgICAgKi9cclxuICAgIEhBU19OQVRJVkVfU1VQUE9SVDogdHlwZW9mIGF0b2IgPT09ICdmdW5jdGlvbicsXHJcbiAgICAvKipcclxuICAgICAqIEJhc2U2NC1lbmNvZGUgYW4gYXJyYXkgb2YgYnl0ZXMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGlucHV0IEFuIGFycmF5IG9mIGJ5dGVzIChudW1iZXJzIHdpdGhcclxuICAgICAqICAgICB2YWx1ZSBpbiBbMCwgMjU1XSkgdG8gZW5jb2RlLlxyXG4gICAgICogQHBhcmFtIHdlYlNhZmUgQm9vbGVhbiBpbmRpY2F0aW5nIHdlIHNob3VsZCB1c2UgdGhlXHJcbiAgICAgKiAgICAgYWx0ZXJuYXRpdmUgYWxwaGFiZXQuXHJcbiAgICAgKiBAcmV0dXJuIFRoZSBiYXNlNjQgZW5jb2RlZCBzdHJpbmcuXHJcbiAgICAgKi9cclxuICAgIGVuY29kZUJ5dGVBcnJheShpbnB1dCwgd2ViU2FmZSkge1xyXG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShpbnB1dCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ2VuY29kZUJ5dGVBcnJheSB0YWtlcyBhbiBhcnJheSBhcyBhIHBhcmFtZXRlcicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmluaXRfKCk7XHJcbiAgICAgICAgY29uc3QgYnl0ZVRvQ2hhck1hcCA9IHdlYlNhZmVcclxuICAgICAgICAgICAgPyB0aGlzLmJ5dGVUb0NoYXJNYXBXZWJTYWZlX1xyXG4gICAgICAgICAgICA6IHRoaXMuYnl0ZVRvQ2hhck1hcF87XHJcbiAgICAgICAgY29uc3Qgb3V0cHV0ID0gW107XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnB1dC5sZW5ndGg7IGkgKz0gMykge1xyXG4gICAgICAgICAgICBjb25zdCBieXRlMSA9IGlucHV0W2ldO1xyXG4gICAgICAgICAgICBjb25zdCBoYXZlQnl0ZTIgPSBpICsgMSA8IGlucHV0Lmxlbmd0aDtcclxuICAgICAgICAgICAgY29uc3QgYnl0ZTIgPSBoYXZlQnl0ZTIgPyBpbnB1dFtpICsgMV0gOiAwO1xyXG4gICAgICAgICAgICBjb25zdCBoYXZlQnl0ZTMgPSBpICsgMiA8IGlucHV0Lmxlbmd0aDtcclxuICAgICAgICAgICAgY29uc3QgYnl0ZTMgPSBoYXZlQnl0ZTMgPyBpbnB1dFtpICsgMl0gOiAwO1xyXG4gICAgICAgICAgICBjb25zdCBvdXRCeXRlMSA9IGJ5dGUxID4+IDI7XHJcbiAgICAgICAgICAgIGNvbnN0IG91dEJ5dGUyID0gKChieXRlMSAmIDB4MDMpIDw8IDQpIHwgKGJ5dGUyID4+IDQpO1xyXG4gICAgICAgICAgICBsZXQgb3V0Qnl0ZTMgPSAoKGJ5dGUyICYgMHgwZikgPDwgMikgfCAoYnl0ZTMgPj4gNik7XHJcbiAgICAgICAgICAgIGxldCBvdXRCeXRlNCA9IGJ5dGUzICYgMHgzZjtcclxuICAgICAgICAgICAgaWYgKCFoYXZlQnl0ZTMpIHtcclxuICAgICAgICAgICAgICAgIG91dEJ5dGU0ID0gNjQ7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWhhdmVCeXRlMikge1xyXG4gICAgICAgICAgICAgICAgICAgIG91dEJ5dGUzID0gNjQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgb3V0cHV0LnB1c2goYnl0ZVRvQ2hhck1hcFtvdXRCeXRlMV0sIGJ5dGVUb0NoYXJNYXBbb3V0Qnl0ZTJdLCBieXRlVG9DaGFyTWFwW291dEJ5dGUzXSwgYnl0ZVRvQ2hhck1hcFtvdXRCeXRlNF0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gb3V0cHV0LmpvaW4oJycpO1xyXG4gICAgfSxcclxuICAgIC8qKlxyXG4gICAgICogQmFzZTY0LWVuY29kZSBhIHN0cmluZy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gaW5wdXQgQSBzdHJpbmcgdG8gZW5jb2RlLlxyXG4gICAgICogQHBhcmFtIHdlYlNhZmUgSWYgdHJ1ZSwgd2Ugc2hvdWxkIHVzZSB0aGVcclxuICAgICAqICAgICBhbHRlcm5hdGl2ZSBhbHBoYWJldC5cclxuICAgICAqIEByZXR1cm4gVGhlIGJhc2U2NCBlbmNvZGVkIHN0cmluZy5cclxuICAgICAqL1xyXG4gICAgZW5jb2RlU3RyaW5nKGlucHV0LCB3ZWJTYWZlKSB7XHJcbiAgICAgICAgLy8gU2hvcnRjdXQgZm9yIE1vemlsbGEgYnJvd3NlcnMgdGhhdCBpbXBsZW1lbnRcclxuICAgICAgICAvLyBhIG5hdGl2ZSBiYXNlNjQgZW5jb2RlciBpbiB0aGUgZm9ybSBvZiBcImJ0b2EvYXRvYlwiXHJcbiAgICAgICAgaWYgKHRoaXMuSEFTX05BVElWRV9TVVBQT1JUICYmICF3ZWJTYWZlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBidG9hKGlucHV0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZW5jb2RlQnl0ZUFycmF5KHN0cmluZ1RvQnl0ZUFycmF5JDEoaW5wdXQpLCB3ZWJTYWZlKTtcclxuICAgIH0sXHJcbiAgICAvKipcclxuICAgICAqIEJhc2U2NC1kZWNvZGUgYSBzdHJpbmcuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGlucHV0IHRvIGRlY29kZS5cclxuICAgICAqIEBwYXJhbSB3ZWJTYWZlIFRydWUgaWYgd2Ugc2hvdWxkIHVzZSB0aGVcclxuICAgICAqICAgICBhbHRlcm5hdGl2ZSBhbHBoYWJldC5cclxuICAgICAqIEByZXR1cm4gc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgZGVjb2RlZCB2YWx1ZS5cclxuICAgICAqL1xyXG4gICAgZGVjb2RlU3RyaW5nKGlucHV0LCB3ZWJTYWZlKSB7XHJcbiAgICAgICAgLy8gU2hvcnRjdXQgZm9yIE1vemlsbGEgYnJvd3NlcnMgdGhhdCBpbXBsZW1lbnRcclxuICAgICAgICAvLyBhIG5hdGl2ZSBiYXNlNjQgZW5jb2RlciBpbiB0aGUgZm9ybSBvZiBcImJ0b2EvYXRvYlwiXHJcbiAgICAgICAgaWYgKHRoaXMuSEFTX05BVElWRV9TVVBQT1JUICYmICF3ZWJTYWZlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBhdG9iKGlucHV0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGJ5dGVBcnJheVRvU3RyaW5nKHRoaXMuZGVjb2RlU3RyaW5nVG9CeXRlQXJyYXkoaW5wdXQsIHdlYlNhZmUpKTtcclxuICAgIH0sXHJcbiAgICAvKipcclxuICAgICAqIEJhc2U2NC1kZWNvZGUgYSBzdHJpbmcuXHJcbiAgICAgKlxyXG4gICAgICogSW4gYmFzZS02NCBkZWNvZGluZywgZ3JvdXBzIG9mIGZvdXIgY2hhcmFjdGVycyBhcmUgY29udmVydGVkIGludG8gdGhyZWVcclxuICAgICAqIGJ5dGVzLiAgSWYgdGhlIGVuY29kZXIgZGlkIG5vdCBhcHBseSBwYWRkaW5nLCB0aGUgaW5wdXQgbGVuZ3RoIG1heSBub3RcclxuICAgICAqIGJlIGEgbXVsdGlwbGUgb2YgNC5cclxuICAgICAqXHJcbiAgICAgKiBJbiB0aGlzIGNhc2UsIHRoZSBsYXN0IGdyb3VwIHdpbGwgaGF2ZSBmZXdlciB0aGFuIDQgY2hhcmFjdGVycywgYW5kXHJcbiAgICAgKiBwYWRkaW5nIHdpbGwgYmUgaW5mZXJyZWQuICBJZiB0aGUgZ3JvdXAgaGFzIG9uZSBvciB0d28gY2hhcmFjdGVycywgaXQgZGVjb2Rlc1xyXG4gICAgICogdG8gb25lIGJ5dGUuICBJZiB0aGUgZ3JvdXAgaGFzIHRocmVlIGNoYXJhY3RlcnMsIGl0IGRlY29kZXMgdG8gdHdvIGJ5dGVzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBpbnB1dCBJbnB1dCB0byBkZWNvZGUuXHJcbiAgICAgKiBAcGFyYW0gd2ViU2FmZSBUcnVlIGlmIHdlIHNob3VsZCB1c2UgdGhlIHdlYi1zYWZlIGFscGhhYmV0LlxyXG4gICAgICogQHJldHVybiBieXRlcyByZXByZXNlbnRpbmcgdGhlIGRlY29kZWQgdmFsdWUuXHJcbiAgICAgKi9cclxuICAgIGRlY29kZVN0cmluZ1RvQnl0ZUFycmF5KGlucHV0LCB3ZWJTYWZlKSB7XHJcbiAgICAgICAgdGhpcy5pbml0XygpO1xyXG4gICAgICAgIGNvbnN0IGNoYXJUb0J5dGVNYXAgPSB3ZWJTYWZlXHJcbiAgICAgICAgICAgID8gdGhpcy5jaGFyVG9CeXRlTWFwV2ViU2FmZV9cclxuICAgICAgICAgICAgOiB0aGlzLmNoYXJUb0J5dGVNYXBfO1xyXG4gICAgICAgIGNvbnN0IG91dHB1dCA9IFtdO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5wdXQubGVuZ3RoOykge1xyXG4gICAgICAgICAgICBjb25zdCBieXRlMSA9IGNoYXJUb0J5dGVNYXBbaW5wdXQuY2hhckF0KGkrKyldO1xyXG4gICAgICAgICAgICBjb25zdCBoYXZlQnl0ZTIgPSBpIDwgaW5wdXQubGVuZ3RoO1xyXG4gICAgICAgICAgICBjb25zdCBieXRlMiA9IGhhdmVCeXRlMiA/IGNoYXJUb0J5dGVNYXBbaW5wdXQuY2hhckF0KGkpXSA6IDA7XHJcbiAgICAgICAgICAgICsraTtcclxuICAgICAgICAgICAgY29uc3QgaGF2ZUJ5dGUzID0gaSA8IGlucHV0Lmxlbmd0aDtcclxuICAgICAgICAgICAgY29uc3QgYnl0ZTMgPSBoYXZlQnl0ZTMgPyBjaGFyVG9CeXRlTWFwW2lucHV0LmNoYXJBdChpKV0gOiA2NDtcclxuICAgICAgICAgICAgKytpO1xyXG4gICAgICAgICAgICBjb25zdCBoYXZlQnl0ZTQgPSBpIDwgaW5wdXQubGVuZ3RoO1xyXG4gICAgICAgICAgICBjb25zdCBieXRlNCA9IGhhdmVCeXRlNCA/IGNoYXJUb0J5dGVNYXBbaW5wdXQuY2hhckF0KGkpXSA6IDY0O1xyXG4gICAgICAgICAgICArK2k7XHJcbiAgICAgICAgICAgIGlmIChieXRlMSA9PSBudWxsIHx8IGJ5dGUyID09IG51bGwgfHwgYnl0ZTMgPT0gbnVsbCB8fCBieXRlNCA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IG91dEJ5dGUxID0gKGJ5dGUxIDw8IDIpIHwgKGJ5dGUyID4+IDQpO1xyXG4gICAgICAgICAgICBvdXRwdXQucHVzaChvdXRCeXRlMSk7XHJcbiAgICAgICAgICAgIGlmIChieXRlMyAhPT0gNjQpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG91dEJ5dGUyID0gKChieXRlMiA8PCA0KSAmIDB4ZjApIHwgKGJ5dGUzID4+IDIpO1xyXG4gICAgICAgICAgICAgICAgb3V0cHV0LnB1c2gob3V0Qnl0ZTIpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGJ5dGU0ICE9PSA2NCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG91dEJ5dGUzID0gKChieXRlMyA8PCA2KSAmIDB4YzApIHwgYnl0ZTQ7XHJcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnB1c2gob3V0Qnl0ZTMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBvdXRwdXQ7XHJcbiAgICB9LFxyXG4gICAgLyoqXHJcbiAgICAgKiBMYXp5IHN0YXRpYyBpbml0aWFsaXphdGlvbiBmdW5jdGlvbi4gQ2FsbGVkIGJlZm9yZVxyXG4gICAgICogYWNjZXNzaW5nIGFueSBvZiB0aGUgc3RhdGljIG1hcCB2YXJpYWJsZXMuXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBpbml0XygpIHtcclxuICAgICAgICBpZiAoIXRoaXMuYnl0ZVRvQ2hhck1hcF8pIHtcclxuICAgICAgICAgICAgdGhpcy5ieXRlVG9DaGFyTWFwXyA9IHt9O1xyXG4gICAgICAgICAgICB0aGlzLmNoYXJUb0J5dGVNYXBfID0ge307XHJcbiAgICAgICAgICAgIHRoaXMuYnl0ZVRvQ2hhck1hcFdlYlNhZmVfID0ge307XHJcbiAgICAgICAgICAgIHRoaXMuY2hhclRvQnl0ZU1hcFdlYlNhZmVfID0ge307XHJcbiAgICAgICAgICAgIC8vIFdlIHdhbnQgcXVpY2sgbWFwcGluZ3MgYmFjayBhbmQgZm9ydGgsIHNvIHdlIHByZWNvbXB1dGUgdHdvIG1hcHMuXHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5FTkNPREVEX1ZBTFMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYnl0ZVRvQ2hhck1hcF9baV0gPSB0aGlzLkVOQ09ERURfVkFMUy5jaGFyQXQoaSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNoYXJUb0J5dGVNYXBfW3RoaXMuYnl0ZVRvQ2hhck1hcF9baV1dID0gaTtcclxuICAgICAgICAgICAgICAgIHRoaXMuYnl0ZVRvQ2hhck1hcFdlYlNhZmVfW2ldID0gdGhpcy5FTkNPREVEX1ZBTFNfV0VCU0FGRS5jaGFyQXQoaSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNoYXJUb0J5dGVNYXBXZWJTYWZlX1t0aGlzLmJ5dGVUb0NoYXJNYXBXZWJTYWZlX1tpXV0gPSBpO1xyXG4gICAgICAgICAgICAgICAgLy8gQmUgZm9yZ2l2aW5nIHdoZW4gZGVjb2RpbmcgYW5kIGNvcnJlY3RseSBkZWNvZGUgYm90aCBlbmNvZGluZ3MuXHJcbiAgICAgICAgICAgICAgICBpZiAoaSA+PSB0aGlzLkVOQ09ERURfVkFMU19CQVNFLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2hhclRvQnl0ZU1hcF9bdGhpcy5FTkNPREVEX1ZBTFNfV0VCU0FGRS5jaGFyQXQoaSldID0gaTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNoYXJUb0J5dGVNYXBXZWJTYWZlX1t0aGlzLkVOQ09ERURfVkFMUy5jaGFyQXQoaSldID0gaTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuLyoqXHJcbiAqIFVSTC1zYWZlIGJhc2U2NCBlbmNvZGluZ1xyXG4gKi9cclxuY29uc3QgYmFzZTY0RW5jb2RlID0gZnVuY3Rpb24gKHN0cikge1xyXG4gICAgY29uc3QgdXRmOEJ5dGVzID0gc3RyaW5nVG9CeXRlQXJyYXkkMShzdHIpO1xyXG4gICAgcmV0dXJuIGJhc2U2NC5lbmNvZGVCeXRlQXJyYXkodXRmOEJ5dGVzLCB0cnVlKTtcclxufTtcclxuLyoqXHJcbiAqIFVSTC1zYWZlIGJhc2U2NCBlbmNvZGluZyAod2l0aG91dCBcIi5cIiBwYWRkaW5nIGluIHRoZSBlbmQpLlxyXG4gKiBlLmcuIFVzZWQgaW4gSlNPTiBXZWIgVG9rZW4gKEpXVCkgcGFydHMuXHJcbiAqL1xyXG5jb25zdCBiYXNlNjR1cmxFbmNvZGVXaXRob3V0UGFkZGluZyA9IGZ1bmN0aW9uIChzdHIpIHtcclxuICAgIC8vIFVzZSBiYXNlNjR1cmwgZW5jb2RpbmcgYW5kIHJlbW92ZSBwYWRkaW5nIGluIHRoZSBlbmQgKGRvdCBjaGFyYWN0ZXJzKS5cclxuICAgIHJldHVybiBiYXNlNjRFbmNvZGUoc3RyKS5yZXBsYWNlKC9cXC4vZywgJycpO1xyXG59O1xyXG4vKipcclxuICogVVJMLXNhZmUgYmFzZTY0IGRlY29kaW5nXHJcbiAqXHJcbiAqIE5PVEU6IERPIE5PVCB1c2UgdGhlIGdsb2JhbCBhdG9iKCkgZnVuY3Rpb24gLSBpdCBkb2VzIE5PVCBzdXBwb3J0IHRoZVxyXG4gKiBiYXNlNjRVcmwgdmFyaWFudCBlbmNvZGluZy5cclxuICpcclxuICogQHBhcmFtIHN0ciBUbyBiZSBkZWNvZGVkXHJcbiAqIEByZXR1cm4gRGVjb2RlZCByZXN1bHQsIGlmIHBvc3NpYmxlXHJcbiAqL1xyXG5jb25zdCBiYXNlNjREZWNvZGUgPSBmdW5jdGlvbiAoc3RyKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIHJldHVybiBiYXNlNjQuZGVjb2RlU3RyaW5nKHN0ciwgdHJ1ZSk7XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ2Jhc2U2NERlY29kZSBmYWlsZWQ6ICcsIGUpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG51bGw7XHJcbn07XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBEbyBhIGRlZXAtY29weSBvZiBiYXNpYyBKYXZhU2NyaXB0IE9iamVjdHMgb3IgQXJyYXlzLlxyXG4gKi9cclxuZnVuY3Rpb24gZGVlcENvcHkodmFsdWUpIHtcclxuICAgIHJldHVybiBkZWVwRXh0ZW5kKHVuZGVmaW5lZCwgdmFsdWUpO1xyXG59XHJcbi8qKlxyXG4gKiBDb3B5IHByb3BlcnRpZXMgZnJvbSBzb3VyY2UgdG8gdGFyZ2V0IChyZWN1cnNpdmVseSBhbGxvd3MgZXh0ZW5zaW9uXHJcbiAqIG9mIE9iamVjdHMgYW5kIEFycmF5cykuICBTY2FsYXIgdmFsdWVzIGluIHRoZSB0YXJnZXQgYXJlIG92ZXItd3JpdHRlbi5cclxuICogSWYgdGFyZ2V0IGlzIHVuZGVmaW5lZCwgYW4gb2JqZWN0IG9mIHRoZSBhcHByb3ByaWF0ZSB0eXBlIHdpbGwgYmUgY3JlYXRlZFxyXG4gKiAoYW5kIHJldHVybmVkKS5cclxuICpcclxuICogV2UgcmVjdXJzaXZlbHkgY29weSBhbGwgY2hpbGQgcHJvcGVydGllcyBvZiBwbGFpbiBPYmplY3RzIGluIHRoZSBzb3VyY2UtIHNvXHJcbiAqIHRoYXQgbmFtZXNwYWNlLSBsaWtlIGRpY3Rpb25hcmllcyBhcmUgbWVyZ2VkLlxyXG4gKlxyXG4gKiBOb3RlIHRoYXQgdGhlIHRhcmdldCBjYW4gYmUgYSBmdW5jdGlvbiwgaW4gd2hpY2ggY2FzZSB0aGUgcHJvcGVydGllcyBpblxyXG4gKiB0aGUgc291cmNlIE9iamVjdCBhcmUgY29waWVkIG9udG8gaXQgYXMgc3RhdGljIHByb3BlcnRpZXMgb2YgdGhlIEZ1bmN0aW9uLlxyXG4gKlxyXG4gKiBOb3RlOiB3ZSBkb24ndCBtZXJnZSBfX3Byb3RvX18gdG8gcHJldmVudCBwcm90b3R5cGUgcG9sbHV0aW9uXHJcbiAqL1xyXG5mdW5jdGlvbiBkZWVwRXh0ZW5kKHRhcmdldCwgc291cmNlKSB7XHJcbiAgICBpZiAoIShzb3VyY2UgaW5zdGFuY2VvZiBPYmplY3QpKSB7XHJcbiAgICAgICAgcmV0dXJuIHNvdXJjZTtcclxuICAgIH1cclxuICAgIHN3aXRjaCAoc291cmNlLmNvbnN0cnVjdG9yKSB7XHJcbiAgICAgICAgY2FzZSBEYXRlOlxyXG4gICAgICAgICAgICAvLyBUcmVhdCBEYXRlcyBsaWtlIHNjYWxhcnM7IGlmIHRoZSB0YXJnZXQgZGF0ZSBvYmplY3QgaGFkIGFueSBjaGlsZFxyXG4gICAgICAgICAgICAvLyBwcm9wZXJ0aWVzIC0gdGhleSB3aWxsIGJlIGxvc3QhXHJcbiAgICAgICAgICAgIGNvbnN0IGRhdGVWYWx1ZSA9IHNvdXJjZTtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKGRhdGVWYWx1ZS5nZXRUaW1lKCkpO1xyXG4gICAgICAgIGNhc2UgT2JqZWN0OlxyXG4gICAgICAgICAgICBpZiAodGFyZ2V0ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIHRhcmdldCA9IHt9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgQXJyYXk6XHJcbiAgICAgICAgICAgIC8vIEFsd2F5cyBjb3B5IHRoZSBhcnJheSBzb3VyY2UgYW5kIG92ZXJ3cml0ZSB0aGUgdGFyZ2V0LlxyXG4gICAgICAgICAgICB0YXJnZXQgPSBbXTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgLy8gTm90IGEgcGxhaW4gT2JqZWN0IC0gdHJlYXQgaXQgYXMgYSBzY2FsYXIuXHJcbiAgICAgICAgICAgIHJldHVybiBzb3VyY2U7XHJcbiAgICB9XHJcbiAgICBmb3IgKGNvbnN0IHByb3AgaW4gc291cmNlKSB7XHJcbiAgICAgICAgLy8gdXNlIGlzVmFsaWRLZXkgdG8gZ3VhcmQgYWdhaW5zdCBwcm90b3R5cGUgcG9sbHV0aW9uLiBTZWUgaHR0cHM6Ly9zbnlrLmlvL3Z1bG4vU05ZSy1KUy1MT0RBU0gtNDUwMjAyXHJcbiAgICAgICAgaWYgKCFzb3VyY2UuaGFzT3duUHJvcGVydHkocHJvcCkgfHwgIWlzVmFsaWRLZXkocHJvcCkpIHtcclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRhcmdldFtwcm9wXSA9IGRlZXBFeHRlbmQodGFyZ2V0W3Byb3BdLCBzb3VyY2VbcHJvcF0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRhcmdldDtcclxufVxyXG5mdW5jdGlvbiBpc1ZhbGlkS2V5KGtleSkge1xyXG4gICAgcmV0dXJuIGtleSAhPT0gJ19fcHJvdG9fXyc7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuY2xhc3MgRGVmZXJyZWQge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5yZWplY3QgPSAoKSA9PiB7IH07XHJcbiAgICAgICAgdGhpcy5yZXNvbHZlID0gKCkgPT4geyB9O1xyXG4gICAgICAgIHRoaXMucHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5yZXNvbHZlID0gcmVzb2x2ZTtcclxuICAgICAgICAgICAgdGhpcy5yZWplY3QgPSByZWplY3Q7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIE91ciBBUEkgaW50ZXJuYWxzIGFyZSBub3QgcHJvbWlzZWlmaWVkIGFuZCBjYW5ub3QgYmVjYXVzZSBvdXIgY2FsbGJhY2sgQVBJcyBoYXZlIHN1YnRsZSBleHBlY3RhdGlvbnMgYXJvdW5kXHJcbiAgICAgKiBpbnZva2luZyBwcm9taXNlcyBpbmxpbmUsIHdoaWNoIFByb21pc2VzIGFyZSBmb3JiaWRkZW4gdG8gZG8uIFRoaXMgbWV0aG9kIGFjY2VwdHMgYW4gb3B0aW9uYWwgbm9kZS1zdHlsZSBjYWxsYmFja1xyXG4gICAgICogYW5kIHJldHVybnMgYSBub2RlLXN0eWxlIGNhbGxiYWNrIHdoaWNoIHdpbGwgcmVzb2x2ZSBvciByZWplY3QgdGhlIERlZmVycmVkJ3MgcHJvbWlzZS5cclxuICAgICAqL1xyXG4gICAgd3JhcENhbGxiYWNrKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgcmV0dXJuIChlcnJvciwgdmFsdWUpID0+IHtcclxuICAgICAgICAgICAgaWYgKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlamVjdChlcnJvcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlc29sdmUodmFsdWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgICAgIC8vIEF0dGFjaGluZyBub29wIGhhbmRsZXIganVzdCBpbiBjYXNlIGRldmVsb3BlciB3YXNuJ3QgZXhwZWN0aW5nXHJcbiAgICAgICAgICAgICAgICAvLyBwcm9taXNlc1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wcm9taXNlLmNhdGNoKCgpID0+IHsgfSk7XHJcbiAgICAgICAgICAgICAgICAvLyBTb21lIG9mIG91ciBjYWxsYmFja3MgZG9uJ3QgZXhwZWN0IGEgdmFsdWUgYW5kIG91ciBvd24gdGVzdHNcclxuICAgICAgICAgICAgICAgIC8vIGFzc2VydCB0aGF0IHRoZSBwYXJhbWV0ZXIgbGVuZ3RoIGlzIDFcclxuICAgICAgICAgICAgICAgIGlmIChjYWxsYmFjay5sZW5ndGggPT09IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnJvcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnJvciwgdmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjEgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5mdW5jdGlvbiBjcmVhdGVNb2NrVXNlclRva2VuKHRva2VuLCBwcm9qZWN0SWQpIHtcclxuICAgIGlmICh0b2tlbi51aWQpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBcInVpZFwiIGZpZWxkIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQgYnkgbW9ja1VzZXJUb2tlbi4gUGxlYXNlIHVzZSBcInN1YlwiIGluc3RlYWQgZm9yIEZpcmViYXNlIEF1dGggVXNlciBJRC4nKTtcclxuICAgIH1cclxuICAgIC8vIFVuc2VjdXJlZCBKV1RzIHVzZSBcIm5vbmVcIiBhcyB0aGUgYWxnb3JpdGhtLlxyXG4gICAgY29uc3QgaGVhZGVyID0ge1xyXG4gICAgICAgIGFsZzogJ25vbmUnLFxyXG4gICAgICAgIHR5cGU6ICdKV1QnXHJcbiAgICB9O1xyXG4gICAgY29uc3QgcHJvamVjdCA9IHByb2plY3RJZCB8fCAnZGVtby1wcm9qZWN0JztcclxuICAgIGNvbnN0IGlhdCA9IHRva2VuLmlhdCB8fCAwO1xyXG4gICAgY29uc3Qgc3ViID0gdG9rZW4uc3ViIHx8IHRva2VuLnVzZXJfaWQ7XHJcbiAgICBpZiAoIXN1Yikge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIm1vY2tVc2VyVG9rZW4gbXVzdCBjb250YWluICdzdWInIG9yICd1c2VyX2lkJyBmaWVsZCFcIik7XHJcbiAgICB9XHJcbiAgICBjb25zdCBwYXlsb2FkID0gT2JqZWN0LmFzc2lnbih7IFxyXG4gICAgICAgIC8vIFNldCBhbGwgcmVxdWlyZWQgZmllbGRzIHRvIGRlY2VudCBkZWZhdWx0c1xyXG4gICAgICAgIGlzczogYGh0dHBzOi8vc2VjdXJldG9rZW4uZ29vZ2xlLmNvbS8ke3Byb2plY3R9YCwgYXVkOiBwcm9qZWN0LCBpYXQsIGV4cDogaWF0ICsgMzYwMCwgYXV0aF90aW1lOiBpYXQsIHN1YiwgdXNlcl9pZDogc3ViLCBmaXJlYmFzZToge1xyXG4gICAgICAgICAgICBzaWduX2luX3Byb3ZpZGVyOiAnY3VzdG9tJyxcclxuICAgICAgICAgICAgaWRlbnRpdGllczoge31cclxuICAgICAgICB9IH0sIHRva2VuKTtcclxuICAgIC8vIFVuc2VjdXJlZCBKV1RzIHVzZSB0aGUgZW1wdHkgc3RyaW5nIGFzIGEgc2lnbmF0dXJlLlxyXG4gICAgY29uc3Qgc2lnbmF0dXJlID0gJyc7XHJcbiAgICByZXR1cm4gW1xyXG4gICAgICAgIGJhc2U2NHVybEVuY29kZVdpdGhvdXRQYWRkaW5nKEpTT04uc3RyaW5naWZ5KGhlYWRlcikpLFxyXG4gICAgICAgIGJhc2U2NHVybEVuY29kZVdpdGhvdXRQYWRkaW5nKEpTT04uc3RyaW5naWZ5KHBheWxvYWQpKSxcclxuICAgICAgICBzaWduYXR1cmVcclxuICAgIF0uam9pbignLicpO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBSZXR1cm5zIG5hdmlnYXRvci51c2VyQWdlbnQgc3RyaW5nIG9yICcnIGlmIGl0J3Mgbm90IGRlZmluZWQuXHJcbiAqIEByZXR1cm4gdXNlciBhZ2VudCBzdHJpbmdcclxuICovXHJcbmZ1bmN0aW9uIGdldFVBKCkge1xyXG4gICAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmXHJcbiAgICAgICAgdHlwZW9mIG5hdmlnYXRvclsndXNlckFnZW50J10gPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgcmV0dXJuIG5hdmlnYXRvclsndXNlckFnZW50J107XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gJyc7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIERldGVjdCBDb3Jkb3ZhIC8gUGhvbmVHYXAgLyBJb25pYyBmcmFtZXdvcmtzIG9uIGEgbW9iaWxlIGRldmljZS5cclxuICpcclxuICogRGVsaWJlcmF0ZWx5IGRvZXMgbm90IHJlbHkgb24gY2hlY2tpbmcgYGZpbGU6Ly9gIFVSTHMgKGFzIHRoaXMgZmFpbHMgUGhvbmVHYXBcclxuICogaW4gdGhlIFJpcHBsZSBlbXVsYXRvcikgbm9yIENvcmRvdmEgYG9uRGV2aWNlUmVhZHlgLCB3aGljaCB3b3VsZCBub3JtYWxseVxyXG4gKiB3YWl0IGZvciBhIGNhbGxiYWNrLlxyXG4gKi9cclxuZnVuY3Rpb24gaXNNb2JpbGVDb3Jkb3ZhKCkge1xyXG4gICAgcmV0dXJuICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJlxyXG4gICAgICAgIC8vIEB0cy1pZ25vcmUgU2V0dGluZyB1cCBhbiBicm9hZGx5IGFwcGxpY2FibGUgaW5kZXggc2lnbmF0dXJlIGZvciBXaW5kb3dcclxuICAgICAgICAvLyBqdXN0IHRvIGRlYWwgd2l0aCB0aGlzIGNhc2Ugd291bGQgcHJvYmFibHkgYmUgYSBiYWQgaWRlYS5cclxuICAgICAgICAhISh3aW5kb3dbJ2NvcmRvdmEnXSB8fCB3aW5kb3dbJ3Bob25lZ2FwJ10gfHwgd2luZG93WydQaG9uZUdhcCddKSAmJlxyXG4gICAgICAgIC9pb3N8aXBob25lfGlwb2R8aXBhZHxhbmRyb2lkfGJsYWNrYmVycnl8aWVtb2JpbGUvaS50ZXN0KGdldFVBKCkpKTtcclxufVxyXG4vKipcclxuICogRGV0ZWN0IE5vZGUuanMuXHJcbiAqXHJcbiAqIEByZXR1cm4gdHJ1ZSBpZiBOb2RlLmpzIGVudmlyb25tZW50IGlzIGRldGVjdGVkLlxyXG4gKi9cclxuLy8gTm9kZSBkZXRlY3Rpb24gbG9naWMgZnJvbTogaHR0cHM6Ly9naXRodWIuY29tL2lsaWFrYW4vZGV0ZWN0LW5vZGUvXHJcbmZ1bmN0aW9uIGlzTm9kZSgpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgcmV0dXJuIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZ2xvYmFsLnByb2Nlc3MpID09PSAnW29iamVjdCBwcm9jZXNzXScpO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIERldGVjdCBCcm93c2VyIEVudmlyb25tZW50XHJcbiAqL1xyXG5mdW5jdGlvbiBpc0Jyb3dzZXIoKSB7XHJcbiAgICByZXR1cm4gdHlwZW9mIHNlbGYgPT09ICdvYmplY3QnICYmIHNlbGYuc2VsZiA9PT0gc2VsZjtcclxufVxyXG5mdW5jdGlvbiBpc0Jyb3dzZXJFeHRlbnNpb24oKSB7XHJcbiAgICBjb25zdCBydW50aW1lID0gdHlwZW9mIGNocm9tZSA9PT0gJ29iamVjdCdcclxuICAgICAgICA/IGNocm9tZS5ydW50aW1lXHJcbiAgICAgICAgOiB0eXBlb2YgYnJvd3NlciA9PT0gJ29iamVjdCdcclxuICAgICAgICAgICAgPyBicm93c2VyLnJ1bnRpbWVcclxuICAgICAgICAgICAgOiB1bmRlZmluZWQ7XHJcbiAgICByZXR1cm4gdHlwZW9mIHJ1bnRpbWUgPT09ICdvYmplY3QnICYmIHJ1bnRpbWUuaWQgIT09IHVuZGVmaW5lZDtcclxufVxyXG4vKipcclxuICogRGV0ZWN0IFJlYWN0IE5hdGl2ZS5cclxuICpcclxuICogQHJldHVybiB0cnVlIGlmIFJlYWN0TmF0aXZlIGVudmlyb25tZW50IGlzIGRldGVjdGVkLlxyXG4gKi9cclxuZnVuY3Rpb24gaXNSZWFjdE5hdGl2ZSgpIHtcclxuICAgIHJldHVybiAodHlwZW9mIG5hdmlnYXRvciA9PT0gJ29iamVjdCcgJiYgbmF2aWdhdG9yWydwcm9kdWN0J10gPT09ICdSZWFjdE5hdGl2ZScpO1xyXG59XHJcbi8qKiBEZXRlY3RzIEVsZWN0cm9uIGFwcHMuICovXHJcbmZ1bmN0aW9uIGlzRWxlY3Ryb24oKSB7XHJcbiAgICByZXR1cm4gZ2V0VUEoKS5pbmRleE9mKCdFbGVjdHJvbi8nKSA+PSAwO1xyXG59XHJcbi8qKiBEZXRlY3RzIEludGVybmV0IEV4cGxvcmVyLiAqL1xyXG5mdW5jdGlvbiBpc0lFKCkge1xyXG4gICAgY29uc3QgdWEgPSBnZXRVQSgpO1xyXG4gICAgcmV0dXJuIHVhLmluZGV4T2YoJ01TSUUgJykgPj0gMCB8fCB1YS5pbmRleE9mKCdUcmlkZW50LycpID49IDA7XHJcbn1cclxuLyoqIERldGVjdHMgVW5pdmVyc2FsIFdpbmRvd3MgUGxhdGZvcm0gYXBwcy4gKi9cclxuZnVuY3Rpb24gaXNVV1AoKSB7XHJcbiAgICByZXR1cm4gZ2V0VUEoKS5pbmRleE9mKCdNU0FwcEhvc3QvJykgPj0gMDtcclxufVxyXG4vKipcclxuICogRGV0ZWN0IHdoZXRoZXIgdGhlIGN1cnJlbnQgU0RLIGJ1aWxkIGlzIHRoZSBOb2RlIHZlcnNpb24uXHJcbiAqXHJcbiAqIEByZXR1cm4gdHJ1ZSBpZiBpdCdzIHRoZSBOb2RlIFNESyBidWlsZC5cclxuICovXHJcbmZ1bmN0aW9uIGlzTm9kZVNkaygpIHtcclxuICAgIHJldHVybiBDT05TVEFOVFMuTk9ERV9DTElFTlQgPT09IHRydWUgfHwgQ09OU1RBTlRTLk5PREVfQURNSU4gPT09IHRydWU7XHJcbn1cclxuLyoqIFJldHVybnMgdHJ1ZSBpZiB3ZSBhcmUgcnVubmluZyBpbiBTYWZhcmkuICovXHJcbmZ1bmN0aW9uIGlzU2FmYXJpKCkge1xyXG4gICAgcmV0dXJuICghaXNOb2RlKCkgJiZcclxuICAgICAgICBuYXZpZ2F0b3IudXNlckFnZW50LmluY2x1ZGVzKCdTYWZhcmknKSAmJlxyXG4gICAgICAgICFuYXZpZ2F0b3IudXNlckFnZW50LmluY2x1ZGVzKCdDaHJvbWUnKSk7XHJcbn1cclxuLyoqXHJcbiAqIFRoaXMgbWV0aG9kIGNoZWNrcyBpZiBpbmRleGVkREIgaXMgc3VwcG9ydGVkIGJ5IGN1cnJlbnQgYnJvd3Nlci9zZXJ2aWNlIHdvcmtlciBjb250ZXh0XHJcbiAqIEByZXR1cm4gdHJ1ZSBpZiBpbmRleGVkREIgaXMgc3VwcG9ydGVkIGJ5IGN1cnJlbnQgYnJvd3Nlci9zZXJ2aWNlIHdvcmtlciBjb250ZXh0XHJcbiAqL1xyXG5mdW5jdGlvbiBpc0luZGV4ZWREQkF2YWlsYWJsZSgpIHtcclxuICAgIHJldHVybiB0eXBlb2YgaW5kZXhlZERCID09PSAnb2JqZWN0JztcclxufVxyXG4vKipcclxuICogVGhpcyBtZXRob2QgdmFsaWRhdGVzIGJyb3dzZXIvc3cgY29udGV4dCBmb3IgaW5kZXhlZERCIGJ5IG9wZW5pbmcgYSBkdW1teSBpbmRleGVkREIgZGF0YWJhc2UgYW5kIHJlamVjdFxyXG4gKiBpZiBlcnJvcnMgb2NjdXIgZHVyaW5nIHRoZSBkYXRhYmFzZSBvcGVuIG9wZXJhdGlvbi5cclxuICpcclxuICogQHRocm93cyBleGNlcHRpb24gaWYgY3VycmVudCBicm93c2VyL3N3IGNvbnRleHQgY2FuJ3QgcnVuIGlkYi5vcGVuIChleDogU2FmYXJpIGlmcmFtZSwgRmlyZWZveFxyXG4gKiBwcml2YXRlIGJyb3dzaW5nKVxyXG4gKi9cclxuZnVuY3Rpb24gdmFsaWRhdGVJbmRleGVkREJPcGVuYWJsZSgpIHtcclxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgbGV0IHByZUV4aXN0ID0gdHJ1ZTtcclxuICAgICAgICAgICAgY29uc3QgREJfQ0hFQ0tfTkFNRSA9ICd2YWxpZGF0ZS1icm93c2VyLWNvbnRleHQtZm9yLWluZGV4ZWRkYi1hbmFseXRpY3MtbW9kdWxlJztcclxuICAgICAgICAgICAgY29uc3QgcmVxdWVzdCA9IHNlbGYuaW5kZXhlZERCLm9wZW4oREJfQ0hFQ0tfTkFNRSk7XHJcbiAgICAgICAgICAgIHJlcXVlc3Qub25zdWNjZXNzID0gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmVxdWVzdC5yZXN1bHQuY2xvc2UoKTtcclxuICAgICAgICAgICAgICAgIC8vIGRlbGV0ZSBkYXRhYmFzZSBvbmx5IHdoZW4gaXQgZG9lc24ndCBwcmUtZXhpc3RcclxuICAgICAgICAgICAgICAgIGlmICghcHJlRXhpc3QpIHtcclxuICAgICAgICAgICAgICAgICAgICBzZWxmLmluZGV4ZWREQi5kZWxldGVEYXRhYmFzZShEQl9DSEVDS19OQU1FKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJlc29sdmUodHJ1ZSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHJlcXVlc3Qub251cGdyYWRlbmVlZGVkID0gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgcHJlRXhpc3QgPSBmYWxzZTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgcmVxdWVzdC5vbmVycm9yID0gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgICAgICAgICAgcmVqZWN0KCgoX2EgPSByZXF1ZXN0LmVycm9yKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubWVzc2FnZSkgfHwgJycpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxufVxyXG4vKipcclxuICpcclxuICogVGhpcyBtZXRob2QgY2hlY2tzIHdoZXRoZXIgY29va2llIGlzIGVuYWJsZWQgd2l0aGluIGN1cnJlbnQgYnJvd3NlclxyXG4gKiBAcmV0dXJuIHRydWUgaWYgY29va2llIGlzIGVuYWJsZWQgd2l0aGluIGN1cnJlbnQgYnJvd3NlclxyXG4gKi9cclxuZnVuY3Rpb24gYXJlQ29va2llc0VuYWJsZWQoKSB7XHJcbiAgICBpZiAodHlwZW9mIG5hdmlnYXRvciA9PT0gJ3VuZGVmaW5lZCcgfHwgIW5hdmlnYXRvci5jb29raWVFbmFibGVkKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbn1cclxuLyoqXHJcbiAqIFBvbHlmaWxsIGZvciBgZ2xvYmFsVGhpc2Agb2JqZWN0LlxyXG4gKiBAcmV0dXJucyB0aGUgYGdsb2JhbFRoaXNgIG9iamVjdCBmb3IgdGhlIGdpdmVuIGVudmlyb25tZW50LlxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0R2xvYmFsKCkge1xyXG4gICAgaWYgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgIHJldHVybiBzZWxmO1xyXG4gICAgfVxyXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgcmV0dXJuIHdpbmRvdztcclxuICAgIH1cclxuICAgIGlmICh0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgIHJldHVybiBnbG9iYWw7XHJcbiAgICB9XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBsb2NhdGUgZ2xvYmFsIG9iamVjdC4nKTtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogQGZpbGVvdmVydmlldyBTdGFuZGFyZGl6ZWQgRmlyZWJhc2UgRXJyb3IuXHJcbiAqXHJcbiAqIFVzYWdlOlxyXG4gKlxyXG4gKiAgIC8vIFR5cGVzY3JpcHQgc3RyaW5nIGxpdGVyYWxzIGZvciB0eXBlLXNhZmUgY29kZXNcclxuICogICB0eXBlIEVyciA9XHJcbiAqICAgICAndW5rbm93bicgfFxyXG4gKiAgICAgJ29iamVjdC1ub3QtZm91bmQnXHJcbiAqICAgICA7XHJcbiAqXHJcbiAqICAgLy8gQ2xvc3VyZSBlbnVtIGZvciB0eXBlLXNhZmUgZXJyb3IgY29kZXNcclxuICogICAvLyBhdC1lbnVtIHtzdHJpbmd9XHJcbiAqICAgdmFyIEVyciA9IHtcclxuICogICAgIFVOS05PV046ICd1bmtub3duJyxcclxuICogICAgIE9CSkVDVF9OT1RfRk9VTkQ6ICdvYmplY3Qtbm90LWZvdW5kJyxcclxuICogICB9XHJcbiAqXHJcbiAqICAgbGV0IGVycm9yczogTWFwPEVyciwgc3RyaW5nPiA9IHtcclxuICogICAgICdnZW5lcmljLWVycm9yJzogXCJVbmtub3duIGVycm9yXCIsXHJcbiAqICAgICAnZmlsZS1ub3QtZm91bmQnOiBcIkNvdWxkIG5vdCBmaW5kIGZpbGU6IHskZmlsZX1cIixcclxuICogICB9O1xyXG4gKlxyXG4gKiAgIC8vIFR5cGUtc2FmZSBmdW5jdGlvbiAtIG11c3QgcGFzcyBhIHZhbGlkIGVycm9yIGNvZGUgYXMgcGFyYW0uXHJcbiAqICAgbGV0IGVycm9yID0gbmV3IEVycm9yRmFjdG9yeTxFcnI+KCdzZXJ2aWNlJywgJ1NlcnZpY2UnLCBlcnJvcnMpO1xyXG4gKlxyXG4gKiAgIC4uLlxyXG4gKiAgIHRocm93IGVycm9yLmNyZWF0ZShFcnIuR0VORVJJQyk7XHJcbiAqICAgLi4uXHJcbiAqICAgdGhyb3cgZXJyb3IuY3JlYXRlKEVyci5GSUxFX05PVF9GT1VORCwgeydmaWxlJzogZmlsZU5hbWV9KTtcclxuICogICAuLi5cclxuICogICAvLyBTZXJ2aWNlOiBDb3VsZCBub3QgZmlsZSBmaWxlOiBmb28udHh0IChzZXJ2aWNlL2ZpbGUtbm90LWZvdW5kKS5cclxuICpcclxuICogICBjYXRjaCAoZSkge1xyXG4gKiAgICAgYXNzZXJ0KGUubWVzc2FnZSA9PT0gXCJDb3VsZCBub3QgZmluZCBmaWxlOiBmb28udHh0LlwiKTtcclxuICogICAgIGlmIChlLmNvZGUgPT09ICdzZXJ2aWNlL2ZpbGUtbm90LWZvdW5kJykge1xyXG4gKiAgICAgICBjb25zb2xlLmxvZyhcIkNvdWxkIG5vdCByZWFkIGZpbGU6IFwiICsgZVsnZmlsZSddKTtcclxuICogICAgIH1cclxuICogICB9XHJcbiAqL1xyXG5jb25zdCBFUlJPUl9OQU1FID0gJ0ZpcmViYXNlRXJyb3InO1xyXG4vLyBCYXNlZCBvbiBjb2RlIGZyb206XHJcbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0Vycm9yI0N1c3RvbV9FcnJvcl9UeXBlc1xyXG5jbGFzcyBGaXJlYmFzZUVycm9yIGV4dGVuZHMgRXJyb3Ige1xyXG4gICAgY29uc3RydWN0b3IoXHJcbiAgICAvKiogVGhlIGVycm9yIGNvZGUgZm9yIHRoaXMgZXJyb3IuICovXHJcbiAgICBjb2RlLCBtZXNzYWdlLCBcclxuICAgIC8qKiBDdXN0b20gZGF0YSBmb3IgdGhpcyBlcnJvci4gKi9cclxuICAgIGN1c3RvbURhdGEpIHtcclxuICAgICAgICBzdXBlcihtZXNzYWdlKTtcclxuICAgICAgICB0aGlzLmNvZGUgPSBjb2RlO1xyXG4gICAgICAgIHRoaXMuY3VzdG9tRGF0YSA9IGN1c3RvbURhdGE7XHJcbiAgICAgICAgLyoqIFRoZSBjdXN0b20gbmFtZSBmb3IgYWxsIEZpcmViYXNlRXJyb3JzLiAqL1xyXG4gICAgICAgIHRoaXMubmFtZSA9IEVSUk9SX05BTUU7XHJcbiAgICAgICAgLy8gRml4IEZvciBFUzVcclxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vTWljcm9zb2Z0L1R5cGVTY3JpcHQtd2lraS9ibG9iL21hc3Rlci9CcmVha2luZy1DaGFuZ2VzLm1kI2V4dGVuZGluZy1idWlsdC1pbnMtbGlrZS1lcnJvci1hcnJheS1hbmQtbWFwLW1heS1uby1sb25nZXItd29ya1xyXG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBGaXJlYmFzZUVycm9yLnByb3RvdHlwZSk7XHJcbiAgICAgICAgLy8gTWFpbnRhaW5zIHByb3BlciBzdGFjayB0cmFjZSBmb3Igd2hlcmUgb3VyIGVycm9yIHdhcyB0aHJvd24uXHJcbiAgICAgICAgLy8gT25seSBhdmFpbGFibGUgb24gVjguXHJcbiAgICAgICAgaWYgKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKSB7XHJcbiAgICAgICAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIEVycm9yRmFjdG9yeS5wcm90b3R5cGUuY3JlYXRlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuY2xhc3MgRXJyb3JGYWN0b3J5IHtcclxuICAgIGNvbnN0cnVjdG9yKHNlcnZpY2UsIHNlcnZpY2VOYW1lLCBlcnJvcnMpIHtcclxuICAgICAgICB0aGlzLnNlcnZpY2UgPSBzZXJ2aWNlO1xyXG4gICAgICAgIHRoaXMuc2VydmljZU5hbWUgPSBzZXJ2aWNlTmFtZTtcclxuICAgICAgICB0aGlzLmVycm9ycyA9IGVycm9ycztcclxuICAgIH1cclxuICAgIGNyZWF0ZShjb2RlLCAuLi5kYXRhKSB7XHJcbiAgICAgICAgY29uc3QgY3VzdG9tRGF0YSA9IGRhdGFbMF0gfHwge307XHJcbiAgICAgICAgY29uc3QgZnVsbENvZGUgPSBgJHt0aGlzLnNlcnZpY2V9LyR7Y29kZX1gO1xyXG4gICAgICAgIGNvbnN0IHRlbXBsYXRlID0gdGhpcy5lcnJvcnNbY29kZV07XHJcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IHRlbXBsYXRlID8gcmVwbGFjZVRlbXBsYXRlKHRlbXBsYXRlLCBjdXN0b21EYXRhKSA6ICdFcnJvcic7XHJcbiAgICAgICAgLy8gU2VydmljZSBOYW1lOiBFcnJvciBtZXNzYWdlIChzZXJ2aWNlL2NvZGUpLlxyXG4gICAgICAgIGNvbnN0IGZ1bGxNZXNzYWdlID0gYCR7dGhpcy5zZXJ2aWNlTmFtZX06ICR7bWVzc2FnZX0gKCR7ZnVsbENvZGV9KS5gO1xyXG4gICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEZpcmViYXNlRXJyb3IoZnVsbENvZGUsIGZ1bGxNZXNzYWdlLCBjdXN0b21EYXRhKTtcclxuICAgICAgICByZXR1cm4gZXJyb3I7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gcmVwbGFjZVRlbXBsYXRlKHRlbXBsYXRlLCBkYXRhKSB7XHJcbiAgICByZXR1cm4gdGVtcGxhdGUucmVwbGFjZShQQVRURVJOLCAoXywga2V5KSA9PiB7XHJcbiAgICAgICAgY29uc3QgdmFsdWUgPSBkYXRhW2tleV07XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlICE9IG51bGwgPyBTdHJpbmcodmFsdWUpIDogYDwke2tleX0/PmA7XHJcbiAgICB9KTtcclxufVxyXG5jb25zdCBQQVRURVJOID0gL1xce1xcJChbXn1dKyl9L2c7XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBFdmFsdWF0ZXMgYSBKU09OIHN0cmluZyBpbnRvIGEgamF2YXNjcmlwdCBvYmplY3QuXHJcbiAqXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgQSBzdHJpbmcgY29udGFpbmluZyBKU09OLlxyXG4gKiBAcmV0dXJuIHsqfSBUaGUgamF2YXNjcmlwdCBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBzcGVjaWZpZWQgSlNPTi5cclxuICovXHJcbmZ1bmN0aW9uIGpzb25FdmFsKHN0cikge1xyXG4gICAgcmV0dXJuIEpTT04ucGFyc2Uoc3RyKTtcclxufVxyXG4vKipcclxuICogUmV0dXJucyBKU09OIHJlcHJlc2VudGluZyBhIGphdmFzY3JpcHQgb2JqZWN0LlxyXG4gKiBAcGFyYW0geyp9IGRhdGEgSmF2YXNjcmlwdCBvYmplY3QgdG8gYmUgc3RyaW5naWZpZWQuXHJcbiAqIEByZXR1cm4ge3N0cmluZ30gVGhlIEpTT04gY29udGVudHMgb2YgdGhlIG9iamVjdC5cclxuICovXHJcbmZ1bmN0aW9uIHN0cmluZ2lmeShkYXRhKSB7XHJcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoZGF0YSk7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIERlY29kZXMgYSBGaXJlYmFzZSBhdXRoLiB0b2tlbiBpbnRvIGNvbnN0aXR1ZW50IHBhcnRzLlxyXG4gKlxyXG4gKiBOb3RlczpcclxuICogLSBNYXkgcmV0dXJuIHdpdGggaW52YWxpZCAvIGluY29tcGxldGUgY2xhaW1zIGlmIHRoZXJlJ3Mgbm8gbmF0aXZlIGJhc2U2NCBkZWNvZGluZyBzdXBwb3J0LlxyXG4gKiAtIERvZXNuJ3QgY2hlY2sgaWYgdGhlIHRva2VuIGlzIGFjdHVhbGx5IHZhbGlkLlxyXG4gKi9cclxuY29uc3QgZGVjb2RlID0gZnVuY3Rpb24gKHRva2VuKSB7XHJcbiAgICBsZXQgaGVhZGVyID0ge30sIGNsYWltcyA9IHt9LCBkYXRhID0ge30sIHNpZ25hdHVyZSA9ICcnO1xyXG4gICAgdHJ5IHtcclxuICAgICAgICBjb25zdCBwYXJ0cyA9IHRva2VuLnNwbGl0KCcuJyk7XHJcbiAgICAgICAgaGVhZGVyID0ganNvbkV2YWwoYmFzZTY0RGVjb2RlKHBhcnRzWzBdKSB8fCAnJyk7XHJcbiAgICAgICAgY2xhaW1zID0ganNvbkV2YWwoYmFzZTY0RGVjb2RlKHBhcnRzWzFdKSB8fCAnJyk7XHJcbiAgICAgICAgc2lnbmF0dXJlID0gcGFydHNbMl07XHJcbiAgICAgICAgZGF0YSA9IGNsYWltc1snZCddIHx8IHt9O1xyXG4gICAgICAgIGRlbGV0ZSBjbGFpbXNbJ2QnXTtcclxuICAgIH1cclxuICAgIGNhdGNoIChlKSB7IH1cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgaGVhZGVyLFxyXG4gICAgICAgIGNsYWltcyxcclxuICAgICAgICBkYXRhLFxyXG4gICAgICAgIHNpZ25hdHVyZVxyXG4gICAgfTtcclxufTtcclxuLyoqXHJcbiAqIERlY29kZXMgYSBGaXJlYmFzZSBhdXRoLiB0b2tlbiBhbmQgY2hlY2tzIHRoZSB2YWxpZGl0eSBvZiBpdHMgdGltZS1iYXNlZCBjbGFpbXMuIFdpbGwgcmV0dXJuIHRydWUgaWYgdGhlXHJcbiAqIHRva2VuIGlzIHdpdGhpbiB0aGUgdGltZSB3aW5kb3cgYXV0aG9yaXplZCBieSB0aGUgJ25iZicgKG5vdC1iZWZvcmUpIGFuZCAnaWF0JyAoaXNzdWVkLWF0KSBjbGFpbXMuXHJcbiAqXHJcbiAqIE5vdGVzOlxyXG4gKiAtIE1heSByZXR1cm4gYSBmYWxzZSBuZWdhdGl2ZSBpZiB0aGVyZSdzIG5vIG5hdGl2ZSBiYXNlNjQgZGVjb2Rpbmcgc3VwcG9ydC5cclxuICogLSBEb2Vzbid0IGNoZWNrIGlmIHRoZSB0b2tlbiBpcyBhY3R1YWxseSB2YWxpZC5cclxuICovXHJcbmNvbnN0IGlzVmFsaWRUaW1lc3RhbXAgPSBmdW5jdGlvbiAodG9rZW4pIHtcclxuICAgIGNvbnN0IGNsYWltcyA9IGRlY29kZSh0b2tlbikuY2xhaW1zO1xyXG4gICAgY29uc3Qgbm93ID0gTWF0aC5mbG9vcihuZXcgRGF0ZSgpLmdldFRpbWUoKSAvIDEwMDApO1xyXG4gICAgbGV0IHZhbGlkU2luY2UgPSAwLCB2YWxpZFVudGlsID0gMDtcclxuICAgIGlmICh0eXBlb2YgY2xhaW1zID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgIGlmIChjbGFpbXMuaGFzT3duUHJvcGVydHkoJ25iZicpKSB7XHJcbiAgICAgICAgICAgIHZhbGlkU2luY2UgPSBjbGFpbXNbJ25iZiddO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChjbGFpbXMuaGFzT3duUHJvcGVydHkoJ2lhdCcpKSB7XHJcbiAgICAgICAgICAgIHZhbGlkU2luY2UgPSBjbGFpbXNbJ2lhdCddO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY2xhaW1zLmhhc093blByb3BlcnR5KCdleHAnKSkge1xyXG4gICAgICAgICAgICB2YWxpZFVudGlsID0gY2xhaW1zWydleHAnXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIHRva2VuIHdpbGwgZXhwaXJlIGFmdGVyIDI0aCBieSBkZWZhdWx0XHJcbiAgICAgICAgICAgIHZhbGlkVW50aWwgPSB2YWxpZFNpbmNlICsgODY0MDA7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuICghIW5vdyAmJlxyXG4gICAgICAgICEhdmFsaWRTaW5jZSAmJlxyXG4gICAgICAgICEhdmFsaWRVbnRpbCAmJlxyXG4gICAgICAgIG5vdyA+PSB2YWxpZFNpbmNlICYmXHJcbiAgICAgICAgbm93IDw9IHZhbGlkVW50aWwpO1xyXG59O1xyXG4vKipcclxuICogRGVjb2RlcyBhIEZpcmViYXNlIGF1dGguIHRva2VuIGFuZCByZXR1cm5zIGl0cyBpc3N1ZWQgYXQgdGltZSBpZiB2YWxpZCwgbnVsbCBvdGhlcndpc2UuXHJcbiAqXHJcbiAqIE5vdGVzOlxyXG4gKiAtIE1heSByZXR1cm4gbnVsbCBpZiB0aGVyZSdzIG5vIG5hdGl2ZSBiYXNlNjQgZGVjb2Rpbmcgc3VwcG9ydC5cclxuICogLSBEb2Vzbid0IGNoZWNrIGlmIHRoZSB0b2tlbiBpcyBhY3R1YWxseSB2YWxpZC5cclxuICovXHJcbmNvbnN0IGlzc3VlZEF0VGltZSA9IGZ1bmN0aW9uICh0b2tlbikge1xyXG4gICAgY29uc3QgY2xhaW1zID0gZGVjb2RlKHRva2VuKS5jbGFpbXM7XHJcbiAgICBpZiAodHlwZW9mIGNsYWltcyA9PT0gJ29iamVjdCcgJiYgY2xhaW1zLmhhc093blByb3BlcnR5KCdpYXQnKSkge1xyXG4gICAgICAgIHJldHVybiBjbGFpbXNbJ2lhdCddO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG51bGw7XHJcbn07XHJcbi8qKlxyXG4gKiBEZWNvZGVzIGEgRmlyZWJhc2UgYXV0aC4gdG9rZW4gYW5kIGNoZWNrcyB0aGUgdmFsaWRpdHkgb2YgaXRzIGZvcm1hdC4gRXhwZWN0cyBhIHZhbGlkIGlzc3VlZC1hdCB0aW1lLlxyXG4gKlxyXG4gKiBOb3RlczpcclxuICogLSBNYXkgcmV0dXJuIGEgZmFsc2UgbmVnYXRpdmUgaWYgdGhlcmUncyBubyBuYXRpdmUgYmFzZTY0IGRlY29kaW5nIHN1cHBvcnQuXHJcbiAqIC0gRG9lc24ndCBjaGVjayBpZiB0aGUgdG9rZW4gaXMgYWN0dWFsbHkgdmFsaWQuXHJcbiAqL1xyXG5jb25zdCBpc1ZhbGlkRm9ybWF0ID0gZnVuY3Rpb24gKHRva2VuKSB7XHJcbiAgICBjb25zdCBkZWNvZGVkID0gZGVjb2RlKHRva2VuKSwgY2xhaW1zID0gZGVjb2RlZC5jbGFpbXM7XHJcbiAgICByZXR1cm4gISFjbGFpbXMgJiYgdHlwZW9mIGNsYWltcyA9PT0gJ29iamVjdCcgJiYgY2xhaW1zLmhhc093blByb3BlcnR5KCdpYXQnKTtcclxufTtcclxuLyoqXHJcbiAqIEF0dGVtcHRzIHRvIHBlZXIgaW50byBhbiBhdXRoIHRva2VuIGFuZCBkZXRlcm1pbmUgaWYgaXQncyBhbiBhZG1pbiBhdXRoIHRva2VuIGJ5IGxvb2tpbmcgYXQgdGhlIGNsYWltcyBwb3J0aW9uLlxyXG4gKlxyXG4gKiBOb3RlczpcclxuICogLSBNYXkgcmV0dXJuIGEgZmFsc2UgbmVnYXRpdmUgaWYgdGhlcmUncyBubyBuYXRpdmUgYmFzZTY0IGRlY29kaW5nIHN1cHBvcnQuXHJcbiAqIC0gRG9lc24ndCBjaGVjayBpZiB0aGUgdG9rZW4gaXMgYWN0dWFsbHkgdmFsaWQuXHJcbiAqL1xyXG5jb25zdCBpc0FkbWluID0gZnVuY3Rpb24gKHRva2VuKSB7XHJcbiAgICBjb25zdCBjbGFpbXMgPSBkZWNvZGUodG9rZW4pLmNsYWltcztcclxuICAgIHJldHVybiB0eXBlb2YgY2xhaW1zID09PSAnb2JqZWN0JyAmJiBjbGFpbXNbJ2FkbWluJ10gPT09IHRydWU7XHJcbn07XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmZ1bmN0aW9uIGNvbnRhaW5zKG9iaiwga2V5KSB7XHJcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KTtcclxufVxyXG5mdW5jdGlvbiBzYWZlR2V0KG9iaiwga2V5KSB7XHJcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkge1xyXG4gICAgICAgIHJldHVybiBvYmpba2V5XTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gaXNFbXB0eShvYmopIHtcclxuICAgIGZvciAoY29uc3Qga2V5IGluIG9iaikge1xyXG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxufVxyXG5mdW5jdGlvbiBtYXAob2JqLCBmbiwgY29udGV4dE9iaikge1xyXG4gICAgY29uc3QgcmVzID0ge307XHJcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBvYmopIHtcclxuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkge1xyXG4gICAgICAgICAgICByZXNba2V5XSA9IGZuLmNhbGwoY29udGV4dE9iaiwgb2JqW2tleV0sIGtleSwgb2JqKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzO1xyXG59XHJcbi8qKlxyXG4gKiBEZWVwIGVxdWFsIHR3byBvYmplY3RzLiBTdXBwb3J0IEFycmF5cyBhbmQgT2JqZWN0cy5cclxuICovXHJcbmZ1bmN0aW9uIGRlZXBFcXVhbChhLCBiKSB7XHJcbiAgICBpZiAoYSA9PT0gYikge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgY29uc3QgYUtleXMgPSBPYmplY3Qua2V5cyhhKTtcclxuICAgIGNvbnN0IGJLZXlzID0gT2JqZWN0LmtleXMoYik7XHJcbiAgICBmb3IgKGNvbnN0IGsgb2YgYUtleXMpIHtcclxuICAgICAgICBpZiAoIWJLZXlzLmluY2x1ZGVzKGspKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgYVByb3AgPSBhW2tdO1xyXG4gICAgICAgIGNvbnN0IGJQcm9wID0gYltrXTtcclxuICAgICAgICBpZiAoaXNPYmplY3QoYVByb3ApICYmIGlzT2JqZWN0KGJQcm9wKSkge1xyXG4gICAgICAgICAgICBpZiAoIWRlZXBFcXVhbChhUHJvcCwgYlByb3ApKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoYVByb3AgIT09IGJQcm9wKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmb3IgKGNvbnN0IGsgb2YgYktleXMpIHtcclxuICAgICAgICBpZiAoIWFLZXlzLmluY2x1ZGVzKGspKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxufVxyXG5mdW5jdGlvbiBpc09iamVjdCh0aGluZykge1xyXG4gICAgcmV0dXJuIHRoaW5nICE9PSBudWxsICYmIHR5cGVvZiB0aGluZyA9PT0gJ29iamVjdCc7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIFJldHVybnMgYSBxdWVyeXN0cmluZy1mb3JtYXR0ZWQgc3RyaW5nIChlLmcuICZhcmc9dmFsJmFyZzI9dmFsMikgZnJvbSBhXHJcbiAqIHBhcmFtcyBvYmplY3QgKGUuZy4ge2FyZzogJ3ZhbCcsIGFyZzI6ICd2YWwyJ30pXHJcbiAqIE5vdGU6IFlvdSBtdXN0IHByZXBlbmQgaXQgd2l0aCA/IHdoZW4gYWRkaW5nIGl0IHRvIGEgVVJMLlxyXG4gKi9cclxuZnVuY3Rpb24gcXVlcnlzdHJpbmcocXVlcnlzdHJpbmdQYXJhbXMpIHtcclxuICAgIGNvbnN0IHBhcmFtcyA9IFtdO1xyXG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMocXVlcnlzdHJpbmdQYXJhbXMpKSB7XHJcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XHJcbiAgICAgICAgICAgIHZhbHVlLmZvckVhY2goYXJyYXlWYWwgPT4ge1xyXG4gICAgICAgICAgICAgICAgcGFyYW1zLnB1c2goZW5jb2RlVVJJQ29tcG9uZW50KGtleSkgKyAnPScgKyBlbmNvZGVVUklDb21wb25lbnQoYXJyYXlWYWwpKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBwYXJhbXMucHVzaChlbmNvZGVVUklDb21wb25lbnQoa2V5KSArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudCh2YWx1ZSkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBwYXJhbXMubGVuZ3RoID8gJyYnICsgcGFyYW1zLmpvaW4oJyYnKSA6ICcnO1xyXG59XHJcbi8qKlxyXG4gKiBEZWNvZGVzIGEgcXVlcnlzdHJpbmcgKGUuZy4gP2FyZz12YWwmYXJnMj12YWwyKSBpbnRvIGEgcGFyYW1zIG9iamVjdFxyXG4gKiAoZS5nLiB7YXJnOiAndmFsJywgYXJnMjogJ3ZhbDInfSlcclxuICovXHJcbmZ1bmN0aW9uIHF1ZXJ5c3RyaW5nRGVjb2RlKHF1ZXJ5c3RyaW5nKSB7XHJcbiAgICBjb25zdCBvYmogPSB7fTtcclxuICAgIGNvbnN0IHRva2VucyA9IHF1ZXJ5c3RyaW5nLnJlcGxhY2UoL15cXD8vLCAnJykuc3BsaXQoJyYnKTtcclxuICAgIHRva2Vucy5mb3JFYWNoKHRva2VuID0+IHtcclxuICAgICAgICBpZiAodG9rZW4pIHtcclxuICAgICAgICAgICAgY29uc3QgW2tleSwgdmFsdWVdID0gdG9rZW4uc3BsaXQoJz0nKTtcclxuICAgICAgICAgICAgb2JqW2RlY29kZVVSSUNvbXBvbmVudChrZXkpXSA9IGRlY29kZVVSSUNvbXBvbmVudCh2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gb2JqO1xyXG59XHJcbi8qKlxyXG4gKiBFeHRyYWN0IHRoZSBxdWVyeSBzdHJpbmcgcGFydCBvZiBhIFVSTCwgaW5jbHVkaW5nIHRoZSBsZWFkaW5nIHF1ZXN0aW9uIG1hcmsgKGlmIHByZXNlbnQpLlxyXG4gKi9cclxuZnVuY3Rpb24gZXh0cmFjdFF1ZXJ5c3RyaW5nKHVybCkge1xyXG4gICAgY29uc3QgcXVlcnlTdGFydCA9IHVybC5pbmRleE9mKCc/Jyk7XHJcbiAgICBpZiAoIXF1ZXJ5U3RhcnQpIHtcclxuICAgICAgICByZXR1cm4gJyc7XHJcbiAgICB9XHJcbiAgICBjb25zdCBmcmFnbWVudFN0YXJ0ID0gdXJsLmluZGV4T2YoJyMnLCBxdWVyeVN0YXJ0KTtcclxuICAgIHJldHVybiB1cmwuc3Vic3RyaW5nKHF1ZXJ5U3RhcnQsIGZyYWdtZW50U3RhcnQgPiAwID8gZnJhZ21lbnRTdGFydCA6IHVuZGVmaW5lZCk7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIEBmaWxlb3ZlcnZpZXcgU0hBLTEgY3J5cHRvZ3JhcGhpYyBoYXNoLlxyXG4gKiBWYXJpYWJsZSBuYW1lcyBmb2xsb3cgdGhlIG5vdGF0aW9uIGluIEZJUFMgUFVCIDE4MC0zOlxyXG4gKiBodHRwOi8vY3NyYy5uaXN0Lmdvdi9wdWJsaWNhdGlvbnMvZmlwcy9maXBzMTgwLTMvZmlwczE4MC0zX2ZpbmFsLnBkZi5cclxuICpcclxuICogVXNhZ2U6XHJcbiAqICAgdmFyIHNoYTEgPSBuZXcgc2hhMSgpO1xyXG4gKiAgIHNoYTEudXBkYXRlKGJ5dGVzKTtcclxuICogICB2YXIgaGFzaCA9IHNoYTEuZGlnZXN0KCk7XHJcbiAqXHJcbiAqIFBlcmZvcm1hbmNlOlxyXG4gKiAgIENocm9tZSAyMzogICB+NDAwIE1iaXQvc1xyXG4gKiAgIEZpcmVmb3ggMTY6ICB+MjUwIE1iaXQvc1xyXG4gKlxyXG4gKi9cclxuLyoqXHJcbiAqIFNIQS0xIGNyeXB0b2dyYXBoaWMgaGFzaCBjb25zdHJ1Y3Rvci5cclxuICpcclxuICogVGhlIHByb3BlcnRpZXMgZGVjbGFyZWQgaGVyZSBhcmUgZGlzY3Vzc2VkIGluIHRoZSBhYm92ZSBhbGdvcml0aG0gZG9jdW1lbnQuXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBAZmluYWxcclxuICogQHN0cnVjdFxyXG4gKi9cclxuY2xhc3MgU2hhMSB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBIb2xkcyB0aGUgcHJldmlvdXMgdmFsdWVzIG9mIGFjY3VtdWxhdGVkIHZhcmlhYmxlcyBhLWUgaW4gdGhlIGNvbXByZXNzX1xyXG4gICAgICAgICAqIGZ1bmN0aW9uLlxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5jaGFpbl8gPSBbXTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBIGJ1ZmZlciBob2xkaW5nIHRoZSBwYXJ0aWFsbHkgY29tcHV0ZWQgaGFzaCByZXN1bHQuXHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmJ1Zl8gPSBbXTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBbiBhcnJheSBvZiA4MCBieXRlcywgZWFjaCBhIHBhcnQgb2YgdGhlIG1lc3NhZ2UgdG8gYmUgaGFzaGVkLiAgUmVmZXJyZWQgdG9cclxuICAgICAgICAgKiBhcyB0aGUgbWVzc2FnZSBzY2hlZHVsZSBpbiB0aGUgZG9jcy5cclxuICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuV18gPSBbXTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDb250YWlucyBkYXRhIG5lZWRlZCB0byBwYWQgbWVzc2FnZXMgbGVzcyB0aGFuIDY0IGJ5dGVzLlxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5wYWRfID0gW107XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHByaXZhdGUge251bWJlcn1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmluYnVmXyA9IDA7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHByaXZhdGUge251bWJlcn1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnRvdGFsXyA9IDA7XHJcbiAgICAgICAgdGhpcy5ibG9ja1NpemUgPSA1MTIgLyA4O1xyXG4gICAgICAgIHRoaXMucGFkX1swXSA9IDEyODtcclxuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IHRoaXMuYmxvY2tTaXplOyArK2kpIHtcclxuICAgICAgICAgICAgdGhpcy5wYWRfW2ldID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5yZXNldCgpO1xyXG4gICAgfVxyXG4gICAgcmVzZXQoKSB7XHJcbiAgICAgICAgdGhpcy5jaGFpbl9bMF0gPSAweDY3NDUyMzAxO1xyXG4gICAgICAgIHRoaXMuY2hhaW5fWzFdID0gMHhlZmNkYWI4OTtcclxuICAgICAgICB0aGlzLmNoYWluX1syXSA9IDB4OThiYWRjZmU7XHJcbiAgICAgICAgdGhpcy5jaGFpbl9bM10gPSAweDEwMzI1NDc2O1xyXG4gICAgICAgIHRoaXMuY2hhaW5fWzRdID0gMHhjM2QyZTFmMDtcclxuICAgICAgICB0aGlzLmluYnVmXyA9IDA7XHJcbiAgICAgICAgdGhpcy50b3RhbF8gPSAwO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBJbnRlcm5hbCBjb21wcmVzcyBoZWxwZXIgZnVuY3Rpb24uXHJcbiAgICAgKiBAcGFyYW0gYnVmIEJsb2NrIHRvIGNvbXByZXNzLlxyXG4gICAgICogQHBhcmFtIG9mZnNldCBPZmZzZXQgb2YgdGhlIGJsb2NrIGluIHRoZSBidWZmZXIuXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBjb21wcmVzc18oYnVmLCBvZmZzZXQpIHtcclxuICAgICAgICBpZiAoIW9mZnNldCkge1xyXG4gICAgICAgICAgICBvZmZzZXQgPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBXID0gdGhpcy5XXztcclxuICAgICAgICAvLyBnZXQgMTYgYmlnIGVuZGlhbiB3b3Jkc1xyXG4gICAgICAgIGlmICh0eXBlb2YgYnVmID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDE2OyBpKyspIHtcclxuICAgICAgICAgICAgICAgIC8vIFRPRE8odXNlcik6IFtidWcgODE0MDEyMl0gUmVjZW50IHZlcnNpb25zIG9mIFNhZmFyaSBmb3IgTWFjIE9TIGFuZCBpT1NcclxuICAgICAgICAgICAgICAgIC8vIGhhdmUgYSBidWcgdGhhdCB0dXJucyB0aGUgcG9zdC1pbmNyZW1lbnQgKysgb3BlcmF0b3IgaW50byBwcmUtaW5jcmVtZW50XHJcbiAgICAgICAgICAgICAgICAvLyBkdXJpbmcgSklUIGNvbXBpbGF0aW9uLiAgV2UgaGF2ZSBjb2RlIHRoYXQgZGVwZW5kcyBoZWF2aWx5IG9uIFNIQS0xIGZvclxyXG4gICAgICAgICAgICAgICAgLy8gY29ycmVjdG5lc3MgYW5kIHdoaWNoIGlzIGFmZmVjdGVkIGJ5IHRoaXMgYnVnLCBzbyBJJ3ZlIHJlbW92ZWQgYWxsIHVzZXNcclxuICAgICAgICAgICAgICAgIC8vIG9mIHBvc3QtaW5jcmVtZW50ICsrIGluIHdoaWNoIHRoZSByZXN1bHQgdmFsdWUgaXMgdXNlZC4gIFdlIGNhbiByZXZlcnRcclxuICAgICAgICAgICAgICAgIC8vIHRoaXMgY2hhbmdlIG9uY2UgdGhlIFNhZmFyaSBidWdcclxuICAgICAgICAgICAgICAgIC8vIChodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTA5MDM2KSBoYXMgYmVlbiBmaXhlZCBhbmRcclxuICAgICAgICAgICAgICAgIC8vIG1vc3QgY2xpZW50cyBoYXZlIGJlZW4gdXBkYXRlZC5cclxuICAgICAgICAgICAgICAgIFdbaV0gPVxyXG4gICAgICAgICAgICAgICAgICAgIChidWYuY2hhckNvZGVBdChvZmZzZXQpIDw8IDI0KSB8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIChidWYuY2hhckNvZGVBdChvZmZzZXQgKyAxKSA8PCAxNikgfFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAoYnVmLmNoYXJDb2RlQXQob2Zmc2V0ICsgMikgPDwgOCkgfFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBidWYuY2hhckNvZGVBdChvZmZzZXQgKyAzKTtcclxuICAgICAgICAgICAgICAgIG9mZnNldCArPSA0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDE2OyBpKyspIHtcclxuICAgICAgICAgICAgICAgIFdbaV0gPVxyXG4gICAgICAgICAgICAgICAgICAgIChidWZbb2Zmc2V0XSA8PCAyNCkgfFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAoYnVmW29mZnNldCArIDFdIDw8IDE2KSB8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIChidWZbb2Zmc2V0ICsgMl0gPDwgOCkgfFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBidWZbb2Zmc2V0ICsgM107XHJcbiAgICAgICAgICAgICAgICBvZmZzZXQgKz0gNDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBleHBhbmQgdG8gODAgd29yZHNcclxuICAgICAgICBmb3IgKGxldCBpID0gMTY7IGkgPCA4MDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHQgPSBXW2kgLSAzXSBeIFdbaSAtIDhdIF4gV1tpIC0gMTRdIF4gV1tpIC0gMTZdO1xyXG4gICAgICAgICAgICBXW2ldID0gKCh0IDw8IDEpIHwgKHQgPj4+IDMxKSkgJiAweGZmZmZmZmZmO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgYSA9IHRoaXMuY2hhaW5fWzBdO1xyXG4gICAgICAgIGxldCBiID0gdGhpcy5jaGFpbl9bMV07XHJcbiAgICAgICAgbGV0IGMgPSB0aGlzLmNoYWluX1syXTtcclxuICAgICAgICBsZXQgZCA9IHRoaXMuY2hhaW5fWzNdO1xyXG4gICAgICAgIGxldCBlID0gdGhpcy5jaGFpbl9bNF07XHJcbiAgICAgICAgbGV0IGYsIGs7XHJcbiAgICAgICAgLy8gVE9ETyh1c2VyKTogVHJ5IHRvIHVucm9sbCB0aGlzIGxvb3AgdG8gc3BlZWQgdXAgdGhlIGNvbXB1dGF0aW9uLlxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgODA7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoaSA8IDQwKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaSA8IDIwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZiA9IGQgXiAoYiAmIChjIF4gZCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGsgPSAweDVhODI3OTk5O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZiA9IGIgXiBjIF4gZDtcclxuICAgICAgICAgICAgICAgICAgICBrID0gMHg2ZWQ5ZWJhMTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmIChpIDwgNjApIHtcclxuICAgICAgICAgICAgICAgICAgICBmID0gKGIgJiBjKSB8IChkICYgKGIgfCBjKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgayA9IDB4OGYxYmJjZGM7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBmID0gYiBeIGMgXiBkO1xyXG4gICAgICAgICAgICAgICAgICAgIGsgPSAweGNhNjJjMWQ2O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IHQgPSAoKChhIDw8IDUpIHwgKGEgPj4+IDI3KSkgKyBmICsgZSArIGsgKyBXW2ldKSAmIDB4ZmZmZmZmZmY7XHJcbiAgICAgICAgICAgIGUgPSBkO1xyXG4gICAgICAgICAgICBkID0gYztcclxuICAgICAgICAgICAgYyA9ICgoYiA8PCAzMCkgfCAoYiA+Pj4gMikpICYgMHhmZmZmZmZmZjtcclxuICAgICAgICAgICAgYiA9IGE7XHJcbiAgICAgICAgICAgIGEgPSB0O1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmNoYWluX1swXSA9ICh0aGlzLmNoYWluX1swXSArIGEpICYgMHhmZmZmZmZmZjtcclxuICAgICAgICB0aGlzLmNoYWluX1sxXSA9ICh0aGlzLmNoYWluX1sxXSArIGIpICYgMHhmZmZmZmZmZjtcclxuICAgICAgICB0aGlzLmNoYWluX1syXSA9ICh0aGlzLmNoYWluX1syXSArIGMpICYgMHhmZmZmZmZmZjtcclxuICAgICAgICB0aGlzLmNoYWluX1szXSA9ICh0aGlzLmNoYWluX1szXSArIGQpICYgMHhmZmZmZmZmZjtcclxuICAgICAgICB0aGlzLmNoYWluX1s0XSA9ICh0aGlzLmNoYWluX1s0XSArIGUpICYgMHhmZmZmZmZmZjtcclxuICAgIH1cclxuICAgIHVwZGF0ZShieXRlcywgbGVuZ3RoKSB7XHJcbiAgICAgICAgLy8gVE9ETyhqb2hubGVueik6IHRpZ2h0ZW4gdGhlIGZ1bmN0aW9uIHNpZ25hdHVyZSBhbmQgcmVtb3ZlIHRoaXMgY2hlY2tcclxuICAgICAgICBpZiAoYnl0ZXMgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBsZW5ndGggPSBieXRlcy5sZW5ndGg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGxlbmd0aE1pbnVzQmxvY2sgPSBsZW5ndGggLSB0aGlzLmJsb2NrU2l6ZTtcclxuICAgICAgICBsZXQgbiA9IDA7XHJcbiAgICAgICAgLy8gVXNpbmcgbG9jYWwgaW5zdGVhZCBvZiBtZW1iZXIgdmFyaWFibGVzIGdpdmVzIH41JSBzcGVlZHVwIG9uIEZpcmVmb3ggMTYuXHJcbiAgICAgICAgY29uc3QgYnVmID0gdGhpcy5idWZfO1xyXG4gICAgICAgIGxldCBpbmJ1ZiA9IHRoaXMuaW5idWZfO1xyXG4gICAgICAgIC8vIFRoZSBvdXRlciB3aGlsZSBsb29wIHNob3VsZCBleGVjdXRlIGF0IG1vc3QgdHdpY2UuXHJcbiAgICAgICAgd2hpbGUgKG4gPCBsZW5ndGgpIHtcclxuICAgICAgICAgICAgLy8gV2hlbiB3ZSBoYXZlIG5vIGRhdGEgaW4gdGhlIGJsb2NrIHRvIHRvcCB1cCwgd2UgY2FuIGRpcmVjdGx5IHByb2Nlc3MgdGhlXHJcbiAgICAgICAgICAgIC8vIGlucHV0IGJ1ZmZlciAoYXNzdW1pbmcgaXQgY29udGFpbnMgc3VmZmljaWVudCBkYXRhKS4gVGhpcyBnaXZlcyB+MjUlXHJcbiAgICAgICAgICAgIC8vIHNwZWVkdXAgb24gQ2hyb21lIDIzIGFuZCB+MTUlIHNwZWVkdXAgb24gRmlyZWZveCAxNiwgYnV0IHJlcXVpcmVzIHRoYXRcclxuICAgICAgICAgICAgLy8gdGhlIGRhdGEgaXMgcHJvdmlkZWQgaW4gbGFyZ2UgY2h1bmtzIChvciBpbiBtdWx0aXBsZXMgb2YgNjQgYnl0ZXMpLlxyXG4gICAgICAgICAgICBpZiAoaW5idWYgPT09IDApIHtcclxuICAgICAgICAgICAgICAgIHdoaWxlIChuIDw9IGxlbmd0aE1pbnVzQmxvY2spIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbXByZXNzXyhieXRlcywgbik7XHJcbiAgICAgICAgICAgICAgICAgICAgbiArPSB0aGlzLmJsb2NrU2l6ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGJ5dGVzID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKG4gPCBsZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICBidWZbaW5idWZdID0gYnl0ZXMuY2hhckNvZGVBdChuKTtcclxuICAgICAgICAgICAgICAgICAgICArK2luYnVmO1xyXG4gICAgICAgICAgICAgICAgICAgICsrbjtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaW5idWYgPT09IHRoaXMuYmxvY2tTaXplKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29tcHJlc3NfKGJ1Zik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGluYnVmID0gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSnVtcCB0byB0aGUgb3V0ZXIgbG9vcCBzbyB3ZSB1c2UgdGhlIGZ1bGwtYmxvY2sgb3B0aW1pemF0aW9uLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAobiA8IGxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGJ1ZltpbmJ1Zl0gPSBieXRlc1tuXTtcclxuICAgICAgICAgICAgICAgICAgICArK2luYnVmO1xyXG4gICAgICAgICAgICAgICAgICAgICsrbjtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaW5idWYgPT09IHRoaXMuYmxvY2tTaXplKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29tcHJlc3NfKGJ1Zik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGluYnVmID0gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSnVtcCB0byB0aGUgb3V0ZXIgbG9vcCBzbyB3ZSB1c2UgdGhlIGZ1bGwtYmxvY2sgb3B0aW1pemF0aW9uLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5pbmJ1Zl8gPSBpbmJ1ZjtcclxuICAgICAgICB0aGlzLnRvdGFsXyArPSBsZW5ndGg7XHJcbiAgICB9XHJcbiAgICAvKiogQG92ZXJyaWRlICovXHJcbiAgICBkaWdlc3QoKSB7XHJcbiAgICAgICAgY29uc3QgZGlnZXN0ID0gW107XHJcbiAgICAgICAgbGV0IHRvdGFsQml0cyA9IHRoaXMudG90YWxfICogODtcclxuICAgICAgICAvLyBBZGQgcGFkIDB4ODAgMHgwMCouXHJcbiAgICAgICAgaWYgKHRoaXMuaW5idWZfIDwgNTYpIHtcclxuICAgICAgICAgICAgdGhpcy51cGRhdGUodGhpcy5wYWRfLCA1NiAtIHRoaXMuaW5idWZfKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlKHRoaXMucGFkXywgdGhpcy5ibG9ja1NpemUgLSAodGhpcy5pbmJ1Zl8gLSA1NikpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBBZGQgIyBiaXRzLlxyXG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLmJsb2NrU2l6ZSAtIDE7IGkgPj0gNTY7IGktLSkge1xyXG4gICAgICAgICAgICB0aGlzLmJ1Zl9baV0gPSB0b3RhbEJpdHMgJiAyNTU7XHJcbiAgICAgICAgICAgIHRvdGFsQml0cyAvPSAyNTY7IC8vIERvbid0IHVzZSBiaXQtc2hpZnRpbmcgaGVyZSFcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5jb21wcmVzc18odGhpcy5idWZfKTtcclxuICAgICAgICBsZXQgbiA9IDA7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA1OyBpKyspIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDI0OyBqID49IDA7IGogLT0gOCkge1xyXG4gICAgICAgICAgICAgICAgZGlnZXN0W25dID0gKHRoaXMuY2hhaW5fW2ldID4+IGopICYgMjU1O1xyXG4gICAgICAgICAgICAgICAgKytuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBkaWdlc3Q7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEhlbHBlciB0byBtYWtlIGEgU3Vic2NyaWJlIGZ1bmN0aW9uIChqdXN0IGxpa2UgUHJvbWlzZSBoZWxwcyBtYWtlIGFcclxuICogVGhlbmFibGUpLlxyXG4gKlxyXG4gKiBAcGFyYW0gZXhlY3V0b3IgRnVuY3Rpb24gd2hpY2ggY2FuIG1ha2UgY2FsbHMgdG8gYSBzaW5nbGUgT2JzZXJ2ZXJcclxuICogICAgIGFzIGEgcHJveHkuXHJcbiAqIEBwYXJhbSBvbk5vT2JzZXJ2ZXJzIENhbGxiYWNrIHdoZW4gY291bnQgb2YgT2JzZXJ2ZXJzIGdvZXMgdG8gemVyby5cclxuICovXHJcbmZ1bmN0aW9uIGNyZWF0ZVN1YnNjcmliZShleGVjdXRvciwgb25Ob09ic2VydmVycykge1xyXG4gICAgY29uc3QgcHJveHkgPSBuZXcgT2JzZXJ2ZXJQcm94eShleGVjdXRvciwgb25Ob09ic2VydmVycyk7XHJcbiAgICByZXR1cm4gcHJveHkuc3Vic2NyaWJlLmJpbmQocHJveHkpO1xyXG59XHJcbi8qKlxyXG4gKiBJbXBsZW1lbnQgZmFuLW91dCBmb3IgYW55IG51bWJlciBvZiBPYnNlcnZlcnMgYXR0YWNoZWQgdmlhIGEgc3Vic2NyaWJlXHJcbiAqIGZ1bmN0aW9uLlxyXG4gKi9cclxuY2xhc3MgT2JzZXJ2ZXJQcm94eSB7XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSBleGVjdXRvciBGdW5jdGlvbiB3aGljaCBjYW4gbWFrZSBjYWxscyB0byBhIHNpbmdsZSBPYnNlcnZlclxyXG4gICAgICogICAgIGFzIGEgcHJveHkuXHJcbiAgICAgKiBAcGFyYW0gb25Ob09ic2VydmVycyBDYWxsYmFjayB3aGVuIGNvdW50IG9mIE9ic2VydmVycyBnb2VzIHRvIHplcm8uXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKGV4ZWN1dG9yLCBvbk5vT2JzZXJ2ZXJzKSB7XHJcbiAgICAgICAgdGhpcy5vYnNlcnZlcnMgPSBbXTtcclxuICAgICAgICB0aGlzLnVuc3Vic2NyaWJlcyA9IFtdO1xyXG4gICAgICAgIHRoaXMub2JzZXJ2ZXJDb3VudCA9IDA7XHJcbiAgICAgICAgLy8gTWljcm8tdGFzayBzY2hlZHVsaW5nIGJ5IGNhbGxpbmcgdGFzay50aGVuKCkuXHJcbiAgICAgICAgdGhpcy50YXNrID0gUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgICAgICAgdGhpcy5maW5hbGl6ZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLm9uTm9PYnNlcnZlcnMgPSBvbk5vT2JzZXJ2ZXJzO1xyXG4gICAgICAgIC8vIENhbGwgdGhlIGV4ZWN1dG9yIGFzeW5jaHJvbm91c2x5IHNvIHN1YnNjcmliZXJzIHRoYXQgYXJlIGNhbGxlZFxyXG4gICAgICAgIC8vIHN5bmNocm9ub3VzbHkgYWZ0ZXIgdGhlIGNyZWF0aW9uIG9mIHRoZSBzdWJzY3JpYmUgZnVuY3Rpb25cclxuICAgICAgICAvLyBjYW4gc3RpbGwgcmVjZWl2ZSB0aGUgdmVyeSBmaXJzdCB2YWx1ZSBnZW5lcmF0ZWQgaW4gdGhlIGV4ZWN1dG9yLlxyXG4gICAgICAgIHRoaXMudGFza1xyXG4gICAgICAgICAgICAudGhlbigoKSA9PiB7XHJcbiAgICAgICAgICAgIGV4ZWN1dG9yKHRoaXMpO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5jYXRjaChlID0+IHtcclxuICAgICAgICAgICAgdGhpcy5lcnJvcihlKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIG5leHQodmFsdWUpIHtcclxuICAgICAgICB0aGlzLmZvckVhY2hPYnNlcnZlcigob2JzZXJ2ZXIpID0+IHtcclxuICAgICAgICAgICAgb2JzZXJ2ZXIubmV4dCh2YWx1ZSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBlcnJvcihlcnJvcikge1xyXG4gICAgICAgIHRoaXMuZm9yRWFjaE9ic2VydmVyKChvYnNlcnZlcikgPT4ge1xyXG4gICAgICAgICAgICBvYnNlcnZlci5lcnJvcihlcnJvcik7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5jbG9zZShlcnJvcik7XHJcbiAgICB9XHJcbiAgICBjb21wbGV0ZSgpIHtcclxuICAgICAgICB0aGlzLmZvckVhY2hPYnNlcnZlcigob2JzZXJ2ZXIpID0+IHtcclxuICAgICAgICAgICAgb2JzZXJ2ZXIuY29tcGxldGUoKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLmNsb3NlKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFN1YnNjcmliZSBmdW5jdGlvbiB0aGF0IGNhbiBiZSB1c2VkIHRvIGFkZCBhbiBPYnNlcnZlciB0byB0aGUgZmFuLW91dCBsaXN0LlxyXG4gICAgICpcclxuICAgICAqIC0gV2UgcmVxdWlyZSB0aGF0IG5vIGV2ZW50IGlzIHNlbnQgdG8gYSBzdWJzY3JpYmVyIHN5Y2hyb25vdXNseSB0byB0aGVpclxyXG4gICAgICogICBjYWxsIHRvIHN1YnNjcmliZSgpLlxyXG4gICAgICovXHJcbiAgICBzdWJzY3JpYmUobmV4dE9yT2JzZXJ2ZXIsIGVycm9yLCBjb21wbGV0ZSkge1xyXG4gICAgICAgIGxldCBvYnNlcnZlcjtcclxuICAgICAgICBpZiAobmV4dE9yT2JzZXJ2ZXIgPT09IHVuZGVmaW5lZCAmJlxyXG4gICAgICAgICAgICBlcnJvciA9PT0gdW5kZWZpbmVkICYmXHJcbiAgICAgICAgICAgIGNvbXBsZXRlID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIE9ic2VydmVyLicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBBc3NlbWJsZSBhbiBPYnNlcnZlciBvYmplY3Qgd2hlbiBwYXNzZWQgYXMgY2FsbGJhY2sgZnVuY3Rpb25zLlxyXG4gICAgICAgIGlmIChpbXBsZW1lbnRzQW55TWV0aG9kcyhuZXh0T3JPYnNlcnZlciwgW1xyXG4gICAgICAgICAgICAnbmV4dCcsXHJcbiAgICAgICAgICAgICdlcnJvcicsXHJcbiAgICAgICAgICAgICdjb21wbGV0ZSdcclxuICAgICAgICBdKSkge1xyXG4gICAgICAgICAgICBvYnNlcnZlciA9IG5leHRPck9ic2VydmVyO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgb2JzZXJ2ZXIgPSB7XHJcbiAgICAgICAgICAgICAgICBuZXh0OiBuZXh0T3JPYnNlcnZlcixcclxuICAgICAgICAgICAgICAgIGVycm9yLFxyXG4gICAgICAgICAgICAgICAgY29tcGxldGVcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG9ic2VydmVyLm5leHQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBvYnNlcnZlci5uZXh0ID0gbm9vcDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG9ic2VydmVyLmVycm9yID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgb2JzZXJ2ZXIuZXJyb3IgPSBub29wO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAob2JzZXJ2ZXIuY29tcGxldGUgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBvYnNlcnZlci5jb21wbGV0ZSA9IG5vb3A7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHVuc3ViID0gdGhpcy51bnN1YnNjcmliZU9uZS5iaW5kKHRoaXMsIHRoaXMub2JzZXJ2ZXJzLmxlbmd0aCk7XHJcbiAgICAgICAgLy8gQXR0ZW1wdCB0byBzdWJzY3JpYmUgdG8gYSB0ZXJtaW5hdGVkIE9ic2VydmFibGUgLSB3ZVxyXG4gICAgICAgIC8vIGp1c3QgcmVzcG9uZCB0byB0aGUgT2JzZXJ2ZXIgd2l0aCB0aGUgZmluYWwgZXJyb3Igb3IgY29tcGxldGVcclxuICAgICAgICAvLyBldmVudC5cclxuICAgICAgICBpZiAodGhpcy5maW5hbGl6ZWQpIHtcclxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1mbG9hdGluZy1wcm9taXNlc1xyXG4gICAgICAgICAgICB0aGlzLnRhc2sudGhlbigoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmZpbmFsRXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb2JzZXJ2ZXIuZXJyb3IodGhpcy5maW5hbEVycm9yKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9ic2VydmVyLmNvbXBsZXRlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBub3RoaW5nXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLm9ic2VydmVycy5wdXNoKG9ic2VydmVyKTtcclxuICAgICAgICByZXR1cm4gdW5zdWI7XHJcbiAgICB9XHJcbiAgICAvLyBVbnN1YnNjcmliZSBpcyBzeW5jaHJvbm91cyAtIHdlIGd1YXJhbnRlZSB0aGF0IG5vIGV2ZW50cyBhcmUgc2VudCB0b1xyXG4gICAgLy8gYW55IHVuc3Vic2NyaWJlZCBPYnNlcnZlci5cclxuICAgIHVuc3Vic2NyaWJlT25lKGkpIHtcclxuICAgICAgICBpZiAodGhpcy5vYnNlcnZlcnMgPT09IHVuZGVmaW5lZCB8fCB0aGlzLm9ic2VydmVyc1tpXSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZGVsZXRlIHRoaXMub2JzZXJ2ZXJzW2ldO1xyXG4gICAgICAgIHRoaXMub2JzZXJ2ZXJDb3VudCAtPSAxO1xyXG4gICAgICAgIGlmICh0aGlzLm9ic2VydmVyQ291bnQgPT09IDAgJiYgdGhpcy5vbk5vT2JzZXJ2ZXJzICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5vbk5vT2JzZXJ2ZXJzKHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZvckVhY2hPYnNlcnZlcihmbikge1xyXG4gICAgICAgIGlmICh0aGlzLmZpbmFsaXplZCkge1xyXG4gICAgICAgICAgICAvLyBBbHJlYWR5IGNsb3NlZCBieSBwcmV2aW91cyBldmVudC4uLi5qdXN0IGVhdCB0aGUgYWRkaXRpb25hbCB2YWx1ZXMuXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gU2luY2Ugc2VuZE9uZSBjYWxscyBhc3luY2hyb25vdXNseSAtIHRoZXJlIGlzIG5vIGNoYW5jZSB0aGF0XHJcbiAgICAgICAgLy8gdGhpcy5vYnNlcnZlcnMgd2lsbCBiZWNvbWUgdW5kZWZpbmVkLlxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5vYnNlcnZlcnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdGhpcy5zZW5kT25lKGksIGZuKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBDYWxsIHRoZSBPYnNlcnZlciB2aWEgb25lIG9mIGl0J3MgY2FsbGJhY2sgZnVuY3Rpb24uIFdlIGFyZSBjYXJlZnVsIHRvXHJcbiAgICAvLyBjb25maXJtIHRoYXQgdGhlIG9ic2VydmUgaGFzIG5vdCBiZWVuIHVuc3Vic2NyaWJlZCBzaW5jZSB0aGlzIGFzeW5jaHJvbm91c1xyXG4gICAgLy8gZnVuY3Rpb24gaGFkIGJlZW4gcXVldWVkLlxyXG4gICAgc2VuZE9uZShpLCBmbikge1xyXG4gICAgICAgIC8vIEV4ZWN1dGUgdGhlIGNhbGxiYWNrIGFzeW5jaHJvbm91c2x5XHJcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1mbG9hdGluZy1wcm9taXNlc1xyXG4gICAgICAgIHRoaXMudGFzay50aGVuKCgpID0+IHtcclxuICAgICAgICAgICAgaWYgKHRoaXMub2JzZXJ2ZXJzICE9PSB1bmRlZmluZWQgJiYgdGhpcy5vYnNlcnZlcnNbaV0gIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICBmbih0aGlzLm9ic2VydmVyc1tpXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIElnbm9yZSBleGNlcHRpb25zIHJhaXNlZCBpbiBPYnNlcnZlcnMgb3IgbWlzc2luZyBtZXRob2RzIG9mIGFuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gT2JzZXJ2ZXIuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gTG9nIGVycm9yIHRvIGNvbnNvbGUuIGIvMzE0MDQ4MDZcclxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmIGNvbnNvbGUuZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGNsb3NlKGVycikge1xyXG4gICAgICAgIGlmICh0aGlzLmZpbmFsaXplZCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuZmluYWxpemVkID0gdHJ1ZTtcclxuICAgICAgICBpZiAoZXJyICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5maW5hbEVycm9yID0gZXJyO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBQcm94eSBpcyBubyBsb25nZXIgbmVlZGVkIC0gZ2FyYmFnZSBjb2xsZWN0IHJlZmVyZW5jZXNcclxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWZsb2F0aW5nLXByb21pc2VzXHJcbiAgICAgICAgdGhpcy50YXNrLnRoZW4oKCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLm9ic2VydmVycyA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgdGhpcy5vbk5vT2JzZXJ2ZXJzID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59XHJcbi8qKiBUdXJuIHN5bmNocm9ub3VzIGZ1bmN0aW9uIGludG8gb25lIGNhbGxlZCBhc3luY2hyb25vdXNseS4gKi9cclxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHlwZXNcclxuZnVuY3Rpb24gYXN5bmMoZm4sIG9uRXJyb3IpIHtcclxuICAgIHJldHVybiAoLi4uYXJncykgPT4ge1xyXG4gICAgICAgIFByb21pc2UucmVzb2x2ZSh0cnVlKVxyXG4gICAgICAgICAgICAudGhlbigoKSA9PiB7XHJcbiAgICAgICAgICAgIGZuKC4uLmFyZ3MpO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5jYXRjaCgoZXJyb3IpID0+IHtcclxuICAgICAgICAgICAgaWYgKG9uRXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIG9uRXJyb3IoZXJyb3IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgb2JqZWN0IHBhc3NlZCBpbiBpbXBsZW1lbnRzIGFueSBvZiB0aGUgbmFtZWQgbWV0aG9kcy5cclxuICovXHJcbmZ1bmN0aW9uIGltcGxlbWVudHNBbnlNZXRob2RzKG9iaiwgbWV0aG9kcykge1xyXG4gICAgaWYgKHR5cGVvZiBvYmogIT09ICdvYmplY3QnIHx8IG9iaiA9PT0gbnVsbCkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIGZvciAoY29uc3QgbWV0aG9kIG9mIG1ldGhvZHMpIHtcclxuICAgICAgICBpZiAobWV0aG9kIGluIG9iaiAmJiB0eXBlb2Ygb2JqW21ldGhvZF0gPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG59XHJcbmZ1bmN0aW9uIG5vb3AoKSB7XHJcbiAgICAvLyBkbyBub3RoaW5nXHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIENoZWNrIHRvIG1ha2Ugc3VyZSB0aGUgYXBwcm9wcmlhdGUgbnVtYmVyIG9mIGFyZ3VtZW50cyBhcmUgcHJvdmlkZWQgZm9yIGEgcHVibGljIGZ1bmN0aW9uLlxyXG4gKiBUaHJvd3MgYW4gZXJyb3IgaWYgaXQgZmFpbHMuXHJcbiAqXHJcbiAqIEBwYXJhbSBmbk5hbWUgVGhlIGZ1bmN0aW9uIG5hbWVcclxuICogQHBhcmFtIG1pbkNvdW50IFRoZSBtaW5pbXVtIG51bWJlciBvZiBhcmd1bWVudHMgdG8gYWxsb3cgZm9yIHRoZSBmdW5jdGlvbiBjYWxsXHJcbiAqIEBwYXJhbSBtYXhDb3VudCBUaGUgbWF4aW11bSBudW1iZXIgb2YgYXJndW1lbnQgdG8gYWxsb3cgZm9yIHRoZSBmdW5jdGlvbiBjYWxsXHJcbiAqIEBwYXJhbSBhcmdDb3VudCBUaGUgYWN0dWFsIG51bWJlciBvZiBhcmd1bWVudHMgcHJvdmlkZWQuXHJcbiAqL1xyXG5jb25zdCB2YWxpZGF0ZUFyZ0NvdW50ID0gZnVuY3Rpb24gKGZuTmFtZSwgbWluQ291bnQsIG1heENvdW50LCBhcmdDb3VudCkge1xyXG4gICAgbGV0IGFyZ0Vycm9yO1xyXG4gICAgaWYgKGFyZ0NvdW50IDwgbWluQ291bnQpIHtcclxuICAgICAgICBhcmdFcnJvciA9ICdhdCBsZWFzdCAnICsgbWluQ291bnQ7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChhcmdDb3VudCA+IG1heENvdW50KSB7XHJcbiAgICAgICAgYXJnRXJyb3IgPSBtYXhDb3VudCA9PT0gMCA/ICdub25lJyA6ICdubyBtb3JlIHRoYW4gJyArIG1heENvdW50O1xyXG4gICAgfVxyXG4gICAgaWYgKGFyZ0Vycm9yKSB7XHJcbiAgICAgICAgY29uc3QgZXJyb3IgPSBmbk5hbWUgK1xyXG4gICAgICAgICAgICAnIGZhaWxlZDogV2FzIGNhbGxlZCB3aXRoICcgK1xyXG4gICAgICAgICAgICBhcmdDb3VudCArXHJcbiAgICAgICAgICAgIChhcmdDb3VudCA9PT0gMSA/ICcgYXJndW1lbnQuJyA6ICcgYXJndW1lbnRzLicpICtcclxuICAgICAgICAgICAgJyBFeHBlY3RzICcgK1xyXG4gICAgICAgICAgICBhcmdFcnJvciArXHJcbiAgICAgICAgICAgICcuJztcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3IpO1xyXG4gICAgfVxyXG59O1xyXG4vKipcclxuICogR2VuZXJhdGVzIGEgc3RyaW5nIHRvIHByZWZpeCBhbiBlcnJvciBtZXNzYWdlIGFib3V0IGZhaWxlZCBhcmd1bWVudCB2YWxpZGF0aW9uXHJcbiAqXHJcbiAqIEBwYXJhbSBmbk5hbWUgVGhlIGZ1bmN0aW9uIG5hbWVcclxuICogQHBhcmFtIGFyZ05hbWUgVGhlIG5hbWUgb2YgdGhlIGFyZ3VtZW50XHJcbiAqIEByZXR1cm4gVGhlIHByZWZpeCB0byBhZGQgdG8gdGhlIGVycm9yIHRocm93biBmb3IgdmFsaWRhdGlvbi5cclxuICovXHJcbmZ1bmN0aW9uIGVycm9yUHJlZml4KGZuTmFtZSwgYXJnTmFtZSkge1xyXG4gICAgcmV0dXJuIGAke2ZuTmFtZX0gZmFpbGVkOiAke2FyZ05hbWV9IGFyZ3VtZW50IGA7XHJcbn1cclxuLyoqXHJcbiAqIEBwYXJhbSBmbk5hbWVcclxuICogQHBhcmFtIGFyZ3VtZW50TnVtYmVyXHJcbiAqIEBwYXJhbSBuYW1lc3BhY2VcclxuICogQHBhcmFtIG9wdGlvbmFsXHJcbiAqL1xyXG5mdW5jdGlvbiB2YWxpZGF0ZU5hbWVzcGFjZShmbk5hbWUsIG5hbWVzcGFjZSwgb3B0aW9uYWwpIHtcclxuICAgIGlmIChvcHRpb25hbCAmJiAhbmFtZXNwYWNlKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgaWYgKHR5cGVvZiBuYW1lc3BhY2UgIT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgLy9UT0RPOiBJIHNob3VsZCBkbyBtb3JlIHZhbGlkYXRpb24gaGVyZS4gV2Ugb25seSBhbGxvdyBjZXJ0YWluIGNoYXJzIGluIG5hbWVzcGFjZXMuXHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yUHJlZml4KGZuTmFtZSwgJ25hbWVzcGFjZScpICsgJ211c3QgYmUgYSB2YWxpZCBmaXJlYmFzZSBuYW1lc3BhY2UuJyk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gdmFsaWRhdGVDYWxsYmFjayhmbk5hbWUsIGFyZ3VtZW50TmFtZSwgXHJcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXR5cGVzXHJcbmNhbGxiYWNrLCBvcHRpb25hbCkge1xyXG4gICAgaWYgKG9wdGlvbmFsICYmICFjYWxsYmFjaykge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JQcmVmaXgoZm5OYW1lLCBhcmd1bWVudE5hbWUpICsgJ211c3QgYmUgYSB2YWxpZCBmdW5jdGlvbi4nKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiB2YWxpZGF0ZUNvbnRleHRPYmplY3QoZm5OYW1lLCBhcmd1bWVudE5hbWUsIGNvbnRleHQsIG9wdGlvbmFsKSB7XHJcbiAgICBpZiAob3B0aW9uYWwgJiYgIWNvbnRleHQpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBpZiAodHlwZW9mIGNvbnRleHQgIT09ICdvYmplY3QnIHx8IGNvbnRleHQgPT09IG51bGwpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JQcmVmaXgoZm5OYW1lLCBhcmd1bWVudE5hbWUpICsgJ211c3QgYmUgYSB2YWxpZCBjb250ZXh0IG9iamVjdC4nKTtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vLyBDb2RlIG9yaWdpbmFsbHkgY2FtZSBmcm9tIGdvb2cuY3J5cHQuc3RyaW5nVG9VdGY4Qnl0ZUFycmF5LCBidXQgZm9yIHNvbWUgcmVhc29uIHRoZXlcclxuLy8gYXV0b21hdGljYWxseSByZXBsYWNlZCAnXFxyXFxuJyB3aXRoICdcXG4nLCBhbmQgdGhleSBkaWRuJ3QgaGFuZGxlIHN1cnJvZ2F0ZSBwYWlycyxcclxuLy8gc28gaXQncyBiZWVuIG1vZGlmaWVkLlxyXG4vLyBOb3RlIHRoYXQgbm90IGFsbCBVbmljb2RlIGNoYXJhY3RlcnMgYXBwZWFyIGFzIHNpbmdsZSBjaGFyYWN0ZXJzIGluIEphdmFTY3JpcHQgc3RyaW5ncy5cclxuLy8gZnJvbUNoYXJDb2RlIHJldHVybnMgdGhlIFVURi0xNiBlbmNvZGluZyBvZiBhIGNoYXJhY3RlciAtIHNvIHNvbWUgVW5pY29kZSBjaGFyYWN0ZXJzXHJcbi8vIHVzZSAyIGNoYXJhY3RlcnMgaW4gSmF2YXNjcmlwdC4gIEFsbCA0LWJ5dGUgVVRGLTggY2hhcmFjdGVycyBiZWdpbiB3aXRoIGEgZmlyc3RcclxuLy8gY2hhcmFjdGVyIGluIHRoZSByYW5nZSAweEQ4MDAgLSAweERCRkYgKHRoZSBmaXJzdCBjaGFyYWN0ZXIgb2YgYSBzby1jYWxsZWQgc3Vycm9nYXRlXHJcbi8vIHBhaXIpLlxyXG4vLyBTZWUgaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzUuMS8jc2VjLTE1LjEuM1xyXG4vKipcclxuICogQHBhcmFtIHtzdHJpbmd9IHN0clxyXG4gKiBAcmV0dXJuIHtBcnJheX1cclxuICovXHJcbmNvbnN0IHN0cmluZ1RvQnl0ZUFycmF5ID0gZnVuY3Rpb24gKHN0cikge1xyXG4gICAgY29uc3Qgb3V0ID0gW107XHJcbiAgICBsZXQgcCA9IDA7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGxldCBjID0gc3RyLmNoYXJDb2RlQXQoaSk7XHJcbiAgICAgICAgLy8gSXMgdGhpcyB0aGUgbGVhZCBzdXJyb2dhdGUgaW4gYSBzdXJyb2dhdGUgcGFpcj9cclxuICAgICAgICBpZiAoYyA+PSAweGQ4MDAgJiYgYyA8PSAweGRiZmYpIHtcclxuICAgICAgICAgICAgY29uc3QgaGlnaCA9IGMgLSAweGQ4MDA7IC8vIHRoZSBoaWdoIDEwIGJpdHMuXHJcbiAgICAgICAgICAgIGkrKztcclxuICAgICAgICAgICAgYXNzZXJ0KGkgPCBzdHIubGVuZ3RoLCAnU3Vycm9nYXRlIHBhaXIgbWlzc2luZyB0cmFpbCBzdXJyb2dhdGUuJyk7XHJcbiAgICAgICAgICAgIGNvbnN0IGxvdyA9IHN0ci5jaGFyQ29kZUF0KGkpIC0gMHhkYzAwOyAvLyB0aGUgbG93IDEwIGJpdHMuXHJcbiAgICAgICAgICAgIGMgPSAweDEwMDAwICsgKGhpZ2ggPDwgMTApICsgbG93O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoYyA8IDEyOCkge1xyXG4gICAgICAgICAgICBvdXRbcCsrXSA9IGM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGMgPCAyMDQ4KSB7XHJcbiAgICAgICAgICAgIG91dFtwKytdID0gKGMgPj4gNikgfCAxOTI7XHJcbiAgICAgICAgICAgIG91dFtwKytdID0gKGMgJiA2MykgfCAxMjg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGMgPCA2NTUzNikge1xyXG4gICAgICAgICAgICBvdXRbcCsrXSA9IChjID4+IDEyKSB8IDIyNDtcclxuICAgICAgICAgICAgb3V0W3ArK10gPSAoKGMgPj4gNikgJiA2MykgfCAxMjg7XHJcbiAgICAgICAgICAgIG91dFtwKytdID0gKGMgJiA2MykgfCAxMjg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBvdXRbcCsrXSA9IChjID4+IDE4KSB8IDI0MDtcclxuICAgICAgICAgICAgb3V0W3ArK10gPSAoKGMgPj4gMTIpICYgNjMpIHwgMTI4O1xyXG4gICAgICAgICAgICBvdXRbcCsrXSA9ICgoYyA+PiA2KSAmIDYzKSB8IDEyODtcclxuICAgICAgICAgICAgb3V0W3ArK10gPSAoYyAmIDYzKSB8IDEyODtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gb3V0O1xyXG59O1xyXG4vKipcclxuICogQ2FsY3VsYXRlIGxlbmd0aCB3aXRob3V0IGFjdHVhbGx5IGNvbnZlcnRpbmc7IHVzZWZ1bCBmb3IgZG9pbmcgY2hlYXBlciB2YWxpZGF0aW9uLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyXHJcbiAqIEByZXR1cm4ge251bWJlcn1cclxuICovXHJcbmNvbnN0IHN0cmluZ0xlbmd0aCA9IGZ1bmN0aW9uIChzdHIpIHtcclxuICAgIGxldCBwID0gMDtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY29uc3QgYyA9IHN0ci5jaGFyQ29kZUF0KGkpO1xyXG4gICAgICAgIGlmIChjIDwgMTI4KSB7XHJcbiAgICAgICAgICAgIHArKztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoYyA8IDIwNDgpIHtcclxuICAgICAgICAgICAgcCArPSAyO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChjID49IDB4ZDgwMCAmJiBjIDw9IDB4ZGJmZikge1xyXG4gICAgICAgICAgICAvLyBMZWFkIHN1cnJvZ2F0ZSBvZiBhIHN1cnJvZ2F0ZSBwYWlyLiAgVGhlIHBhaXIgdG9nZXRoZXIgd2lsbCB0YWtlIDQgYnl0ZXMgdG8gcmVwcmVzZW50LlxyXG4gICAgICAgICAgICBwICs9IDQ7XHJcbiAgICAgICAgICAgIGkrKzsgLy8gc2tpcCB0cmFpbCBzdXJyb2dhdGUuXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBwICs9IDM7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHA7XHJcbn07XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBUaGUgYW1vdW50IG9mIG1pbGxpc2Vjb25kcyB0byBleHBvbmVudGlhbGx5IGluY3JlYXNlLlxyXG4gKi9cclxuY29uc3QgREVGQVVMVF9JTlRFUlZBTF9NSUxMSVMgPSAxMDAwO1xyXG4vKipcclxuICogVGhlIGZhY3RvciB0byBiYWNrb2ZmIGJ5LlxyXG4gKiBTaG91bGQgYmUgYSBudW1iZXIgZ3JlYXRlciB0aGFuIDEuXHJcbiAqL1xyXG5jb25zdCBERUZBVUxUX0JBQ0tPRkZfRkFDVE9SID0gMjtcclxuLyoqXHJcbiAqIFRoZSBtYXhpbXVtIG1pbGxpc2Vjb25kcyB0byBpbmNyZWFzZSB0by5cclxuICpcclxuICogPHA+VmlzaWJsZSBmb3IgdGVzdGluZ1xyXG4gKi9cclxuY29uc3QgTUFYX1ZBTFVFX01JTExJUyA9IDQgKiA2MCAqIDYwICogMTAwMDsgLy8gRm91ciBob3VycywgbGlrZSBpT1MgYW5kIEFuZHJvaWQuXHJcbi8qKlxyXG4gKiBUaGUgcGVyY2VudGFnZSBvZiBiYWNrb2ZmIHRpbWUgdG8gcmFuZG9taXplIGJ5LlxyXG4gKiBTZWVcclxuICogaHR0cDovL2dvL3NhZmUtY2xpZW50LWJlaGF2aW9yI3N0ZXAtMS1kZXRlcm1pbmUtdGhlLWFwcHJvcHJpYXRlLXJldHJ5LWludGVydmFsLXRvLWhhbmRsZS1zcGlrZS10cmFmZmljXHJcbiAqIGZvciBjb250ZXh0LlxyXG4gKlxyXG4gKiA8cD5WaXNpYmxlIGZvciB0ZXN0aW5nXHJcbiAqL1xyXG5jb25zdCBSQU5ET01fRkFDVE9SID0gMC41O1xyXG4vKipcclxuICogQmFzZWQgb24gdGhlIGJhY2tvZmYgbWV0aG9kIGZyb21cclxuICogaHR0cHM6Ly9naXRodWIuY29tL2dvb2dsZS9jbG9zdXJlLWxpYnJhcnkvYmxvYi9tYXN0ZXIvY2xvc3VyZS9nb29nL21hdGgvZXhwb25lbnRpYWxiYWNrb2ZmLmpzLlxyXG4gKiBFeHRyYWN0ZWQgaGVyZSBzbyB3ZSBkb24ndCBuZWVkIHRvIHBhc3MgbWV0YWRhdGEgYW5kIGEgc3RhdGVmdWwgRXhwb25lbnRpYWxCYWNrb2ZmIG9iamVjdCBhcm91bmQuXHJcbiAqL1xyXG5mdW5jdGlvbiBjYWxjdWxhdGVCYWNrb2ZmTWlsbGlzKGJhY2tvZmZDb3VudCwgaW50ZXJ2YWxNaWxsaXMgPSBERUZBVUxUX0lOVEVSVkFMX01JTExJUywgYmFja29mZkZhY3RvciA9IERFRkFVTFRfQkFDS09GRl9GQUNUT1IpIHtcclxuICAgIC8vIENhbGN1bGF0ZXMgYW4gZXhwb25lbnRpYWxseSBpbmNyZWFzaW5nIHZhbHVlLlxyXG4gICAgLy8gRGV2aWF0aW9uOiBjYWxjdWxhdGVzIHZhbHVlIGZyb20gY291bnQgYW5kIGEgY29uc3RhbnQgaW50ZXJ2YWwsIHNvIHdlIG9ubHkgbmVlZCB0byBzYXZlIHZhbHVlXHJcbiAgICAvLyBhbmQgY291bnQgdG8gcmVzdG9yZSBzdGF0ZS5cclxuICAgIGNvbnN0IGN1cnJCYXNlVmFsdWUgPSBpbnRlcnZhbE1pbGxpcyAqIE1hdGgucG93KGJhY2tvZmZGYWN0b3IsIGJhY2tvZmZDb3VudCk7XHJcbiAgICAvLyBBIHJhbmRvbSBcImZ1enpcIiB0byBhdm9pZCB3YXZlcyBvZiByZXRyaWVzLlxyXG4gICAgLy8gRGV2aWF0aW9uOiByYW5kb21GYWN0b3IgaXMgcmVxdWlyZWQuXHJcbiAgICBjb25zdCByYW5kb21XYWl0ID0gTWF0aC5yb3VuZChcclxuICAgIC8vIEEgZnJhY3Rpb24gb2YgdGhlIGJhY2tvZmYgdmFsdWUgdG8gYWRkL3N1YnRyYWN0LlxyXG4gICAgLy8gRGV2aWF0aW9uOiBjaGFuZ2VzIG11bHRpcGxpY2F0aW9uIG9yZGVyIHRvIGltcHJvdmUgcmVhZGFiaWxpdHkuXHJcbiAgICBSQU5ET01fRkFDVE9SICpcclxuICAgICAgICBjdXJyQmFzZVZhbHVlICpcclxuICAgICAgICAvLyBBIHJhbmRvbSBmbG9hdCAocm91bmRlZCB0byBpbnQgYnkgTWF0aC5yb3VuZCBhYm92ZSkgaW4gdGhlIHJhbmdlIFstMSwgMV0uIERldGVybWluZXNcclxuICAgICAgICAvLyBpZiB3ZSBhZGQgb3Igc3VidHJhY3QuXHJcbiAgICAgICAgKE1hdGgucmFuZG9tKCkgLSAwLjUpICpcclxuICAgICAgICAyKTtcclxuICAgIC8vIExpbWl0cyBiYWNrb2ZmIHRvIG1heCB0byBhdm9pZCBlZmZlY3RpdmVseSBwZXJtYW5lbnQgYmFja29mZi5cclxuICAgIHJldHVybiBNYXRoLm1pbihNQVhfVkFMVUVfTUlMTElTLCBjdXJyQmFzZVZhbHVlICsgcmFuZG9tV2FpdCk7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIFByb3ZpZGUgRW5nbGlzaCBvcmRpbmFsIGxldHRlcnMgYWZ0ZXIgYSBudW1iZXJcclxuICovXHJcbmZ1bmN0aW9uIG9yZGluYWwoaSkge1xyXG4gICAgaWYgKCFOdW1iZXIuaXNGaW5pdGUoaSkpIHtcclxuICAgICAgICByZXR1cm4gYCR7aX1gO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGkgKyBpbmRpY2F0b3IoaSk7XHJcbn1cclxuZnVuY3Rpb24gaW5kaWNhdG9yKGkpIHtcclxuICAgIGkgPSBNYXRoLmFicyhpKTtcclxuICAgIGNvbnN0IGNlbnQgPSBpICUgMTAwO1xyXG4gICAgaWYgKGNlbnQgPj0gMTAgJiYgY2VudCA8PSAyMCkge1xyXG4gICAgICAgIHJldHVybiAndGgnO1xyXG4gICAgfVxyXG4gICAgY29uc3QgZGVjID0gaSAlIDEwO1xyXG4gICAgaWYgKGRlYyA9PT0gMSkge1xyXG4gICAgICAgIHJldHVybiAnc3QnO1xyXG4gICAgfVxyXG4gICAgaWYgKGRlYyA9PT0gMikge1xyXG4gICAgICAgIHJldHVybiAnbmQnO1xyXG4gICAgfVxyXG4gICAgaWYgKGRlYyA9PT0gMykge1xyXG4gICAgICAgIHJldHVybiAncmQnO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuICd0aCc7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIxIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0TW9kdWxhckluc3RhbmNlKHNlcnZpY2UpIHtcclxuICAgIGlmIChzZXJ2aWNlICYmIHNlcnZpY2UuX2RlbGVnYXRlKSB7XHJcbiAgICAgICAgcmV0dXJuIHNlcnZpY2UuX2RlbGVnYXRlO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIHNlcnZpY2U7XHJcbiAgICB9XHJcbn1cblxuZXhwb3J0IHsgQ09OU1RBTlRTLCBEZWZlcnJlZCwgRXJyb3JGYWN0b3J5LCBGaXJlYmFzZUVycm9yLCBNQVhfVkFMVUVfTUlMTElTLCBSQU5ET01fRkFDVE9SLCBTaGExLCBhcmVDb29raWVzRW5hYmxlZCwgYXNzZXJ0LCBhc3NlcnRpb25FcnJvciwgYXN5bmMsIGJhc2U2NCwgYmFzZTY0RGVjb2RlLCBiYXNlNjRFbmNvZGUsIGJhc2U2NHVybEVuY29kZVdpdGhvdXRQYWRkaW5nLCBjYWxjdWxhdGVCYWNrb2ZmTWlsbGlzLCBjb250YWlucywgY3JlYXRlTW9ja1VzZXJUb2tlbiwgY3JlYXRlU3Vic2NyaWJlLCBkZWNvZGUsIGRlZXBDb3B5LCBkZWVwRXF1YWwsIGRlZXBFeHRlbmQsIGVycm9yUHJlZml4LCBleHRyYWN0UXVlcnlzdHJpbmcsIGdldEdsb2JhbCwgZ2V0TW9kdWxhckluc3RhbmNlLCBnZXRVQSwgaXNBZG1pbiwgaXNCcm93c2VyLCBpc0Jyb3dzZXJFeHRlbnNpb24sIGlzRWxlY3Ryb24sIGlzRW1wdHksIGlzSUUsIGlzSW5kZXhlZERCQXZhaWxhYmxlLCBpc01vYmlsZUNvcmRvdmEsIGlzTm9kZSwgaXNOb2RlU2RrLCBpc1JlYWN0TmF0aXZlLCBpc1NhZmFyaSwgaXNVV1AsIGlzVmFsaWRGb3JtYXQsIGlzVmFsaWRUaW1lc3RhbXAsIGlzc3VlZEF0VGltZSwganNvbkV2YWwsIG1hcCwgb3JkaW5hbCwgcXVlcnlzdHJpbmcsIHF1ZXJ5c3RyaW5nRGVjb2RlLCBzYWZlR2V0LCBzdHJpbmdMZW5ndGgsIHN0cmluZ1RvQnl0ZUFycmF5LCBzdHJpbmdpZnksIHZhbGlkYXRlQXJnQ291bnQsIHZhbGlkYXRlQ2FsbGJhY2ssIHZhbGlkYXRlQ29udGV4dE9iamVjdCwgdmFsaWRhdGVJbmRleGVkREJPcGVuYWJsZSwgdmFsaWRhdGVOYW1lc3BhY2UgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmVzbTIwMTcuanMubWFwXG4iLCIvLyBJbXBvcnRzXG5pbXBvcnQgX19fQ1NTX0xPQURFUl9BUElfU09VUkNFTUFQX0lNUE9SVF9fXyBmcm9tIFwiLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL3NvdXJjZU1hcHMuanNcIjtcbmltcG9ydCBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18gZnJvbSBcIi4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9hcGkuanNcIjtcbmltcG9ydCBfX19DU1NfTE9BREVSX0dFVF9VUkxfSU1QT1JUX19fIGZyb20gXCIuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvZ2V0VXJsLmpzXCI7XG52YXIgX19fQ1NTX0xPQURFUl9VUkxfSU1QT1JUXzBfX18gPSBuZXcgVVJMKFwiLi4vYXNzZXRzL2Fycm93LnN2Z1wiLCBpbXBvcnQubWV0YS51cmwpO1xudmFyIF9fX0NTU19MT0FERVJfVVJMX0lNUE9SVF8xX19fID0gbmV3IFVSTChcIi4uL2Fzc2V0cy9sYXJnZS1tYXAud2VicFwiLCBpbXBvcnQubWV0YS51cmwpO1xudmFyIF9fX0NTU19MT0FERVJfVVJMX0lNUE9SVF8yX19fID0gbmV3IFVSTChcIi4uL2Fzc2V0cy9zbWFsbC1tYXAud2VicFwiLCBpbXBvcnQubWV0YS51cmwpO1xudmFyIF9fX0NTU19MT0FERVJfVVJMX0lNUE9SVF8zX19fID0gbmV3IFVSTChcIi4uL2Fzc2V0cy9waW5rLW92ZXJsYXkud2VicFwiLCBpbXBvcnQubWV0YS51cmwpO1xudmFyIF9fX0NTU19MT0FERVJfVVJMX0lNUE9SVF80X19fID0gbmV3IFVSTChcIi4uL2Fzc2V0cy9kb3dubG9hZC5zdmdcIiwgaW1wb3J0Lm1ldGEudXJsKTtcbnZhciBfX19DU1NfTE9BREVSX1VSTF9JTVBPUlRfNV9fXyA9IG5ldyBVUkwoXCIuLi9hc3NldHMvZHJhd2luZy1jb21wYXNzLnN2Z1wiLCBpbXBvcnQubWV0YS51cmwpO1xudmFyIF9fX0NTU19MT0FERVJfVVJMX0lNUE9SVF82X19fID0gbmV3IFVSTChcIi4uL2Fzc2V0cy9jYXJkLWRyaWJiYmxlLnN2Z1wiLCBpbXBvcnQubWV0YS51cmwpO1xudmFyIF9fX0NTU19MT0FERVJfVVJMX0lNUE9SVF83X19fID0gbmV3IFVSTChcIi4uL2Fzc2V0cy9jYXJkLWdpdGh1Yi5zdmdcIiwgaW1wb3J0Lm1ldGEudXJsKTtcbnZhciBfX19DU1NfTE9BREVSX1VSTF9JTVBPUlRfOF9fXyA9IG5ldyBVUkwoXCIuLi9hc3NldHMvcGlnZGljZS5zdmdcIiwgaW1wb3J0Lm1ldGEudXJsKTtcbnZhciBfX19DU1NfTE9BREVSX1VSTF9JTVBPUlRfOV9fXyA9IG5ldyBVUkwoXCIuLi9hc3NldHMvbW9uc3Rlci1zbGF5ZXIuc3ZnXCIsIGltcG9ydC5tZXRhLnVybCk7XG52YXIgX19fQ1NTX0xPQURFUl9VUkxfSU1QT1JUXzEwX19fID0gbmV3IFVSTChcIi4uL2Fzc2V0cy9vc2MtZ2Vla3Muc3ZnXCIsIGltcG9ydC5tZXRhLnVybCk7XG52YXIgX19fQ1NTX0xPQURFUl9VUkxfSU1QT1JUXzExX19fID0gbmV3IFVSTChcIi4uL2Fzc2V0cy9jb250YWN0LXRoZW1lLTEud2VicFwiLCBpbXBvcnQubWV0YS51cmwpO1xudmFyIF9fX0NTU19MT0FERVJfVVJMX0lNUE9SVF8xMl9fXyA9IG5ldyBVUkwoXCIuLi9hc3NldHMvYXJyb3ctc2VuZC5zdmdcIiwgaW1wb3J0Lm1ldGEudXJsKTtcbnZhciBfX19DU1NfTE9BREVSX1VSTF9JTVBPUlRfMTNfX18gPSBuZXcgVVJMKFwiLi4vYXNzZXRzL2NvbnRhY3QtdGhlbWUtMi53ZWJwXCIsIGltcG9ydC5tZXRhLnVybCk7XG52YXIgX19fQ1NTX0xPQURFUl9VUkxfSU1QT1JUXzE0X19fID0gbmV3IFVSTChcIi4uL2Fzc2V0cy9jb250YWN0LXRoZW1lLTMud2VicFwiLCBpbXBvcnQubWV0YS51cmwpO1xudmFyIF9fX0NTU19MT0FERVJfRVhQT1JUX19fID0gX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fKF9fX0NTU19MT0FERVJfQVBJX1NPVVJDRU1BUF9JTVBPUlRfX18pO1xuX19fQ1NTX0xPQURFUl9FWFBPUlRfX18ucHVzaChbbW9kdWxlLmlkLCBcIkBpbXBvcnQgdXJsKGh0dHBzOi8vZm9udHMuZ29vZ2xlYXBpcy5jb20vY3NzMj9mYW1pbHk9UG9wcGluczp3Z2h0QDEwMDszMDA7NTAwOzYwMDs4MDAmZGlzcGxheT1zd2FwKTtcIl0pO1xudmFyIF9fX0NTU19MT0FERVJfVVJMX1JFUExBQ0VNRU5UXzBfX18gPSBfX19DU1NfTE9BREVSX0dFVF9VUkxfSU1QT1JUX19fKF9fX0NTU19MT0FERVJfVVJMX0lNUE9SVF8wX19fKTtcbnZhciBfX19DU1NfTE9BREVSX1VSTF9SRVBMQUNFTUVOVF8xX19fID0gX19fQ1NTX0xPQURFUl9HRVRfVVJMX0lNUE9SVF9fXyhfX19DU1NfTE9BREVSX1VSTF9JTVBPUlRfMV9fXyk7XG52YXIgX19fQ1NTX0xPQURFUl9VUkxfUkVQTEFDRU1FTlRfMl9fXyA9IF9fX0NTU19MT0FERVJfR0VUX1VSTF9JTVBPUlRfX18oX19fQ1NTX0xPQURFUl9VUkxfSU1QT1JUXzJfX18pO1xudmFyIF9fX0NTU19MT0FERVJfVVJMX1JFUExBQ0VNRU5UXzNfX18gPSBfX19DU1NfTE9BREVSX0dFVF9VUkxfSU1QT1JUX19fKF9fX0NTU19MT0FERVJfVVJMX0lNUE9SVF8zX19fKTtcbnZhciBfX19DU1NfTE9BREVSX1VSTF9SRVBMQUNFTUVOVF80X19fID0gX19fQ1NTX0xPQURFUl9HRVRfVVJMX0lNUE9SVF9fXyhfX19DU1NfTE9BREVSX1VSTF9JTVBPUlRfNF9fXyk7XG52YXIgX19fQ1NTX0xPQURFUl9VUkxfUkVQTEFDRU1FTlRfNV9fXyA9IF9fX0NTU19MT0FERVJfR0VUX1VSTF9JTVBPUlRfX18oX19fQ1NTX0xPQURFUl9VUkxfSU1QT1JUXzVfX18pO1xudmFyIF9fX0NTU19MT0FERVJfVVJMX1JFUExBQ0VNRU5UXzZfX18gPSBfX19DU1NfTE9BREVSX0dFVF9VUkxfSU1QT1JUX19fKF9fX0NTU19MT0FERVJfVVJMX0lNUE9SVF82X19fKTtcbnZhciBfX19DU1NfTE9BREVSX1VSTF9SRVBMQUNFTUVOVF83X19fID0gX19fQ1NTX0xPQURFUl9HRVRfVVJMX0lNUE9SVF9fXyhfX19DU1NfTE9BREVSX1VSTF9JTVBPUlRfN19fXyk7XG52YXIgX19fQ1NTX0xPQURFUl9VUkxfUkVQTEFDRU1FTlRfOF9fXyA9IF9fX0NTU19MT0FERVJfR0VUX1VSTF9JTVBPUlRfX18oX19fQ1NTX0xPQURFUl9VUkxfSU1QT1JUXzhfX18pO1xudmFyIF9fX0NTU19MT0FERVJfVVJMX1JFUExBQ0VNRU5UXzlfX18gPSBfX19DU1NfTE9BREVSX0dFVF9VUkxfSU1QT1JUX19fKF9fX0NTU19MT0FERVJfVVJMX0lNUE9SVF85X19fKTtcbnZhciBfX19DU1NfTE9BREVSX1VSTF9SRVBMQUNFTUVOVF8xMF9fXyA9IF9fX0NTU19MT0FERVJfR0VUX1VSTF9JTVBPUlRfX18oX19fQ1NTX0xPQURFUl9VUkxfSU1QT1JUXzEwX19fKTtcbnZhciBfX19DU1NfTE9BREVSX1VSTF9SRVBMQUNFTUVOVF8xMV9fXyA9IF9fX0NTU19MT0FERVJfR0VUX1VSTF9JTVBPUlRfX18oX19fQ1NTX0xPQURFUl9VUkxfSU1QT1JUXzExX19fKTtcbnZhciBfX19DU1NfTE9BREVSX1VSTF9SRVBMQUNFTUVOVF8xMl9fXyA9IF9fX0NTU19MT0FERVJfR0VUX1VSTF9JTVBPUlRfX18oX19fQ1NTX0xPQURFUl9VUkxfSU1QT1JUXzEyX19fKTtcbnZhciBfX19DU1NfTE9BREVSX1VSTF9SRVBMQUNFTUVOVF8xM19fXyA9IF9fX0NTU19MT0FERVJfR0VUX1VSTF9JTVBPUlRfX18oX19fQ1NTX0xPQURFUl9VUkxfSU1QT1JUXzEzX19fKTtcbnZhciBfX19DU1NfTE9BREVSX1VSTF9SRVBMQUNFTUVOVF8xNF9fXyA9IF9fX0NTU19MT0FERVJfR0VUX1VSTF9JTVBPUlRfX18oX19fQ1NTX0xPQURFUl9VUkxfSU1QT1JUXzE0X19fKTtcbi8vIE1vZHVsZVxuX19fQ1NTX0xPQURFUl9FWFBPUlRfX18ucHVzaChbbW9kdWxlLmlkLCBcIiosICo6OmJlZm9yZSwgKjo6YWZ0ZXIge1xcbiAgbWFyZ2luOiAwO1xcbiAgcGFkZGluZzogMDtcXG4gIC13ZWJraXQtYm94LXNpemluZzogYm9yZGVyLWJveDtcXG4gIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxuICAtd2Via2l0LXRhcC1oaWdobGlnaHQtY29sb3I6IHRyYW5zcGFyZW50O1xcbiAgLW1vei11c2VyLXNlbGVjdDogLW1vei1ub25lO1xcbiAgLWtodG1sLXVzZXItc2VsZWN0OiBub25lO1xcbiAgLXdlYmtpdC11c2VyLXNlbGVjdDogbm9uZTtcXG4gIC1tcy11c2VyLXNlbGVjdDogbm9uZTtcXG4gIHVzZXItc2VsZWN0OiBub25lOyB9XFxuXFxuKjo6bW96LWZvY3VzLWlubmVyIHtcXG4gIGJvcmRlcjogMDsgfVxcblxcbmh0bWwsXFxuYm9keSB7XFxuICB3aWR0aDogMTAwdnc7XFxuICBoZWlnaHQ6IDEwMHZoOyB9XFxuXFxudWwge1xcbiAgbGlzdC1zdHlsZS10eXBlOiBub25lOyB9XFxuXFxuKiB7XFxuICAtd2Via2l0LWZvbnQtc21vb3RoaW5nOiBhbnRpYWxpYXNlZDtcXG4gIC1tb3otb3N4LWZvbnQtc21vb3RoaW5nOiBncmF5c2NhbGU7XFxuICB0ZXh0LXJlbmRlcmluZzogb3B0aW1pemVMZWdpYmlsaXR5O1xcbiAgZm9udC1mYW1pbHk6ICdQb3BwaW5zJywgc2Fucy1zZXJpZjsgfVxcblxcbmJvZHkgaDEge1xcbiAgZm9udC1zaXplOiAzLjA1MnJlbTsgfVxcblxcbmJvZHkgaDIge1xcbiAgZm9udC1zaXplOiAyLjQ0MXJlbTsgfVxcblxcbmJvZHkgaDMge1xcbiAgZm9udC1zaXplOiAxLjk1M3JlbTsgfVxcblxcbmJvZHkgaDQge1xcbiAgZm9udC1zaXplOiAxLjU2M3JlbTsgfVxcblxcbmJvZHkgaDUge1xcbiAgZm9udC1zaXplOiAxLjI1cmVtOyB9XFxuXFxuYm9keSBoNiB7XFxuICBmb250LXNpemU6IDAuOHJlbTsgfVxcblxcbmJvZHkgLmJ0biwgYm9keSAuYnRuLXByaW1hcnksXFxuYm9keSAuYnRuLXNlY29uZGFyeSB7XFxuICBmb250LXNpemU6IDAuODVyZW07IH1cXG5cXG5ib2R5IGlucHV0W3R5cGU9c3VibWl0XSxcXG5ib2R5IGlucHV0W3R5cGU9dGV4dF0sXFxuYm9keSBpbnB1dFt0eXBlPWVtYWlsXSxcXG5ib2R5IHRleHRhcmVhIHtcXG4gIGZvbnQtc2l6ZTogMC44cmVtOyB9XFxuXFxuYm9keSBzbWFsbCwgYm9keSBsYWJlbCB7XFxuICBmb250LXNpemU6IDAuOHJlbTsgfVxcblxcbmJvZHkgLnRpbnktc21hbGwsIGJvZHkgLndvcmsgLmNhcmRzLWNvbnRhaW5lciAuY2FyZCBmb290ZXIgLnllYXIsIC53b3JrIC5jYXJkcy1jb250YWluZXIgLmNhcmQgZm9vdGVyIGJvZHkgLnllYXIge1xcbiAgZm9udC1zaXplOiAwLjZyZW07IH1cXG5cXG5wIHtcXG4gIGZvbnQtd2VpZ2h0OiA0MDA7IH1cXG5cXG5oMSwgaDIge1xcbiAgbGluZS1oZWlnaHQ6IDEzMCU7XFxuICBmb250LXdlaWdodDogNzAwOyB9XFxuXFxuaDMge1xcbiAgbGluZS1oZWlnaHQ6IDEzMCU7XFxuICBmb250LXdlaWdodDogNDAwOyB9XFxuXFxuaDQge1xcbiAgbGluZS1oZWlnaHQ6IDEwMCU7XFxuICBmb250LXdlaWdodDogNjAwOyB9XFxuXFxuaDUge1xcbiAgZm9udC13ZWlnaHQ6IDQwMDtcXG4gIGxpbmUtaGVpZ2h0OiAxMjAlOyB9XFxuXFxuaDYge1xcbiAgZm9udC13ZWlnaHQ6IDUwMDsgfVxcblxcbnN0cm9uZyB7XFxuICBmb250LXdlaWdodDogODAwOyB9XFxuXFxuQG1lZGlhIHNjcmVlbiBhbmQgKG1pbi13aWR0aDogMTExNnB4KSB7XFxuICBodG1sIHtcXG4gICAgZm9udC1zaXplOiAxMjUlOyB9IH1cXG5cXG5AbWVkaWEgc2NyZWVuIGFuZCAobWF4LXdpZHRoOiAxMTE2cHgpIHtcXG4gIGh0bWwge1xcbiAgICBmb250LXNpemU6IDExNSU7IH0gfVxcblxcbkBtZWRpYSBzY3JlZW4gYW5kIChtYXgtd2lkdGg6IDk1MHB4KSB7XFxuICBodG1sIHtcXG4gICAgZm9udC1zaXplOiAxMTAlOyB9IH1cXG5cXG5AbWVkaWEgc2NyZWVuIGFuZCAobWF4LXdpZHRoOiA3NTBweCkge1xcbiAgaHRtbCB7XFxuICAgIGZvbnQtc2l6ZTogMTA1JTsgfSB9XFxuXFxuQG1lZGlhIHNjcmVlbiBhbmQgKG1heC13aWR0aDogNDc1cHgpIHtcXG4gIGJvZHkgKiB7XFxuICAgIHRleHQtYWxpZ246IGNlbnRlcjsgfVxcbiAgYm9keSBoMSB7XFxuICAgIGZvbnQtc2l6ZTogMi4ycmVtOyB9XFxuICBib2R5IGgyIHtcXG4gICAgZm9udC1zaXplOiAxLjlyZW07IH1cXG4gIGJvZHkgaDMge1xcbiAgICBmb250LXNpemU6IDEuNzI4cmVtOyB9XFxuICBib2R5IGg0IHtcXG4gICAgZm9udC1zaXplOiAxLjQ0cmVtOyB9XFxuICBib2R5IGg1IHtcXG4gICAgZm9udC1zaXplOiAxLjJyZW07IH1cXG4gIGJvZHkgaDYge1xcbiAgICBmb250LXNpemU6IDAuOHJlbTsgfVxcbiAgYm9keSAuYnRuLCBib2R5IC5idG4tcHJpbWFyeSxcXG4gIGJvZHkgLmJ0bi1zZWNvbmRhcnksXFxuICBib2R5IGlucHV0W3R5cGU9c3VibWl0XSxcXG4gIGJvZHkgaW5wdXRbdHlwZT10ZXh0XSxcXG4gIGJvZHkgaW5wdXRbdHlwZT1lbWFpbF0sXFxuICBib2R5IHRleHRhcmVhIHtcXG4gICAgZm9udC1zaXplOiAwLjlyZW07IH1cXG4gIGJvZHkgc21hbGwsIGJvZHkgbGFiZWwge1xcbiAgICBmb250LXNpemU6IDAuOHJlbTsgfSB9XFxuXFxuQG1lZGlhIHNjcmVlbiBhbmQgKG1heC13aWR0aDogMzYwcHgpIHtcXG4gIGh0bWwge1xcbiAgICBmb250LXNpemU6IDEwMCU7IH0gfVxcblxcbi5yb290LCAuZGFyayB7XFxuICAtLXByaW1hcnktcGluazogI0YzNUU4NDtcXG4gIC0tcHJpbWFyeS1wdXJwbGU6ICM2RTgyRjk7XFxuICAtLXByaW1hcnktZ3JlZW46ICM5RkZCQ0U7XFxuICAtLXBpbmstcHVycGxlLWdyZDogbGluZWFyLWdyYWRpZW50KDkwZGVnLCB2YXIoLS1wcmltYXJ5LXBpbmspIDAlLCAjQUY3MEMwIDUwJSwgdmFyKC0tcHJpbWFyeS1wdXJwbGUpIDEwMCUpO1xcbiAgLS1wdXJwbGUtZ3JlZW4tZ3JkOiBsaW5lYXItZ3JhZGllbnQoOTBkZWcsIHZhcigtLXByaW1hcnktcHVycGxlKSAwJSwgIzIyQjlGRiA1MC4zMSUsICNBNkZGRDggMTAwJSwgdmFyKC0tcHJpbWFyeS1ncmVlbikgMTAwJSk7XFxuICAtLWJ0bi1waW5rLXB1cnBsZS1ncmQ6IGxpbmVhci1ncmFkaWVudCg5MGRlZywgdmFyKC0tcHJpbWFyeS1waW5rKSAwJSwgdmFyKC0tcHJpbWFyeS1waW5rKSA1MCUsIHZhcigtLXByaW1hcnktcHVycGxlKSAxMDAlKTtcXG4gIC0tYnRuLXBpbmstcHVycGxlLWdyZC1ib3JkZXI6IGxpbmVhci1ncmFkaWVudCg5MGRlZywgI0ZFMzA2NCAwLCAjRkUzMDY0IDUwJSwgIzQxNUNGRiAxMDAlKTtcXG4gIC0tYmFubmVyLWJvcmRlci1ncmQ6IGxpbmVhci1ncmFkaWVudCg5MGRlZywgI2QxZmZlOCAwJSwgcmdiYSgwLDAsMCwgMCkgMjUlLCByZ2JhKDAsMCwwLCAwKSA3NSUsICM4NjJERjcgMTAwJSk7XFxuICAtLWNvbnRhY3QtYm9yZGVyLWdyZDogbGluZWFyLWdyYWRpZW50KDEwNS44ZGVnLCAjZDFmZmU4IDAlLCByZ2JhKDAsMCwwLCAwKSAyNSUsIHJnYmEoMCwwLDAsIDApIDc1JSwgIzg2MkRGNyAxMDAlKTtcXG4gIC0tdGh1bWItZ3JkOiBsaW5lYXItZ3JhZGllbnQoMTgwZGVnLCB2YXIoLS1wcmltYXJ5LXBpbmspIDAlLCB2YXIoLS1wcmltYXJ5LXB1cnBsZSkgMTAwJSk7XFxuICAtLWNvbG9yLWVycm9yOiAjREMzNTQ1O1xcbiAgLS1jb2xvci1zdWNjZXNzOiAjMjhBNzQ1OyB9XFxuXFxuLmRhcmsge1xcbiAgLS1iZzogIzAwMDtcXG4gIC0tZmc6ICNmZmY7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1iZyk7XFxuICBjb2xvcjogdmFyKC0tZmcpOyB9XFxuICAuZGFyayBoMSwgLmRhcmsgaDIge1xcbiAgICBiYWNrZ3JvdW5kOiB2YXIoLS1waW5rLXB1cnBsZS1ncmQpO1xcbiAgICBjb2xvcjogdHJhbnNwYXJlbnQ7XFxuICAgIGJhY2tncm91bmQtY2xpcDogdGV4dDtcXG4gICAgLXdlYmtpdC1iYWNrZ3JvdW5kLWNsaXA6IHRleHQ7XFxuICAgIGRpc3BsYXk6IHRhYmxlLWNlbGw7IH1cXG4gIC5kYXJrIGEge1xcbiAgICBjb2xvcjogdmFyKC0tZmcpOyB9XFxuICAuZGFyayAuYnRuLCAuZGFyayAuYnRuLXByaW1hcnksXFxuICAuZGFyayAuYnRuLXNlY29uZGFyeSB7XFxuICAgIGNvbG9yOiB2YXIoLS1mZyk7XFxuICAgIGJveC1zaGFkb3c6IDAgMXB4IDEwcHggcmdiYSgyNDAsIDk1LCAxMzUsIDAuNSk7XFxuICAgIHRyYW5zaXRpb246IGJhY2tncm91bmQtcG9zaXRpb24gMC4zcywgYm94LXNoYWRvdyAwLjNzOyB9XFxuICAgIC5kYXJrIC5idG46OmJlZm9yZSwgLmRhcmsgLmJ0bi1wcmltYXJ5OjpiZWZvcmUsXFxuICAgIC5kYXJrIC5idG4tc2Vjb25kYXJ5OjpiZWZvcmUge1xcbiAgICAgIGNvbnRlbnQ6ICcnO1xcbiAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgICB0b3A6IDA7XFxuICAgICAgYm90dG9tOiAwO1xcbiAgICAgIGxlZnQ6IDA7XFxuICAgICAgcmlnaHQ6IDA7XFxuICAgICAgYm9yZGVyLXJhZGl1czogaW5oZXJpdDtcXG4gICAgICBwYWRkaW5nOiAycHg7XFxuICAgICAgYmFja2dyb3VuZDogdmFyKC0tYnRuLXBpbmstcHVycGxlLWdyZC1ib3JkZXIpO1xcbiAgICAgIGJhY2tncm91bmQtc2l6ZTogMjAwJSAxMDAlO1xcbiAgICAgIGJhY2tncm91bmQtcG9zaXRpb246IHJpZ2h0IGNlbnRlcjtcXG4gICAgICAtd2Via2l0LW1hc2s6IGxpbmVhci1ncmFkaWVudCgjZmZmIDAgMCkgY29udGVudC1ib3gsIGxpbmVhci1ncmFkaWVudCgjZmZmIDAgMCk7XFxuICAgICAgLXdlYmtpdC1tYXNrLWNvbXBvc2l0ZTogeG9yO1xcbiAgICAgIG1hc2stY29tcG9zaXRlOiBleGNsdWRlO1xcbiAgICAgIHRyYW5zaXRpb246IGluaGVyaXQ7IH1cXG4gICAgLmRhcmsgLmJ0bjpob3Zlcjo6YmVmb3JlLCAuZGFyayAuYnRuLXByaW1hcnk6aG92ZXI6OmJlZm9yZSxcXG4gICAgLmRhcmsgLmJ0bi1zZWNvbmRhcnk6aG92ZXI6OmJlZm9yZSB7XFxuICAgICAgYmFja2dyb3VuZC1wb3NpdGlvbjogbGVmdCBjZW50ZXI7IH1cXG4gICAgLmRhcmsgLmJ0bjpob3ZlciwgLmRhcmsgLmJ0bi1wcmltYXJ5OmhvdmVyLFxcbiAgICAuZGFyayAuYnRuLXNlY29uZGFyeTpob3ZlciB7XFxuICAgICAgYm94LXNoYWRvdzogMCAxcHggMjVweCByZ2JhKDI0MCwgOTUsIDEzNSwgMC41KTsgfVxcbiAgLmRhcmsgLmJ0bi1wcmltYXJ5IHtcXG4gICAgYmFja2dyb3VuZC1pbWFnZTogdmFyKC0tYnRuLXBpbmstcHVycGxlLWdyZCk7XFxuICAgIGJhY2tncm91bmQtc2l6ZTogMjAwJSBhdXRvO1xcbiAgICBiYWNrZ3JvdW5kLXBvc2l0aW9uOiAxMDAlIDUwJTsgfVxcbiAgICAuZGFyayAuYnRuLXByaW1hcnkgLmJ0bi1pY29uIHtcXG4gICAgICB0cmFuc2l0aW9uOiB0cmFuc2Zvcm0gMC4zczsgfVxcbiAgICAuZGFyayAuYnRuLXByaW1hcnk6aG92ZXIge1xcbiAgICAgIGJhY2tncm91bmQtcG9zaXRpb246IGxlZnQgY2VudGVyOyB9XFxuICAuZGFyayAuYnRuLXNlY29uZGFyeSB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHZhcigtLWJnKTsgfVxcbiAgLmRhcmsgZm9ybSB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6ICMyNzI3Mjc7IH1cXG4gIC5kYXJrIGlucHV0W3R5cGU9dGV4dF0sIC5kYXJrIGlucHV0W3R5cGU9ZW1haWxdLCAuZGFyayB0ZXh0YXJlYSB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6ICMxRjFGMUY7XFxuICAgIGJvcmRlci1jb2xvcjogdHJhbnNwYXJlbnQ7XFxuICAgIHRyYW5zaXRpb246IGJvcmRlci1jb2xvciAwLjFzIGVhc2Utb3V0LCBiYWNrZ3JvdW5kLWNvbG9yIDAuMnMgZWFzZS1vdXQ7XFxuICAgIGNvbG9yOiAjZmZmZmZmOyB9XFxuICAgIC5kYXJrIGlucHV0W3R5cGU9dGV4dF06aG92ZXIsIC5kYXJrIGlucHV0W3R5cGU9ZW1haWxdOmhvdmVyLCAuZGFyayB0ZXh0YXJlYTpob3ZlciB7XFxuICAgICAgYm9yZGVyLWNvbG9yOiAjNjA2MDYwICFpbXBvcnRhbnQ7IH1cXG4gICAgLmRhcmsgaW5wdXRbdHlwZT10ZXh0XTpmb2N1cywgLmRhcmsgaW5wdXRbdHlwZT1lbWFpbF06Zm9jdXMsIC5kYXJrIHRleHRhcmVhOmZvY3VzIHtcXG4gICAgICBib3JkZXItY29sb3I6IHZhcigtLXByaW1hcnktcHVycGxlKSAhaW1wb3J0YW50O1xcbiAgICAgIGJhY2tncm91bmQtY29sb3I6ICMxNDE0MTQ7IH1cXG4gIC5kYXJrIC5lcnJvci1tc2cge1xcbiAgICBjb2xvcjogdmFyKC0tY29sb3ItZXJyb3IpOyB9XFxuICAuZGFyayAubWUgLmV4cCB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6ICMxQTFBMUE7IH1cXG4gICAgLmRhcmsgLm1lIC5leHAgI3llYXJzIHtcXG4gICAgICBjb2xvcjogdmFyKC0tcHJpbWFyeS1ncmVlbik7IH1cXG4gIC5kYXJrIC5za2lsbHMgLmR1dGllcyAuYWN0aXZlLWR1dHkge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjMUExQTFBOyB9XFxuICAuZGFyayAuc2tpbGxzIC50ZWNoLXRvb2xzIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogIzFBMUExQTsgfVxcbiAgLmRhcmsgbGFiZWxbaW1wb3J0YW5jZT0nY3J1Y2lhbCddOjphZnRlciB7XFxuICAgIGNvbnRlbnQ6ICcqJztcXG4gICAgY29sb3I6IHZhcigtLWNvbG9yLWVycm9yKTsgfVxcblxcbioge1xcbiAgc2Nyb2xsLWJlaGF2aW9yOiBzbW9vdGg7XFxuICBtYXJnaW46IDA7XFxuICBwYWRkaW5nOiAwO1xcbiAgYm94LXNpemluZzogYm9yZGVyLWJveDsgfVxcblxcbio6bm90KHRleHRhcmVhKTpmb2N1cyB7XFxuICBvdXRsaW5lOiAyLjVweCBkYXNoZWQgdmFyKC0tcHJpbWFyeS1wdXJwbGUpO1xcbiAgb3V0bGluZS1vZmZzZXQ6IDVweDsgfVxcblxcbmJvZHk6Oi13ZWJraXQtc2Nyb2xsYmFyIHtcXG4gIGJhY2tncm91bmQtY29sb3I6ICMwMDA7XFxuICB3aWR0aDogMC41NXJlbTtcXG4gIGhlaWdodDogMC41NXJlbTsgfVxcblxcbmJvZHk6Oi13ZWJraXQtc2Nyb2xsYmFyLXRodW1iIHtcXG4gIGJvcmRlcjogNHB4IHNvbGlkIHJnYmEoMCwgMCwgMCwgMCk7XFxuICBiYWNrZ3JvdW5kLWNsaXA6IHBhZGRpbmctYm94O1xcbiAgYm9yZGVyLXJhZGl1czogMTBweDtcXG4gIGJhY2tncm91bmQtY29sb3I6ICNBQUFBQUE7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1wcmltYXJ5LXBpbmspOyB9XFxuXFxuLmNvbnRhaW5lciB7XFxuICB3aWR0aDogOTAlO1xcbiAgbWF4LXdpZHRoOiAxNjAwcHg7XFxuICBtYXJnaW46IDAgYXV0bzsgfVxcblxcbi53aWRlLWJhbm5lciwgLmxhbmRpbmcgLmhvYmJpZXMsIC5tZSAucmVzdW1lIHtcXG4gIC13ZWJraXQtYmFja2Ryb3AtZmlsdGVyOiBibHVyKDUwcHgpO1xcbiAgYmFja2Ryb3AtZmlsdGVyOiBibHVyKDUwcHgpO1xcbiAgd2lkdGg6IDEwMHZ3O1xcbiAgcG9zaXRpb246IHJlbGF0aXZlOyB9XFxuICBAc3VwcG9ydHMgbm90IChiYWNrZHJvcC1maWx0ZXI6IG5vbmUpIHtcXG4gICAgLndpZGUtYmFubmVyLCAubGFuZGluZyAuaG9iYmllcywgLm1lIC5yZXN1bWUge1xcbiAgICAgIGJhY2tncm91bmQtY29sb3I6ICMxNDE0MTQ7IH0gfVxcbiAgLndpZGUtYmFubmVyOjpiZWZvcmUsIC5sYW5kaW5nIC5ob2JiaWVzOjpiZWZvcmUsIC5tZSAucmVzdW1lOjpiZWZvcmUsIC53aWRlLWJhbm5lcjo6YWZ0ZXIsIC5sYW5kaW5nIC5ob2JiaWVzOjphZnRlciwgLm1lIC5yZXN1bWU6OmFmdGVyIHtcXG4gICAgY29udGVudDogJyc7XFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgbGVmdDogMDtcXG4gICAgd2lkdGg6IDEwMHZ3O1xcbiAgICBoZWlnaHQ6IDEuNXB4O1xcbiAgICBiYWNrZ3JvdW5kOiB2YXIoLS1iYW5uZXItYm9yZGVyLWdyZCk7IH1cXG4gIC53aWRlLWJhbm5lcjo6YmVmb3JlLCAubGFuZGluZyAuaG9iYmllczo6YmVmb3JlLCAubWUgLnJlc3VtZTo6YmVmb3JlIHtcXG4gICAgdG9wOiAwOyB9XFxuICAud2lkZS1iYW5uZXI6OmFmdGVyLCAubGFuZGluZyAuaG9iYmllczo6YWZ0ZXIsIC5tZSAucmVzdW1lOjphZnRlciB7XFxuICAgIGJvdHRvbTogMDsgfVxcblxcbi5ub3QtY2VudGVyZWQsIC5sYW5kaW5nIC5ob2JiaWVzIC5ob2JieSwgLndvcmsgLmNhcmRzLWNvbnRhaW5lciwgLmNvbnRhY3Qge1xcbiAgdGV4dC1hbGlnbjogbGVmdCAhaW1wb3J0YW50OyB9XFxuICAubm90LWNlbnRlcmVkICosIC5sYW5kaW5nIC5ob2JiaWVzIC5ob2JieSAqLCAud29yayAuY2FyZHMtY29udGFpbmVyICosIC5jb250YWN0ICoge1xcbiAgICB0ZXh0LWFsaWduOiBsZWZ0ICFpbXBvcnRhbnQ7IH1cXG5cXG5hIHtcXG4gIHRleHQtZGVjb3JhdGlvbjogbm9uZTtcXG4gIGRpc3BsYXk6IGlubGluZS1ibG9jazsgfVxcblxcbmEsIGJ1dHRvbiB7XFxuICBjdXJzb3I6IHBvaW50ZXI7IH1cXG5cXG4uYnRuLCAuYnRuLXByaW1hcnksXFxuLmJ0bi1zZWNvbmRhcnksXFxuYnV0dG9uLFxcbmlucHV0W3R5cGU9c3VibWl0XSxcXG5pbnB1dFt0eXBlPXRleHRdLFxcbmlucHV0W3R5cGU9ZW1haWxdLFxcbnRleHRhcmVhIHtcXG4gIGJvcmRlcjogbm9uZTsgfVxcblxcbnRleHRhcmVhIHtcXG4gIHJlc2l6ZTogbm9uZTsgfVxcblxcbmlucHV0W3R5cGU9dGV4dF0sXFxuaW5wdXRbdHlwZT1lbWFpbF0sXFxudGV4dGFyZWEge1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgZGlzcGxheTogYmxvY2s7XFxuICB3aWR0aDogMTAwJTtcXG4gIGJvcmRlci13aWR0aDogMnB4O1xcbiAgYm9yZGVyLXN0eWxlOiBzb2xpZDtcXG4gIGJvcmRlci1yYWRpdXM6IDEwcHg7XFxuICBwYWRkaW5nOiAwLjVyZW0gMC43cmVtO1xcbiAgb3V0bGluZTogbm9uZTsgfVxcblxcbnRleHRhcmVhIHtcXG4gIGhlaWdodDogYXV0bzsgfVxcblxcbi5idG4sIC5idG4tcHJpbWFyeSxcXG4uYnRuLXNlY29uZGFyeSB7XFxuICBib3JkZXItcmFkaXVzOiA2cHg7XFxuICBwYWRkaW5nOiAwLjVyZW0gMS41cmVtO1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgZGlzcGxheTogZmxleDtcXG4gIGp1c3RpZnktY29udGVudDogY2VudGVyO1xcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gIGZsZXgtZGlyZWN0aW9uOiByb3c7XFxuICBncmlkLWdhcDogMC4yNXJlbTtcXG4gIGZsZXgtc2hyaW5rOiAwOyB9XFxuICAuYnRuIC5idG4taWNvbiwgLmJ0bi1wcmltYXJ5IC5idG4taWNvbiwgLmJ0bi1zZWNvbmRhcnkgLmJ0bi1pY29uIHtcXG4gICAgd2lkdGg6IDIycHg7XFxuICAgIGhlaWdodDogMjJweDtcXG4gICAgYmFja2dyb3VuZC1yZXBlYXQ6IG5vLXJlcGVhdDtcXG4gICAgYmFja2dyb3VuZC1zaXplOiBjb3ZlcjsgfVxcblxcbi5idG4tcHJpbWFyeSAuYnRuLWljb24ge1xcbiAgYmFja2dyb3VuZC1pbWFnZTogdXJsKFwiICsgX19fQ1NTX0xPQURFUl9VUkxfUkVQTEFDRU1FTlRfMF9fXyArIFwiKTsgfVxcblxcbi5idG4tcHJpbWFyeTpob3ZlciAuYnRuLWljb24ge1xcbiAgdHJhbnNmb3JtOiB0cmFuc2xhdGVYKDVweCk7IH1cXG5cXG4uYnRuLXNlY29uZGFyeSB7XFxuICBmbGV4LWRpcmVjdGlvbjogcm93LXJldmVyc2U7XFxuICBnYXA6IDEwcHg7IH1cXG5cXG4uaGVhZGVyLWJ0biB7XFxuICBwYWRkaW5nOiAwLjM1cmVtIDEuNXJlbTsgfVxcbiAgLmhlYWRlci1idG4gLmJ0bi1pY29uIHtcXG4gICAgd2lkdGg6IDE1cHg7XFxuICAgIGhlaWdodDogMTVweDsgfVxcblxcbmh0bWwge1xcbiAgd2lkdGg6IDEwMCU7XFxuICBoZWlnaHQ6IDEwMCU7XFxuICBoZWlnaHQ6IC13ZWJraXQtc3RyZXRjaDsgfVxcblxcbmJvZHkge1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgb3ZlcmZsb3cteDogaGlkZGVuO1xcbiAgd2lkdGg6IGluaGVyaXQ7XFxuICBoZWlnaHQ6IGluaGVyaXQ7IH1cXG4gIGJvZHkgbWFpbiB7XFxuICAgIHdpZHRoOiBpbmhlcml0O1xcbiAgICBoZWlnaHQ6IGluaGVyaXQ7IH1cXG5cXG4uZml4IHtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTsgfVxcblxcbi5sYW5kaW5nIHtcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gIG1pbi1oZWlnaHQ6IDEwMCU7XFxuICBkaXNwbGF5OiBncmlkO1xcbiAgZ3JpZC10ZW1wbGF0ZS1yb3dzOiBhdXRvIDFmciBhdXRvOyB9XFxuICAubGFuZGluZyA+IC5jb250YWluZXIge1xcbiAgICBncmlkLXJvdzogMi8zO1xcbiAgICBhbGlnbi1zZWxmOiBjZW50ZXI7IH1cXG4gIC5sYW5kaW5nIGhlYWRlciB7XFxuICAgIGdyaWQtcm93OiAxLzI7XFxuICAgIG1pbi13aWR0aDogMTAwdnc7XFxuICAgIHdpZHRoOiAxMDB2dztcXG4gICAgei1pbmRleDogMztcXG4gICAgLXdlYmtpdC1iYWNrZHJvcC1maWx0ZXI6IGJsdXIoNTBweCk7XFxuICAgIGJhY2tkcm9wLWZpbHRlcjogYmx1cig1MHB4KTtcXG4gICAgYm9yZGVyLWJvdHRvbTogMXB4IHNvbGlkICNmZmY7IH1cXG4gICAgQHN1cHBvcnRzIG5vdCAoYmFja2Ryb3AtZmlsdGVyOiBub25lKSB7XFxuICAgICAgLmxhbmRpbmcgaGVhZGVyIHtcXG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6ICMxNDE0MTQ7IH0gfVxcbiAgICAubGFuZGluZyBoZWFkZXIgLmNvbnRhaW5lciB7XFxuICAgICAgZGlzcGxheTogZ3JpZDtcXG4gICAgICBncmlkLXRlbXBsYXRlLWNvbHVtbnM6IDFmciAzZnIgMWZyOyB9XFxuICAgICAgLmxhbmRpbmcgaGVhZGVyIC5jb250YWluZXIgLmRlc2t0b3AtbmF2IHtcXG4gICAgICAgIGdyaWQtY29sdW1uOiAyLzM7XFxuICAgICAgICBkaXNwbGF5OiBmbGV4O1xcbiAgICAgICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XFxuICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgICAgICAgZmxleC1kaXJlY3Rpb246IHJvdztcXG4gICAgICAgIGdyaWQtZ2FwOiAycmVtOyB9XFxuICAgICAgICAubGFuZGluZyBoZWFkZXIgLmNvbnRhaW5lciAuZGVza3RvcC1uYXYgLmxvZ28ge1xcbiAgICAgICAgICB3aWR0aDogNzBweDtcXG4gICAgICAgICAgaGVpZ2h0OiA3MHB4O1xcbiAgICAgICAgICBvdmVyZmxvdzogaGlkZGVuOyB9XFxuICAgICAgICAgIC5sYW5kaW5nIGhlYWRlciAuY29udGFpbmVyIC5kZXNrdG9wLW5hdiAubG9nbyBzdmcge1xcbiAgICAgICAgICAgIHdpZHRoOiBpbmhlcml0O1xcbiAgICAgICAgICAgIGhlaWdodDogaW5oZXJpdDsgfVxcbiAgICAgICAgLmxhbmRpbmcgaGVhZGVyIC5jb250YWluZXIgLmRlc2t0b3AtbmF2IC5kZXNrdG9wLWxpbmtzIHtcXG4gICAgICAgICAgZGlzcGxheTogZmxleDtcXG4gICAgICAgICAganVzdGlmeS1jb250ZW50OiBpbmhlcml0O1xcbiAgICAgICAgICBhbGlnbi1pdGVtczogaW5oZXJpdDtcXG4gICAgICAgICAgZmxleC1kaXJlY3Rpb246IGluaGVyaXQ7XFxuICAgICAgICAgIGdyaWQtZ2FwOiBpbmhlcml0OyB9XFxuICAgICAgICAgIC5sYW5kaW5nIGhlYWRlciAuY29udGFpbmVyIC5kZXNrdG9wLW5hdiAuZGVza3RvcC1saW5rcyAuc2VjdGlvbi1saW5rIGEge1xcbiAgICAgICAgICAgIHRleHQtdHJhbnNmb3JtOiB1cHBlcmNhc2U7XFxuICAgICAgICAgICAgZm9udC1zaXplOiA5MCU7XFxuICAgICAgICAgICAgcGFkZGluZzogMC4yNXJlbSAwLjRyZW07XFxuICAgICAgICAgICAgYm9yZGVyLXJhZGl1czogNXB4O1xcbiAgICAgICAgICAgIHRyYW5zaXRpb246IGJhY2tncm91bmQtY29sb3IgMC4xNXMgZWFzZS1pbjsgfVxcbiAgICAgICAgICAgIC5sYW5kaW5nIGhlYWRlciAuY29udGFpbmVyIC5kZXNrdG9wLW5hdiAuZGVza3RvcC1saW5rcyAuc2VjdGlvbi1saW5rIGE6aG92ZXIge1xcbiAgICAgICAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tcHJpbWFyeS1wdXJwbGUpOyB9XFxuICAgICAgLmxhbmRpbmcgaGVhZGVyIC5jb250YWluZXIgLmhlYWRlci1idG4ge1xcbiAgICAgICAgZ3JpZC1jb2x1bW46IDMvNDtcXG4gICAgICAgIGp1c3RpZnktc2VsZjogZW5kO1xcbiAgICAgICAgYWxpZ24tc2VsZjogY2VudGVyO1xcbiAgICAgICAgd2lkdGg6IGZpdC1jb250ZW50ICFpbXBvcnRhbnQ7IH1cXG4gICAgICAubGFuZGluZyBoZWFkZXIgLmNvbnRhaW5lciAuYnRuLWhhbSB7XFxuICAgICAgICB6LWluZGV4OiAyO1xcbiAgICAgICAgd2lkdGg6IDI1cHg7XFxuICAgICAgICBoZWlnaHQ6IDI1cHg7IH1cXG4gICAgICAgIC5sYW5kaW5nIGhlYWRlciAuY29udGFpbmVyIC5idG4taGFtIGltZyB7XFxuICAgICAgICAgIHdpZHRoOiBpbmhlcml0O1xcbiAgICAgICAgICBoZWlnaHQ6IGluaGVyaXQ7IH1cXG4gICAgICAubGFuZGluZyBoZWFkZXIgLmNvbnRhaW5lciAubW9iaWxlLW5hdiB7XFxuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgICAgICB0b3A6IDUwcHg7XFxuICAgICAgICBsZWZ0OiAwO1xcbiAgICAgICAgd2lkdGg6IDEwMHZ3O1xcbiAgICAgICAgaGVpZ2h0OiBjYWxjKDEwMHZoIC0gNTBweCk7XFxuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1iZyk7XFxuICAgICAgICBkaXNwbGF5OiBub25lOyB9XFxuICAgICAgICAubGFuZGluZyBoZWFkZXIgLmNvbnRhaW5lciAubW9iaWxlLW5hdiB1bCB7XFxuICAgICAgICAgIHBhZGRpbmc6IDNyZW0gMS41cmVtO1xcbiAgICAgICAgICBkaXNwbGF5OiBmbGV4O1xcbiAgICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcXG4gICAgICAgICAgYWxpZ24taXRlbXM6IHN0YXJ0O1xcbiAgICAgICAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xcbiAgICAgICAgICBncmlkLWdhcDogMC4zcmVtOyB9XFxuICAgICAgICAgIC5sYW5kaW5nIGhlYWRlciAuY29udGFpbmVyIC5tb2JpbGUtbmF2IHVsIC5oYW0tbGluayB7XFxuICAgICAgICAgICAgZm9udC1zaXplOiAxMzAlO1xcbiAgICAgICAgICAgIHRleHQtZGVjb3JhdGlvbjogdW5kZXJsaW5lOyB9XFxuICAgICAgICAubGFuZGluZyBoZWFkZXIgLmNvbnRhaW5lciAubW9iaWxlLW5hdiAuaGFtLWltZyB7XFxuICAgICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgICAgICAgd2lkdGg6IDEzMCU7XFxuICAgICAgICAgIGhlaWdodDogYXV0bztcXG4gICAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGUoLTUwJSwgMCk7XFxuICAgICAgICAgIGxlZnQ6IDUwJTtcXG4gICAgICAgICAgYm90dG9tOiAtMTIlO1xcbiAgICAgICAgICBkaXNwbGF5OiBub25lOyB9XFxuICAgICAgLmxhbmRpbmcgaGVhZGVyIC5jb250YWluZXIgLmJ0bi1oYW0sIC5sYW5kaW5nIGhlYWRlciAuY29udGFpbmVyIC5tb2JpbGUtbmF2IHtcXG4gICAgICAgIGRpc3BsYXk6IG5vbmU7IH1cXG4gIC5sYW5kaW5nIC5zdGlja3kge1xcbiAgICBwb3NpdGlvbjogZml4ZWQ7XFxuICAgIHRvcDogMDtcXG4gICAgd2lkdGg6IDEwMCU7IH1cXG4gIC5sYW5kaW5nIC5oZXJvIHtcXG4gICAgcGFkZGluZzogMi41cmVtIDA7IH1cXG4gICAgLmxhbmRpbmcgLmhlcm8gLmhlcm8tdGV4dCAuaGVyby1oZWFkaW5nIHtcXG4gICAgICBkaXNwbGF5OiBmbGV4O1xcbiAgICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xcbiAgICAgIGFsaWduLWl0ZW1zOiBzdGFydDtcXG4gICAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xcbiAgICAgIGdyaWQtZ2FwOiAwcmVtOyB9XFxuICAgICAgLmxhbmRpbmcgLmhlcm8gLmhlcm8tdGV4dCAuaGVyby1oZWFkaW5nICNxdWFsaXRpZXMge1xcbiAgICAgICAgbGluZS1oZWlnaHQ6IDEuMmVtO1xcbiAgICAgICAgaGVpZ2h0OiAxLjJlbTtcXG4gICAgICAgIGJhY2tncm91bmQ6IHZhcigtLXB1cnBsZS1ncmVlbi1ncmQpO1xcbiAgICAgICAgY29sb3I6IHRyYW5zcGFyZW50O1xcbiAgICAgICAgYmFja2dyb3VuZC1jbGlwOiB0ZXh0O1xcbiAgICAgICAgLXdlYmtpdC1iYWNrZ3JvdW5kLWNsaXA6IHRleHQ7XFxuICAgICAgICBkaXNwbGF5OiB0YWJsZS1jZWxsO1xcbiAgICAgICAgdGV4dC10cmFuc2Zvcm06IHVwcGVyY2FzZTsgfVxcbiAgICAgICAgLmxhbmRpbmcgLmhlcm8gLmhlcm8tdGV4dCAuaGVyby1oZWFkaW5nICNxdWFsaXRpZXMgLnR5cGVkLWN1cnNvciB7XFxuICAgICAgICAgIGZvbnQtd2VpZ2h0OiAzMDA7XFxuICAgICAgICAgIGFuaW1hdGlvbjogYmxpbmsgMS41cyBzdGVwcyg1LCBzdGFydCkgaW5maW5pdGU7IH1cXG5cXG5Aa2V5ZnJhbWVzIGJsaW5rIHtcXG4gIHRvIHtcXG4gICAgdmlzaWJpbGl0eTogaGlkZGVuOyB9IH1cXG4gICAgLmxhbmRpbmcgLmhlcm8gLmN0YXMge1xcbiAgICAgIG1hcmdpbi10b3A6IDJyZW07XFxuICAgICAgZGlzcGxheTogZmxleDtcXG4gICAgICBqdXN0aWZ5LWNvbnRlbnQ6IHN0YXJ0O1xcbiAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICAgICAgZmxleC1kaXJlY3Rpb246IHJvdztcXG4gICAgICBncmlkLWdhcDogMXJlbTsgfVxcbiAgICAgIC5sYW5kaW5nIC5oZXJvIC5jdGFzICNidG4td29yayAuYnRuLWljb24ge1xcbiAgICAgICAgZGlzcGxheTogbm9uZTsgfVxcbiAgLmxhbmRpbmcgLmhvYmJpZXMge1xcbiAgICBncmlkLXJvdzogMy80O1xcbiAgICB6LWluZGV4OiAyO1xcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICAgIHBhZGRpbmc6IDAuNnJlbSAxcmVtO1xcbiAgICBvdmVyZmxvdzogaGlkZGVuOyB9XFxuICAgIC5sYW5kaW5nIC5ob2JiaWVzIC5jb250YWluZXIge1xcbiAgICAgIGRpc3BsYXk6IGZsZXg7XFxuICAgICAganVzdGlmeS1jb250ZW50OiBzcGFjZS1hcm91bmQ7XFxuICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gICAgICBmbGV4LWRpcmVjdGlvbjogcm93O1xcbiAgICAgIGdyaWQtZ2FwOiAxLjVyZW07IH1cXG4gICAgLmxhbmRpbmcgLmhvYmJpZXMgLmhvYmJ5IHtcXG4gICAgICBwYWRkaW5nOiAwLjVyZW0gMXJlbTtcXG4gICAgICBwb2ludGVyLWV2ZW50czogbm9uZTsgfVxcbiAgICAgIC5sYW5kaW5nIC5ob2JiaWVzIC5ob2JieSBhIHtcXG4gICAgICAgIGRpc3BsYXk6IGZsZXg7XFxuICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IHN0YXJ0O1xcbiAgICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gICAgICAgIGZsZXgtZGlyZWN0aW9uOiByb3c7XFxuICAgICAgICBncmlkLWdhcDogMC41cmVtOyB9XFxuICAgICAgICAubGFuZGluZyAuaG9iYmllcyAuaG9iYnkgYSAubmFtZSAuaG9iYnktdSwgLmxhbmRpbmcgLmhvYmJpZXMgLmhvYmJ5IGEgLm5hbWUgLmhvYmJ5LWwge1xcbiAgICAgICAgICBmb250LXdlaWdodDogNjAwOyB9XFxuICAgICAgICAubGFuZGluZyAuaG9iYmllcyAuaG9iYnkgYSAubmFtZSAuaG9iYnktbCB7XFxuICAgICAgICAgIG1hcmdpbi10b3A6IC0wLjNyZW07XFxuICAgICAgICAgIG9wYWNpdHk6IDAuNjsgfVxcbiAgICAgICAgLmxhbmRpbmcgLmhvYmJpZXMgLmhvYmJ5IGEgaW1nIHtcXG4gICAgICAgICAgd2lkdGg6IDY1cHg7XFxuICAgICAgICAgIGhlaWdodDogNjVweDsgfVxcbiAgICAubGFuZGluZyAuaG9iYmllcyAjZGV2ZWxvcGVyIC5uYW1lIHtcXG4gICAgICBwb3NpdGlvbjogcmVsYXRpdmU7IH1cXG4gICAgICAubGFuZGluZyAuaG9iYmllcyAjZGV2ZWxvcGVyIC5uYW1lICNzcXVpZ2dseS1saW5lIHtcXG4gICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgICAgIHRvcDogNTAlO1xcbiAgICAgICAgbGVmdDogNTAlO1xcbiAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGUoLTUwJSwgLTUwJSk7XFxuICAgICAgICB3aWR0aDogMTAwJTtcXG4gICAgICAgIHRvcDogMTE1JTsgfVxcbiAgICAubGFuZGluZyAuaG9iYmllcyAjZGVzaWduZXIge1xcbiAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gICAgICBib3JkZXI6IDJweCBzb2xpZCAjMThBMEZCOyB9XFxuICAgICAgLmxhbmRpbmcgLmhvYmJpZXMgI2Rlc2lnbmVyIC5vdXRsaW5lLFxcbiAgICAgIC5sYW5kaW5nIC5ob2JiaWVzICNkZXNpZ25lciAubWluaS1zcSB7XFxuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7IH1cXG4gICAgICAubGFuZGluZyAuaG9iYmllcyAjZGVzaWduZXIgLm1pbmktc3Ege1xcbiAgICAgICAgd2lkdGg6IDE0cHg7XFxuICAgICAgICBoZWlnaHQ6IDE0cHg7XFxuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjZmZmO1xcbiAgICAgICAgYm9yZGVyOiAycHggc29saWQgIzE4QTBGQjtcXG4gICAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlKC01MCUsIC01MCUpOyB9XFxuICAgICAgLmxhbmRpbmcgLmhvYmJpZXMgI2Rlc2lnbmVyICN1cHBlci1sZWZ0IHtcXG4gICAgICAgIHRvcDogMDtcXG4gICAgICAgIGxlZnQ6IDA7IH1cXG4gICAgICAubGFuZGluZyAuaG9iYmllcyAjZGVzaWduZXIgI3VwcGVyLXJpZ2h0IHtcXG4gICAgICAgIHRvcDogMDtcXG4gICAgICAgIGxlZnQ6IDEwMCU7IH1cXG4gICAgICAubGFuZGluZyAuaG9iYmllcyAjZGVzaWduZXIgI2xvd2VyLWxlZnQge1xcbiAgICAgICAgdG9wOiAxMDAlO1xcbiAgICAgICAgbGVmdDogMDsgfVxcbiAgICAgIC5sYW5kaW5nIC5ob2JiaWVzICNkZXNpZ25lciAjbG93ZXItcmlnaHQge1xcbiAgICAgICAgdG9wOiAxMDAlO1xcbiAgICAgICAgbGVmdDogMTAwJTsgfVxcblxcbkBtZWRpYSBzY3JlZW4gYW5kIChtYXgtd2lkdGg6IDE0MDBweCkge1xcbiAgLmxhbmRpbmcgLmNvbnRhaW5lciAuaGVyby1pbWFnZSB7XFxuICAgIHdpZHRoOiBhdXRvO1xcbiAgICBoZWlnaHQ6IDY1dmg7IH0gfVxcblxcbkBtZWRpYSBzY3JlZW4gYW5kIChtYXgtd2lkdGg6IDExMTZweCkge1xcbiAgLmxhbmRpbmcgLmhvYmJpZXMge1xcbiAgICBwYWRkaW5nOiAwLjZyZW07XFxuICAgIGdyaWQtZ2FwOiAwLjc1cmVtOyB9XFxuICAgIC5sYW5kaW5nIC5ob2JiaWVzIC5ob2JieSB7XFxuICAgICAgcGFkZGluZzogMC41cmVtO1xcbiAgICAgIGdyaWQtZ2FwOiAwLjc1cmVtOyB9XFxuICAgICAgLmxhbmRpbmcgLmhvYmJpZXMgLmhvYmJ5IC5pbWctaG9iYnkge1xcbiAgICAgICAgd2lkdGg6IDYwcHg7XFxuICAgICAgICBoZWlnaHQ6IDYwcHg7IH0gfVxcblxcbkBtZWRpYSBzY3JlZW4gYW5kIChtYXgtd2lkdGg6IDk1MHB4KSB7XFxuICAubGFuZGluZyBoZWFkZXIgLmNvbnRhaW5lciB7XFxuICAgIGdyaWQtdGVtcGxhdGUtY29sdW1uczogMWZyIGF1dG87IH1cXG4gICAgLmxhbmRpbmcgaGVhZGVyIC5jb250YWluZXIgLmRlc2t0b3AtbmF2IHtcXG4gICAgICBncmlkLWNvbHVtbjogMTtcXG4gICAgICBqdXN0aWZ5LWNvbnRlbnQ6IHN0YXJ0O1xcbiAgICAgIGdhcDogMXJlbTsgfVxcbiAgICAgIC5sYW5kaW5nIGhlYWRlciAuY29udGFpbmVyIC5kZXNrdG9wLW5hdiAubG9nbyB7XFxuICAgICAgICBvcmRlcjogMTsgfVxcbiAgICAgIC5sYW5kaW5nIGhlYWRlciAuY29udGFpbmVyIC5kZXNrdG9wLW5hdiAuZGVza3RvcC1saW5rcyB7XFxuICAgICAgICBvcmRlcjogMjsgfVxcbiAgICAubGFuZGluZyBoZWFkZXIgLmNvbnRhaW5lciAuYnRuLCAubGFuZGluZyBoZWFkZXIgLmNvbnRhaW5lciAuYnRuLXByaW1hcnksXFxuICAgIC5sYW5kaW5nIGhlYWRlciAuY29udGFpbmVyIC5idG4tc2Vjb25kYXJ5IHtcXG4gICAgICBncmlkLWNvbHVtbjogMjsgfVxcbiAgLmxhbmRpbmcgLmNvbnRhaW5lciAuaGVyby1pbWFnZSB7XFxuICAgIHdpZHRoOiBhdXRvO1xcbiAgICBoZWlnaHQ6IDQwdmg7IH0gfVxcblxcbkBtZWRpYSBzY3JlZW4gYW5kIChtYXgtd2lkdGg6IDgxMHB4KSB7XFxuICAubGFuZGluZyAuY29udGFpbmVyIC5oZXJvIC5oZXJvLXRleHQge1xcbiAgICB0ZXh0LWFsaWduOiBjZW50ZXI7IH1cXG4gICAgLmxhbmRpbmcgLmNvbnRhaW5lciAuaGVybyAuaGVyby10ZXh0IC5oZXJvLWhlYWRpbmcge1xcbiAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7IH1cXG4gIC5sYW5kaW5nIC5jb250YWluZXIgLmhlcm8gLmN0YXMge1xcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjsgfSB9XFxuXFxuQG1lZGlhIHNjcmVlbiBhbmQgKG1heC13aWR0aDogNzUwcHgpIHtcXG4gIC5sYW5kaW5nIC5jb250YWluZXIge1xcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IHN0YXJ0OyB9IH1cXG5cXG5AbWVkaWEgc2NyZWVuIGFuZCAobWF4LXdpZHRoOiA2NTBweCkge1xcbiAgLmxhbmRpbmcgaGVhZGVyIC5jb250YWluZXIge1xcbiAgICBncmlkLXRlbXBsYXRlLWNvbHVtbnM6IDFmciAyZnIgMWZyO1xcbiAgICBhbGlnbi1pdGVtczogY2VudGVyOyB9XFxuICAgIC5sYW5kaW5nIGhlYWRlciAuY29udGFpbmVyIC5kZXNrdG9wLW5hdiB7XFxuICAgICAgZ3JpZC1jb2x1bW46IDI7XFxuICAgICAganVzdGlmeS1zZWxmOiBjZW50ZXI7IH1cXG4gICAgICAubGFuZGluZyBoZWFkZXIgLmNvbnRhaW5lciAuZGVza3RvcC1uYXYgLmxvZ28ge1xcbiAgICAgICAgd2lkdGg6IDUwcHg7XFxuICAgICAgICBoZWlnaHQ6IDUwcHg7IH1cXG4gICAgICAubGFuZGluZyBoZWFkZXIgLmNvbnRhaW5lciAuZGVza3RvcC1uYXYgLmRlc2t0b3AtbGlua3Mge1xcbiAgICAgICAgZGlzcGxheTogbm9uZTsgfVxcbiAgICAubGFuZGluZyBoZWFkZXIgLmNvbnRhaW5lciAuYnRuLWhhbSwgLmxhbmRpbmcgaGVhZGVyIC5jb250YWluZXIgLm1vYmlsZS1uYXYge1xcbiAgICAgIGRpc3BsYXk6IG5vbmU7IH1cXG4gICAgLmxhbmRpbmcgaGVhZGVyIC5jb250YWluZXIgLmJ0bi1oYW0ge1xcbiAgICAgIGRpc3BsYXk6IGJsb2NrO1xcbiAgICAgIGdyaWQtY29sdW1uOiAxO1xcbiAgICAgIGdyaWQtcm93OiAxOyB9XFxuICAgIC5sYW5kaW5nIGhlYWRlciAuY29udGFpbmVyIC5oZWFkZXItYnRuIHtcXG4gICAgICBkaXNwbGF5OiBub25lOyB9XFxuICAubGFuZGluZyAuaGVybyB7XFxuICAgIGFsaWduLWl0ZW1zOiBzdHJldGNoOyB9XFxuICAgIC5sYW5kaW5nIC5oZXJvIC5oZXJvLXRleHQgLmhlcm8taGVhZGluZyB7XFxuICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjsgfVxcbiAgICAubGFuZGluZyAuaGVybyAuaGVyby10ZXh0IHAge1xcbiAgICAgIG1hcmdpbi10b3A6IDAuMjVyZW07IH1cXG4gICAgLmxhbmRpbmcgLmhlcm8gLmN0YXMge1xcbiAgICAgIGdyaWQtZ2FwOiAxcmVtOyB9XFxuICAubGFuZGluZyAuaG9iYmllcyAuaG9iYnkge1xcbiAgICBib3JkZXItcmFkaXVzOiAxMHB4O1xcbiAgICBwb2ludGVyLWV2ZW50czogYWxsO1xcbiAgICBjdXJzb3I6IHBvaW50ZXI7XFxuICAgIGJvcmRlcjogMnB4IHNvbGlkIHJnYmEoMjU1LCAyNTUsIDI1NSwgMCk7IH1cXG4gICAgLmxhbmRpbmcgLmhvYmJpZXMgLmhvYmJ5IGEge1xcbiAgICAgIHdpZHRoOiAxMDAlO1xcbiAgICAgIGhlaWdodDogMTAwJTtcXG4gICAgICBvdXRsaW5lOiBub25lOyB9XFxuICAgICAgLmxhbmRpbmcgLmhvYmJpZXMgLmhvYmJ5IGEgLm5hbWUge1xcbiAgICAgICAgZGlzcGxheTogbm9uZTsgfVxcbiAgICAgIC5sYW5kaW5nIC5ob2JiaWVzIC5ob2JieSBhIC5pbWctaG9iYnkge1xcbiAgICAgICAgd2lkdGg6IDU1cHg7XFxuICAgICAgICBoZWlnaHQ6IDU1cHg7IH1cXG4gICAgICAubGFuZGluZyAuaG9iYmllcyAuaG9iYnkgYTpmb2N1cyAubmFtZSB7XFxuICAgICAgICBkaXNwbGF5OiBibG9jazsgfVxcbiAgICAubGFuZGluZyAuaG9iYmllcyAuaG9iYnk6aG92ZXIge1xcbiAgICAgIGJvcmRlci1jb2xvcjogcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjIpOyB9XFxuICAubGFuZGluZyAuaG9iYmllcyAjZGVzaWduZXIge1xcbiAgICBib3JkZXItcmFkaXVzOiAwICFpbXBvcnRhbnQ7IH1cXG4gICAgLmxhbmRpbmcgLmhvYmJpZXMgI2Rlc2lnbmVyIC5taW5pLXNxIHtcXG4gICAgICB3aWR0aDogMTBweDtcXG4gICAgICBoZWlnaHQ6IDEwcHg7IH0gfVxcblxcbi5sYW5kaW5nIC5kZWNvcmF0aW9uLWNhcmQtZ3JpZCB7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICB0b3A6IDA7XFxuICByaWdodDogMDtcXG4gIHotaW5kZXg6IC0xO1xcbiAgZGlzcGxheTogZ3JpZDtcXG4gIGdyaWQtdGVtcGxhdGUtcm93czogcmVwZWF0KDYsIDFmcik7XFxuICBncmlkLXRlbXBsYXRlLWNvbHVtbnM6IDMwMHB4IDE1MHB4O1xcbiAgZ3JpZC1nYXA6IDIwcHg7XFxuICBoZWlnaHQ6IDEwMCU7IH1cXG4gIC5sYW5kaW5nIC5kZWNvcmF0aW9uLWNhcmQtZ3JpZCAuZGVjb3JhdGlvbi1jYXJkIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogIzJkMzQzNjtcXG4gICAgYmFja2dyb3VuZC1pbWFnZTogbGluZWFyLWdyYWRpZW50KDMxNWRlZywgIzJkMzQzNiAwJSwgIzE5MTkxOSA3NCUpO1xcbiAgICBvcGFjaXR5OiAwLjU7IH1cXG4gICAgLmxhbmRpbmcgLmRlY29yYXRpb24tY2FyZC1ncmlkIC5kZWNvcmF0aW9uLWNhcmQ6bnRoLWNoaWxkKDEpIHtcXG4gICAgICBncmlkLXJvdzogMS80O1xcbiAgICAgIGdyaWQtY29sdW1uOiAyO1xcbiAgICAgIGJvcmRlci1yYWRpdXM6IDAgMCAwIDIwcHg7IH1cXG4gICAgLmxhbmRpbmcgLmRlY29yYXRpb24tY2FyZC1ncmlkIC5kZWNvcmF0aW9uLWNhcmQ6bnRoLWNoaWxkKDIpIHtcXG4gICAgICBncmlkLXJvdzogNC83O1xcbiAgICAgIGdyaWQtY29sdW1uOiAyO1xcbiAgICAgIGJvcmRlci1yYWRpdXM6IDIwcHggMCAwIDA7IH1cXG4gICAgLmxhbmRpbmcgLmRlY29yYXRpb24tY2FyZC1ncmlkIC5kZWNvcmF0aW9uLWNhcmQ6bnRoLWNoaWxkKDMpIHtcXG4gICAgICBncmlkLXJvdzogMS8yO1xcbiAgICAgIGdyaWQtY29sdW1uOiAxO1xcbiAgICAgIGJvcmRlci1yYWRpdXM6IDAgMCAyMHB4IDIwcHg7IH1cXG4gICAgLmxhbmRpbmcgLmRlY29yYXRpb24tY2FyZC1ncmlkIC5kZWNvcmF0aW9uLWNhcmQ6bnRoLWNoaWxkKDQpIHtcXG4gICAgICBncmlkLXJvdzogMi81O1xcbiAgICAgIGdyaWQtY29sdW1uOiAxO1xcbiAgICAgIGJvcmRlci1yYWRpdXM6IDIwcHg7XFxuICAgICAgcGFkZGluZzogMS41cmVtO1xcbiAgICAgIGRpc3BsYXk6IGZsZXg7XFxuICAgICAganVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xcbiAgICAgIGFsaWduLWl0ZW1zOiBzdGFydDtcXG4gICAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xcbiAgICAgIGdyaWQtZ2FwOiAwcmVtO1xcbiAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gICAgICBvcGFjaXR5OiAxOyB9XFxuICAgICAgLmxhbmRpbmcgLmRlY29yYXRpb24tY2FyZC1ncmlkIC5kZWNvcmF0aW9uLWNhcmQ6bnRoLWNoaWxkKDQpIHN2ZyB7XFxuICAgICAgICB3aWR0aDogMTAwJTtcXG4gICAgICAgIGJvcmRlci1yYWRpdXM6IDMuNXB4OyB9XFxuICAgICAgLmxhbmRpbmcgLmRlY29yYXRpb24tY2FyZC1ncmlkIC5kZWNvcmF0aW9uLWNhcmQ6bnRoLWNoaWxkKDQpIC5jdXJzb3Ige1xcbiAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICAgICAgdG9wOiA4NSU7XFxuICAgICAgICBsZWZ0OiA4NSU7IH1cXG4gICAgLmxhbmRpbmcgLmRlY29yYXRpb24tY2FyZC1ncmlkIC5kZWNvcmF0aW9uLWNhcmQ6bnRoLWNoaWxkKDUpIHtcXG4gICAgICBncmlkLXJvdzogNS83O1xcbiAgICAgIGdyaWQtY29sdW1uOiAxO1xcbiAgICAgIGJvcmRlci1yYWRpdXM6IDIwcHggMjBweCAwIDA7IH1cXG5cXG5AbWVkaWEgc2NyZWVuIGFuZCAobWF4LXdpZHRoOiAxMzg1cHgpIHtcXG4gIC5sYW5kaW5nIC5kZWNvcmF0aW9uLWNhcmQtZ3JpZCB7XFxuICAgIGdyaWQtdGVtcGxhdGUtY29sdW1uczogMzAwcHggMTAwcHg7IH0gfVxcblxcbkBtZWRpYSBzY3JlZW4gYW5kIChtYXgtd2lkdGg6IDExNTBweCkge1xcbiAgLmxhbmRpbmcgLmRlY29yYXRpb24tY2FyZC1ncmlkIHtcXG4gICAgZ3JpZC10ZW1wbGF0ZS1jb2x1bW5zOiAyNTBweCAwOyB9XFxuICAgIC5sYW5kaW5nIC5kZWNvcmF0aW9uLWNhcmQtZ3JpZCAuY3Vyc29yIHtcXG4gICAgICB3aWR0aDogNDVweDtcXG4gICAgICBoZWlnaHQ6IGF1dG87IH0gfVxcblxcbkBtZWRpYSBzY3JlZW4gYW5kIChtYXgtd2lkdGg6IDk1MHB4KSB7XFxuICAubGFuZGluZyAuZGVjb3JhdGlvbi1jYXJkLWdyaWQge1xcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVgoNTAlKTsgfVxcbiAgICAubGFuZGluZyAuZGVjb3JhdGlvbi1jYXJkLWdyaWQgLmN1cnNvciB7XFxuICAgICAgZGlzcGxheTogbm9uZTsgfSB9XFxuXFxuQG1lZGlhIHNjcmVlbiBhbmQgKG1heC13aWR0aDogODEwcHgpIHtcXG4gIC5sYW5kaW5nIC5kZWNvcmF0aW9uLWNhcmQtZ3JpZCB7XFxuICAgIG9wYWNpdHk6IDAuNjsgfVxcbiAgICAubGFuZGluZyAuZGVjb3JhdGlvbi1jYXJkLWdyaWQgc3ZnIHtcXG4gICAgICBvcGFjaXR5OiAwLjI7IH0gfVxcblxcbkBtZWRpYSBzY3JlZW4gYW5kIChtaW4taGVpZ2h0OiA5NTBweCkge1xcbiAgLmxhbmRpbmcgLmRlY29yYXRpb24tY2FyZC1ncmlkIC5kZWNvcmF0aW9uLWNhcmQ6bnRoLWNoaWxkKDQpIHtcXG4gICAganVzdGlmeS1jb250ZW50OiBzdGFydDtcXG4gICAgZ2FwOiAycmVtOyB9XFxuICAgIC5sYW5kaW5nIC5kZWNvcmF0aW9uLWNhcmQtZ3JpZCAuZGVjb3JhdGlvbi1jYXJkOm50aC1jaGlsZCg0KSAjc2FtcGxlLXBhcmFncmFwaCB7XFxuICAgICAgZmxleC1ncm93OiAxOyB9IH1cXG5cXG5AbWVkaWEgc2NyZWVuIGFuZCAobWF4LWhlaWdodDogNzUwcHgpIHtcXG4gIC5sYW5kaW5nIC5kZWNvcmF0aW9uLWNhcmQtZ3JpZCAuZGVjb3JhdGlvbi1jYXJkOm50aC1jaGlsZCg0KSAjc2FtcGxlLXBhcmFncmFwaCB7XFxuICAgIGhlaWdodDogMTAwcHg7IH0gfVxcblxcbkBtZWRpYSBzY3JlZW4gYW5kIChtYXgtaGVpZ2h0OiA0NTBweCkge1xcbiAgLmxhbmRpbmcgLmRlY29yYXRpb24tY2FyZC1ncmlkIC5kZWNvcmF0aW9uLWNhcmQ6bnRoLWNoaWxkKDQpICNzYW1wbGUtcGFyYWdyYXBoIHtcXG4gICAgaGVpZ2h0OiA4MHB4OyB9IH1cXG5cXG4ubWUge1xcbiAgcG9zaXRpb246IHJlbGF0aXZlOyB9XFxuICAubWUgLmxhcmdlLW1hcCB7XFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgd2lkdGg6IDEwMCU7XFxuICAgIGhlaWdodDogMTAwJTtcXG4gICAgdG9wOiAwO1xcbiAgICBsZWZ0OiAwO1xcbiAgICBiYWNrZ3JvdW5kLWltYWdlOiB1cmwoXCIgKyBfX19DU1NfTE9BREVSX1VSTF9SRVBMQUNFTUVOVF8xX19fICsgXCIpO1xcbiAgICBiYWNrZ3JvdW5kLXJlcGVhdDogbm8tcmVwZWF0O1xcbiAgICBiYWNrZ3JvdW5kLXNpemU6IGNvdmVyO1xcbiAgICB6LWluZGV4OiAtMTtcXG4gICAgb3BhY2l0eTogMC4wODsgfVxcbiAgLm1lIC5jb3JlIHtcXG4gICAgZGlzcGxheTogZ3JpZDtcXG4gICAgZ3JpZC10ZW1wbGF0ZS1yb3dzOiByZXBlYXQoMiwgMWZyKTtcXG4gICAgZ3JpZC10ZW1wbGF0ZS1jb2x1bW5zOiAwLjZmciAyZnIgMWZyO1xcbiAgICBncmlkLWdhcDogMXJlbTsgfVxcbiAgICAubWUgLmNvcmUgYXJ0aWNsZSB7XFxuICAgICAgZGlzcGxheTogZmxleDtcXG4gICAgICBqdXN0aWZ5LWNvbnRlbnQ6IHN0YXJ0O1xcbiAgICAgIGFsaWduLWl0ZW1zOiBzdGFydDtcXG4gICAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xcbiAgICAgIGdyaWQtZ2FwOiAwcmVtOyB9XFxuICAgICAgLm1lIC5jb3JlIGFydGljbGUgaGVhZGVyIHtcXG4gICAgICAgIGRpc3BsYXk6IGZsZXg7XFxuICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IHN0YXJ0O1xcbiAgICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gICAgICAgIGZsZXgtZGlyZWN0aW9uOiByb3c7XFxuICAgICAgICBncmlkLWdhcDogMC4yNXJlbTtcXG4gICAgICAgIG1hcmdpbi1ib3R0b206IDAuMjVyZW07IH1cXG4gICAgICAgIC5tZSAuY29yZSBhcnRpY2xlIGhlYWRlciBzbWFsbCB7XFxuICAgICAgICAgIGZvbnQtd2VpZ2h0OiA4MDA7IH1cXG4gICAgLm1lIC5jb3JlIC5leHAge1xcbiAgICAgIHBhZGRpbmc6IDFyZW0gMDtcXG4gICAgICBncmlkLXJvdzogMS8yO1xcbiAgICAgIGdyaWQtY29sdW1uOiAxLzI7XFxuICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgICAgIGRpc3BsYXk6IGZsZXg7XFxuICAgICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XFxuICAgICAgYWxpZ24taXRlbXM6IHN0YXJ0O1xcbiAgICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XFxuICAgICAgZ3JpZC1nYXA6IDA7IH1cXG4gICAgICAubWUgLmNvcmUgLmV4cCAjYmFja2dyb3VuZCB7XFxuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiBpbmhlcml0O1xcbiAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGUoLTEwMCUsIDApO1xcbiAgICAgICAgd2lkdGg6IDEwMDAlO1xcbiAgICAgICAgaGVpZ2h0OiAxMDAlO1xcbiAgICAgICAgbGVmdDogMCU7IH1cXG4gICAgICAubWUgLmNvcmUgLmV4cCBzbWFsbCB7XFxuICAgICAgICBsaW5lLWhlaWdodDogMTMwJTsgfVxcbiAgICAubWUgLmNvcmUgLndoYXQge1xcbiAgICAgIGdyaWQtcm93OiAyLzM7XFxuICAgICAgZ3JpZC1jb2x1bW46IDEvMzsgfVxcbiAgICAubWUgLmNvcmUgLnNtYWxsLXNjcmVlbi13aGVyZSB7XFxuICAgICAgZGlzcGxheTogbm9uZTsgfVxcbiAgICAubWUgLmNvcmUgLmxhcmdlLXNjcmVlbi13aGVyZSB7XFxuICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgICAgIGdyaWQtcm93OiAxLzM7XFxuICAgICAgZ3JpZC1jb2x1bW46IDMvNDtcXG4gICAgICBtYXgtaGVpZ2h0OiAzNTBweDtcXG4gICAgICBkaXNwbGF5OiBmbGV4O1xcbiAgICAgIGp1c3RpZnktY29udGVudDogc3RhcnQ7XFxuICAgICAgYWxpZ24taXRlbXM6IHN0cmV0Y2g7XFxuICAgICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcXG4gICAgICBncmlkLWdhcDogMHJlbTsgfVxcbiAgICAgIC5tZSAuY29yZSAubGFyZ2Utc2NyZWVuLXdoZXJlIC5xdWVzdGlvbiB7XFxuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgICAgICB6LWluZGV4OiAxO1xcbiAgICAgICAgdG9wOiAxMHB4O1xcbiAgICAgICAgbGVmdDogMTBweDtcXG4gICAgICAgIGZpbHRlcjogZHJvcC1zaGFkb3coMCAwIDEwcHggIzNmM2YzZik7IH1cXG4gICAgICAubWUgLmNvcmUgLmxhcmdlLXNjcmVlbi13aGVyZSAubWFwIHtcXG4gICAgICAgIGZsZXgtYmFzaXM6IDE7XFxuICAgICAgICBmbGV4LWdyb3c6IDE7XFxuICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICAgICAgICBvdmVyZmxvdzogaGlkZGVuO1xcbiAgICAgICAgd2lkdGg6IDEwMCU7IH1cXG4gICAgICAgIC5tZSAuY29yZSAubGFyZ2Utc2NyZWVuLXdoZXJlIC5tYXAgLmNhaXJvLW1hcCwgLm1lIC5jb3JlIC5sYXJnZS1zY3JlZW4td2hlcmUgLm1hcCAub3ZlcmxheSB7XFxuICAgICAgICAgIHdpZHRoOiAxMDAlO1xcbiAgICAgICAgICBoZWlnaHQ6IDEwMCU7XFxuICAgICAgICAgIGJhY2tncm91bmQtcmVwZWF0OiBuby1yZXBlYXQ7XFxuICAgICAgICAgIGJhY2tncm91bmQtc2l6ZTogY292ZXI7XFxuICAgICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgICAgICAgdG9wOiAwO1xcbiAgICAgICAgICBsZWZ0OiAwOyB9XFxuICAgICAgICAubWUgLmNvcmUgLmxhcmdlLXNjcmVlbi13aGVyZSAubWFwIC5jYWlyby1tYXAge1xcbiAgICAgICAgICBiYWNrZ3JvdW5kLWltYWdlOiB1cmwoXCIgKyBfX19DU1NfTE9BREVSX1VSTF9SRVBMQUNFTUVOVF8yX19fICsgXCIpOyB9XFxuICAgICAgICAubWUgLmNvcmUgLmxhcmdlLXNjcmVlbi13aGVyZSAubWFwIC5vdmVybGF5IHtcXG4gICAgICAgICAgYmFja2dyb3VuZC1pbWFnZTogdXJsKFwiICsgX19fQ1NTX0xPQURFUl9VUkxfUkVQTEFDRU1FTlRfM19fXyArIFwiKTtcXG4gICAgICAgICAgb3BhY2l0eTogMC44OyB9XFxuICAgICAgICAubWUgLmNvcmUgLmxhcmdlLXNjcmVlbi13aGVyZSAubWFwIGg0IHtcXG4gICAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICAgICAgICB6LWluZGV4OiAxO1xcbiAgICAgICAgICBjb2xvcjogdmFyKC0tcHJpbWFyeS1ncmVlbik7XFxuICAgICAgICAgIGZpbHRlcjogZHJvcC1zaGFkb3coMCAwIDEwcHggcmdiYSgwLCAwLCAwLCAwLjIpKTtcXG4gICAgICAgICAgdGV4dC10cmFuc2Zvcm06IHVwcGVyY2FzZTtcXG4gICAgICAgICAgZm9udC13ZWlnaHQ6IDgwMDtcXG4gICAgICAgICAgbGluZS1oZWlnaHQ6IDEyMCU7XFxuICAgICAgICAgIGJvdHRvbTogMC43NXJlbTtcXG4gICAgICAgICAgbGVmdDogMC43NXJlbTsgfVxcbiAgLm1lIC5yZXN1bWUge1xcbiAgICAtd2Via2l0LWJhY2tkcm9wLWZpbHRlcjogYmx1cig3cHgpO1xcbiAgICBiYWNrZHJvcC1maWx0ZXI6IGJsdXIoN3B4KTtcXG4gICAgbWFyZ2luLXRvcDogM3JlbTtcXG4gICAgcGFkZGluZzogMS41cmVtO1xcbiAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxuICAgIGRpc3BsYXk6IGZsZXg7XFxuICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgICBmbGV4LWRpcmVjdGlvbjogcm93O1xcbiAgICBncmlkLWdhcDogMXJlbTtcXG4gICAgZmxleC13cmFwOiB3cmFwOyB9XFxuICAgIEBzdXBwb3J0cyBub3QgKGJhY2tkcm9wLWZpbHRlcjogbm9uZSkge1xcbiAgICAgIC5tZSAucmVzdW1lIHtcXG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6ICMxNDE0MTQ7IH0gfVxcbiAgICAubWUgLnJlc3VtZSAjYnRuRG93bmxvYWQgLmJ0bi1pY29uIHtcXG4gICAgICBiYWNrZ3JvdW5kLWltYWdlOiB1cmwoXCIgKyBfX19DU1NfTE9BREVSX1VSTF9SRVBMQUNFTUVOVF80X19fICsgXCIpOyB9XFxuXFxuQG1lZGlhIHNjcmVlbiBhbmQgKG1heC13aWR0aDogMTExNnB4KSB7XFxuICAubWUgLmNvcmUge1xcbiAgICBncmlkLXRlbXBsYXRlLXJvd3M6IHJlcGVhdCgyLCBhdXRvKTtcXG4gICAgZ3JpZC10ZW1wbGF0ZS1jb2x1bW5zOiByZXBlYXQoNCwgMWZyKTsgfVxcbiAgICAubWUgLmNvcmUgLmV4cCB7XFxuICAgICAgZ3JpZC1yb3c6IDEvMjtcXG4gICAgICBncmlkLWNvbHVtbjogMS8yOyB9XFxuICAgIC5tZSAuY29yZSAud2hvIHtcXG4gICAgICBncmlkLXJvdzogMS8yO1xcbiAgICAgIGdyaWQtY29sdW1uOiAyLzU7IH1cXG4gICAgLm1lIC5jb3JlIC5sYXJnZS1zY3JlZW4td2hlcmUge1xcbiAgICAgIGdyaWQtcm93OiAyLzQ7XFxuICAgICAgZ3JpZC1jb2x1bW46IDEvMzsgfVxcbiAgICAubWUgLmNvcmUgLndoYXQge1xcbiAgICAgIGdyaWQtcm93OiAyLzQ7XFxuICAgICAgZ3JpZC1jb2x1bW46IDMvNTtcXG4gICAgICBtYXJnaW46IGF1dG8gMDsgfSB9XFxuXFxuQG1lZGlhIHNjcmVlbiBhbmQgKG1heC13aWR0aDogNzUwcHgpIHtcXG4gIC5tZSAuY29yZSB7XFxuICAgIGdyaWQtdGVtcGxhdGUtcm93czogcmVwZWF0KDMsIGF1dG8pO1xcbiAgICBncmlkLXRlbXBsYXRlLWNvbHVtbnM6IDFmcjsgfVxcbiAgICAubWUgLmNvcmUgLmV4cCwgLm1lIC5jb3JlIC5sYXJnZS1zY3JlZW4td2hlcmUge1xcbiAgICAgIGRpc3BsYXk6IG5vbmU7IH1cXG4gICAgLm1lIC5jb3JlIC53aG8ge1xcbiAgICAgIGdyaWQtcm93OiAxLzI7XFxuICAgICAgZ3JpZC1jb2x1bW46IDE7IH1cXG4gICAgLm1lIC5jb3JlIC5zbWFsbC1zY3JlZW4td2hlcmUge1xcbiAgICAgIGRpc3BsYXk6IGZsZXg7XFxuICAgICAganVzdGlmeS1jb250ZW50OiBzdGFydDtcXG4gICAgICBhbGlnbi1pdGVtczogc3RhcnQ7XFxuICAgICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcXG4gICAgICBncmlkLWdhcDogMHJlbTtcXG4gICAgICBncmlkLXJvdzogMi8zO1xcbiAgICAgIGdyaWQtY29sdW1uOiAxOyB9XFxuICAgIC5tZSAuY29yZSAud2hhdCB7XFxuICAgICAgZ3JpZC1yb3c6IDMvNDtcXG4gICAgICBncmlkLWNvbHVtbjogMTsgfVxcbiAgLm1lIC5sYXJnZS1tYXAge1xcbiAgICBiYWNrZ3JvdW5kLXNpemU6IGF1dG87XFxuICAgIGRpc3BsYXk6IGJsb2NrOyB9IH1cXG5cXG5AbWVkaWEgc2NyZWVuIGFuZCAobWF4LXdpZHRoOiA2NTBweCkge1xcbiAgLm1lIC5jb3JlIGFydGljbGUgLnF1ZXN0aW9uIHtcXG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgICAtLXF1ZXN0aW9uLWJhcnMtd2lkdGg6IDEyMCU7XFxuICAgIC0tcXVlc3Rpb24tYmFycy1wb3NpdGlvbjogY2FsYygtMSAqIHZhcigtLXF1ZXN0aW9uLWJhcnMtd2lkdGgpIC0gMTUlKTsgfVxcbiAgICAubWUgLmNvcmUgYXJ0aWNsZSAucXVlc3Rpb246OmJlZm9yZSwgLm1lIC5jb3JlIGFydGljbGUgLnF1ZXN0aW9uOjphZnRlciB7XFxuICAgICAgY29udGVudDogJyAnO1xcbiAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgICBoZWlnaHQ6IDNweDtcXG4gICAgICB3aWR0aDogdmFyKC0tcXVlc3Rpb24tYmFycy13aWR0aCk7XFxuICAgICAgYmFja2dyb3VuZC1jb2xvcjogI2ZmZjtcXG4gICAgICBvcGFjaXR5OiAxOyB9XFxuICAgIC5tZSAuY29yZSBhcnRpY2xlIC5xdWVzdGlvbjo6YmVmb3JlIHtcXG4gICAgICBsZWZ0OiB2YXIoLS1xdWVzdGlvbi1iYXJzLXBvc2l0aW9uKTsgfVxcbiAgICAubWUgLmNvcmUgYXJ0aWNsZSAucXVlc3Rpb246OmFmdGVyIHtcXG4gICAgICByaWdodDogdmFyKC0tcXVlc3Rpb24tYmFycy1wb3NpdGlvbik7IH0gfVxcblxcbkBtZWRpYSBzY3JlZW4gYW5kIChtYXgtd2lkdGg6IDQ3NXB4KSB7XFxuICAubWUgLmNvcmUgYXJ0aWNsZSB7XFxuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXIgIWltcG9ydGFudDsgfSB9XFxuXFxuLnNraWxscyAuZHV0aWVzLWNvbnRhaW5lciB7XFxuICBtYXJnaW4tdG9wOiAycmVtOyB9XFxuXFxuLnNraWxscyAuZHV0aWVzIHtcXG4gIGRpc3BsYXk6IGdyaWQ7XFxuICBncmlkLXRlbXBsYXRlLXJvd3M6IDFmcjtcXG4gIGdyaWQtdGVtcGxhdGUtY29sdW1uczogcmVwZWF0KDQsIGF1dG8pO1xcbiAganVzdGlmeS1jb250ZW50OiBzdGFydDsgfVxcbiAgLnNraWxscyAuZHV0aWVzIC5kdXR5IHtcXG4gICAgcGFkZGluZzogMXJlbTtcXG4gICAgZGlzcGxheTogZ3JpZDtcXG4gICAgcGxhY2UtaXRlbXM6IGNlbnRlcjtcXG4gICAgYm9yZGVyLXJhZGl1czogMTBweDtcXG4gICAgdHJhbnNpdGlvbjogYmFja2dyb3VuZC1jb2xvciAwLjE1cyAsIHRyYW5zZm9ybSAwLjE1czsgfVxcbiAgICAuc2tpbGxzIC5kdXRpZXMgLmR1dHkgaW1nIHtcXG4gICAgICB3aWR0aDogMTIwcHg7XFxuICAgICAgaGVpZ2h0OiAxMjBweDtcXG4gICAgICB0cmFuc2l0aW9uOiBiYWNrZ3JvdW5kLWNvbG9yIDAuMTVzICwgdHJhbnNmb3JtIDAuMTVzO1xcbiAgICAgIGN1cnNvcjogcG9pbnRlcjtcXG4gICAgICBib3JkZXItcmFkaXVzOiBpbmhlcml0O1xcbiAgICAgIC13ZWJraXQtZmlsdGVyOiBicmlnaHRuZXNzKDApIGludmVydCgxKTtcXG4gICAgICBmaWx0ZXI6IGJyaWdodG5lc3MoMCkgaW52ZXJ0KDEpOyB9XFxuICAgIC5za2lsbHMgLmR1dGllcyAuZHV0eSBoNiB7XFxuICAgICAgZm9udC13ZWlnaHQ6IDYwMDtcXG4gICAgICBsaW5lLWhlaWdodDogMTAwJTtcXG4gICAgICBvcGFjaXR5OiAwO1xcbiAgICAgIHRleHQtYWxpZ246IGNlbnRlcjtcXG4gICAgICB0cmFuc2l0aW9uOiBvcGFjaXR5IDAuMnM7IH1cXG4gIC5za2lsbHMgLmR1dGllcyAuYWN0aXZlLWR1dHkge1xcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVkoLTFyZW0pOyB9XFxuICAgIC5za2lsbHMgLmR1dGllcyAuYWN0aXZlLWR1dHkgaW1nIHtcXG4gICAgICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudCAhaW1wb3J0YW50O1xcbiAgICAgIGZpbHRlcjogYnJpZ2h0bmVzcygxKSBpbnZlcnQoMCk7IH1cXG4gICAgLnNraWxscyAuZHV0aWVzIC5hY3RpdmUtZHV0eSAuZHV0eS1uYW1lIHtcXG4gICAgICBvcGFjaXR5OiAxOyB9XFxuXFxuLnNraWxscyAudGVjaC10b29scyB7XFxuICB3aWR0aDogMTAwJTtcXG4gIG1hcmdpbjogMnJlbSAwIDAgMDtcXG4gIHBhZGRpbmc6IDJyZW0gMDtcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTsgfVxcbiAgLnNraWxscyAudGVjaC10b29sczo6YmVmb3JlIHtcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICBjb250ZW50OiBcXFwiIFxcXCI7XFxuICAgIHdpZHRoOiAxMDAlO1xcbiAgICBoZWlnaHQ6IDEwMCU7XFxuICAgIHRvcDogMDtcXG4gICAgYmFja2dyb3VuZC1pbWFnZTogdXJsKFwiICsgX19fQ1NTX0xPQURFUl9VUkxfUkVQTEFDRU1FTlRfNV9fXyArIFwiKTtcXG4gICAgYmFja2dyb3VuZC1yZXBlYXQ6IG5vLXJlcGVhdDtcXG4gICAgYmFja2dyb3VuZC1zaXplOiAzMDBweDtcXG4gICAgYmFja2dyb3VuZC1wb3NpdGlvbjogYm90dG9tIC00LjhyZW0gcmlnaHQ7XFxuICAgIG9wYWNpdHk6IDAuNDsgfVxcbiAgLnNraWxscyAudGVjaC10b29scyAuY29udGFpbmVyICNpbm5lci10aXRsZSB7XFxuICAgIGZvbnQtd2VpZ2h0OiA4MDA7XFxuICAgIHRleHQtdHJhbnNmb3JtOiB1cHBlcmNhc2U7XFxuICAgIG1hcmdpbi1ib3R0b206IDFyZW07IH1cXG4gIC5za2lsbHMgLnRlY2gtdG9vbHMgLmNvbnRhaW5lciAuaWNvbnMge1xcbiAgICBtYXJnaW4tdG9wOiAxcmVtO1xcbiAgICBkaXNwbGF5OiBmbGV4O1xcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IHN0YXJ0O1xcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgICBmbGV4LWRpcmVjdGlvbjogcm93O1xcbiAgICBncmlkLWdhcDogMC43NXJlbTsgfVxcbiAgICAuc2tpbGxzIC50ZWNoLXRvb2xzIC5jb250YWluZXIgLmljb25zIGxpIHtcXG4gICAgICB3aWR0aDogYXV0bztcXG4gICAgICBoZWlnaHQ6IDQwcHg7IH1cXG4gICAgICAuc2tpbGxzIC50ZWNoLXRvb2xzIC5jb250YWluZXIgLmljb25zIGxpIGltZyB7XFxuICAgICAgICB3aWR0aDogaW5oZXJpdDtcXG4gICAgICAgIGhlaWdodDogaW5oZXJpdDsgfVxcblxcbkBtZWRpYSBzY3JlZW4gYW5kIChtYXgtd2lkdGg6IDExMTZweCkge1xcbiAgLnNraWxscyAudGVjaC10b29sczo6YmVmb3JlIHtcXG4gICAgYmFja2dyb3VuZC1zaXplOiA0MDBweDtcXG4gICAgYmFja2dyb3VuZC1wb3NpdGlvbjogdG9wIC0wLjVyZW0gcmlnaHQ7XFxuICAgIG9wYWNpdHk6IDAuMjU7IH0gfVxcblxcbkBtZWRpYSBzY3JlZW4gYW5kIChtYXgtd2lkdGg6IDk1MHB4KSB7XFxuICAuc2tpbGxzIC5kdXRpZXMge1xcbiAgICBncmlkLWdhcDogMC4yNXJlbTsgfVxcbiAgICAuc2tpbGxzIC5kdXRpZXMgLmR1dHkge1xcbiAgICAgIHBhZGRpbmc6IDFyZW0gMC43NXJlbTsgfVxcbiAgICAgIC5za2lsbHMgLmR1dGllcyAuZHV0eSBpbWcge1xcbiAgICAgICAgd2lkdGg6IDExMHB4O1xcbiAgICAgICAgaGVpZ2h0OiAxMTBweDsgfVxcbiAgICAgIC5za2lsbHMgLmR1dGllcyAuZHV0eSAuZHV0eS1uYW1lIHtcXG4gICAgICAgIGRpc3BsYXk6IG5vbmU7IH1cXG4gIC5za2lsbHMgLmR1dHktZXhwbGFpbmVkIHtcXG4gICAgbWFyZ2luLXRvcDogMXJlbTsgfVxcbiAgICAuc2tpbGxzIC5kdXR5LWV4cGxhaW5lZCAjZHV0eS1uYW1lIHtcXG4gICAgICBkaXNwbGF5OiBibG9jaztcXG4gICAgICBmb250LXdlaWdodDogNjAwOyB9XFxuICAgIC5za2lsbHMgLmR1dHktZXhwbGFpbmVkICNkdXR5LWRlc2NyaXB0aW9uIHtcXG4gICAgICBtYXJnaW4tdG9wOiAwLjNyZW07IH1cXG4gIC5za2lsbHMgLnRlY2gtdG9vbHMgLmNvbnRhaW5lciAuaWNvbnMgbGkge1xcbiAgICB3aWR0aDogYXV0bztcXG4gICAgaGVpZ2h0OiAzNXB4OyB9IH1cXG5cXG5AbWVkaWEgc2NyZWVuIGFuZCAobWF4LXdpZHRoOiA3NTBweCkge1xcbiAgLnNraWxscyAuZHV0aWVzIC5kdXR5IGltZyB7XFxuICAgIHdpZHRoOiA4MHB4O1xcbiAgICBoZWlnaHQ6IDgwcHg7IH1cXG4gIC5za2lsbHMgLnRlY2gtdG9vbHMgLmNvbnRhaW5lciAuaWNvbnMgbGkge1xcbiAgICB6LWluZGV4OiAxO1xcbiAgICB3aWR0aDogYXV0bztcXG4gICAgaGVpZ2h0OiAzMHB4OyB9IH1cXG5cXG5AbWVkaWEgc2NyZWVuIGFuZCAobWF4LXdpZHRoOiA2NTBweCkge1xcbiAgLnNraWxscyAudGVjaC10b29sczpiZWZvcmUge1xcbiAgICBkaXNwbGF5OiBub25lOyB9XFxuICAuc2tpbGxzIC50ZWNoLXRvb2xzIC5jb250YWluZXIgI2lubmVyLXRpdGxlIGJyIHtcXG4gICAgZGlzcGxheTogbm9uZTsgfVxcbiAgLnNraWxscyAudGVjaC10b29scyAuY29udGFpbmVyIC5pY29ucyBsaSB7XFxuICAgIHdpZHRoOiBhdXRvO1xcbiAgICBoZWlnaHQ6IDI1cHg7IH0gfVxcblxcbkBtZWRpYSBzY3JlZW4gYW5kIChtYXgtd2lkdGg6IDQ3NXB4KSB7XFxuICAuc2tpbGxzIHtcXG4gICAgdGV4dC1hbGlnbjogY2VudGVyOyB9XFxuICAgIC5za2lsbHMgLmR1dGllcyB7XFxuICAgICAgd2lkdGg6IGZpdC1jb250ZW50O1xcbiAgICAgIG1hcmdpbjogMCBhdXRvO1xcbiAgICAgIGdyaWQtdGVtcGxhdGUtcm93czogcmVwZWF0KDIsIDFmcik7XFxuICAgICAgZ3JpZC10ZW1wbGF0ZS1jb2x1bW5zOiByZXBlYXQoMiwgYXV0byk7XFxuICAgICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XFxuICAgICAgZ3JpZC1nYXA6IDA7IH1cXG4gICAgICAuc2tpbGxzIC5kdXRpZXMgLmFjdGl2ZS1kdXR5IHtcXG4gICAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWSgwKTsgfVxcbiAgICAgICAgLnNraWxscyAuZHV0aWVzIC5hY3RpdmUtZHV0eSBpbWcge1xcbiAgICAgICAgICB0cmFuc2Zvcm06IHNjYWxlKDEuMTUpOyB9XFxuICAgIC5za2lsbHMgLnRlY2gtdG9vbHMgLmNvbnRhaW5lciAuaWNvbnMge1xcbiAgICAgIGRpc3BsYXk6IGdyaWQ7XFxuICAgICAgZ3JpZC10ZW1wbGF0ZS1yb3dzOiByZXBlYXQoMiwgYXV0byk7XFxuICAgICAgZ3JpZC10ZW1wbGF0ZS1jb2x1bW5zOiByZXBlYXQoNSwgYXV0byk7XFxuICAgICAgd2lkdGg6IGZpdC1jb250ZW50O1xcbiAgICAgIG1hcmdpbjogMCBhdXRvOyB9XFxuICAgICAgLnNraWxscyAudGVjaC10b29scyAuY29udGFpbmVyIC5pY29ucyBsaSB7XFxuICAgICAgICB3aWR0aDogYXV0bztcXG4gICAgICAgIGhlaWdodDogMjVweDsgfSB9XFxuXFxuLndvcmsge1xcbiAgLS1nYXA6IDJyZW07IH1cXG4gIC53b3JrIC5jYXJkcy1jb250YWluZXIge1xcbiAgICBkaXNwbGF5OiBmbGV4O1xcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IHN0YXJ0O1xcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgICBmbGV4LWRpcmVjdGlvbjogcm93O1xcbiAgICBncmlkLWdhcDogdmFyKC0tZ2FwKTtcXG4gICAgb3ZlcmZsb3cteDogYXV0bztcXG4gICAgLS1vdmVybGF5aW5nLW1hcmdpbjogMTUwcHg7IH1cXG4gICAgLndvcmsgLmNhcmRzLWNvbnRhaW5lciAuY2FyZCB7XFxuICAgICAgdHJhbnNpdGlvbjogdHJhbnNmb3JtIC4ycyBlYXNlOyB9XFxuICAgIC53b3JrIC5jYXJkcy1jb250YWluZXIgLmNhcmQ6bm90KDpmaXJzdC1jaGlsZCkge1xcbiAgICAgIG1hcmdpbi1sZWZ0OiBjYWxjKHZhcigtLW92ZXJsYXlpbmctbWFyZ2luKSAqIC0xKTtcXG4gICAgICBib3gtc2hhZG93OiAtMXB4IDBweCA0OHB4IHJnYmEoMCwgMCwgMCwgMC44KTsgfVxcbiAgICAud29yayAuY2FyZHMtY29udGFpbmVyIC5jYXJkOmZvY3VzLXdpdGhpbiB+IC5jYXJkLCAud29yayAuY2FyZHMtY29udGFpbmVyIC5jYXJkOmhvdmVyIH4gLmNhcmQge1xcbiAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWChjYWxjKHZhcigtLW92ZXJsYXlpbmctbWFyZ2luKSArIDUwcHgpKTsgfVxcbiAgICAud29yayAuY2FyZHMtY29udGFpbmVyIC5nZW5lcmljLWNhcmQsIC53b3JrIC5jYXJkcy1jb250YWluZXIgLmNhcmQge1xcbiAgICAgIGJvcmRlci1yYWRpdXM6IDI1cHg7XFxuICAgICAgYmFja2dyb3VuZC1jb2xvcjogIzE5MTkxOTtcXG4gICAgICBib3JkZXI6IDJweCBzb2xpZCAjM2QzZDNkO1xcbiAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTsgfVxcbiAgICAud29yayAuY2FyZHMtY29udGFpbmVyIC5jYXJkIHtcXG4gICAgICB3aWR0aDogMzQwcHg7XFxuICAgICAgaGVpZ2h0OiAzODBweDtcXG4gICAgICBkaXNwbGF5OiBmbGV4O1xcbiAgICAgIGp1c3RpZnktY29udGVudDogc3BhY2UtYmV0d2VlbjtcXG4gICAgICBhbGlnbi1pdGVtczogc3RhcnQ7XFxuICAgICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcXG4gICAgICBncmlkLWdhcDogMHJlbTtcXG4gICAgICBvdmVyZmxvdzogaGlkZGVuO1xcbiAgICAgIHotaW5kZXg6IDI7IH1cXG4gICAgICAud29yayAuY2FyZHMtY29udGFpbmVyIC5jYXJkIC5jYXJkLWJnIHtcXG4gICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgICAgIHRvcDogMDtcXG4gICAgICAgIGxlZnQ6IDA7XFxuICAgICAgICB3aWR0aDogMTAwJTtcXG4gICAgICAgIGhlaWdodDogMTAwJTtcXG4gICAgICAgIGJvcmRlci1yYWRpdXM6IGluaGVyaXQ7XFxuICAgICAgICBiYWNrZ3JvdW5kLXJlcGVhdDogbm8tcmVwZWF0O1xcbiAgICAgICAgYmFja2dyb3VuZC1zaXplOiA3MCU7XFxuICAgICAgICBiYWNrZ3JvdW5kLXBvc2l0aW9uOiBib3R0b20gLTMwJSByaWdodCAtNDAlO1xcbiAgICAgICAgb3BhY2l0eTogMC4yOyB9XFxuICAgICAgLndvcmsgLmNhcmRzLWNvbnRhaW5lciAuY2FyZCBoZWFkZXIge1xcbiAgICAgICAgd2lkdGg6IDEwMCU7XFxuICAgICAgICBwYWRkaW5nOiAxcmVtIDFyZW0gMDtcXG4gICAgICAgIGRpc3BsYXk6IGZsZXg7XFxuICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IHN0YXJ0O1xcbiAgICAgICAgYWxpZ24taXRlbXM6IHN0YXJ0O1xcbiAgICAgICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcXG4gICAgICAgIGdyaWQtZ2FwOiAwLjVyZW07IH1cXG4gICAgICAgIC53b3JrIC5jYXJkcy1jb250YWluZXIgLmNhcmQgaGVhZGVyIC5jYXJkLXRpdGxlIHtcXG4gICAgICAgICAgZGlzcGxheTogZmxleDtcXG4gICAgICAgICAganVzdGlmeS1jb250ZW50OiBzdGFydDtcXG4gICAgICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gICAgICAgICAgZmxleC1kaXJlY3Rpb246IHJvdztcXG4gICAgICAgICAgZ3JpZC1nYXA6IDAuNXJlbTtcXG4gICAgICAgICAgei1pbmRleDogMzsgfVxcbiAgICAgICAgICAud29yayAuY2FyZHMtY29udGFpbmVyIC5jYXJkIGhlYWRlciAuY2FyZC10aXRsZSAuY2FyZC1uYW1lIHtcXG4gICAgICAgICAgICBmb250LXdlaWdodDogODAwO1xcbiAgICAgICAgICAgIGxpbmUtaGVpZ2h0OiAxMjAlO1xcbiAgICAgICAgICAgIGJhY2tncm91bmQ6IHZhcigtLXB1cnBsZS1ncmVlbi1ncmQpO1xcbiAgICAgICAgICAgIGNvbG9yOiB0cmFuc3BhcmVudDtcXG4gICAgICAgICAgICBiYWNrZ3JvdW5kLWNsaXA6IHRleHQ7XFxuICAgICAgICAgICAgLXdlYmtpdC1iYWNrZ3JvdW5kLWNsaXA6IHRleHQ7XFxuICAgICAgICAgICAgZGlzcGxheTogdGFibGUtY2VsbDsgfVxcbiAgICAgICAgICAud29yayAuY2FyZHMtY29udGFpbmVyIC5jYXJkIGhlYWRlciAuY2FyZC10aXRsZSAuYXJyb3cge1xcbiAgICAgICAgICAgIHRyYW5zaXRpb246IHRyYW5zZm9ybSAuMnMgZWFzZTtcXG4gICAgICAgICAgICBqdXN0aWZ5LXNlbGY6IHN0YXJ0O1xcbiAgICAgICAgICAgIGFsaWduLXNlbGY6IGNlbnRlcjtcXG4gICAgICAgICAgICB3aWR0aDogMjJweDtcXG4gICAgICAgICAgICBoZWlnaHQ6IDIycHg7IH1cXG4gICAgICAgICAgLndvcmsgLmNhcmRzLWNvbnRhaW5lciAuY2FyZCBoZWFkZXIgLmNhcmQtdGl0bGU6aG92ZXIge1xcbiAgICAgICAgICAgIGZpbHRlcjogYnJpZ2h0bmVzcygwLjgpOyB9XFxuICAgICAgICAud29yayAuY2FyZHMtY29udGFpbmVyIC5jYXJkIGhlYWRlciAud29yay1kb25lIHtcXG4gICAgICAgICAgZ3JpZC1yb3c6IDI7XFxuICAgICAgICAgIGdyaWQtY29sdW1uOiAxLzM7XFxuICAgICAgICAgIGp1c3RpZnktc2VsZjogc3RhcnQ7XFxuICAgICAgICAgIGRpc3BsYXk6IGZsZXg7XFxuICAgICAgICAgIGp1c3RpZnktY29udGVudDogc3RhcnQ7XFxuICAgICAgICAgIGFsaWduLWl0ZW1zOiBzdGFydDtcXG4gICAgICAgICAgZmxleC1kaXJlY3Rpb246IHJvdztcXG4gICAgICAgICAgZ3JpZC1nYXA6IDAuNXJlbTtcXG4gICAgICAgICAgZmxleC1ncm93OiAxOyB9XFxuICAgICAgICAgIC53b3JrIC5jYXJkcy1jb250YWluZXIgLmNhcmQgaGVhZGVyIC53b3JrLWRvbmUgaW1nIHtcXG4gICAgICAgICAgICB3aWR0aDogMzBweDtcXG4gICAgICAgICAgICBoZWlnaHQ6IGF1dG87IH1cXG4gICAgICAud29yayAuY2FyZHMtY29udGFpbmVyIC5jYXJkIGZvb3RlciB7XFxuICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICAgICAgICBkaXNwbGF5OiBncmlkO1xcbiAgICAgICAgZ3JpZC10ZW1wbGF0ZS1yb3dzOiByZXBlYXQoMiwgYXV0byk7XFxuICAgICAgICBncmlkLXRlbXBsYXRlLWNvbHVtbnM6IDFmciBhdXRvO1xcbiAgICAgICAgZ3JpZC1nYXA6IDAuNzVyZW0gMDtcXG4gICAgICAgIHBhZGRpbmc6IDFyZW07XFxuICAgICAgICBib3JkZXItcmFkaXVzOiBpbmhlcml0O1xcbiAgICAgICAgei1pbmRleDogaW5oZXJpdDsgfVxcbiAgICAgICAgLndvcmsgLmNhcmRzLWNvbnRhaW5lciAuY2FyZCBmb290ZXIgLmNhcmQtZGVzY3JpcHRpb24ge1xcbiAgICAgICAgICBncmlkLWNvbHVtbjogMS8zOyB9XFxuICAgICAgICAud29yayAuY2FyZHMtY29udGFpbmVyIC5jYXJkIGZvb3RlciAueWVhciB7XFxuICAgICAgICAgIGdyaWQtcm93OiAyLzM7XFxuICAgICAgICAgIGdyaWQtY29sdW1uOiAyLzM7XFxuICAgICAgICAgIGFsaWduLXNlbGY6IGNlbnRlcjtcXG4gICAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tcHJpbWFyeS1ncmVlbik7XFxuICAgICAgICAgIGNvbG9yOiByZ2JhKDAsIDAsIDAsIDAuNyk7XFxuICAgICAgICAgIHBhZGRpbmc6IDAuMXJlbSAwLjJyZW07XFxuICAgICAgICAgIGJvcmRlci1yYWRpdXM6IDVweDsgfVxcbiAgICAgICAgLndvcmsgLmNhcmRzLWNvbnRhaW5lciAuY2FyZCBmb290ZXIgLnJlbGF0ZWQtbGlua3Mge1xcbiAgICAgICAgICBncmlkLXJvdzogMi8zO1xcbiAgICAgICAgICBncmlkLWNvbHVtbjogMS8yO1xcbiAgICAgICAgICBkaXNwbGF5OiBmbGV4O1xcbiAgICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IHN0YXJ0O1xcbiAgICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgICAgICAgICBmbGV4LWRpcmVjdGlvbjogcm93O1xcbiAgICAgICAgICBncmlkLWdhcDogMC4zcmVtOyB9XFxuICAgICAgICAgIC53b3JrIC5jYXJkcy1jb250YWluZXIgLmNhcmQgZm9vdGVyIC5yZWxhdGVkLWxpbmtzIGEge1xcbiAgICAgICAgICAgIHdpZHRoOiAyN3B4O1xcbiAgICAgICAgICAgIGhlaWdodDogMjdweDtcXG4gICAgICAgICAgICBiYWNrZ3JvdW5kLXNpemU6IGNvdmVyOyB9XFxuICAgICAgICAgICAgQG1lZGlhIChob3Zlcikge1xcbiAgICAgICAgICAgICAgLndvcmsgLmNhcmRzLWNvbnRhaW5lciAuY2FyZCBmb290ZXIgLnJlbGF0ZWQtbGlua3MgYTpob3ZlciB7XFxuICAgICAgICAgICAgICAgIGZpbHRlcjogYnJpZ2h0bmVzcygwLjgpOyB9IH1cXG4gICAgICAgICAgICAud29yayAuY2FyZHMtY29udGFpbmVyIC5jYXJkIGZvb3RlciAucmVsYXRlZC1saW5rcyBhIGltZyB7XFxuICAgICAgICAgICAgICB3aWR0aDogaW5oZXJpdDtcXG4gICAgICAgICAgICAgIGhlaWdodDogaW5oZXJpdDsgfVxcbiAgICAgICAgICAgIC53b3JrIC5jYXJkcy1jb250YWluZXIgLmNhcmQgZm9vdGVyIC5yZWxhdGVkLWxpbmtzIGE6bnRoLWNoaWxkKDEpIHtcXG4gICAgICAgICAgICAgIGJhY2tncm91bmQtaW1hZ2U6IHVybChcIiArIF9fX0NTU19MT0FERVJfVVJMX1JFUExBQ0VNRU5UXzZfX18gKyBcIik7IH1cXG4gICAgICAgICAgICAud29yayAuY2FyZHMtY29udGFpbmVyIC5jYXJkIGZvb3RlciAucmVsYXRlZC1saW5rcyBhOm50aC1jaGlsZCgyKSB7XFxuICAgICAgICAgICAgICBiYWNrZ3JvdW5kLWltYWdlOiB1cmwoXCIgKyBfX19DU1NfTE9BREVSX1VSTF9SRVBMQUNFTUVOVF83X19fICsgXCIpOyB9XFxuICAgICAgQG1lZGlhIChob3Zlcikge1xcbiAgICAgICAgLndvcmsgLmNhcmRzLWNvbnRhaW5lciAuY2FyZCBoZWFkZXIgLndvcmstZG9uZSBpbWcge1xcbiAgICAgICAgICBmaWx0ZXI6IGJyaWdodG5lc3MoMCkgaW52ZXJ0KDEpOyB9XFxuICAgICAgICAud29yayAuY2FyZHMtY29udGFpbmVyIC5jYXJkIGZvb3RlciB7XFxuICAgICAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWSgzNCUpO1xcbiAgICAgICAgICB0cmFuc2l0aW9uOiB0cmFuc2Zvcm0gLjJzIGVhc2UgLjFzOyB9XFxuICAgICAgICAud29yayAuY2FyZHMtY29udGFpbmVyIC5jYXJkOmhvdmVyIC53b3JrLWRvbmUgaW1nIHtcXG4gICAgICAgICAgZmlsdGVyOiBicmlnaHRuZXNzKDEpIGludmVydCgwKTsgfVxcbiAgICAgICAgLndvcmsgLmNhcmRzLWNvbnRhaW5lciAuY2FyZDpob3ZlciBmb290ZXIge1xcbiAgICAgICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVkoMCk7IH0gfVxcbiAgICAud29yayAuY2FyZHMtY29udGFpbmVyICNwaWctZGljZSAuY2FyZC1iZyB7XFxuICAgICAgYmFja2dyb3VuZC1pbWFnZTogdXJsKFwiICsgX19fQ1NTX0xPQURFUl9VUkxfUkVQTEFDRU1FTlRfOF9fXyArIFwiKTsgfVxcbiAgICAud29yayAuY2FyZHMtY29udGFpbmVyICNtb25zdGVyLXNsYXllciAuY2FyZC1iZyB7XFxuICAgICAgYmFja2dyb3VuZC1pbWFnZTogdXJsKFwiICsgX19fQ1NTX0xPQURFUl9VUkxfUkVQTEFDRU1FTlRfOV9fXyArIFwiKTsgfVxcbiAgICAud29yayAuY2FyZHMtY29udGFpbmVyICNtb25zdGVyLXNsYXllciAuY2FyZC1uYW1lIHtcXG4gICAgICB3aWR0aDogbWluLWNvbnRlbnQ7IH1cXG4gICAgLndvcmsgLmNhcmRzLWNvbnRhaW5lciAjb3NjLWdlZWtzIC5jYXJkLWJnIHtcXG4gICAgICBiYWNrZ3JvdW5kLWltYWdlOiB1cmwoXCIgKyBfX19DU1NfTE9BREVSX1VSTF9SRVBMQUNFTUVOVF8xMF9fXyArIFwiKTsgfVxcbiAgICAud29yayAuY2FyZHMtY29udGFpbmVyIC5kdW1teS1jYXJkIHtcXG4gICAgICBtYXJnaW46IDAgIWltcG9ydGFudDtcXG4gICAgICBmbGV4LWdyb3c6IDE7XFxuICAgICAgYm9yZGVyOiAycHggZGFzaGVkICMzZDNkM2Q7XFxuICAgICAgYm9yZGVyLXJhZGl1czogMjVweDtcXG4gICAgICBhbGlnbi1zZWxmOiBzdHJldGNoO1xcbiAgICAgIGRpc3BsYXk6IGdyaWQ7XFxuICAgICAgcGxhY2UtaXRlbXM6IGNlbnRlcjsgfVxcbiAgICAgIC53b3JrIC5jYXJkcy1jb250YWluZXIgLmR1bW15LWNhcmQgaW1nIHtcXG4gICAgICAgIHdpZHRoOiAxMDBweDtcXG4gICAgICAgIGhlaWdodDogYXV0bztcXG4gICAgICAgIG9wYWNpdHk6IDAuNDsgfVxcbiAgLndvcmsgLnRhc2tzLWV4cGxhaW5lZCB7XFxuICAgIG1hcmdpbi10b3A6IDFyZW07XFxuICAgIGRpc3BsYXk6IGZsZXg7XFxuICAgIGp1c3RpZnktY29udGVudDogc3RhcnQ7XFxuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICAgIGZsZXgtZGlyZWN0aW9uOiByb3c7XFxuICAgIGdyaWQtZ2FwOiAxNXB4O1xcbiAgICBmbGV4LXdyYXA6IHdyYXA7IH1cXG4gICAgLndvcmsgLnRhc2tzLWV4cGxhaW5lZCAudGFzayB7XFxuICAgICAgZGlzcGxheTogZmxleDtcXG4gICAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcXG4gICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgICAgIGZsZXgtZGlyZWN0aW9uOiByb3c7XFxuICAgICAgZ3JpZC1nYXA6IDVweDsgfVxcbiAgICAgIC53b3JrIC50YXNrcy1leHBsYWluZWQgLnRhc2sgaW1nIHtcXG4gICAgICAgIHdpZHRoOiAyMHB4O1xcbiAgICAgICAgaGVpZ2h0OiAyMHB4OyB9XFxuXFxuQG1lZGlhIHNjcmVlbiBhbmQgKG1heC13aWR0aDogMTExNnB4KSB7XFxuICAud29yayAuY2FyZHMtd3JhcHBlciAuY2FyZHMtY29udGFpbmVyIC5jYXJkIHtcXG4gICAgd2lkdGg6IDMxMHB4O1xcbiAgICBoZWlnaHQ6IDM1MHB4OyB9XFxuICAud29yayAuY2FyZHMtd3JhcHBlciAuY2FyZHMtY29udGFpbmVyIC5kdW1teS1jYXJkIHtcXG4gICAgZGlzcGxheTogbm9uZTsgfSB9XFxuXFxuQG1lZGlhIHNjcmVlbiBhbmQgKG1heC13aWR0aDogNzUwcHgpIHtcXG4gIC53b3JrIC5jYXJkcy13cmFwcGVyIC5jYXJkcy1jb250YWluZXIge1xcbiAgICAtLW92ZXJsYXlpbmctbWFyZ2luOiAyMTBweDsgfVxcbiAgICAud29yayAuY2FyZHMtd3JhcHBlciAuY2FyZHMtY29udGFpbmVyIC5jYXJkIHtcXG4gICAgICB3aWR0aDogMzMwcHg7XFxuICAgICAgaGVpZ2h0OiAzNTBweDsgfSB9XFxuXFxuQG1lZGlhIHNjcmVlbiBhbmQgKG1heC13aWR0aDogNjUwcHgpIHtcXG4gIC53b3JrIC5jYXJkcy13cmFwcGVyIHtcXG4gICAgd2lkdGg6IDEwMCU7IH1cXG4gICAgLndvcmsgLmNhcmRzLXdyYXBwZXIgLmNhcmRzLWNvbnRhaW5lciB7XFxuICAgICAgd2lkdGg6IGluaGVyaXQ7XFxuICAgICAgZGlzcGxheTogZ3JpZDtcXG4gICAgICBncmlkLXRlbXBsYXRlLWNvbHVtbnM6IHJlcGVhdCgzLCBhdXRvKTtcXG4gICAgICBzY3JvbGwtc25hcC10eXBlOiB4IG1hbmRhdG9yeTtcXG4gICAgICBzY3JvbGwtYmVoYXZpb3I6IHNtb290aDsgfVxcbiAgICAgIC53b3JrIC5jYXJkcy13cmFwcGVyIC5jYXJkcy1jb250YWluZXIgLmNhcmQge1xcbiAgICAgICAgLS1vdmVybGF5aW5nLW1hcmdpbjogMDtcXG4gICAgICAgIGJveC1zaGFkb3c6IG5vbmU7XFxuICAgICAgICB0cmFuc2l0aW9uOiBub25lO1xcbiAgICAgICAgbWFyZ2luLWxlZnQ6IDA7XFxuICAgICAgICB3aWR0aDogNzB2dztcXG4gICAgICAgIG1hcmdpbjogMDtcXG4gICAgICAgIHNjcm9sbC1zbmFwLWFsaWduOiBjZW50ZXI7XFxuICAgICAgICBzY3JvbGwtc25hcC1zdG9wOiBhbHdheXM7IH1cXG4gICAgICAgIC53b3JrIC5jYXJkcy13cmFwcGVyIC5jYXJkcy1jb250YWluZXIgLmNhcmQgLndvcmstZG9uZSBpbWcge1xcbiAgICAgICAgICB3aWR0aDogMjVweDtcXG4gICAgICAgICAgaGVpZ2h0OiAyNXB4OyB9XFxuICAgICAgICAud29yayAuY2FyZHMtd3JhcHBlciAuY2FyZHMtY29udGFpbmVyIC5jYXJkOmZpcnN0LW9mLXR5cGUge1xcbiAgICAgICAgICBtYXJnaW4tbGVmdDogdmFyKC0tZ2FwKTsgfVxcbiAgICAgICAgLndvcmsgLmNhcmRzLXdyYXBwZXIgLmNhcmRzLWNvbnRhaW5lciAuY2FyZDpsYXN0LW9mLXR5cGUge1xcbiAgICAgICAgICBtYXJnaW4tcmlnaHQ6IHZhcigtLWdhcCk7IH0gfVxcblxcbkBtZWRpYSBzY3JlZW4gYW5kIChtYXgtd2lkdGg6IDQ3NXB4KSB7XFxuICAud29yayB7XFxuICAgIC0tZ2FwOiAxcmVtOyB9XFxuICAgIC53b3JrIC5jYXJkcy13cmFwcGVyIC5jYXJkcy1jb250YWluZXIgLmNhcmQge1xcbiAgICAgIHdpZHRoOiA4MHZ3OyB9XFxuICAgIC53b3JrIC50YXNrcy1leHBsYWluZWQge1xcbiAgICAgIGp1c3RpZnktY29udGVudDogY2VudGVyOyB9IH1cXG5cXG5AbWVkaWEgc2NyZWVuIGFuZCAobWF4LXdpZHRoOiAzNjBweCkge1xcbiAgLndvcmsgLmNhcmRzLXdyYXBwZXIgLmNhcmRzLWNvbnRhaW5lciAuY2FyZCB7XFxuICAgIGhlaWdodDogMzAwcHg7IH0gfVxcblxcbi5jb250YWN0IHtcXG4gIG1pbi1oZWlnaHQ6IGNsYW1wKDY1MHB4LCAxMDAlLCAxMDAlKTtcXG4gIGRpc3BsYXk6IGdyaWQ7XFxuICBncmlkLXRlbXBsYXRlLXJvd3M6IDIuNWZyIDFmcjsgfVxcbiAgLmNvbnRhY3QgLmNvbnRhY3QtdGhlbWUge1xcbiAgICB3aWR0aDogMTAwJTtcXG4gICAgaGVpZ2h0OiAxMDAlO1xcbiAgICBkaXNwbGF5OiBub25lOyB9XFxuICAuY29udGFjdCAudXBwZXIge1xcbiAgICBncmlkLXJvdzogMS8yO1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjMEYwRjBGO1xcbiAgICBiYWNrZ3JvdW5kLWltYWdlOiB1cmwoXCIgKyBfX19DU1NfTE9BREVSX1VSTF9SRVBMQUNFTUVOVF8xMV9fXyArIFwiKTtcXG4gICAgYmFja2dyb3VuZC1yZXBlYXQ6IG5vLXJlcGVhdDtcXG4gICAgYmFja2dyb3VuZC1zaXplOiBjbGFtcCg2MDBweCwgNTAlLCA1MCUpIGF1dG87XFxuICAgIGJhY2tncm91bmQtcG9zaXRpb246IGJvdHRvbSBsZWZ0O1xcbiAgICB3aWR0aDogMTAwJTtcXG4gICAgbWFyZ2luOiAwIGF1dG87XFxuICAgIG1heC13aWR0aDogMTYwMHB4OyB9XFxuICAgIC5jb250YWN0IC51cHBlciAuY29udGFpbmVyIHtcXG4gICAgICBoZWlnaHQ6IDEwMCU7XFxuICAgICAgZGlzcGxheTogZmxleDtcXG4gICAgICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XFxuICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gICAgICBmbGV4LWRpcmVjdGlvbjogcm93O1xcbiAgICAgIGdyaWQtZ2FwOiAwcmVtOyB9XFxuICAgICAgLmNvbnRhY3QgLnVwcGVyIC5jb250YWluZXIgLnRpdGxlIHtcXG4gICAgICAgIGFsaWduLXNlbGY6IGZsZXgtZW5kOyB9XFxuICAgICAgLmNvbnRhY3QgLnVwcGVyIC5jb250YWluZXIgZm9ybSB7XFxuICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICAgICAgICBkaXNwbGF5OiBmbGV4O1xcbiAgICAgICAganVzdGlmeS1jb250ZW50OiBzdHJldGNoO1xcbiAgICAgICAgYWxpZ24taXRlbXM6IHN0cmV0Y2g7XFxuICAgICAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xcbiAgICAgICAgZ3JpZC1nYXA6IDAuNXJlbTtcXG4gICAgICAgIGJvcmRlci1yYWRpdXM6IDEwcHg7XFxuICAgICAgICBwYWRkaW5nOiAwLjc1cmVtO1xcbiAgICAgICAgd2lkdGg6IDQwJTtcXG4gICAgICAgIGhlaWdodDogODUlO1xcbiAgICAgICAgbWluLXdpZHRoOiA0ODBweDtcXG4gICAgICAgIG1pbi1oZWlnaHQ6IGF1dG87XFxuICAgICAgICBtYXgtd2lkdGg6IGF1dG87XFxuICAgICAgICBtYXgtaGVpZ2h0OiA0NzBweDtcXG4gICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTsgfVxcbiAgICAgICAgLmNvbnRhY3QgLnVwcGVyIC5jb250YWluZXIgZm9ybSAuaW5wdXQtY29udGFpbmVyIHtcXG4gICAgICAgICAgZGlzcGxheTogZ3JpZDtcXG4gICAgICAgICAgZ3JpZC10ZW1wbGF0ZS1yb3dzOiBhdXRvIDFmcjtcXG4gICAgICAgICAgZ3JpZC10ZW1wbGF0ZS1jb2x1bW5zOiBhdXRvIDFmcjtcXG4gICAgICAgICAgZ3JpZC1yb3ctZ2FwOiA1cHg7IH1cXG4gICAgICAgICAgLmNvbnRhY3QgLnVwcGVyIC5jb250YWluZXIgZm9ybSAuaW5wdXQtY29udGFpbmVyIGxhYmVsIHtcXG4gICAgICAgICAgICBncmlkLXJvdzogMTtcXG4gICAgICAgICAgICBncmlkLWNvbHVtbjogMTtcXG4gICAgICAgICAgICBqdXN0aWZ5LXNlbGY6IGxlZnQ7XFxuICAgICAgICAgICAgbWFyZ2luOiAwIDAgMCA1cHg7IH1cXG4gICAgICAgICAgLmNvbnRhY3QgLnVwcGVyIC5jb250YWluZXIgZm9ybSAuaW5wdXQtY29udGFpbmVyIC5lcnJvci1tc2cge1xcbiAgICAgICAgICAgIGRpc3BsYXk6IG5vbmU7XFxuICAgICAgICAgICAgZ3JpZC1yb3c6IDE7XFxuICAgICAgICAgICAgZ3JpZC1jb2x1bW46IDI7XFxuICAgICAgICAgICAganVzdGlmeS1zZWxmOiByaWdodDtcXG4gICAgICAgICAgICBhbGlnbi1zZWxmOiBlbmQ7IH1cXG4gICAgICAgICAgLmNvbnRhY3QgLnVwcGVyIC5jb250YWluZXIgZm9ybSAuaW5wdXQtY29udGFpbmVyIC50ZXh0LWJveCB7XFxuICAgICAgICAgICAgZ3JpZC1yb3c6IDI7XFxuICAgICAgICAgICAgZ3JpZC1jb2x1bW46IDEvMzsgfVxcbiAgICAgICAgICAuY29udGFjdCAudXBwZXIgLmNvbnRhaW5lciBmb3JtIC5pbnB1dC1jb250YWluZXI6bnRoLWNoaWxkKDMpIHtcXG4gICAgICAgICAgICBmbGV4LWdyb3c6IDE7IH1cXG4gICAgICAgIC5jb250YWN0IC51cHBlciAuY29udGFpbmVyIGZvcm0gLmludmFsaWQtaW5wdXQgLmVycm9yLW1zZyB7XFxuICAgICAgICAgIGRpc3BsYXk6IGlubGluZS1ibG9jazsgfVxcbiAgICAgICAgLmNvbnRhY3QgLnVwcGVyIC5jb250YWluZXIgZm9ybSAuaW52YWxpZC1pbnB1dCAudGV4dC1ib3gge1xcbiAgICAgICAgICBib3JkZXItY29sb3I6IHZhcigtLWNvbG9yLWVycm9yKTsgfVxcbiAgICAgICAgLmNvbnRhY3QgLnVwcGVyIC5jb250YWluZXIgZm9ybSAudmFsaWQtaW5wdXQgLmVycm9yLW1zZyB7XFxuICAgICAgICAgIGRpc3BsYXk6IG5vbmU7IH1cXG4gICAgICAgIC5jb250YWN0IC51cHBlciAuY29udGFpbmVyIGZvcm0gLnZhbGlkLWlucHV0IC50ZXh0LWJveCB7XFxuICAgICAgICAgIGJvcmRlci1jb2xvcjogdmFyKC0tY29sb3Itc3VjY2Vzcyk7IH1cXG4gICAgICAgIC5jb250YWN0IC51cHBlciAuY29udGFpbmVyIGZvcm0gLmJ0biwgLmNvbnRhY3QgLnVwcGVyIC5jb250YWluZXIgZm9ybSAuYnRuLXByaW1hcnksXFxuICAgICAgICAuY29udGFjdCAudXBwZXIgLmNvbnRhaW5lciBmb3JtIC5idG4tc2Vjb25kYXJ5IHtcXG4gICAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICAgICAgICBib3JkZXItcmFkaXVzOiA5OTlweDtcXG4gICAgICAgICAgcGFkZGluZzogMC43NXJlbTtcXG4gICAgICAgICAgd2lkdGg6IGZpdC1jb250ZW50O1xcbiAgICAgICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZSgtNTAlLCAtNTAlKTtcXG4gICAgICAgICAgdG9wOiA5NiU7XFxuICAgICAgICAgIGxlZnQ6IDk2JTtcXG4gICAgICAgICAgei1pbmRleDogMzsgfVxcbiAgICAgICAgICAuY29udGFjdCAudXBwZXIgLmNvbnRhaW5lciBmb3JtIC5idG4gLmJ0bi1pY29uLCAuY29udGFjdCAudXBwZXIgLmNvbnRhaW5lciBmb3JtIC5idG4tcHJpbWFyeSAuYnRuLWljb24sIC5jb250YWN0IC51cHBlciAuY29udGFpbmVyIGZvcm0gLmJ0bi1zZWNvbmRhcnkgLmJ0bi1pY29uIHtcXG4gICAgICAgICAgICB3aWR0aDogMzBweDtcXG4gICAgICAgICAgICBoZWlnaHQ6IDMwcHg7XFxuICAgICAgICAgICAgYmFja2dyb3VuZC1pbWFnZTogdXJsKFwiICsgX19fQ1NTX0xPQURFUl9VUkxfUkVQTEFDRU1FTlRfMTJfX18gKyBcIik7IH1cXG4gICAgICAgIC5jb250YWN0IC51cHBlciAuY29udGFpbmVyIGZvcm0gLmNvbmYge1xcbiAgICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgICAgICAgIHdpZHRoOiAxMDAlO1xcbiAgICAgICAgICBoZWlnaHQ6IDEwMCU7XFxuICAgICAgICAgIGJhY2tncm91bmQtY29sb3I6IGluaGVyaXQ7XFxuICAgICAgICAgIGJvcmRlci1yYWRpdXM6IGluaGVyaXQ7XFxuICAgICAgICAgIHBhZGRpbmc6IDEuNXJlbTtcXG4gICAgICAgICAgdG9wOiAwO1xcbiAgICAgICAgICBsZWZ0OiAwO1xcbiAgICAgICAgICBjb2xvcjogdmFyKC0tcHJpbWFyeS1ncmVlbik7XFxuICAgICAgICAgIHRleHQtYWxpZ246IGNlbnRlcjtcXG4gICAgICAgICAgZGlzcGxheTogZmxleDtcXG4gICAgICAgICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XFxuICAgICAgICAgIGFsaWduLWl0ZW1zOiBzdGFydDtcXG4gICAgICAgICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcXG4gICAgICAgICAgZ3JpZC1nYXA6IDAuNXJlbTtcXG4gICAgICAgICAgZGlzcGxheTogbm9uZTsgfVxcbiAgICAgICAgICAuY29udGFjdCAudXBwZXIgLmNvbnRhaW5lciBmb3JtIC5jb25mIGltZyB7XFxuICAgICAgICAgICAgd2lkdGg6IDVyZW07XFxuICAgICAgICAgICAgaGVpZ2h0OiA1cmVtO1xcbiAgICAgICAgICAgIG1hcmdpbi1ib3R0b206IDFyZW07IH1cXG4gICAgICAgICAgLmNvbnRhY3QgLnVwcGVyIC5jb250YWluZXIgZm9ybSAuY29uZiBzbWFsbCB7XFxuICAgICAgICAgICAgb3BhY2l0eTogMC43OyB9XFxuICAgICAgLmNvbnRhY3QgLnVwcGVyIC5jb250YWluZXIgLnNob3ctY29uZiAuYnRuLCAuY29udGFjdCAudXBwZXIgLmNvbnRhaW5lciAuc2hvdy1jb25mIC5idG4tcHJpbWFyeSxcXG4gICAgICAuY29udGFjdCAudXBwZXIgLmNvbnRhaW5lciAuc2hvdy1jb25mIC5idG4tc2Vjb25kYXJ5IHtcXG4gICAgICAgIHBvaW50ZXItZXZlbnRzOiBub25lOyB9XFxuICAgICAgLmNvbnRhY3QgLnVwcGVyIC5jb250YWluZXIgLnNob3ctY29uZiAuY29uZiB7XFxuICAgICAgICBkaXNwbGF5OiBmbGV4OyB9XFxuICAuY29udGFjdCAubG93ZXIge1xcbiAgICBncmlkLXJvdzogMi8zO1xcbiAgICBkaXNwbGF5OiBncmlkO1xcbiAgICBwbGFjZS1pdGVtczogY2VudGVyOyB9XFxuICAgIC5jb250YWN0IC5sb3dlciAuY29udGFpbmVyIHtcXG4gICAgICBkaXNwbGF5OiBmbGV4O1xcbiAgICAgIGp1c3RpZnktY29udGVudDogc3BhY2UtYmV0d2VlbjtcXG4gICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgICAgIGZsZXgtZGlyZWN0aW9uOiByb3c7XFxuICAgICAgZ3JpZC1nYXA6IDByZW07IH1cXG4gICAgICAuY29udGFjdCAubG93ZXIgLmNvbnRhaW5lciAuY29udGFjdC1pbmZvIHtcXG4gICAgICAgIGRpc3BsYXk6IGZsZXg7XFxuICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IHN0YXJ0O1xcbiAgICAgICAgYWxpZ24taXRlbXM6IHN0YXJ0O1xcbiAgICAgICAgZmxleC1kaXJlY3Rpb246IHJvdztcXG4gICAgICAgIGdyaWQtZ2FwOiAzcmVtOyB9XFxuICAgICAgICAuY29udGFjdCAubG93ZXIgLmNvbnRhaW5lciAuY29udGFjdC1pbmZvIGxpIHtcXG4gICAgICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gICAgICAgICAgZGlzcGxheTogZmxleDtcXG4gICAgICAgICAganVzdGlmeS1jb250ZW50OiBzdGFydDtcXG4gICAgICAgICAgYWxpZ24taXRlbXM6IHN0YXJ0O1xcbiAgICAgICAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xcbiAgICAgICAgICBncmlkLWdhcDogMC42cmVtOyB9XFxuICAgICAgICAgIC5jb250YWN0IC5sb3dlciAuY29udGFpbmVyIC5jb250YWN0LWluZm8gbGkgaW1nIHtcXG4gICAgICAgICAgICB3aWR0aDogNDBweDtcXG4gICAgICAgICAgICBoZWlnaHQ6IDQwcHg7IH1cXG4gICAgICAgICAgLmNvbnRhY3QgLmxvd2VyIC5jb250YWluZXIgLmNvbnRhY3QtaW5mbyBsaSBzbWFsbCB7XFxuICAgICAgICAgICAgZGlzcGxheTogYmxvY2s7IH1cXG4gICAgICAgIC5jb250YWN0IC5sb3dlciAuY29udGFpbmVyIC5jb250YWN0LWluZm8gI3dvcmstcGhvbmUtbnVtYmVyLCAuY29udGFjdCAubG93ZXIgLmNvbnRhaW5lciAuY29udGFjdC1pbmZvICN3b3JrLWVtYWlsIHtcXG4gICAgICAgICAgdGV4dC1kZWNvcmF0aW9uOiB1bmRlcmxpbmU7IH1cXG4gICAgICAuY29udGFjdCAubG93ZXIgLmNvbnRhaW5lciAuc29jaWFsIHtcXG4gICAgICAgIGRpc3BsYXk6IGZsZXg7XFxuICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcXG4gICAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICAgICAgICBmbGV4LWRpcmVjdGlvbjogcm93LXJldmVyc2U7XFxuICAgICAgICBncmlkLWdhcDogMnJlbTsgfVxcbiAgICAgICAgLmNvbnRhY3QgLmxvd2VyIC5jb250YWluZXIgLnNvY2lhbCBzbWFsbDo6YmVmb3JlIHtcXG4gICAgICAgICAgY29udGVudDogJyc7XFxuICAgICAgICAgIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXG4gICAgICAgICAgd2lkdGg6IDIwcHg7XFxuICAgICAgICAgIGhlaWdodDogNHB4O1xcbiAgICAgICAgICBiYWNrZ3JvdW5kOiAjZmZmO1xcbiAgICAgICAgICBtYXJnaW46IDAgMC41cmVtIDNweCAwOyB9XFxuICAgICAgICAuY29udGFjdCAubG93ZXIgLmNvbnRhaW5lciAuc29jaWFsIC5wbGF0Zm9ybXMge1xcbiAgICAgICAgICBkaXNwbGF5OiBmbGV4O1xcbiAgICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IHN0YXJ0O1xcbiAgICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgICAgICAgICBmbGV4LWRpcmVjdGlvbjogcm93O1xcbiAgICAgICAgICBncmlkLWdhcDogMC40cmVtOyB9XFxuICAgICAgICAgIC5jb250YWN0IC5sb3dlciAuY29udGFpbmVyIC5zb2NpYWwgLnBsYXRmb3JtcyBsaSB7XFxuICAgICAgICAgICAgd2lkdGg6IDMzcHg7XFxuICAgICAgICAgICAgaGVpZ2h0OiAzM3B4O1xcbiAgICAgICAgICAgIGJvcmRlci1yYWRpdXM6IDk5OXB4O1xcbiAgICAgICAgICAgIHRyYW5zaXRpb246IHRyYW5zZm9ybSAwLjE1cyBlYXNlLW91dDsgfVxcbiAgICAgICAgICAgIC5jb250YWN0IC5sb3dlciAuY29udGFpbmVyIC5zb2NpYWwgLnBsYXRmb3JtcyBsaSAqIHtcXG4gICAgICAgICAgICAgIHdpZHRoOiBpbmhlcml0O1xcbiAgICAgICAgICAgICAgaGVpZ2h0OiBpbmhlcml0O1xcbiAgICAgICAgICAgICAgYm9yZGVyLXJhZGl1czogaW5oZXJpdDsgfVxcbiAgICAgICAgICAgIC5jb250YWN0IC5sb3dlciAuY29udGFpbmVyIC5zb2NpYWwgLnBsYXRmb3JtcyBsaTpob3ZlciB7XFxuICAgICAgICAgICAgICB0cmFuc2Zvcm06IHNjYWxlKDEuMTUpIHRyYW5zbGF0ZVkoLTJweCk7IH1cXG5cXG5AbWVkaWEgc2NyZWVuIGFuZCAobWF4LXdpZHRoOiAxMTE2cHgpIHtcXG4gIC5jb250YWN0IC51cHBlciB7XFxuICAgIGJhY2tncm91bmQtaW1hZ2U6IHVybChcIiArIF9fX0NTU19MT0FERVJfVVJMX1JFUExBQ0VNRU5UXzEzX19fICsgXCIpO1xcbiAgICBiYWNrZ3JvdW5kLXNpemU6IGF1dG8gOTUlO1xcbiAgICBiYWNrZ3JvdW5kLXBvc2l0aW9uOiBib3R0b20gNjAlIGxlZnQgLTEwJTsgfVxcbiAgICAuY29udGFjdCAudXBwZXIgLmNvbnRhaW5lciAudGl0bGUge1xcbiAgICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XFxuICAgICAgYWxpZ24taXRlbXM6IGZsZXgtc3RhcnQ7IH1cXG4gICAgLmNvbnRhY3QgLnVwcGVyIC5jb250YWluZXIgZm9ybSB7XFxuICAgICAgd2lkdGg6IDU1JTtcXG4gICAgICBoZWlnaHQ6IGNhbGMoMTAwJSwgMnJlbSk7IH1cXG4gIC5jb250YWN0IC5sb3dlciAuY29udGFpbmVyIHtcXG4gICAgYWxpZ24taXRlbXM6IGZsZXgtZW5kOyB9XFxuICAgIC5jb250YWN0IC5sb3dlciAuY29udGFpbmVyIC5jb250YWN0LWluZm8ge1xcbiAgICAgIGdhcDogMC43NXJlbTtcXG4gICAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uOyB9XFxuICAgICAgLmNvbnRhY3QgLmxvd2VyIC5jb250YWluZXIgLmNvbnRhY3QtaW5mbyBsaSB7XFxuICAgICAgICBmbGV4LWRpcmVjdGlvbjogcm93O1xcbiAgICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjsgfVxcbiAgICAgICAgLmNvbnRhY3QgLmxvd2VyIC5jb250YWluZXIgLmNvbnRhY3QtaW5mbyBsaSBpbWcge1xcbiAgICAgICAgICB3aWR0aDogMzVweDtcXG4gICAgICAgICAgaGVpZ2h0OiAzNXB4OyB9XFxuICAgICAgICAuY29udGFjdCAubG93ZXIgLmNvbnRhaW5lciAuY29udGFjdC1pbmZvIGxpIGJyIHtcXG4gICAgICAgICAgZGlzcGxheTogbm9uZTsgfVxcbiAgICAuY29udGFjdCAubG93ZXIgLmNvbnRhaW5lciAuc29jaWFsIHtcXG4gICAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xcbiAgICAgIGFsaWduLWl0ZW1zOiBmbGV4LWVuZDtcXG4gICAgICBnYXA6IDAuNnJlbTsgfSB9XFxuXFxuQG1lZGlhIHNjcmVlbiBhbmQgKG1heC13aWR0aDogOTUwcHgpIHtcXG4gIC5jb250YWN0IC51cHBlciAuY29udGFpbmVyIHtcXG4gICAgcGFkZGluZy1ib3R0b206IDEuNXJlbTtcXG4gICAgYWxpZ24taXRlbXM6IGZsZXgtZW5kOyB9XFxuICAgIC5jb250YWN0IC51cHBlciAuY29udGFpbmVyIGZvcm0ge1xcbiAgICAgIG1pbi13aWR0aDogMzgwcHg7IH1cXG4gICAgLmNvbnRhY3QgLnVwcGVyIC5jb250YWluZXIgLnRpdGxlIHtcXG4gICAgICBtYXJnaW46IDA7IH0gfVxcblxcbkBtZWRpYSBzY3JlZW4gYW5kIChtYXgtd2lkdGg6IDY1MHB4KSB7XFxuICAuY29udGFjdCB7XFxuICAgIGdyaWQtdGVtcGxhdGUtcm93czogMi41ZnIgMWZyO1xcbiAgICBncmlkLXRlbXBsYXRlLXJvd3M6IDJmciAxZnI7IH1cXG4gICAgLmNvbnRhY3QgLnVwcGVyIHtcXG4gICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjMjcyNzI3O1xcbiAgICAgIGJhY2tncm91bmQtY29sb3I6ICMyOTI5Mjk7XFxuICAgICAgYmFja2dyb3VuZC1pbWFnZTogbm9uZTsgfVxcbiAgICAgIC5jb250YWN0IC51cHBlciAuY29udGFpbmVyIHtcXG4gICAgICAgIGRpc3BsYXk6IGdyaWQ7XFxuICAgICAgICBncmlkLXRlbXBsYXRlLXJvd3M6IGF1dG8gMWZyO1xcbiAgICAgICAgd2lkdGg6IDEwMHZ3O1xcbiAgICAgICAgcGFkZGluZy1ib3R0b206IDA7IH1cXG4gICAgICAgIC5jb250YWN0IC51cHBlciAuY29udGFpbmVyIC5jb250YWN0LXRoZW1lIHtcXG4gICAgICAgICAgZGlzcGxheTogbm9uZTtcXG4gICAgICAgICAgZ3JpZC1yb3c6IDEvMjtcXG4gICAgICAgICAgYmFja2dyb3VuZC1pbWFnZTogdXJsKFwiICsgX19fQ1NTX0xPQURFUl9VUkxfUkVQTEFDRU1FTlRfMTRfX18gKyBcIik7XFxuICAgICAgICAgIGJhY2tncm91bmQtcmVwZWF0OiBuby1yZXBlYXQ7XFxuICAgICAgICAgIGJhY2tncm91bmQtc2l6ZTogYXV0byAyMzAlO1xcbiAgICAgICAgICBiYWNrZ3JvdW5kLXBvc2l0aW9uOiBjZW50ZXIgY2VudGVyOyB9XFxuICAgICAgICAuY29udGFjdCAudXBwZXIgLmNvbnRhaW5lciAudGl0bGUge1xcbiAgICAgICAgICBncmlkLXJvdzogMi8zO1xcbiAgICAgICAgICBncmlkLXJvdzogMS8yO1xcbiAgICAgICAgICBmbGV4LWRpcmVjdGlvbjogcm93O1xcbiAgICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcXG4gICAgICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gICAgICAgICAgbWFyZ2luOiAwO1xcbiAgICAgICAgICB3aWR0aDogMTAwdnc7XFxuICAgICAgICAgIHBhZGRpbmc6IDEuNXJlbSAwIDAuNXJlbTsgfVxcbiAgICAgICAgLmNvbnRhY3QgLnVwcGVyIC5jb250YWluZXIgZm9ybSB7XFxuICAgICAgICAgIGdyaWQtcm93OiAzLzQ7XFxuICAgICAgICAgIGdyaWQtcm93OiAyLzM7XFxuICAgICAgICAgIG1pbi13aWR0aDogYXV0bztcXG4gICAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgICAgICAgICB3aWR0aDogMTAwJTtcXG4gICAgICAgICAgaGVpZ2h0OiAxMDAlOyB9XFxuICAgICAgICAgIC5jb250YWN0IC51cHBlciAuY29udGFpbmVyIGZvcm0gI21lc3NhZ2Uge1xcbiAgICAgICAgICAgIGdyaWQtY29sdW1uOiAxLzM7IH1cXG4gICAgICAgICAgLmNvbnRhY3QgLnVwcGVyIC5jb250YWluZXIgZm9ybSAuYnRuLCAuY29udGFjdCAudXBwZXIgLmNvbnRhaW5lciBmb3JtIC5idG4tcHJpbWFyeSxcXG4gICAgICAgICAgLmNvbnRhY3QgLnVwcGVyIC5jb250YWluZXIgZm9ybSAuYnRuLXNlY29uZGFyeSB7XFxuICAgICAgICAgICAgdG9wOiA5OCU7XFxuICAgICAgICAgICAgbGVmdDogNTAlOyB9XFxuICAgICAgICAgIC5jb250YWN0IC51cHBlciAuY29udGFpbmVyIGZvcm0gLnNob3ctY29uZiB7XFxuICAgICAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogIzI5MjkyOTsgfVxcbiAgICAuY29udGFjdCAubG93ZXIgLmNvbnRhaW5lciB7XFxuICAgICAgcGFkZGluZzogMnJlbSAwIDFyZW0gMDtcXG4gICAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xcbiAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICAgICAgZ2FwOiAycmVtOyB9XFxuICAgICAgLmNvbnRhY3QgLmxvd2VyIC5jb250YWluZXIgLnNvY2lhbCBzbWFsbCB7XFxuICAgICAgICBkaXNwbGF5OiBub25lOyB9IH1cXG5cXG4uc2tpbGxzIHAge1xcbiAgbWF4LXdpZHRoOiA2MGNoOyB9XFxuXFxuc2VjdGlvbjpub3QoLmxhbmRpbmcpOm5vdCguY29udGFjdCkge1xcbiAgbWFyZ2luLXRvcDogLTcwcHg7XFxuICBwYWRkaW5nLXRvcDogMTQwcHg7IH1cXG5cXG4uY29udGFjdCB7XFxuICBwYWRkaW5nLXRvcDogNzBweDsgfVxcblxcbnNlY3Rpb24gLnRpdGxlIHtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICBqdXN0aWZ5LWNvbnRlbnQ6IHN0YXJ0O1xcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gIGdyaWQtZ2FwOiAwLjVyZW07XFxuICBtYXJnaW4tYm90dG9tOiAxcmVtO1xcbiAgd2hpdGUtc3BhY2U6IG5vd3JhcDsgfVxcblxcbkBtZWRpYSBzY3JlZW4gYW5kIChtaW4td2lkdGg6IDExMTZweCkge1xcbiAgLmltZy10aXRsZSB7XFxuICAgIHdpZHRoOiA4MHB4OyB9IH1cXG5cXG5AbWVkaWEgc2NyZWVuIGFuZCAobWF4LXdpZHRoOiAxMTE2cHgpIHtcXG4gIC5pbWctdGl0bGUge1xcbiAgICB3aWR0aDogNzBweDsgfSB9XFxuXFxuQG1lZGlhIHNjcmVlbiBhbmQgKG1heC13aWR0aDogNzUwcHgpIHtcXG4gIC5pbWctdGl0bGUge1xcbiAgICB3aWR0aDogNjVweDsgfVxcbiAgLm1lIHAsIC5za2lsbHMgcCB7XFxuICAgIG1heC13aWR0aDogMTAwJTsgfSB9XFxuXFxuQG1lZGlhIHNjcmVlbiBhbmQgKG1heC13aWR0aDogNjUwcHgpIHtcXG4gIHNlY3Rpb246bm90KC5sYW5kaW5nKTpub3QoLmNvbnRhY3QpIHtcXG4gICAgbWFyZ2luLXRvcDogLTUwcHg7XFxuICAgIHBhZGRpbmctdG9wOiAxMDBweDsgfVxcbiAgLmNvbnRhY3Qge1xcbiAgICBwYWRkaW5nLXRvcDogNTBweDsgfSB9XFxuXFxuQG1lZGlhIHNjcmVlbiBhbmQgKG1heC13aWR0aDogNDc1cHgpIHtcXG4gIC5pbWctdGl0bGUge1xcbiAgICB3aWR0aDogNjBweDsgfVxcbiAgLmJ0biwgLmJ0bi1wcmltYXJ5LFxcbiAgLmJ0bi1zZWNvbmRhcnkge1xcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjsgfVxcbiAgICAuYnRuIC5idG4taWNvbiwgLmJ0bi1wcmltYXJ5IC5idG4taWNvbiwgLmJ0bi1zZWNvbmRhcnkgLmJ0bi1pY29uIHtcXG4gICAgICB3aWR0aDogMTVweDtcXG4gICAgICBoZWlnaHQ6IDE1cHg7IH1cXG4gIC50aXRsZSB7XFxuICAgIGZsZXgtd3JhcDogd3JhcDtcXG4gICAganVzdGlmeS1jb250ZW50OiBjZW50ZXIgIWltcG9ydGFudDsgfVxcbiAgICAudGl0bGUgaDIge1xcbiAgICAgIHdpZHRoOiBtaW4tY29udGVudDsgfSB9XFxuXCIsIFwiXCIse1widmVyc2lvblwiOjMsXCJzb3VyY2VzXCI6W1wid2VicGFjazovLy4vc3JjL3Nhc3MvX25vcm1hbGl6ZS5zYXNzXCIsXCJ3ZWJwYWNrOi8vLi9zcmMvc2Fzcy9fbWl4aW5zLnNhc3NcIixcIndlYnBhY2s6Ly8uL3NyYy9zYXNzL190eXBvZ3JhcGh5LnNhc3NcIixcIndlYnBhY2s6Ly8uL3NyYy9zYXNzL190aGVtaW5nLnNhc3NcIixcIndlYnBhY2s6Ly8uL3NyYy9zYXNzL19nZW5lcmljLnNhc3NcIixcIndlYnBhY2s6Ly8uL3NyYy9zYXNzL2luZGV4LnNhc3NcIixcIndlYnBhY2s6Ly8uL3NyYy9zYXNzL19sYW5kaW5nLnNhc3NcIixcIndlYnBhY2s6Ly8uL3NyYy9zYXNzL19kZWNvcmF0aW9ucy5zYXNzXCIsXCJ3ZWJwYWNrOi8vLi9zcmMvc2Fzcy9fbWUuc2Fzc1wiLFwid2VicGFjazovLy4vc3JjL3Nhc3MvX3NraWxscy5zYXNzXCIsXCJ3ZWJwYWNrOi8vLi9zcmMvc2Fzcy9fd29yay5zYXNzXCIsXCJ3ZWJwYWNrOi8vLi9zcmMvc2Fzcy9fY29udGFjdC5zYXNzXCJdLFwibmFtZXNcIjpbXSxcIm1hcHBpbmdzXCI6XCJBQUNBO0VBQ0ksU0FBUztFQUNULFVBQVU7RUFFViw4QkFBOEI7RUFDOUIsc0JBQXNCO0VBR3RCLHdDQUF3QztFQUl4QywyQkFBMkI7RUFDM0Isd0JBQXdCO0VBQ3hCLHlCQUF5QjtFQUN6QixxQkFBcUI7RUFDckIsaUJBQWlCLEVBQUE7O0FBRXJCO0VBQ0ksU0FBUyxFQUFBOztBQUViOztFQ21ESSxZRGpEbUI7RUNrRG5CLGFEbEQwQixFQUFBOztBQUU5QjtFQUNJLHFCQUFxQixFQUFBOztBRXpCekI7RUFFSSxtQ0FBbUM7RUFDbkMsa0NBQWtDO0VBQ2xDLGtDQUFrQztFQUVsQyxrQ0FBa0MsRUFBQTs7QUFZbEM7RUFDSSxtQkFBbUIsRUFBQTs7QUFDdkI7RUFDSSxtQkFBbUIsRUFBQTs7QUFDdkI7RUFDSSxtQkFBbUIsRUFBQTs7QUFDdkI7RUFDSSxtQkFBbUIsRUFBQTs7QUFDdkI7RUFDSSxrQkFBa0IsRUFBQTs7QUFDdEI7RUFDSSxpQkFBaUIsRUFBQTs7QUFDckI7O0VBQ0ksa0JBQWtCLEVBQUE7O0FBQ3RCOzs7O0VBSUksaUJBQWlCLEVBQUE7O0FBQ3JCO0VBQ0ksaUJBQWlCLEVBQUE7O0FBQ3JCO0VBQ0ksaUJBQWlCLEVBQUE7O0FBNEJ6QjtFQUNJLGdCQUFnQixFQUFBOztBQUVwQjtFQUNJLGlCQUFpQjtFQUNqQixnQkFBZ0IsRUFBQTs7QUFFcEI7RUFDSSxpQkFBaUI7RUFDakIsZ0JBQWdCLEVBQUE7O0FBRXBCO0VBQ0ksaUJBQWlCO0VBQ2pCLGdCQUFnQixFQUFBOztBQUVwQjtFQUNJLGdCQUFnQjtFQUNoQixpQkFBaUIsRUFBQTs7QUFFckI7RUFDSSxnQkFBZ0IsRUFBQTs7QUFFcEI7RUFDSSxnQkFBZ0IsRUFBQTs7QUFFcEI7RUFDSTtJQUNJLGVBQWUsRUFBQSxFQUFHOztBQUUxQjtFQUhJO0lBS0ksZUFBZSxFQUFBLEVBQUc7O0FBRTFCO0VB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QSxFQUFHOztBQUU5QjtFQTlCQTtJQWdDUSxpQkFBaUI7SUFDakIsa0JBQWtCLEVBQUE7RU1qRTFCO0lObUVRLGlCQUFpQixFQUFBLEVBQUc7O0FBRTVCO0VBckJJO0lBdUJJLFdBQVcsRUFBQTtFREpuQjs7SUNNUSx1QkFBdUIsRUFBQTtJRG9CL0I7TUhwQkksV0lFMEI7TUpEMUIsWUlDZ0MsRUFBQTtFQUNoQztJQUNJLGVBQWU7SUFDZixrQ0FBa0MsRUFBQTtJQUZ0QztNQUlRLGtCQUFrQixFQUFBLEVBQUdcIixcInNvdXJjZXNDb250ZW50XCI6W1wiLy9ub3JtYWxpemF0aW9uXFxuKiwgKjo6YmVmb3JlLCAqOjphZnRlciB7XFxuICAgIG1hcmdpbjogMDtcXG4gICAgcGFkZGluZzogMDtcXG5cXG4gICAgLXdlYmtpdC1ib3gtc2l6aW5nOiBib3JkZXItYm94O1xcbiAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xcblxcbiAgICAvL2Rpc2FibGUgc2VtaS1ibHVlIGhpZ2hsaWdodCBvbiBtb2JpbGVcXG4gICAgLXdlYmtpdC10YXAtaGlnaGxpZ2h0LWNvbG9yOiB0cmFuc3BhcmVudDtcXG4gICAgLy8gb3V0bGluZTogbm9uZVxcblxcbiAgICAvL2Rpc2FibGUgdXNlciBzZWxlY3RcXG4gICAgLW1vei11c2VyLXNlbGVjdDogLW1vei1ub25lO1xcbiAgICAta2h0bWwtdXNlci1zZWxlY3Q6IG5vbmU7XFxuICAgIC13ZWJraXQtdXNlci1zZWxlY3Q6IG5vbmU7XFxuICAgIC1tcy11c2VyLXNlbGVjdDogbm9uZTtcXG4gICAgdXNlci1zZWxlY3Q6IG5vbmU7IH1cXG5cXG4qOjptb3otZm9jdXMtaW5uZXIge1xcbiAgICBib3JkZXI6IDA7IH1cXG5cXG5odG1sLFxcbmJvZHkge1xcbiAgICBAaW5jbHVkZSBzaXplKDEwMHZ3LCAxMDB2aCk7IH1cXG5cXG51bCB7XFxuICAgIGxpc3Qtc3R5bGUtdHlwZTogbm9uZTsgfVxcblwiLFwiQG1peGluIGNlbnRlci1hbGlnbiB7XFxuICAgICoge1xcbiAgICAgICAgdGV4dC1hbGlnbjogY2VudGVyOyB9IH1cXG5cXG5AbWl4aW4gZmlsbC1ncmQoJGdyZDogdmFyKC0tcGluay1wdXJwbGUtZ3JkKSkge1xcbiAgICBiYWNrZ3JvdW5kOiAkZ3JkO1xcbiAgICBjb2xvcjogdHJhbnNwYXJlbnQ7XFxuICAgIGJhY2tncm91bmQtY2xpcDogdGV4dDtcXG4gICAgLXdlYmtpdC1iYWNrZ3JvdW5kLWNsaXA6IHRleHQ7XFxuICAgIGRpc3BsYXk6IHRhYmxlLWNlbGw7IH1cXG5cXG5AbWl4aW4gYnRuLWJvcmRlci1ncmQoJGdyZDogdmFyKC0tYnRuLXBpbmstcHVycGxlLWdyZC1ib3JkZXIpLCAkYm9yZGVyLXdpZHRoOiAycHgpIHtcXG4gICAgJjo6YmVmb3JlIHtcXG4gICAgICAgIGNvbnRlbnQ6ICcnO1xcbiAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICAgICAgdG9wOiAwO1xcbiAgICAgICAgYm90dG9tOiAwO1xcbiAgICAgICAgbGVmdDogMDtcXG4gICAgICAgIHJpZ2h0OiAwO1xcbiAgICAgICAgYm9yZGVyLXJhZGl1czogaW5oZXJpdDtcXG5cXG4gICAgICAgIHBhZGRpbmc6ICRib3JkZXItd2lkdGg7XFxuICAgICAgICBiYWNrZ3JvdW5kOiAkZ3JkO1xcbiAgICAgICAgYmFja2dyb3VuZC1zaXplOiAyMDAlIDEwMCU7XFxuICAgICAgICBiYWNrZ3JvdW5kLXBvc2l0aW9uOiByaWdodCBjZW50ZXI7XFxuICAgICAgICAtd2Via2l0LW1hc2s6IGxpbmVhci1ncmFkaWVudCgjZmZmIDAgMCkgY29udGVudC1ib3gsIGxpbmVhci1ncmFkaWVudCgjZmZmIDAgMCk7XFxuICAgICAgICAtd2Via2l0LW1hc2stY29tcG9zaXRlOiB4b3I7XFxuICAgICAgICBtYXNrLWNvbXBvc2l0ZTogZXhjbHVkZTtcXG5cXG4gICAgICAgIHRyYW5zaXRpb246IGluaGVyaXQ7IH1cXG4gICAgJjpob3Zlcjo6YmVmb3JlIHtcXG4gICAgICAgIGJhY2tncm91bmQtcG9zaXRpb246IGxlZnQgY2VudGVyOyB9IH1cXG5cXG5AbWl4aW4gYXBwbHktY2FyZHMtZWZmZWN0KCkge1xcbiAgICAtLW92ZXJsYXlpbmctbWFyZ2luOiAxNTBweDtcXG4gICAgLmNhcmQge1xcbiAgICAgICAgdHJhbnNpdGlvbjogdHJhbnNmb3JtIC4ycyBlYXNlOyB9XFxuICAgIC5jYXJkOm5vdCg6Zmlyc3QtY2hpbGQpIHtcXG4gICAgICAgIG1hcmdpbi1sZWZ0OiBjYWxjKHZhcigtLW92ZXJsYXlpbmctbWFyZ2luKSAqIC0xKTtcXG4gICAgICAgIGJveC1zaGFkb3c6IC0xcHggMHB4IDQ4cHggcmdiYSgwLCAwLCAwLCAwLjgpOyB9XFxuICAgIC5jYXJkOmZvY3VzLXdpdGhpbn4uY2FyZCwgLmNhcmQ6aG92ZXJ+LmNhcmQge1xcbiAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVYKGNhbGModmFyKC0tb3ZlcmxheWluZy1tYXJnaW4pICsgNTBweCkpOyB9IH1cXG5cXG5AbWl4aW4gZGlzYWJsZS1jYXJkcy1lZmZlY3QoKSB7IC8vcmVzZXRzIGFsbCBlZmZlY3RzIGRvbmUgYWJvdmVcXG4gICAgLS1vdmVybGF5aW5nLW1hcmdpbjogMDtcXG4gICAgYm94LXNoYWRvdzogbm9uZTtcXG4gICAgdHJhbnNpdGlvbjogbm9uZTtcXG4gICAgbWFyZ2luLWxlZnQ6IDA7IH1cXG5cXG5AbWl4aW4gc2V0LWJhZGdlLXN0eWxlcygkYmFzZS1jb2xvcjogdmFyKC0tcHJpbWFyeS1ncmVlbikpIHtcXG4gICAgQGV4dGVuZCAudGlueS1zbWFsbDtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogJGJhc2UtY29sb3I7XFxuICAgIGNvbG9yOiByZ2JhKDAsIDAsIDAsIDAuOCk7XFxuICAgIHBhZGRpbmc6IDAuMXJlbSAwLjJyZW07XFxuICAgIGJvcmRlci1yYWRpdXM6IDVweDsgfVxcblxcbkBtaXhpbiBiYWNrZHJvcC1ibHVyKCRibHVyOiA1MHB4KSB7XFxuICAgIC13ZWJraXQtYmFja2Ryb3AtZmlsdGVyOiBibHVyKCRibHVyKTtcXG4gICAgYmFja2Ryb3AtZmlsdGVyOiBibHVyKCRibHVyKTtcXG5cXG4gICAgQHN1cHBvcnRzIG5vdCAoYmFja2Ryb3AtZmlsdGVyOiBub25lKSB7XFxuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjMTQxNDE0OyB9IH1cXG5cXG4vL0dlbmVyaWMgTWl4aW5zXFxuQG1peGluIG1pbi1zaXplKCRtaW4td2lkdGgsICRtaW4taGVpZ2h0KSB7XFxuICAgIG1pbi13aWR0aDogJG1pbi13aWR0aDtcXG4gICAgbWluLWhlaWdodDogJG1pbi1oZWlnaHQ7IH1cXG5cXG5AbWl4aW4gbWF4LXNpemUoJG1heC13aWR0aCwgJG1heC1oZWlnaHQpIHtcXG4gICAgbWF4LXdpZHRoOiAkbWF4LXdpZHRoO1xcbiAgICBtYXgtaGVpZ2h0OiAkbWF4LWhlaWdodDsgfVxcblxcbkBtaXhpbiBzaXplKCR3aWR0aCwgJGhlaWdodCkge1xcbiAgICB3aWR0aDogJHdpZHRoO1xcbiAgICBoZWlnaHQ6ICRoZWlnaHQ7IH1cXG5cXG5AbWl4aW4gYWJzb2x1dGUtY2VudGVyKCkge1xcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgIHRvcDogNTAlO1xcbiAgICBsZWZ0OiA1MCU7XFxuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlKC01MCUsIC01MCUpOyB9XFxuXFxuQG1peGluIGdyaWQtY2VudGVyKCkge1xcbiAgICBkaXNwbGF5OiBncmlkO1xcbiAgICBwbGFjZS1pdGVtczogY2VudGVyOyB9XFxuXFxuQG1peGluIGZsZXgoJGp1c3RpZnktY2VudGVudDogc3RhcnQsICRhbGlnbi1pdGVtczogc3RhcnQsICRmbGV4LWRpcmVjdGlvbjogcm93LCAkZ3JpZC1nYXA6IDByZW0pIHtcXG4gICAgZGlzcGxheTogZmxleDtcXG4gICAganVzdGlmeS1jb250ZW50OiAkanVzdGlmeS1jZW50ZW50O1xcbiAgICBhbGlnbi1pdGVtczogJGFsaWduLWl0ZW1zO1xcbiAgICBmbGV4LWRpcmVjdGlvbjogJGZsZXgtZGlyZWN0aW9uO1xcbiAgICBncmlkLWdhcDogJGdyaWQtZ2FwOyB9XFxuXFxuQG1peGluIGFic29sdXRlLWNvdmVyKCkge1xcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgIHRvcDogMDtcXG4gICAgbGVmdDogMDtcXG4gICAgQGluY2x1ZGUgc2l6ZSgxMDAlLCAxMDAlKTsgfVxcblxcbi8vaW52ZXJ0cyB0aGUgZWxlbWVudCB0byBCJlcsIGFuZCBiYWNrIGFnYWluIHRvIGl0J3MgY29sb3Igd2hlbiBob3ZlcmVkXFxuXFxuQG1peGluIGRhcmtlbi1vbi1ob3ZlcigkZGFya25lc3M6IDAuOCkge1xcbiAgICBAbWVkaWEgbm90IChob3Zlcikge1xcbiAgICAgICAgJjpob3ZlciB7XFxuICAgICAgICAgICAgZmlsdGVyOiBicmlnaHRuZXNzKCRkYXJrbmVzcyk7IH0gfSB9XFxuXFxuJGludmVydC1maWx0ZXI6IGJyaWdodG5lc3MoMCkgaW52ZXJ0KDEpO1xcbkBtaXhpbiBjb2xvci1vbi1ob3ZlcigkaW5pdGlhbC1maWx0ZXI6ICRpbnZlcnQtZmlsdGVyKSB7XFxuICAgIEBtZWRpYSBub3QgKGhvdmVyKSB7XFxuICAgICAgICBmaWx0ZXI6ICRpbml0aWFsLWZpbHRlcjtcXG4gICAgICAgICY6aG92ZXIge1xcbiAgICAgICAgICAgIGZpbHRlcjogYnJpZ2h0bmVzcygxKSBpbnZlcnQoMCk7IH0gfSB9XFxuXCIsXCIvLyBQb3BwaW5zXFxuQGltcG9ydCB1cmwoJ2h0dHBzOi8vZm9udHMuZ29vZ2xlYXBpcy5jb20vY3NzMj9mYW1pbHk9UG9wcGluczp3Z2h0QDEwMDszMDA7NTAwOzYwMDs4MDAmZGlzcGxheT1zd2FwJyk7XFxuKiB7XFxuICAgIC8vZm9udCBzbW9vdGhpbmdcXG4gICAgLXdlYmtpdC1mb250LXNtb290aGluZzogYW50aWFsaWFzZWQ7XFxuICAgIC1tb3otb3N4LWZvbnQtc21vb3RoaW5nOiBncmF5c2NhbGU7XFxuICAgIHRleHQtcmVuZGVyaW5nOiBvcHRpbWl6ZUxlZ2liaWxpdHk7XFxuXFxuICAgIGZvbnQtZmFtaWx5OiAnUG9wcGlucycsIHNhbnMtc2VyaWY7IH1cXG5cXG4vL2Zvcm0gZmFjdG9ycyAobm90IGV4YWN0KVxcbiRsYXB0b3A6IDExMTZweDtcXG4kdGFibGV0MDogOTUwcHg7XFxuJHRhYmxldDE6IDc1MHB4O1xcbiR0YWJsZXQyOiA2NTBweDtcXG4kcGhvbmUxOiA0NzVweDtcXG4kcGhvbmUyOiAzNjBweDtcXG4kZm9sZGFibGU6IDI4MHB4O1xcblxcbkBtaXhpbiBtYWpvci10aGlyZCB7XFxuICAgIGgxIHtcXG4gICAgICAgIGZvbnQtc2l6ZTogMy4wNTJyZW07IH1cXG4gICAgaDIge1xcbiAgICAgICAgZm9udC1zaXplOiAyLjQ0MXJlbTsgfVxcbiAgICBoMyB7XFxuICAgICAgICBmb250LXNpemU6IDEuOTUzcmVtOyB9XFxuICAgIGg0IHtcXG4gICAgICAgIGZvbnQtc2l6ZTogMS41NjNyZW07IH1cXG4gICAgaDUge1xcbiAgICAgICAgZm9udC1zaXplOiAxLjI1cmVtOyB9XFxuICAgIGg2IHtcXG4gICAgICAgIGZvbnQtc2l6ZTogMC44cmVtOyB9XFxuICAgIC5idG4ge1xcbiAgICAgICAgZm9udC1zaXplOiAwLjg1cmVtOyB9XFxuICAgIGlucHV0W3R5cGUgPSBzdWJtaXRdLFxcbiAgICBpbnB1dFt0eXBlID0gdGV4dF0sXFxuICAgIGlucHV0W3R5cGUgPSBlbWFpbF0sXFxuICAgIHRleHRhcmVhIHtcXG4gICAgICAgIGZvbnQtc2l6ZTogMC44cmVtOyB9XFxuICAgIHNtYWxsLCBsYWJlbCB7XFxuICAgICAgICBmb250LXNpemU6IDAuOHJlbTsgfVxcbiAgICAudGlueS1zbWFsbCB7XFxuICAgICAgICBmb250LXNpemU6IDAuNnJlbTsgfSB9XFxuXFxuQG1peGluIG1pbm9yLXRoaXJkKCkge1xcbiAgICBoMSB7XFxuICAgICAgICBmb250LXNpemU6IDIuMnJlbTsgfVxcbiAgICBoMiB7XFxuICAgICAgICBmb250LXNpemU6IDEuOXJlbTsgfVxcbiAgICBoMyB7XFxuICAgICAgICBmb250LXNpemU6IDEuNzI4cmVtOyB9XFxuICAgIGg0IHtcXG4gICAgICAgIGZvbnQtc2l6ZTogMS40NHJlbTsgfVxcbiAgICBoNSB7XFxuICAgICAgICBmb250LXNpemU6IDEuMnJlbTsgfVxcbiAgICBoNiB7XFxuICAgICAgICBmb250LXNpemU6IDAuOHJlbTsgfVxcbiAgICAuYnRuLFxcbiAgICBpbnB1dFt0eXBlID0gc3VibWl0XSxcXG4gICAgaW5wdXRbdHlwZSA9IHRleHRdLFxcbiAgICBpbnB1dFt0eXBlID0gZW1haWxdLFxcbiAgICB0ZXh0YXJlYSB7XFxuICAgICAgICBmb250LXNpemU6IDAuOXJlbTsgfVxcbiAgICBzbWFsbCwgbGFiZWwge1xcbiAgICAgICAgZm9udC1zaXplOiAwLjhyZW07IH0gfVxcblxcbmJvZHkge1xcbiAgICBAaW5jbHVkZSBtYWpvci10aGlyZCgpOyB9XFxuXFxuLy9Gb250IHdlaWdodHMgYW5kIGxpbmUgaGVpZ2h0c1xcbnAge1xcbiAgICBmb250LXdlaWdodDogNDAwOyB9XFxuXFxuaDEsIGgyIHtcXG4gICAgbGluZS1oZWlnaHQ6IDEzMCU7XFxuICAgIGZvbnQtd2VpZ2h0OiA3MDA7IH1cXG5cXG5oMyB7XFxuICAgIGxpbmUtaGVpZ2h0OiAxMzAlO1xcbiAgICBmb250LXdlaWdodDogNDAwOyB9XFxuXFxuaDQge1xcbiAgICBsaW5lLWhlaWdodDogMTAwJTtcXG4gICAgZm9udC13ZWlnaHQ6IDYwMDsgfVxcblxcbmg1IHtcXG4gICAgZm9udC13ZWlnaHQ6IDQwMDtcXG4gICAgbGluZS1oZWlnaHQ6IDEyMCU7IH1cXG5cXG5oNiB7XFxuICAgIGZvbnQtd2VpZ2h0OiA1MDA7IH1cXG5cXG5zdHJvbmcge1xcbiAgICBmb250LXdlaWdodDogODAwOyB9XFxuXFxuQG1lZGlhIHNjcmVlbiBhbmQgKCBtaW4td2lkdGg6ICRsYXB0b3AgKSB7IC8vMTExNnB4XFxuICAgIGh0bWwge1xcbiAgICAgICAgZm9udC1zaXplOiAxMjUlOyB9IH0gLy8yMHB4XFxuXFxuQG1lZGlhIHNjcmVlbiBhbmQgKCBtYXgtd2lkdGg6ICRsYXB0b3AgKSB7IC8vMTExNnB4XFxuICAgIGh0bWwge1xcbiAgICAgICAgZm9udC1zaXplOiAxMTUlOyB9IH0gLy8xOC40cHhcXG5cXG5AbWVkaWEgc2NyZWVuIGFuZCAoIG1heC13aWR0aDogJHRhYmxldDAgKSB7IC8vOTUwcHhcXG4gICAgaHRtbCB7XFxuICAgICAgICBmb250LXNpemU6IDExMCU7IH0gfSAvLzE3LjZweFxcblxcbkBtZWRpYSBzY3JlZW4gYW5kICggbWF4LXdpZHRoOiAkdGFibGV0MSApIHsgLy83NTBweFxcbiAgICBodG1sIHtcXG4gICAgICAgIGZvbnQtc2l6ZTogMTA1JTsgfSB9IC8vMTYuOHB4XFxuXFxuQG1lZGlhIHNjcmVlbiBhbmQgKCBtYXgtd2lkdGg6ICRwaG9uZTEpIHsgLy80NzVweFxcbiAgICBib2R5IHtcXG4gICAgICAgIEBpbmNsdWRlIGNlbnRlci1hbGlnbigpO1xcbiAgICAgICAgQGluY2x1ZGUgbWlub3ItdGhpcmQoKTsgfSB9XFxuXFxuQG1lZGlhIHNjcmVlbiBhbmQgKCBtYXgtd2lkdGg6ICRwaG9uZTIpIHsgLy8zNjBweFxcbiAgICBodG1sIHtcXG4gICAgICAgIGZvbnQtc2l6ZTogMTAwJTsgfSB9IC8vMTZweFxcblxcbi8vICBBbnkgY3VzdG9tIHR5cG9ncmFwaHkgd2lsbCBiZSB3cml0dGVuIGluIGl0J3MgcGxhY2VcXG4vLyAgYW5kIG5vdCBoZXJlXFxuXCIsXCIucm9vdCB7XFxuICAgIC8vPT09PT09PT09PT09PT09PT09PT09PS8vXFxuICAgIC8vUFJJTUFSWSBDT0xPUiBQQUxFVFRFIC8vXFxuICAgIC8vPT09PT09PT09PT09PT09PT09PT09PS8vXFxuICAgIC0tcHJpbWFyeS1waW5rOiAjRjM1RTg0O1xcbiAgICAtLXByaW1hcnktcHVycGxlOiAjNkU4MkY5O1xcbiAgICAtLXByaW1hcnktZ3JlZW46ICM5RkZCQ0U7XFxuXFxuICAgIC8vPT09PT09PT09PT09PT09PT09PS8vXFxuICAgIC8vUFJJTUFSWSBHUkFESUVOVFMgLy9cXG4gICAgLy89PT09PT09PT09PT09PT09PT0vL1xcbiAgICAtLXBpbmstcHVycGxlLWdyZDogbGluZWFyLWdyYWRpZW50KDkwZGVnLCB2YXIoLS1wcmltYXJ5LXBpbmspIDAlLCAjQUY3MEMwIDUwJSwgdmFyKC0tcHJpbWFyeS1wdXJwbGUpIDEwMCUpO1xcbiAgICAtLXB1cnBsZS1ncmVlbi1ncmQ6IGxpbmVhci1ncmFkaWVudCg5MGRlZywgdmFyKC0tcHJpbWFyeS1wdXJwbGUpIDAlLCAjMjJCOUZGIDUwLjMxJSwgI0E2RkZEOCAxMDAlLCB2YXIoLS1wcmltYXJ5LWdyZWVuKSAxMDAlKTtcXG5cXG4gICAgLy89PT09PT09PT09PT09PT09PT0vL1xcbiAgICAvL0JVVFRPTlMgR1JBRElFTlRTIC8vXFxuICAgIC8vPT09PT09PT09PT09PT09PT0vL1xcbiAgICAtLWJ0bi1waW5rLXB1cnBsZS1ncmQ6IGxpbmVhci1ncmFkaWVudCg5MGRlZywgdmFyKC0tcHJpbWFyeS1waW5rKSAwJSwgdmFyKC0tcHJpbWFyeS1waW5rKSA1MCUsIHZhcigtLXByaW1hcnktcHVycGxlKSAxMDAlKTtcXG4gICAgLS1idG4tcGluay1wdXJwbGUtZ3JkLWJvcmRlcjogbGluZWFyLWdyYWRpZW50KDkwZGVnLCAjRkUzMDY0IDAsICNGRTMwNjQgNTAlLCAjNDE1Q0ZGIDEwMCUpO1xcblxcbiAgICAvLz09PT09PT09PT09PT09PT09PT09Ly9cXG4gICAgLy9TRUNPTkRBUlkgR1JBRElFTlRTIC8vXFxuICAgIC8vPT09PT09PT09PT09PT09PT09PT0vL1xcbiAgICAvLyBFaXRoZXIgbm90IG9mdGVuIHVzZWQgb3IgbWFkZSBmb3Igc3BlY2lhbCBjYXNlc1xcbiAgICAtLWJhbm5lci1ib3JkZXItZ3JkOiBsaW5lYXItZ3JhZGllbnQoOTBkZWcsICNkMWZmZTggMCUsIHJnYmEoMCwwLDAsIDApIDI1JSwgcmdiYSgwLDAsMCwgMCkgNzUlLCAjODYyREY3IDEwMCUpO1xcbiAgICAtLWNvbnRhY3QtYm9yZGVyLWdyZDogbGluZWFyLWdyYWRpZW50KDEwNS44ZGVnLCAjZDFmZmU4IDAlLCByZ2JhKDAsMCwwLCAwKSAyNSUsIHJnYmEoMCwwLDAsIDApIDc1JSwgIzg2MkRGNyAxMDAlKTtcXG4gICAgLS10aHVtYi1ncmQ6IGxpbmVhci1ncmFkaWVudCgxODBkZWcsIHZhcigtLXByaW1hcnktcGluaykgMCUsIHZhcigtLXByaW1hcnktcHVycGxlKSAxMDAlKTtcXG5cXG4gICAgLS1jb2xvci1lcnJvcjogI0RDMzU0NTtcXG4gICAgLS1jb2xvci1zdWNjZXNzOiAjMjhBNzQ1OyB9XFxuXFxuJGJ0bi10cmFuc2l0aW9uLWR1cmF0aW9uOiAwLjNzO1xcblxcbi8vc2VjdGlvbnMgdGhlbWluZ1xcbkBtaXhpbiBsYW5kaW5nLXRoZW1pbmcoJHRoZW1lOiBkYXJrKSB7XFxuICAgIEBpZiAkdGhlbWUgPT0gZGFyayB7fVxcbiAgICBAZWxzZSBpZiAkdGhlbWUgPT0gbGlnaHQge30gfVxcblxcbkBtaXhpbiBtZS10aGVtaW5nKCR0aGVtZTogZGFyaykge1xcbiAgICAvL2xhcmdlLXNjcmVlbi1leHBcXG4gICAgJGV4cC1iZzogcmdiYSgyNTUsIDAsIDAsIDAuMyk7XFxuICAgICR5ZWFycy1mZzogcmdiYSgyNTUsIDAsIDAsIDAuMyk7XFxuXFxuICAgIEBpZiAkdGhlbWUgPT0gZGFyayB7XFxuICAgICAgICAkZXhwLWJnOiAjMUExQTFBO1xcbiAgICAgICAgJHllYXJzLWZnOiB2YXIoLS1wcmltYXJ5LWdyZWVuKTsgfVxcblxcbiAgICBAZWxzZSBpZiAkdGhlbWUgPT0gbGlnaHQge31cXG5cXG4gICAgLm1lIC5leHAge1xcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogJGV4cC1iZztcXG4gICAgICAgICN5ZWFycyB7XFxuICAgICAgICAgICAgY29sb3I6IHZhcigtLXByaW1hcnktZ3JlZW4pOyB9IH0gfVxcblxcbkBtaXhpbiBza2lsbHMtdGhlbWluZygkdGhlbWU6IGRhcmspIHtcXG4gICAgLy9kdXRpZXNcXG4gICAgJGFjdGl2ZS1kdXR5LWJnOiByZ2JhKDI1NSwgMCwgMCwgMC4zKTtcXG4gICAgLy90ZWNoICYgdG9vbHNcXG4gICAgJHRvb2xzLWJhbm5lci1iZzogcmdiYSgyNTUsIDAsIDAsIDAuMyk7XFxuICAgIEBpZiAkdGhlbWUgPT0gZGFyayB7XFxuICAgICAgICAkYWN0aXZlLWR1dHktYmc6ICMxQTFBMUE7XFxuICAgICAgICAkdG9vbHMtYmFubmVyLWJnOiAjMUExQTFBOyB9XFxuICAgIEBlbHNlIGlmICR0aGVtZSA9PSBsaWdodCB7fVxcblxcbiAgICAuc2tpbGxzIHtcXG4gICAgICAgIC5kdXRpZXMgLmFjdGl2ZS1kdXR5IHtcXG4gICAgICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAkYWN0aXZlLWR1dHktYmc7IH1cXG4gICAgICAgIC50ZWNoLXRvb2xzIHtcXG4gICAgICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAkdG9vbHMtYmFubmVyLWJnOyB9IH0gfVxcblxcbkBtaXhpbiB3b3JrLXRoZW1pbmcoJHRoZW1lOiBkYXJrKSB7XFxuICAgICRjYXJkLWJnOiByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMyk7XFxuICAgICRjYXJkLWJvcmRlci1jb2xvcjogcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjMpO1xcbiAgICBAaWYgJHRoZW1lID09IGRhcmsge31cXG4gICAgQGVsc2UgaWYgJHRoZW1lID09IGxpZ2h0IHt9IH1cXG5cXG5AbWl4aW4gY29udGFjdC10aGVtaW5nKCR0aGVtZTogZGFyaykge1xcbiAgICBsYWJlbFtpbXBvcnRhbmNlPSdjcnVjaWFsJ10ge1xcbiAgICAgICAgJjo6YWZ0ZXIge1xcbiAgICAgICAgICAgIGNvbnRlbnQ6ICcqJztcXG4gICAgICAgICAgICBjb2xvcjogdmFyKC0tY29sb3ItZXJyb3IpOyB9IH1cXG4gICAgQGlmICR0aGVtZSA9PSBkYXJrIHt9XFxuICAgIEBlbHNlIGlmICR0aGVtZSA9PSBsaWdodCB7fSB9XFxuXFxuLmRhcmsge1xcbiAgICBAZXh0ZW5kIC5yb290O1xcblxcbiAgICAvL01haW4gYmFja2dyb3VuZCBhbmQgZm9yZWdyb3VuZCBmb3IgdGhpcyB0aGVtZVxcbiAgICAtLWJnOiAjMDAwO1xcbiAgICAtLWZnOiAjZmZmO1xcblxcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1iZyk7XFxuICAgIGNvbG9yOiB2YXIoLS1mZyk7XFxuICAgIGgxLCBoMiB7XFxuICAgICAgICBAaW5jbHVkZSBmaWxsLWdyZCgpOyB9XFxuICAgIGEge1xcbiAgICAgICAgY29sb3I6IHZhcigtLWZnKTsgfVxcblxcbiAgICAuYnRuIHtcXG4gICAgICAgIGNvbG9yOiB2YXIoLS1mZyk7XFxuICAgICAgICBAaW5jbHVkZSBidG4tYm9yZGVyLWdyZCgpO1xcbiAgICAgICAgYm94LXNoYWRvdzogMCAxcHggMTBweCByZ2JhKDI0MCw5NSwxMzUsIDAuNSk7XFxuXFxuICAgICAgICB0cmFuc2l0aW9uOiBiYWNrZ3JvdW5kLXBvc2l0aW9uICRidG4tdHJhbnNpdGlvbi1kdXJhdGlvbiwgYm94LXNoYWRvdyAkYnRuLXRyYW5zaXRpb24tZHVyYXRpb247XFxuICAgICAgICAmOmhvdmVyIHtcXG4gICAgICAgICAgICBib3gtc2hhZG93OiAwIDFweCAyNXB4IHJnYmEoMjQwLDk1LDEzNSwgMC41KTsgfSB9XFxuXFxuICAgIC5idG4tcHJpbWFyeSB7XFxuICAgICAgICBiYWNrZ3JvdW5kLWltYWdlOiB2YXIoLS1idG4tcGluay1wdXJwbGUtZ3JkKTtcXG4gICAgICAgIGJhY2tncm91bmQtc2l6ZTogMjAwJSBhdXRvO1xcbiAgICAgICAgYmFja2dyb3VuZC1wb3NpdGlvbjogMTAwJSA1MCU7XFxuICAgICAgICAuYnRuLWljb24ge1xcbiAgICAgICAgICAgIHRyYW5zaXRpb246IHRyYW5zZm9ybSAkYnRuLXRyYW5zaXRpb24tZHVyYXRpb247IH1cXG4gICAgICAgICY6aG92ZXIge1xcbiAgICAgICAgICAgIGJhY2tncm91bmQtcG9zaXRpb246IGxlZnQgY2VudGVyOyB9IH1cXG5cXG4gICAgLmJ0bi1zZWNvbmRhcnkge1xcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tYmcpOyB9XFxuXFxuICAgIGZvcm0ge1xcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogIzI3MjcyNzsgfVxcblxcbiAgICBpbnB1dFt0eXBlID0gdGV4dF0sIGlucHV0W3R5cGUgPSBlbWFpbF0sIHRleHRhcmVhIHtcXG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6ICMxRjFGMUY7XFxuICAgICAgICBib3JkZXItY29sb3I6IHRyYW5zcGFyZW50O1xcbiAgICAgICAgdHJhbnNpdGlvbjogYm9yZGVyLWNvbG9yIDAuMXMgZWFzZS1vdXQsIGJhY2tncm91bmQtY29sb3IgMC4ycyBlYXNlLW91dDtcXG4gICAgICAgIGNvbG9yOiAjZmZmZmZmO1xcbiAgICAgICAgJjpob3ZlciB7XFxuICAgICAgICAgICAgYm9yZGVyLWNvbG9yOiAjNjA2MDYwICFpbXBvcnRhbnQ7IH1cXG4gICAgICAgICY6Zm9jdXMge1xcbiAgICAgICAgICAgIGJvcmRlci1jb2xvcjogdmFyKC0tcHJpbWFyeS1wdXJwbGUpICFpbXBvcnRhbnQ7XFxuICAgICAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogIzE0MTQxNDsgfSB9XFxuICAgIC5lcnJvci1tc2cge1xcbiAgICAgICAgY29sb3I6IHZhcigtLWNvbG9yLWVycm9yKTsgfVxcblxcbiAgICBAaW5jbHVkZSBsYW5kaW5nLXRoZW1pbmcoZGFyayk7XFxuICAgIEBpbmNsdWRlIG1lLXRoZW1pbmcoZGFyayk7XFxuICAgIEBpbmNsdWRlIHNraWxscy10aGVtaW5nKGRhcmspO1xcbiAgICBAaW5jbHVkZSB3b3JrLXRoZW1pbmcoZGFyayk7XFxuICAgIEBpbmNsdWRlIGNvbnRhY3QtdGhlbWluZyhkYXJrKTsgfVxcblxcbi8vIzE5MTkxOVxcbi8vIzFBMUExQVxcbi8vIzFBMUExQVxcbi8vIzBGMEYwRlxcbi8vIzI3MjcyN1xcbi8vIzFGMUYxRlxcblwiLFwiQGltcG9ydCBcXFwibWl4aW5zXFxcIjtcXG5AaW1wb3J0IFxcXCJub3JtYWxpemVcXFwiO1xcbkBpbXBvcnQgXFxcInR5cG9ncmFwaHlcXFwiO1xcbkBpbXBvcnQgXFxcInRoZW1pbmdcXFwiO1xcblxcbi8vPT09PT09PT09PT09PT09PT09PS8vXFxuLy8gR2xvYmFsIFZhcmlhYmxlcyAvL1xcbi8vPT09PT09PT09PT09PT09PT09Ly9cXG4kYm9yZGVyLXJhZGl1czogMTBweDtcXG4kbWF4LXdpZHRoOiAxNjAwcHg7XFxuJGNvbnRhaW5lci13aWR0aDogOTAlO1xcblxcbioge1xcbiAgICBzY3JvbGwtYmVoYXZpb3I6IHNtb290aDtcXG4gICAgbWFyZ2luOiAwO1xcbiAgICBwYWRkaW5nOiAwO1xcbiAgICBib3gtc2l6aW5nOiBib3JkZXItYm94OyB9XFxuXFxuKjpub3QodGV4dGFyZWEpOmZvY3VzIHtcXG4gICAgb3V0bGluZTogMi41cHggZGFzaGVkIHZhcigtLXByaW1hcnktcHVycGxlKTtcXG4gICAgb3V0bGluZS1vZmZzZXQ6IDVweDsgfVxcblxcbmJvZHkge1xcbiAgICAmOjotd2Via2l0LXNjcm9sbGJhciB7XFxuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjMDAwO1xcbiAgICAgICAgQGluY2x1ZGUgc2l6ZSgwLjU1cmVtLCAwLjU1cmVtKTsgfVxcbiAgICAmOjotd2Via2l0LXNjcm9sbGJhci10aHVtYiB7XFxuICAgICAgICBib3JkZXI6IDRweCBzb2xpZCByZ2JhKDAsIDAsIDAsIDApO1xcbiAgICAgICAgYmFja2dyb3VuZC1jbGlwOiBwYWRkaW5nLWJveDtcXG4gICAgICAgIGJvcmRlci1yYWRpdXM6ICRib3JkZXItcmFkaXVzO1xcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogI0FBQUFBQTtcXG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IHZhcigtLXByaW1hcnktcGluayk7IH0gfVxcblxcbi5jb250YWluZXIge1xcbiAgICB3aWR0aDogJGNvbnRhaW5lci13aWR0aDtcXG4gICAgbWF4LXdpZHRoOiAkbWF4LXdpZHRoO1xcbiAgICBtYXJnaW46IDAgYXV0bzsgfVxcblxcbi53aWRlLWJhbm5lciB7XFxuICAgIEBpbmNsdWRlIGJhY2tkcm9wLWJsdXIoKTtcXG5cXG4gICAgd2lkdGg6IDEwMHZ3O1xcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICAgICY6OmJlZm9yZSxcXG4gICAgJjo6YWZ0ZXIge1xcbiAgICAgICAgY29udGVudDogJyc7XFxuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgICAgICBsZWZ0OiAwO1xcbiAgICAgICAgQGluY2x1ZGUgc2l6ZSgxMDB2dywgMS41cHgpO1xcbiAgICAgICAgYmFja2dyb3VuZDogdmFyKC0tYmFubmVyLWJvcmRlci1ncmQpOyB9XFxuICAgICY6OmJlZm9yZSB7XFxuICAgICAgICB0b3A6IDA7IH1cXG4gICAgJjo6YWZ0ZXIge1xcbiAgICAgICAgYm90dG9tOiAwOyB9IH1cXG5cXG4ubm90LWNlbnRlcmVkIHtcXG4gICAgdGV4dC1hbGlnbjogbGVmdCAhaW1wb3J0YW50O1xcbiAgICAqIHtcXG4gICAgICAgIHRleHQtYWxpZ246IGxlZnQgIWltcG9ydGFudDsgfSB9XFxuXFxuYSB7XFxuICAgIHRleHQtZGVjb3JhdGlvbjogbm9uZTtcXG4gICAgZGlzcGxheTogaW5saW5lLWJsb2NrOyB9XFxuXFxuYSwgYnV0dG9uIHtcXG4gICAgY3Vyc29yOiBwb2ludGVyOyB9XFxuXFxuLmJ0bixcXG5idXR0b24sXFxuaW5wdXRbdHlwZSA9IHN1Ym1pdF0sXFxuaW5wdXRbdHlwZSA9IHRleHRdLFxcbmlucHV0W3R5cGUgPSBlbWFpbF0sXFxudGV4dGFyZWEge1xcbiAgICBib3JkZXI6IG5vbmU7IH1cXG5cXG50ZXh0YXJlYSB7XFxuICAgIHJlc2l6ZTogbm9uZTsgfVxcblxcbmlucHV0W3R5cGUgPSB0ZXh0XSxcXG5pbnB1dFt0eXBlID0gZW1haWxdLFxcbnRleHRhcmVhIHtcXG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgICBkaXNwbGF5OiBibG9jaztcXG4gICAgd2lkdGg6IDEwMCU7XFxuICAgIGJvcmRlci13aWR0aDogMnB4O1xcbiAgICBib3JkZXItc3R5bGU6IHNvbGlkO1xcbiAgICBib3JkZXItcmFkaXVzOiAkYm9yZGVyLXJhZGl1cztcXG4gICAgcGFkZGluZzogMC41cmVtIDAuN3JlbTtcXG4gICAgb3V0bGluZTogbm9uZTsgfVxcblxcbnRleHRhcmVhIHtcXG4gICAgaGVpZ2h0OiBhdXRvOyB9XFxuXFxuLmJ0biB7XFxuICAgIGJvcmRlci1yYWRpdXM6IDZweDtcXG5cXG4gICAgcGFkZGluZzogMC41cmVtIDEuNXJlbTtcXG5cXG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xcblxcbiAgICBAaW5jbHVkZSBmbGV4KGNlbnRlciwgY2VudGVyLCByb3csIDAuMjVyZW0pO1xcbiAgICBmbGV4LXNocmluazogMDtcXG5cXG4gICAgLmJ0bi1pY29uIHtcXG4gICAgICAgIEBpbmNsdWRlIHNpemUoMjJweCwgMjJweCk7XFxuICAgICAgICBiYWNrZ3JvdW5kLXJlcGVhdDogbm8tcmVwZWF0O1xcbiAgICAgICAgYmFja2dyb3VuZC1zaXplOiBjb3ZlcjsgfSB9XFxuXFxuLmJ0bi1wcmltYXJ5LFxcbi5idG4tc2Vjb25kYXJ5IHtcXG4gICAgQGV4dGVuZCAuYnRuOyB9XFxuXFxuLmJ0bi1wcmltYXJ5IHtcXG4gICAgLmJ0bi1pY29uIHtcXG4gICAgICAgIGJhY2tncm91bmQtaW1hZ2U6IHVybCgnLi4vYXNzZXRzL2Fycm93LnN2ZycpOyB9XFxuICAgICY6aG92ZXIge1xcbiAgICAgICAgLmJ0bi1pY29uIHtcXG4gICAgICAgICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVgoNXB4KTsgfSB9IH1cXG5cXG4uYnRuLXNlY29uZGFyeSB7XFxuICAgIGZsZXgtZGlyZWN0aW9uOiByb3ctcmV2ZXJzZTtcXG4gICAgZ2FwOiAxMHB4OyB9XFxuXFxuLmhlYWRlci1idG4ge1xcbiAgICBwYWRkaW5nOiAwLjM1cmVtIDEuNXJlbTtcXG4gICAgLmJ0bi1pY29uIHtcXG4gICAgICAgIEBpbmNsdWRlIHNpemUoMTVweCwgMTVweCk7IH0gfVxcblwiLFwiQGltcG9ydCBcXFwiZ2VuZXJpY1xcXCI7XFxuXFxuaHRtbCB7XFxuICAgIEBpbmNsdWRlIHNpemUoMTAwJSwgMTAwJSk7XFxuICAgIC8vIGhlaWdodDogLXdlYmtpdC1maWxsLWF2YWlsYWJsZVxcbiAgICBoZWlnaHQ6IC13ZWJraXQtc3RyZXRjaDsgfVxcblxcbmJvZHkge1xcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICAgIG92ZXJmbG93LXg6IGhpZGRlbjtcXG4gICAgQGluY2x1ZGUgc2l6ZShpbmhlcml0LCBpbmhlcml0KTtcXG4gICAgbWFpbiB7XFxuICAgICAgICBAaW5jbHVkZSBzaXplKGluaGVyaXQsIGluaGVyaXQpOyB9IH1cXG5cXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xcbi8vIFJlZHVuZGFudCAyIGxpbmVzIChKdXN0IHRvIHByZXZlbnQgc29tZSBTQVNTIGluZGVudGF0aW9uIGlzc3VlKVxcbi8vIFJlbW92ZSB0aGUgdHdvIGxpbmUgdG8gY2hlY2sgdGhlIGlzc3VlXFxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cXG4uZml4IHtcXG4gICAgcG9zaXRpb246IGFic29sdXRlOyB9XFxuXFxuQGltcG9ydCBcXFwibGFuZGluZ1xcXCI7XFxuQGltcG9ydCBcXFwiZGVjb3JhdGlvbnNcXFwiO1xcbkBpbXBvcnQgXFxcIm1lXFxcIjtcXG5AaW1wb3J0IFxcXCJza2lsbHNcXFwiO1xcbkBpbXBvcnQgXFxcIndvcmtcXFwiO1xcbkBpbXBvcnQgXFxcImNvbnRhY3RcXFwiO1xcblxcbi5za2lsbHMge1xcbiAgICBwIHtcXG4gICAgICAgIG1heC13aWR0aDogNjBjaDsgfSB9XFxuXFxuc2VjdGlvbjpub3QoLmxhbmRpbmcpOm5vdCguY29udGFjdCkge1xcbiAgICBtYXJnaW4tdG9wOiAtNzBweDtcXG4gICAgcGFkZGluZy10b3A6IDE0MHB4OyB9XFxuXFxuLmNvbnRhY3Qge1xcbiAgICBwYWRkaW5nLXRvcDogNzBweDsgfVxcblxcbnNlY3Rpb24gLnRpdGxlIHtcXG4gICAgZGlzcGxheTogZmxleDtcXG4gICAganVzdGlmeS1jb250ZW50OiBzdGFydDtcXG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gICAgZ3JpZC1nYXA6IDAuNXJlbTtcXG4gICAgbWFyZ2luLWJvdHRvbTogMXJlbTtcXG4gICAgd2hpdGUtc3BhY2U6IG5vd3JhcDsgfVxcblxcbkBtZWRpYSBzY3JlZW4gYW5kICggbWluLXdpZHRoOiAkbGFwdG9wKSB7IC8vMTExNnB4XFxuICAgIC5pbWctdGl0bGUge1xcbiAgICAgICAgd2lkdGg6IDgwcHg7IH0gfVxcblxcbkBtZWRpYSBzY3JlZW4gYW5kICggbWF4LXdpZHRoOiAkbGFwdG9wKSB7IC8vMTExNnB4XFxuICAgIC5pbWctdGl0bGUge1xcbiAgICAgICAgd2lkdGg6IDcwcHg7IH0gfVxcblxcbkBtZWRpYSBzY3JlZW4gYW5kICggbWF4LXdpZHRoOiAkdGFibGV0MSkgeyAvLzc1MHB4XFxuICAgIC5pbWctdGl0bGUge1xcbiAgICAgICAgd2lkdGg6IDY1cHg7IH1cXG4gICAgLm1lLCAuc2tpbGxzIHtcXG4gICAgICAgIHAge1xcbiAgICAgICAgICAgIG1heC13aWR0aDogMTAwJTsgfSB9IH1cXG5cXG5AbWVkaWEgc2NyZWVuIGFuZCAoIG1heC13aWR0aDogJHRhYmxldDIpIHsgLy82NTBweFxcbiAgICBzZWN0aW9uOm5vdCgubGFuZGluZyk6bm90KC5jb250YWN0KSB7XFxuICAgICAgICBtYXJnaW4tdG9wOiAtNTBweDtcXG4gICAgICAgIHBhZGRpbmctdG9wOiAxMDBweDsgfVxcbiAgICAuY29udGFjdCB7XFxuICAgICAgICBwYWRkaW5nLXRvcDogNTBweDsgfSB9XFxuXFxuQG1lZGlhIHNjcmVlbiBhbmQgKCBtYXgtd2lkdGg6ICRwaG9uZTEpIHsgLy80NzVweFxcbiAgICAuaW1nLXRpdGxlIHtcXG4gICAgICAgIHdpZHRoOiA2MHB4OyB9XFxuICAgIC5idG4ge1xcbiAgICAgICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XFxuICAgICAgICAuYnRuLWljb24ge1xcbiAgICAgICAgICAgIEBpbmNsdWRlIHNpemUoMTVweCwgMTVweCk7IH0gfVxcbiAgICAudGl0bGUge1xcbiAgICAgICAgZmxleC13cmFwOiB3cmFwO1xcbiAgICAgICAganVzdGlmeS1jb250ZW50OiBjZW50ZXIgIWltcG9ydGFudDtcXG4gICAgICAgIGgyIHtcXG4gICAgICAgICAgICB3aWR0aDogbWluLWNvbnRlbnQ7IH0gfSB9XFxuXCIsXCIvL3Njcm9sbCBhbmltYXRpb25zXFxuLy9odHRwczovL2Nvb2xjc3NhbmltYXRpb24uY29tL2hvdy10by1tYWtlLXNjcm9sbC1hbmltYXRpb25zL1xcblxcbi5sYW5kaW5nIHtcXG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xcblxcbiAgICBtaW4taGVpZ2h0OiAxMDAlO1xcblxcbiAgICBkaXNwbGF5OiBncmlkO1xcbiAgICBncmlkLXRlbXBsYXRlLXJvd3M6IGF1dG8gMWZyIGF1dG87XFxuXFxuICAgID4gLmNvbnRhaW5lciB7XFxuICAgICAgICBncmlkLXJvdzogMi8zO1xcbiAgICAgICAgYWxpZ24tc2VsZjogY2VudGVyOyB9XFxuXFxuICAgIGhlYWRlciB7XFxuICAgICAgICBncmlkLXJvdzogMS8yO1xcbiAgICAgICAgbWluLXdpZHRoOiAxMDB2dztcXG4gICAgICAgIHdpZHRoOiAxMDB2dztcXG4gICAgICAgIHotaW5kZXg6IDM7XFxuICAgICAgICBAaW5jbHVkZSBiYWNrZHJvcC1ibHVyKCk7XFxuICAgICAgICBib3JkZXItYm90dG9tOiAxcHggc29saWQgI2ZmZjtcXG4gICAgICAgIC5jb250YWluZXIge1xcbiAgICAgICAgICAgIGRpc3BsYXk6IGdyaWQ7XFxuICAgICAgICAgICAgZ3JpZC10ZW1wbGF0ZS1jb2x1bW5zOiAxZnIgM2ZyIDFmcjtcXG4gICAgICAgICAgICAuZGVza3RvcC1uYXYge1xcbiAgICAgICAgICAgICAgICBncmlkLWNvbHVtbjogMi8zO1xcbiAgICAgICAgICAgICAgICBAaW5jbHVkZSBmbGV4KGNlbnRlciwgY2VudGVyLCByb3csIDJyZW0pO1xcbiAgICAgICAgICAgICAgICAubG9nbyB7XFxuICAgICAgICAgICAgICAgICAgICBAaW5jbHVkZSBzaXplKDcwcHgsIDcwcHgpO1xcbiAgICAgICAgICAgICAgICAgICAgb3ZlcmZsb3c6IGhpZGRlbjtcXG4gICAgICAgICAgICAgICAgICAgIHN2ZyB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgQGluY2x1ZGUgc2l6ZShpbmhlcml0LCBpbmhlcml0KTsgfSB9XFxuICAgICAgICAgICAgICAgIC5kZXNrdG9wLWxpbmtzIHtcXG4gICAgICAgICAgICAgICAgICAgIEBpbmNsdWRlIGZsZXgoaW5oZXJpdCwgaW5oZXJpdCwgaW5oZXJpdCwgaW5oZXJpdCk7XFxuICAgICAgICAgICAgICAgICAgICAuc2VjdGlvbi1saW5rIGEge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQtdHJhbnNmb3JtOiB1cHBlcmNhc2U7XFxuICAgICAgICAgICAgICAgICAgICAgICAgZm9udC1zaXplOiA5MCU7XFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFkZGluZzogMC4yNXJlbSAwLjRyZW07XFxuICAgICAgICAgICAgICAgICAgICAgICAgYm9yZGVyLXJhZGl1czogNXB4O1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zaXRpb246IGJhY2tncm91bmQtY29sb3IgMC4xNXMgZWFzZS1pbjtcXG4gICAgICAgICAgICAgICAgICAgICAgICAmOmhvdmVyIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tcHJpbWFyeS1wdXJwbGUpOyB9IH0gfSB9XFxuXFxuICAgICAgICAgICAgLmhlYWRlci1idG4ge1xcbiAgICAgICAgICAgICAgICBncmlkLWNvbHVtbjogMy80O1xcbiAgICAgICAgICAgICAgICBqdXN0aWZ5LXNlbGY6IGVuZDtcXG4gICAgICAgICAgICAgICAgYWxpZ24tc2VsZjogY2VudGVyO1xcbiAgICAgICAgICAgICAgICB3aWR0aDogZml0LWNvbnRlbnQgIWltcG9ydGFudDsgfVxcbiAgICAgICAgICAgIC5idG4taGFtIHtcXG4gICAgICAgICAgICAgICAgei1pbmRleDogMjtcXG4gICAgICAgICAgICAgICAgQGluY2x1ZGUgc2l6ZSgyNXB4LCAyNXB4KTtcXG4gICAgICAgICAgICAgICAgaW1nIHtcXG4gICAgICAgICAgICAgICAgICAgIEBpbmNsdWRlIHNpemUoaW5oZXJpdCwgaW5oZXJpdCk7IH0gfVxcbiAgICAgICAgICAgIC5tb2JpbGUtbmF2IHtcXG4gICAgICAgICAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICAgICAgICAgICAgICB0b3A6IDUwcHg7XFxuICAgICAgICAgICAgICAgIGxlZnQ6IDA7XFxuICAgICAgICAgICAgICAgIHdpZHRoOiAxMDB2dztcXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBjYWxjKDEwMHZoIC0gNTBweCk7XFxuICAgICAgICAgICAgICAgIC8vVE9ETzogbW92ZSB0byB0aGVtaW5nXFxuICAgICAgICAgICAgICAgIGJhY2tncm91bmQtY29sb3I6IHZhcigtLWJnKTtcXG4gICAgICAgICAgICAgICAgZGlzcGxheTogbm9uZTtcXG5cXG4gICAgICAgICAgICAgICAgdWwge1xcbiAgICAgICAgICAgICAgICAgICAgcGFkZGluZzogM3JlbSAxLjVyZW07XFxuICAgICAgICAgICAgICAgICAgICBAaW5jbHVkZSBmbGV4KGNlbnRlciwgc3RhcnQsIGNvbHVtbiwgMC4zcmVtKTtcXG4gICAgICAgICAgICAgICAgICAgIC5oYW0tbGluayB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgZm9udC1zaXplOiAxMzAlO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQtZGVjb3JhdGlvbjogdW5kZXJsaW5lOyB9IH1cXG5cXG4gICAgICAgICAgICAgICAgLmhhbS1pbWcge1xcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xcblxcbiAgICAgICAgICAgICAgICAgICAgQGluY2x1ZGUgc2l6ZSgxMzAlLCBhdXRvKTtcXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlKC01MCUsIDApO1xcbiAgICAgICAgICAgICAgICAgICAgbGVmdDogNTAlO1xcbiAgICAgICAgICAgICAgICAgICAgYm90dG9tOiAtMTIlO1xcblxcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheTogbm9uZTsgfSB9XFxuXFxuICAgICAgICAgICAgLmJ0bi1oYW0sIC5tb2JpbGUtbmF2IHtcXG4gICAgICAgICAgICAgICAgZGlzcGxheTogbm9uZTsgfSB9IH1cXG4gICAgLnN0aWNreSB7XFxuICAgICAgICBwb3NpdGlvbjogZml4ZWQ7XFxuICAgICAgICB0b3A6IDA7XFxuICAgICAgICB3aWR0aDogMTAwJTsgfVxcblxcbiAgICAuaGVybyB7XFxuICAgICAgICBwYWRkaW5nOiAyLjVyZW0gMDtcXG5cXG4gICAgICAgIC5oZXJvLXRleHQge1xcbiAgICAgICAgICAgIC5oZXJvLWhlYWRpbmcge1xcbiAgICAgICAgICAgICAgICBAaW5jbHVkZSBmbGV4KGNlbnRlciwgc3RhcnQsIGNvbHVtbik7XFxuICAgICAgICAgICAgICAgICNxdWFsaXRpZXMge1xcbiAgICAgICAgICAgICAgICAgICAgbGluZS1oZWlnaHQ6IDEuMmVtO1xcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiAxLjJlbTtcXG4gICAgICAgICAgICAgICAgICAgIEBpbmNsdWRlIGZpbGwtZ3JkKHZhcigtLXB1cnBsZS1ncmVlbi1ncmQpKTtcXG4gICAgICAgICAgICAgICAgICAgIHRleHQtdHJhbnNmb3JtOiB1cHBlcmNhc2U7XFxuICAgICAgICAgICAgICAgICAgICAudHlwZWQtY3Vyc29yIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBmb250LXdlaWdodDogMzAwO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGFuaW1hdGlvbjogYmxpbmsgMS41cyBzdGVwcyg1LCBzdGFydCkgaW5maW5pdGU7XFxuICAgICAgICAgICAgICAgICAgICAgICAgQGtleWZyYW1lcyBibGluayB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZpc2liaWxpdHk6IGhpZGRlbjsgfSB9IH0gfSB9IH1cXG4gICAgICAgIC5jdGFzIHtcXG4gICAgICAgICAgICBtYXJnaW4tdG9wOiAycmVtO1xcbiAgICAgICAgICAgIEBpbmNsdWRlIGZsZXgoc3RhcnQsIGNlbnRlciwgcm93LCAxcmVtKTtcXG4gICAgICAgICAgICAjYnRuLXdvcmsgLmJ0bi1pY29uIHtcXG4gICAgICAgICAgICAgICAgZGlzcGxheTogbm9uZTsgfSB9IH1cXG5cXG4gICAgLmhvYmJpZXMge1xcbiAgICAgICAgLy8tLS0tLS0tLS0tLS0tLS1QQVJBTExBWC0tLS0tLS0tLS0tLS0tLVxcbiAgICAgICAgZ3JpZC1yb3c6IDMvNDtcXG4gICAgICAgIEBleHRlbmQgLndpZGUtYmFubmVyO1xcbiAgICAgICAgei1pbmRleDogMjtcXG4gICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gICAgICAgIHBhZGRpbmc6IDAuNnJlbSAxcmVtO1xcbiAgICAgICAgb3ZlcmZsb3c6IGhpZGRlbjtcXG4gICAgICAgIC5jb250YWluZXIge1xcbiAgICAgICAgICAgIEBpbmNsdWRlIGZsZXgoc3BhY2UtYXJvdW5kLCBjZW50ZXIsIHJvdywgMS41cmVtKTsgfVxcbiAgICAgICAgLmhvYmJ5IHtcXG4gICAgICAgICAgICBAZXh0ZW5kIC5ub3QtY2VudGVyZWQ7XFxuICAgICAgICAgICAgcGFkZGluZzogMC41cmVtIDFyZW07XFxuICAgICAgICAgICAgcG9pbnRlci1ldmVudHM6IG5vbmU7XFxuICAgICAgICAgICAgYSB7XFxuICAgICAgICAgICAgICAgIEBpbmNsdWRlIGZsZXgoc3RhcnQsIGNlbnRlciwgcm93LCAwLjVyZW0pO1xcbiAgICAgICAgICAgICAgICAubmFtZSB7XFxuICAgICAgICAgICAgICAgICAgICAuaG9iYnktdSwgLmhvYmJ5LWwge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvbnQtd2VpZ2h0OiA2MDA7IH1cXG4gICAgICAgICAgICAgICAgICAgIC5ob2JieS1sIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXJnaW4tdG9wOiAtMC4zcmVtO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wYWNpdHk6IDAuNjsgfSB9XFxuICAgICAgICAgICAgICAgIGltZyB7XFxuICAgICAgICAgICAgICAgICAgICBAaW5jbHVkZSBzaXplKDY1cHgsIDY1cHgpOyB9IH0gfVxcbiAgICAgICAgI2RldmVsb3BlciAubmFtZSB7XFxuICAgICAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgICAgICAgICAgICNzcXVpZ2dseS1saW5lIHtcXG4gICAgICAgICAgICAgICAgQGluY2x1ZGUgYWJzb2x1dGUtY2VudGVyKCk7XFxuICAgICAgICAgICAgICAgIHdpZHRoOiAxMDAlO1xcbiAgICAgICAgICAgICAgICB0b3A6IDExNSU7IH0gfVxcbiAgICAgICAgI2Rlc2lnbmVyIHtcXG4gICAgICAgICAgICAkb2JqLXNlbGVjdC1ib3JkZXI6IDJweCBzb2xpZCAjMThBMEZCO1xcbiAgICAgICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gICAgICAgICAgICBib3JkZXI6ICRvYmotc2VsZWN0LWJvcmRlcjtcXG4gICAgICAgICAgICAub3V0bGluZSxcXG4gICAgICAgICAgICAubWluaS1zcSB7XFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTsgfVxcbiAgICAgICAgICAgIC5taW5pLXNxIHtcXG4gICAgICAgICAgICAgICAgQGluY2x1ZGUgc2l6ZSgxNHB4LCAxNHB4KTtcXG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogI2ZmZjtcXG4gICAgICAgICAgICAgICAgYm9yZGVyOiAkb2JqLXNlbGVjdC1ib3JkZXI7XFxuICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlKC01MCUsIC01MCUpOyB9XFxuICAgICAgICAgICAgI3VwcGVyLWxlZnQge1xcbiAgICAgICAgICAgICAgICB0b3A6IDA7XFxuICAgICAgICAgICAgICAgIGxlZnQ6IDA7IH1cXG4gICAgICAgICAgICAjdXBwZXItcmlnaHQge1xcbiAgICAgICAgICAgICAgICB0b3A6IDA7XFxuICAgICAgICAgICAgICAgIGxlZnQ6IDEwMCU7IH1cXG4gICAgICAgICAgICAjbG93ZXItbGVmdCB7XFxuICAgICAgICAgICAgICAgIHRvcDogMTAwJTtcXG4gICAgICAgICAgICAgICAgbGVmdDogMDsgfVxcbiAgICAgICAgICAgICNsb3dlci1yaWdodCB7XFxuICAgICAgICAgICAgICAgIHRvcDogMTAwJTtcXG4gICAgICAgICAgICAgICAgbGVmdDogMTAwJTsgfSB9IH0gfVxcblxcbkBtZWRpYSBzY3JlZW4gYW5kIChtYXgtd2lkdGg6IDE0MDBweCkgeyAvL2N1c3RvbVxcbiAgICAubGFuZGluZyB7XFxuICAgICAgICAuY29udGFpbmVyIHtcXG4gICAgICAgICAgICAuaGVyby1pbWFnZSB7XFxuICAgICAgICAgICAgICAgIEBpbmNsdWRlIHNpemUoYXV0bywgNjV2aCk7IH0gfSB9IH1cXG5cXG5AbWVkaWEgc2NyZWVuIGFuZCAobWF4LXdpZHRoOiAkbGFwdG9wKSB7IC8vMTExNnB4XFxuICAgIC5sYW5kaW5nIHtcXG4gICAgICAgIC5ob2JiaWVzIHtcXG4gICAgICAgICAgICBwYWRkaW5nOiAwLjZyZW07XFxuICAgICAgICAgICAgZ3JpZC1nYXA6IDAuNzVyZW07XFxuICAgICAgICAgICAgLmhvYmJ5IHtcXG4gICAgICAgICAgICAgICAgcGFkZGluZzogMC41cmVtO1xcbiAgICAgICAgICAgICAgICBncmlkLWdhcDogMC43NXJlbTtcXG4gICAgICAgICAgICAgICAgLmltZy1ob2JieSB7XFxuICAgICAgICAgICAgICAgICAgICBAaW5jbHVkZSBzaXplKDYwcHgsIDYwcHgpOyB9IH0gfSB9IH1cXG5cXG5AbWVkaWEgc2NyZWVuIGFuZCAobWF4LXdpZHRoOiAkdGFibGV0MCkgeyAvLzk1MHB4XFxuICAgIC5sYW5kaW5nIHtcXG4gICAgICAgIGhlYWRlciAuY29udGFpbmVyIHtcXG4gICAgICAgICAgICBncmlkLXRlbXBsYXRlLWNvbHVtbnM6IDFmciBhdXRvO1xcbiAgICAgICAgICAgIC5kZXNrdG9wLW5hdiB7XFxuICAgICAgICAgICAgICAgIGdyaWQtY29sdW1uOiAxO1xcbiAgICAgICAgICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IHN0YXJ0O1xcbiAgICAgICAgICAgICAgICBnYXA6IDFyZW07XFxuICAgICAgICAgICAgICAgIC5sb2dvIHtcXG4gICAgICAgICAgICAgICAgICAgIG9yZGVyOiAxOyB9XFxuICAgICAgICAgICAgICAgIC5kZXNrdG9wLWxpbmtzIHtcXG4gICAgICAgICAgICAgICAgICAgIG9yZGVyOiAyOyB9IH1cXG4gICAgICAgICAgICAuYnRuIHtcXG4gICAgICAgICAgICAgICAgZ3JpZC1jb2x1bW46IDI7IH0gfVxcbiAgICAgICAgLmNvbnRhaW5lciB7XFxuICAgICAgICAgICAgLmhlcm8taW1hZ2Uge1xcbiAgICAgICAgICAgICAgICBAaW5jbHVkZSBzaXplKGF1dG8sIDQwdmgpOyB9IH0gfSB9XFxuXFxuQG1lZGlhIHNjcmVlbiBhbmQgKG1heC13aWR0aDogODEwcHgpIHtcXG4gICAgLmxhbmRpbmcge1xcbiAgICAgICAgLmNvbnRhaW5lciAuaGVybyB7XFxuICAgICAgICAgICAgLmhlcm8tdGV4dCB7XFxuICAgICAgICAgICAgICAgIHRleHQtYWxpZ246IGNlbnRlcjtcXG4gICAgICAgICAgICAgICAgLmhlcm8taGVhZGluZyB7XFxuICAgICAgICAgICAgICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyOyB9IH1cXG4gICAgICAgICAgICAuY3RhcyB7XFxuICAgICAgICAgICAgICAgIGp1c3RpZnktY29udGVudDogY2VudGVyOyB9IH0gfSB9XFxuXFxuQG1lZGlhIHNjcmVlbiBhbmQgKG1heC13aWR0aDogJHRhYmxldDEpIHsgLy83NTBweFxcbiAgICAubGFuZGluZyB7XFxuICAgICAgICAuY29udGFpbmVyIHtcXG4gICAgICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IHN0YXJ0O1xcbiAgICAgICAgICAgIC5oZXJvLWltYWdlIHtcXG4gfSB9IH0gfSAgICAgICAgICAgICAgICAvLyBkaXNwbGF5OiBub25lXFxuXFxuQG1lZGlhIHNjcmVlbiBhbmQgKG1heC13aWR0aDogJHRhYmxldDIpIHsgLy82NTBweFxcbiAgICAubGFuZGluZyB7XFxuICAgICAgICBoZWFkZXIgLmNvbnRhaW5lciB7XFxuICAgICAgICAgICAgZ3JpZC10ZW1wbGF0ZS1jb2x1bW5zOiAxZnIgMmZyIDFmcjtcXG4gICAgICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgICAgICAgICAgIC5kZXNrdG9wLW5hdiB7XFxuICAgICAgICAgICAgICAgIGdyaWQtY29sdW1uOiAyO1xcbiAgICAgICAgICAgICAgICBqdXN0aWZ5LXNlbGY6IGNlbnRlcjtcXG4gICAgICAgICAgICAgICAgLmxvZ28ge1xcbiAgICAgICAgICAgICAgICAgICAgQGluY2x1ZGUgc2l6ZSg1MHB4LCA1MHB4KTsgfVxcbiAgICAgICAgICAgICAgICAuZGVza3RvcC1saW5rcyB7XFxuICAgICAgICAgICAgICAgICAgICBkaXNwbGF5OiBub25lOyB9IH1cXG4gICAgICAgICAgICAuYnRuLWhhbSwgLm1vYmlsZS1uYXYge1xcbiAgICAgICAgICAgICAgICBkaXNwbGF5OiBub25lOyB9XFxuICAgICAgICAgICAgLmJ0bi1oYW0ge1xcbiAgICAgICAgICAgICAgICBkaXNwbGF5OiBibG9jaztcXG4gICAgICAgICAgICAgICAgZ3JpZC1jb2x1bW46IDE7XFxuICAgICAgICAgICAgICAgIGdyaWQtcm93OiAxOyB9XFxuXFxuICAgICAgICAgICAgLmhlYWRlci1idG4ge1xcbiAgICAgICAgICAgICAgICBkaXNwbGF5OiBub25lOyB9IH1cXG5cXG4gICAgICAgIC5oZXJvIHtcXG4gICAgICAgICAgICBhbGlnbi1pdGVtczogc3RyZXRjaDtcXG4gICAgICAgICAgICAuaGVyby10ZXh0IHtcXG4gICAgICAgICAgICAgICAgLmhlcm8taGVhZGluZyB7XFxuICAgICAgICAgICAgICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyOyB9XFxuICAgICAgICAgICAgICAgIHAge1xcbiAgICAgICAgICAgICAgICAgICAgbWFyZ2luLXRvcDogMC4yNXJlbTsgfSB9XFxuICAgICAgICAgICAgLmN0YXMge1xcbiAgICAgICAgICAgICAgICBncmlkLWdhcDogMXJlbTtcXG4gfSB9ICAgICAgICAgICAgICAgIC8vIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW5cXG4gICAgICAgIC5ob2JiaWVzIHtcXG4gICAgICAgICAgICAuaG9iYnkge1xcbiAgICAgICAgICAgICAgICBib3JkZXItcmFkaXVzOiAkYm9yZGVyLXJhZGl1cztcXG4gICAgICAgICAgICAgICAgcG9pbnRlci1ldmVudHM6IGFsbDtcXG4gICAgICAgICAgICAgICAgY3Vyc29yOiBwb2ludGVyO1xcbiAgICAgICAgICAgICAgICBib3JkZXI6IDJweCBzb2xpZCByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMCk7XFxuICAgICAgICAgICAgICAgIGEge1xcbiAgICAgICAgICAgICAgICAgICAgQGluY2x1ZGUgc2l6ZSgxMDAlLCAxMDAlKTtcXG4gICAgICAgICAgICAgICAgICAgIG91dGxpbmU6IG5vbmU7XFxuICAgICAgICAgICAgICAgICAgICAubmFtZSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGxheTogbm9uZTsgfVxcbiAgICAgICAgICAgICAgICAgICAgLmltZy1ob2JieSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgQGluY2x1ZGUgc2l6ZSg1NXB4LCA1NXB4KTsgfVxcbiAgICAgICAgICAgICAgICAgICAgJjpmb2N1cyB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgLm5hbWUge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXNwbGF5OiBibG9jazsgfSB9IH1cXG4gICAgICAgICAgICAgICAgJjpob3ZlciB7XFxuICAgICAgICAgICAgICAgICAgICBib3JkZXItY29sb3I6IHJnYmEoMjU1LCAyNTUsIDI1NSwgMC4yKTsgfSB9XFxuICAgICAgICAgICAgI2Rlc2lnbmVyIHtcXG4gICAgICAgICAgICAgICAgYm9yZGVyLXJhZGl1czogMCAhaW1wb3J0YW50O1xcbiAgICAgICAgICAgICAgICAubWluaS1zcSB7XFxuICAgICAgICAgICAgICAgICAgICBAaW5jbHVkZSBzaXplKDEwcHgsIDEwcHgpOyB9IH0gfSB9IH1cXG5cIixcIiRkY2FyZC1ib3JkZXItcmFkaXVzOiAyMHB4O1xcbi5sYW5kaW5nIHtcXG4gICAgLmRlY29yYXRpb24tY2FyZC1ncmlkIHtcXG4gICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgICAgIHRvcDogMDtcXG4gICAgICAgIHJpZ2h0OiAwO1xcbiAgICAgICAgei1pbmRleDogLTE7XFxuXFxuICAgICAgICBkaXNwbGF5OiBncmlkO1xcbiAgICAgICAgZ3JpZC10ZW1wbGF0ZS1yb3dzOiByZXBlYXQoNiwgMWZyKTtcXG4gICAgICAgIGdyaWQtdGVtcGxhdGUtY29sdW1uczogMzAwcHggMTUwcHg7XFxuICAgICAgICBncmlkLWdhcDogMjBweDtcXG4gICAgICAgIGhlaWdodDogMTAwJTtcXG4gICAgICAgIC5kZWNvcmF0aW9uLWNhcmQge1xcbiAgICAgICAgICAgIGJhY2tncm91bmQtY29sb3I6ICMyZDM0MzY7XFxuICAgICAgICAgICAgYmFja2dyb3VuZC1pbWFnZTogbGluZWFyLWdyYWRpZW50KDMxNWRlZywgIzJkMzQzNiAwJSwgIzE5MTkxOSA3NCUpO1xcbiAgICAgICAgICAgIG9wYWNpdHk6IDAuNTtcXG4gICAgICAgICAgICAmOm50aC1jaGlsZCgxKSB7XFxuICAgICAgICAgICAgICAgIGdyaWQtcm93OiAxLzQ7XFxuICAgICAgICAgICAgICAgIGdyaWQtY29sdW1uOiAyO1xcbiAgICAgICAgICAgICAgICBib3JkZXItcmFkaXVzOiAwIDAgMCAkZGNhcmQtYm9yZGVyLXJhZGl1czsgfVxcbiAgICAgICAgICAgICY6bnRoLWNoaWxkKDIpIHtcXG4gICAgICAgICAgICAgICAgZ3JpZC1yb3c6IDQvNztcXG4gICAgICAgICAgICAgICAgZ3JpZC1jb2x1bW46IDI7XFxuICAgICAgICAgICAgICAgIGJvcmRlci1yYWRpdXM6ICRkY2FyZC1ib3JkZXItcmFkaXVzIDAgMCAwOyB9XFxuICAgICAgICAgICAgJjpudGgtY2hpbGQoMykge1xcbiAgICAgICAgICAgICAgICBncmlkLXJvdzogMS8yO1xcbiAgICAgICAgICAgICAgICBncmlkLWNvbHVtbjogMTtcXG4gICAgICAgICAgICAgICAgYm9yZGVyLXJhZGl1czogMCAwICRkY2FyZC1ib3JkZXItcmFkaXVzICRkY2FyZC1ib3JkZXItcmFkaXVzOyB9XFxuICAgICAgICAgICAgJjpudGgtY2hpbGQoNCkgeyAvL3NhbXBsZSBjYXJkXFxuICAgICAgICAgICAgICAgIGdyaWQtcm93OiAyLzU7XFxuICAgICAgICAgICAgICAgIGdyaWQtY29sdW1uOiAxO1xcbiAgICAgICAgICAgICAgICBib3JkZXItcmFkaXVzOiAkZGNhcmQtYm9yZGVyLXJhZGl1cztcXG4gICAgICAgICAgICAgICAgcGFkZGluZzogMS41cmVtO1xcbiAgICAgICAgICAgICAgICBAaW5jbHVkZSBmbGV4KHNwYWNlLWJldHdlZW4sIHN0YXJ0LCBjb2x1bW4pO1xcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICAgICAgICAgICAgICAgIG9wYWNpdHk6IDE7XFxuICAgICAgICAgICAgICAgIHN2ZyB7XFxuICAgICAgICAgICAgICAgICAgICB3aWR0aDogMTAwJTtcXG4gICAgICAgICAgICAgICAgICAgIGJvcmRlci1yYWRpdXM6IDMuNXB4OyB9XFxuXFxuICAgICAgICAgICAgICAgIC5jdXJzb3Ige1xcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICAgICAgICAgICAgICAgICAgdG9wOiA4NSU7XFxuICAgICAgICAgICAgICAgICAgICBsZWZ0OiA4NSU7IH0gfVxcbiAgICAgICAgICAgICY6bnRoLWNoaWxkKDUpIHtcXG4gICAgICAgICAgICAgICAgZ3JpZC1yb3c6IDUvNztcXG4gICAgICAgICAgICAgICAgZ3JpZC1jb2x1bW46IDE7XFxuICAgICAgICAgICAgICAgIGJvcmRlci1yYWRpdXM6ICRkY2FyZC1ib3JkZXItcmFkaXVzICRkY2FyZC1ib3JkZXItcmFkaXVzIDAgMDsgfSB9IH0gfVxcblxcbkBtZWRpYSBzY3JlZW4gYW5kIChtYXgtd2lkdGg6IDEzODVweCkge1xcbiAgICAubGFuZGluZyB7XFxuICAgICAgICAuZGVjb3JhdGlvbi1jYXJkLWdyaWQge1xcbiAgICAgICAgICAgIGdyaWQtdGVtcGxhdGUtY29sdW1uczogMzAwcHggMTAwcHg7IH0gfSB9XFxuXFxuQG1lZGlhIHNjcmVlbiBhbmQgKG1heC13aWR0aDogMTE1MHB4KSB7XFxuICAgIC5sYW5kaW5nIHtcXG4gICAgICAgIC5kZWNvcmF0aW9uLWNhcmQtZ3JpZCB7XFxuICAgICAgICAgICAgZ3JpZC10ZW1wbGF0ZS1jb2x1bW5zOiAyNTBweCAwO1xcbiAgICAgICAgICAgIC5jdXJzb3Ige1xcbiAgICAgICAgICAgICAgICBAaW5jbHVkZSBzaXplKDQ1cHgsIGF1dG8pOyB9IH0gfSB9XFxuXFxuQG1lZGlhIHNjcmVlbiBhbmQgKG1heC13aWR0aDogJHRhYmxldDApIHsgLy85NTBweFxcbiAgICAubGFuZGluZyB7XFxuICAgICAgICAuZGVjb3JhdGlvbi1jYXJkLWdyaWQge1xcbiAgICAgICAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWCg1MCUpO1xcbiAgICAgICAgICAgIC5jdXJzb3Ige1xcbiAgICAgICAgICAgICAgICBkaXNwbGF5OiBub25lOyB9IH0gfSB9XFxuXFxuQG1lZGlhIHNjcmVlbiBhbmQgKG1heC13aWR0aDogODEwcHgpIHtcXG4gICAgLmxhbmRpbmcge1xcbiAgICAgICAgLmRlY29yYXRpb24tY2FyZC1ncmlkIHtcXG4gICAgICAgICAgICBvcGFjaXR5OiAwLjY7XFxuICAgICAgICAgICAgc3ZnIHtcXG4gICAgICAgICAgICAgICAgb3BhY2l0eTogMC4yOyB9IH0gfSB9XFxuXFxuLy9zcGVjaWFsIGhlaWdodCBtZWRpYSBxdWVyaWVzIGZvciBzdmdzIGluc2lkZSBzYW1wbGUgY2FyZCBiZWluZyBwcm9wZXJseSBzZXBlcmF0ZWRcXG5AbWVkaWEgc2NyZWVuIGFuZCAobWluLWhlaWdodDogOTUwcHgpIHtcXG4gICAgLmxhbmRpbmcgLmRlY29yYXRpb24tY2FyZC1ncmlkIC5kZWNvcmF0aW9uLWNhcmQ6bnRoLWNoaWxkKDQpIHtcXG4gICAgICAgIGp1c3RpZnktY29udGVudDogc3RhcnQ7XFxuICAgICAgICBnYXA6IDJyZW07XFxuICAgICAgICAjc2FtcGxlLXBhcmFncmFwaCB7XFxuICAgICAgICAgICAgZmxleC1ncm93OiAxOyB9IH0gfVxcbkBtZWRpYSBzY3JlZW4gYW5kIChtYXgtaGVpZ2h0OiA3NTBweCkge1xcbiAgICAubGFuZGluZyAuZGVjb3JhdGlvbi1jYXJkLWdyaWQgLmRlY29yYXRpb24tY2FyZDpudGgtY2hpbGQoNCkge1xcbiAgICAgICAgI3NhbXBsZS1wYXJhZ3JhcGgge1xcbiAgICAgICAgICAgIGhlaWdodDogMTAwcHg7IH0gfSB9XFxuXFxuQG1lZGlhIHNjcmVlbiBhbmQgKG1heC1oZWlnaHQ6IDQ1MHB4KSB7XFxuICAgIC5sYW5kaW5nIC5kZWNvcmF0aW9uLWNhcmQtZ3JpZCAuZGVjb3JhdGlvbi1jYXJkOm50aC1jaGlsZCg0KSB7XFxuICAgICAgICAjc2FtcGxlLXBhcmFncmFwaCB7XFxuICAgICAgICAgICAgaGVpZ2h0OiA4MHB4OyB9IH0gfVxcblwiLFwiLm1lIHtcXG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgICAubGFyZ2UtbWFwIHtcXG4gICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgICAgIEBpbmNsdWRlIHNpemUoMTAwJSwgMTAwJSk7XFxuICAgICAgICB0b3A6IDA7XFxuICAgICAgICBsZWZ0OiAwO1xcbiAgICAgICAgYmFja2dyb3VuZC1pbWFnZTogdXJsKCcuLi9hc3NldHMvbGFyZ2UtbWFwLndlYnAnKTtcXG4gICAgICAgIGJhY2tncm91bmQtcmVwZWF0OiBuby1yZXBlYXQ7XFxuICAgICAgICBiYWNrZ3JvdW5kLXNpemU6IGNvdmVyO1xcbiAgICAgICAgei1pbmRleDogLTE7XFxuICAgICAgICBvcGFjaXR5OiAwLjA4OyB9XFxuICAgIC5jb3JlIHtcXG4gICAgICAgIGRpc3BsYXk6IGdyaWQ7XFxuICAgICAgICBncmlkLXRlbXBsYXRlLXJvd3M6IHJlcGVhdCgyLCAxZnIpO1xcbiAgICAgICAgZ3JpZC10ZW1wbGF0ZS1jb2x1bW5zOiAwLjZmciAyZnIgMWZyO1xcbiAgICAgICAgZ3JpZC1nYXA6IDFyZW07XFxuICAgICAgICBhcnRpY2xlIHtcXG4gICAgICAgICAgICBAaW5jbHVkZSBmbGV4KHN0YXJ0LCBzdGFydCwgY29sdW1uKTtcXG4gICAgICAgICAgICBoZWFkZXIge1xcbiAgICAgICAgICAgICAgICBAaW5jbHVkZSBmbGV4KHN0YXJ0LCBjZW50ZXIsIHJvdywgMC4yNXJlbSk7XFxuICAgICAgICAgICAgICAgIG1hcmdpbi1ib3R0b206IDAuMjVyZW07XFxuICAgICAgICAgICAgICAgIHNtYWxsIHtcXG4gICAgICAgICAgICAgICAgICAgIGZvbnQtd2VpZ2h0OiA4MDA7IH0gfSB9XFxuICAgICAgICAuZXhwIHtcXG4gICAgICAgICAgICBwYWRkaW5nOiAxcmVtIDA7XFxuICAgICAgICAgICAgZ3JpZC1yb3c6IDEvMjtcXG4gICAgICAgICAgICBncmlkLWNvbHVtbjogMS8yO1xcbiAgICAgICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gICAgICAgICAgICBAaW5jbHVkZSBmbGV4KGNlbnRlciwgc3RhcnQsIGNvbHVtbiwgMCk7XFxuICAgICAgICAgICAgI2JhY2tncm91bmQge1xcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgICAgICAgICAgICAgIGJhY2tncm91bmQtY29sb3I6IGluaGVyaXQ7XFxuICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlKC0xMDAlLCAwKTtcXG4gICAgICAgICAgICAgICAgd2lkdGg6IDEwMDAlO1xcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDEwMCU7XFxuICAgICAgICAgICAgICAgIGxlZnQ6IDAlOyB9XFxuICAgICAgICAgICAgc21hbGwge1xcbiAgICAgICAgICAgICAgICBsaW5lLWhlaWdodDogMTMwJTsgfSB9XFxuICAgICAgICAud2hhdCB7XFxuICAgICAgICAgICAgZ3JpZC1yb3c6IDIvMztcXG4gICAgICAgICAgICBncmlkLWNvbHVtbjogMS8zOyB9XFxuICAgICAgICAuc21hbGwtc2NyZWVuLXdoZXJlIHtcXG4gICAgICAgICAgICBkaXNwbGF5OiBub25lOyB9XFxuICAgICAgICAubGFyZ2Utc2NyZWVuLXdoZXJlIHtcXG4gICAgICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICAgICAgICAgICAgZ3JpZC1yb3c6IDEvMztcXG4gICAgICAgICAgICBncmlkLWNvbHVtbjogMy80O1xcbiAgICAgICAgICAgIG1heC1oZWlnaHQ6IDM1MHB4O1xcbiAgICAgICAgICAgIEBpbmNsdWRlIGZsZXgoc3RhcnQsIHN0cmV0Y2gsIGNvbHVtbik7XFxuICAgICAgICAgICAgLnF1ZXN0aW9uIHtcXG4gICAgICAgICAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICAgICAgICAgICAgICB6LWluZGV4OiAxO1xcbiAgICAgICAgICAgICAgICB0b3A6IDEwcHg7XFxuICAgICAgICAgICAgICAgIGxlZnQ6IDEwcHg7XFxuICAgICAgICAgICAgICAgIGZpbHRlcjogZHJvcC1zaGFkb3coMCAwIDEwcHggIzNmM2YzZik7IH1cXG4gICAgICAgICAgICAubWFwIHtcXG4gICAgICAgICAgICAgICAgZmxleC1iYXNpczogMTtcXG4gICAgICAgICAgICAgICAgZmxleC1ncm93OiAxO1xcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICAgICAgICAgICAgICAgIG92ZXJmbG93OiBoaWRkZW47XFxuICAgICAgICAgICAgICAgIHdpZHRoOiAxMDAlO1xcbiAgICAgICAgICAgICAgICAuY2Fpcm8tbWFwLCAub3ZlcmxheSB7XFxuICAgICAgICAgICAgICAgICAgICBAaW5jbHVkZSBzaXplKDEwMCUsIDEwMCUpO1xcbiAgICAgICAgICAgICAgICAgICAgYmFja2dyb3VuZC1yZXBlYXQ6IG5vLXJlcGVhdDtcXG4gICAgICAgICAgICAgICAgICAgIGJhY2tncm91bmQtc2l6ZTogY292ZXI7XFxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgICAgICAgICAgICAgICAgICB0b3A6IDA7XFxuICAgICAgICAgICAgICAgICAgICBsZWZ0OiAwOyB9XFxuICAgICAgICAgICAgICAgIC5jYWlyby1tYXAge1xcbiAgICAgICAgICAgICAgICAgICAgYmFja2dyb3VuZC1pbWFnZTogdXJsKCcuLi9hc3NldHMvc21hbGwtbWFwLndlYnAnKTsgfVxcbiAgICAgICAgICAgICAgICAub3ZlcmxheSB7XFxuICAgICAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kLWltYWdlOiB1cmwoJy4uL2Fzc2V0cy9waW5rLW92ZXJsYXkud2VicCcpO1xcbiAgICAgICAgICAgICAgICAgICAgb3BhY2l0eTogMC44OyB9XFxuICAgICAgICAgICAgICAgIGg0IHtcXG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgICAgICAgICAgICAgICAgIHotaW5kZXg6IDE7XFxuICAgICAgICAgICAgICAgICAgICBjb2xvcjogdmFyKC0tcHJpbWFyeS1ncmVlbik7XFxuICAgICAgICAgICAgICAgICAgICBmaWx0ZXI6IGRyb3Atc2hhZG93KDAgMCAxMHB4IHJnYmEoMCwgMCwgMCwgMC4yKSk7XFxuICAgICAgICAgICAgICAgICAgICB0ZXh0LXRyYW5zZm9ybTogdXBwZXJjYXNlO1xcbiAgICAgICAgICAgICAgICAgICAgZm9udC13ZWlnaHQ6IDgwMDtcXG4gICAgICAgICAgICAgICAgICAgIGxpbmUtaGVpZ2h0OiAxMjAlO1xcbiAgICAgICAgICAgICAgICAgICAgYm90dG9tOiAwLjc1cmVtO1xcbiAgICAgICAgICAgICAgICAgICAgbGVmdDogMC43NXJlbTsgfSB9IH0gfVxcblxcbiAgICAucmVzdW1lIHtcXG4gICAgICAgIEBleHRlbmQgLndpZGUtYmFubmVyO1xcbiAgICAgICAgQGluY2x1ZGUgYmFja2Ryb3AtYmx1cig3cHgpO1xcbiAgICAgICAgbWFyZ2luLXRvcDogM3JlbTtcXG4gICAgICAgIHBhZGRpbmc6IDEuNXJlbTtcXG4gICAgICAgIHRleHQtYWxpZ246IGNlbnRlcjtcXG4gICAgICAgIEBpbmNsdWRlIGZsZXgoY2VudGVyLCBjZW50ZXIsIHJvdywgMXJlbSk7XFxuICAgICAgICBmbGV4LXdyYXA6IHdyYXA7XFxuICAgICAgICAjYnRuRG93bmxvYWQgLmJ0bi1pY29uIHtcXG4gICAgICAgICAgICBiYWNrZ3JvdW5kLWltYWdlOiB1cmwoJy4uL2Fzc2V0cy9kb3dubG9hZC5zdmcnKTsgfSB9IH1cXG5cXG5AbWVkaWEgc2NyZWVuIGFuZChtYXgtd2lkdGg6ICAkbGFwdG9wKSB7IC8vMTExNnB4XFxuICAgIC5tZSB7XFxuICAgICAgICAuY29yZSB7XFxuICAgICAgICAgICAgZ3JpZC10ZW1wbGF0ZS1yb3dzOiByZXBlYXQoMiwgYXV0byk7XFxuICAgICAgICAgICAgZ3JpZC10ZW1wbGF0ZS1jb2x1bW5zOiByZXBlYXQoNCwgMWZyKTtcXG4gICAgICAgICAgICAuZXhwIHtcXG4gICAgICAgICAgICAgICAgZ3JpZC1yb3c6IDEvMjtcXG4gICAgICAgICAgICAgICAgZ3JpZC1jb2x1bW46IDEvMjsgfVxcbiAgICAgICAgICAgIC53aG8ge1xcbiAgICAgICAgICAgICAgICBncmlkLXJvdzogMS8yO1xcbiAgICAgICAgICAgICAgICBncmlkLWNvbHVtbjogMi81OyB9XFxuICAgICAgICAgICAgLmxhcmdlLXNjcmVlbi13aGVyZSB7XFxuICAgICAgICAgICAgICAgIGdyaWQtcm93OiAyLzQ7XFxuICAgICAgICAgICAgICAgIGdyaWQtY29sdW1uOiAxLzM7IH1cXG4gICAgICAgICAgICAud2hhdCB7XFxuICAgICAgICAgICAgICAgIGdyaWQtcm93OiAyLzQ7XFxuICAgICAgICAgICAgICAgIGdyaWQtY29sdW1uOiAzLzU7XFxuICAgICAgICAgICAgICAgIG1hcmdpbjogYXV0byAwOyB9IH0gfSB9XFxuXFxuQG1lZGlhIHNjcmVlbiBhbmQgKCBtYXgtd2lkdGg6ICR0YWJsZXQxICkgeyAvLzc1MHB4XFxuICAgIC5tZSB7XFxuICAgICAgICAuY29yZSB7XFxuICAgICAgICAgICAgZ3JpZC10ZW1wbGF0ZS1yb3dzOiByZXBlYXQoMywgYXV0byk7XFxuICAgICAgICAgICAgZ3JpZC10ZW1wbGF0ZS1jb2x1bW5zOiAxZnI7XFxuICAgICAgICAgICAgLmV4cCwgLmxhcmdlLXNjcmVlbi13aGVyZSB7XFxuICAgICAgICAgICAgICAgIGRpc3BsYXk6IG5vbmU7IH1cXG4gICAgICAgICAgICAud2hvIHtcXG4gICAgICAgICAgICAgICAgZ3JpZC1yb3c6IDEvMjtcXG4gICAgICAgICAgICAgICAgZ3JpZC1jb2x1bW46IDE7IH1cXG4gICAgICAgICAgICAuc21hbGwtc2NyZWVuLXdoZXJlIHtcXG4gICAgICAgICAgICAgICAgQGluY2x1ZGUgZmxleChzdGFydCwgc3RhcnQsIGNvbHVtbik7XFxuICAgICAgICAgICAgICAgIGdyaWQtcm93OiAyLzM7XFxuICAgICAgICAgICAgICAgIGdyaWQtY29sdW1uOiAxOyB9XFxuICAgICAgICAgICAgLndoYXQge1xcbiAgICAgICAgICAgICAgICBncmlkLXJvdzogMy80O1xcbiAgICAgICAgICAgICAgICBncmlkLWNvbHVtbjogMTsgfSB9XFxuICAgICAgICAubGFyZ2UtbWFwIHtcXG4gICAgICAgICAgICBiYWNrZ3JvdW5kLXNpemU6IGF1dG87XFxuICAgICAgICAgICAgZGlzcGxheTogYmxvY2s7IH0gfSB9XFxuXFxuQG1lZGlhIHNjcmVlbiBhbmQgKCBtYXgtd2lkdGg6ICR0YWJsZXQyICkgeyAvLzY1MHB4XFxuICAgIC5tZSAuY29yZSB7XFxuICAgICAgICBhcnRpY2xlIHtcXG4gICAgICAgICAgICAucXVlc3Rpb24ge1xcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICAgICAgICAgICAgICAgIC0tcXVlc3Rpb24tYmFycy13aWR0aDogMTIwJTtcXG4gICAgICAgICAgICAgICAgLS1xdWVzdGlvbi1iYXJzLXBvc2l0aW9uOiBjYWxjKC0xICogdmFyKC0tcXVlc3Rpb24tYmFycy13aWR0aCkgLSAxNSUpO1xcbiAgICAgICAgICAgICAgICAmOjpiZWZvcmUsICY6OmFmdGVyIHtcXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6ICcgJztcXG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogM3B4O1xcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHZhcigtLXF1ZXN0aW9uLWJhcnMtd2lkdGgpO1xcbiAgICAgICAgICAgICAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogI2ZmZjtcXG4gICAgICAgICAgICAgICAgICAgIG9wYWNpdHk6IDE7IH1cXG4gICAgICAgICAgICAgICAgJjo6YmVmb3JlIHtcXG4gICAgICAgICAgICAgICAgICAgIC8vIGRpc3BsYXk6IG5vbmVcXG4gICAgICAgICAgICAgICAgICAgIGxlZnQ6IHZhcigtLXF1ZXN0aW9uLWJhcnMtcG9zaXRpb24pOyB9XFxuICAgICAgICAgICAgICAgICY6OmFmdGVyIHtcXG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0OiB2YXIoLS1xdWVzdGlvbi1iYXJzLXBvc2l0aW9uKTsgfSB9IH0gfSB9XFxuXFxuQG1lZGlhIHNjcmVlbiBhbmQgKCBtYXgtd2lkdGg6ICRwaG9uZTEpIHsgLy80NzVweFxcbiAgICAubWUgLmNvcmUge1xcbiAgICAgICAgYXJ0aWNsZSB7XFxuICAgICAgICAgICAgYWxpZ24taXRlbXM6IGNlbnRlciAhaW1wb3J0YW50OyB9IH0gfVxcblwiLFwiLnNraWxscyB7XFxuICAgIC8vYm9yZGVyOiAxcHggZGFzaGVkIG9yYW5nZVxcbiAgICAuZHV0aWVzLWNvbnRhaW5lciB7XFxuICAgICAgICBtYXJnaW4tdG9wOiAycmVtOyB9XFxuICAgIC5kdXRpZXMge1xcbiAgICAgICAgZGlzcGxheTogZ3JpZDtcXG4gICAgICAgIGdyaWQtdGVtcGxhdGUtcm93czogMWZyO1xcbiAgICAgICAgZ3JpZC10ZW1wbGF0ZS1jb2x1bW5zOiByZXBlYXQoNCwgYXV0byk7XFxuICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IHN0YXJ0O1xcblxcbiAgICAgICAgLmR1dHkge1xcbiAgICAgICAgICAgIHBhZGRpbmc6IDFyZW07XFxuXFxuICAgICAgICAgICAgQGluY2x1ZGUgZ3JpZC1jZW50ZXIoKTtcXG5cXG4gICAgICAgICAgICBib3JkZXItcmFkaXVzOiAkYm9yZGVyLXJhZGl1cztcXG5cXG4gICAgICAgICAgICB0cmFuc2l0aW9uOiBiYWNrZ3JvdW5kLWNvbG9yIDAuMTVzICwgdHJhbnNmb3JtIDAuMTVzO1xcbiAgICAgICAgICAgIGltZyB7XFxuICAgICAgICAgICAgICAgIEBpbmNsdWRlIHNpemUoMTIwcHgsIDEyMHB4KTtcXG5cXG4gICAgICAgICAgICAgICAgdHJhbnNpdGlvbjogYmFja2dyb3VuZC1jb2xvciAwLjE1cyAsIHRyYW5zZm9ybSAwLjE1cztcXG5cXG4gICAgICAgICAgICAgICAgY3Vyc29yOiBwb2ludGVyO1xcbiAgICAgICAgICAgICAgICBib3JkZXItcmFkaXVzOiBpbmhlcml0O1xcbiAgICAgICAgICAgICAgICAtd2Via2l0LWZpbHRlcjogYnJpZ2h0bmVzcygwKSBpbnZlcnQoMSk7XFxuICAgICAgICAgICAgICAgIGZpbHRlcjogYnJpZ2h0bmVzcygwKSBpbnZlcnQoMSk7XFxuICAgICAgICAgICAgICAgIC8vICY6aG92ZXJcXG4gICAgICAgICAgICAgICAgLy8gIC8vcHJldmVudGluZyBiYWNrZ3JvdW5kIGNoYW5nZSB3aGVuIGhvdmVyaW5nXFxuIH0gICAgICAgICAgICAgICAgLy8gIC8vaW4gY2FzZSBvZiBhbHJlYWR5IGFjdGl2YXRpbmcgZG9uZSBpbiBKU1xcblxcbiAgICAgICAgICAgIGg2IHtcXG4gICAgICAgICAgICAgICAgZm9udC13ZWlnaHQ6IDYwMDtcXG4gICAgICAgICAgICAgICAgbGluZS1oZWlnaHQ6IDEwMCU7XFxuICAgICAgICAgICAgICAgIG9wYWNpdHk6IDA7XFxuICAgICAgICAgICAgICAgIHRleHQtYWxpZ246IGNlbnRlcjtcXG4gICAgICAgICAgICAgICAgdHJhbnNpdGlvbjogb3BhY2l0eSAwLjJzOyB9IH1cXG4gICAgICAgIC5hY3RpdmUtZHV0eSB7XFxuICAgICAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVZKC0xcmVtKTtcXG4gICAgICAgICAgICBpbWcge1xcbiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudCAhaW1wb3J0YW50O1xcbiAgICAgICAgICAgICAgICBmaWx0ZXI6IGJyaWdodG5lc3MoMSkgaW52ZXJ0KDApOyB9XFxuICAgICAgICAgICAgLmR1dHktbmFtZSB7XFxuICAgICAgICAgICAgICAgIG9wYWNpdHk6IDE7IH0gfSB9XFxuXFxuICAgIC50ZWNoLXRvb2xzIHtcXG4gICAgICAgIHdpZHRoOiAxMDAlO1xcbiAgICAgICAgbWFyZ2luOiAycmVtIDAgMCAwO1xcbiAgICAgICAgcGFkZGluZzogMnJlbSAwO1xcbiAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgICAgICAgJjo6YmVmb3JlIHtcXG4gICAgICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgICAgICAgICAgY29udGVudDogXFxcIiBcXFwiO1xcbiAgICAgICAgICAgIEBpbmNsdWRlIHNpemUoMTAwJSwgMTAwJSk7XFxuICAgICAgICAgICAgdG9wOiAwO1xcblxcbiAgICAgICAgICAgIGJhY2tncm91bmQtaW1hZ2U6IHVybCguLi9hc3NldHMvZHJhd2luZy1jb21wYXNzLnN2Zyk7XFxuICAgICAgICAgICAgYmFja2dyb3VuZC1yZXBlYXQ6IG5vLXJlcGVhdDtcXG4gICAgICAgICAgICBiYWNrZ3JvdW5kLXNpemU6IDMwMHB4O1xcbiAgICAgICAgICAgIGJhY2tncm91bmQtcG9zaXRpb246IGJvdHRvbSAtNC44cmVtIHJpZ2h0O1xcbiAgICAgICAgICAgIG9wYWNpdHk6IDAuNDsgfVxcbiAgICAgICAgLmNvbnRhaW5lciB7XFxuICAgICAgICAgICAgI2lubmVyLXRpdGxlIHtcXG4gICAgICAgICAgICAgICAgZm9udC13ZWlnaHQ6IDgwMDtcXG4gICAgICAgICAgICAgICAgdGV4dC10cmFuc2Zvcm06IHVwcGVyY2FzZTtcXG4gICAgICAgICAgICAgICAgbWFyZ2luLWJvdHRvbTogMXJlbTsgfVxcbiAgICAgICAgICAgIC5pY29ucyB7XFxuICAgICAgICAgICAgICAgIG1hcmdpbi10b3A6IDFyZW07XFxuICAgICAgICAgICAgICAgIEBpbmNsdWRlIGZsZXgoc3RhcnQsIGNlbnRlciwgcm93LCAwLjc1cmVtKTtcXG4gICAgICAgICAgICAgICAgbGkge1xcbiAgICAgICAgICAgICAgICAgICAgQGluY2x1ZGUgc2l6ZShhdXRvLCA0MHB4KTtcXG4gICAgICAgICAgICAgICAgICAgIGltZyB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgQGluY2x1ZGUgc2l6ZShpbmhlcml0LCBpbmhlcml0KTsgfSB9IH0gfSB9IH1cXG5cXG5AbWVkaWEgc2NyZWVuIGFuZCAoIG1heC13aWR0aDogJGxhcHRvcCApIHsgLy8xMTE2cHhcXG4gICAgLnNraWxscyB7XFxuICAgICAgICAudGVjaC10b29scyB7XFxuICAgICAgICAgICAgJjo6YmVmb3JlIHtcXG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZC1zaXplOiA0MDBweDtcXG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZC1wb3NpdGlvbjogdG9wIC0wLjVyZW0gcmlnaHQ7XFxuICAgICAgICAgICAgICAgIG9wYWNpdHk6IDAuMjU7IH1cXG5cXG4gICAgICAgICAgICAuaWNvbnMge1xcbiAgICAgICAgICAgICAgICAvLyBkaXNwbGF5OiBncmlkICFpbXBvcnRhbnRcXG4gICAgICAgICAgICAgICAgLy8gZ3JpZC10ZW1wbGF0ZS1yb3dzOiByZXBlYXQoMiwgYXV0bylcXG4gfSB9IH0gfSAgICAgICAgICAgICAgICAvLyBncmlkLXRlbXBsYXRlLWNvbHVtbnM6IHJlcGVhdCg1LCBhdXRvKVxcblxcbkBtZWRpYSBzY3JlZW4gYW5kICggbWF4LXdpZHRoOiA5NTBweCApIHtcXG4gICAgLnNraWxscyB7XFxuICAgICAgICAuZHV0aWVzIHtcXG4gICAgICAgICAgICBncmlkLWdhcDogMC4yNXJlbTtcXG4gICAgICAgICAgICAuZHV0eSB7XFxuICAgICAgICAgICAgICAgIHBhZGRpbmc6IDFyZW0gMC43NXJlbTtcXG4gICAgICAgICAgICAgICAgaW1nIHtcXG4gICAgICAgICAgICAgICAgICAgIEBpbmNsdWRlIHNpemUoMTEwcHgsIDExMHB4KTsgfVxcbiAgICAgICAgICAgICAgICAuZHV0eS1uYW1lIHtcXG4gICAgICAgICAgICAgICAgICAgIGRpc3BsYXk6IG5vbmU7IH0gfSB9XFxuICAgICAgICAuZHV0eS1leHBsYWluZWQge1xcbiAgICAgICAgICAgIG1hcmdpbi10b3A6IDFyZW07XFxuICAgICAgICAgICAgI2R1dHktbmFtZSB7XFxuICAgICAgICAgICAgICAgIGRpc3BsYXk6IGJsb2NrO1xcbiAgICAgICAgICAgICAgICBmb250LXdlaWdodDogNjAwOyB9XFxuICAgICAgICAgICAgI2R1dHktZGVzY3JpcHRpb24ge1xcbiAgICAgICAgICAgICAgICBtYXJnaW4tdG9wOiAwLjNyZW07IH0gfVxcbiAgICAgICAgLnRlY2gtdG9vbHMgLmNvbnRhaW5lciAuaWNvbnMge1xcbiAgICAgICAgICAgIGxpIHtcXG4gICAgICAgICAgICAgICAgQGluY2x1ZGUgc2l6ZShhdXRvLCAzNXB4KTsgfSB9IH0gfVxcblxcbkBtZWRpYSBzY3JlZW4gYW5kICggbWF4LXdpZHRoOiAkdGFibGV0MSApIHsgIC8vNzUwcHhcXG4gICAgLnNraWxscyB7XFxuICAgICAgICAuZHV0aWVzIC5kdXR5IGltZyB7XFxuICAgICAgICAgICAgQGluY2x1ZGUgc2l6ZSg4MHB4LCA4MHB4KTsgfVxcbiAgICAgICAgLnRlY2gtdG9vbHMgLmNvbnRhaW5lciAuaWNvbnMge1xcbiAgICAgICAgICAgIGxpIHtcXG4gICAgICAgICAgICAgICAgei1pbmRleDogMTtcXG4gICAgICAgICAgICAgICAgQGluY2x1ZGUgc2l6ZShhdXRvLCAzMHB4KTsgfSB9IH0gfVxcblxcbkBtZWRpYSBzY3JlZW4gYW5kICggbWF4LXdpZHRoOiAkdGFibGV0MiApIHsgLy82NTBweFxcbiAgICAuc2tpbGxzIHtcXG4gICAgICAgIC5kdXRpZXMge1xcbiAgICAgICAgICAgIC8vIHdpZHRoOiBmaXQtY29udGVudFxcbiB9ICAgICAgICAgICAgLy8gbWFyZ2luOiAwIGF1dG9cXG4gICAgICAgIC50ZWNoLXRvb2xzIHtcXG4gICAgICAgICAgICAmOmJlZm9yZSB7XFxuICAgICAgICAgICAgICAgIGRpc3BsYXk6IG5vbmU7IH1cXG4gICAgICAgICAgICAuY29udGFpbmVyIHtcXG4gICAgICAgICAgICAgICAgI2lubmVyLXRpdGxlIGJyIHtcXG4gICAgICAgICAgICAgICAgICAgIGRpc3BsYXk6IG5vbmU7IH1cXG4gICAgICAgICAgICAgICAgLmljb25zIHtcXG4gICAgICAgICAgICAgICAgICAgIC8vIHdpZHRoOiBmaXQtY29udGVudFxcbiAgICAgICAgICAgICAgICAgICAgLy8gbWFyZ2luOiAwIGF1dG9cXG4gICAgICAgICAgICAgICAgICAgIGxpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBAaW5jbHVkZSBzaXplKGF1dG8sIDI1cHgpOyB9IH0gfSB9IH0gfVxcblxcbkBtZWRpYSBzY3JlZW4gYW5kICggbWF4LXdpZHRoOiAkcGhvbmUxKSB7IC8vNDc1cHhcXG4gICAgLnNraWxscyB7XFxuICAgICAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxuICAgICAgICAuZHV0aWVzIHtcXG4gICAgICAgICAgICB3aWR0aDogZml0LWNvbnRlbnQ7XFxuICAgICAgICAgICAgbWFyZ2luOiAwIGF1dG87XFxuICAgICAgICAgICAgZ3JpZC10ZW1wbGF0ZS1yb3dzOiByZXBlYXQoMiwgMWZyKTtcXG4gICAgICAgICAgICBncmlkLXRlbXBsYXRlLWNvbHVtbnM6IHJlcGVhdCgyLCBhdXRvKTtcXG4gICAgICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcXG4gICAgICAgICAgICBncmlkLWdhcDogMDtcXG4gICAgICAgICAgICAvLyAuZHV0eSBpbWdcXG4gICAgICAgICAgICAvLyAgICAgK3NpemUoOTVweCwgOTVweClcXG4gICAgICAgICAgICAuYWN0aXZlLWR1dHkge1xcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVkoMCk7XFxuICAgICAgICAgICAgICAgIGltZyB7XFxuICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm06IHNjYWxlKDEuMTUpOyB9IH0gfVxcbiAgICAgICAgLmR1dHktZXhwbGFpbmVkIHtcXG4gICAgICAgICAgICAvL1RPRE86IGR1dHktZXhwbGFpbmVkIGhlaWdodFxcbiB9ICAgICAgICAgICAgLy8gaGVpZ2h0OiA1ZW1cXG4gICAgICAgIC50ZWNoLXRvb2xzIHtcXG4gICAgICAgICAgICAuY29udGFpbmVyIHtcXG4gICAgICAgICAgICAgICAgLmljb25zIHtcXG4gICAgICAgICAgICAgICAgICAgIGRpc3BsYXk6IGdyaWQ7XFxuICAgICAgICAgICAgICAgICAgICBncmlkLXRlbXBsYXRlLXJvd3M6IHJlcGVhdCgyLCBhdXRvKTtcXG4gICAgICAgICAgICAgICAgICAgIGdyaWQtdGVtcGxhdGUtY29sdW1uczogcmVwZWF0KDUsIGF1dG8pO1xcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IGZpdC1jb250ZW50O1xcbiAgICAgICAgICAgICAgICAgICAgbWFyZ2luOiAwIGF1dG87XFxuICAgICAgICAgICAgICAgICAgICBsaSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgQGluY2x1ZGUgc2l6ZShhdXRvLCAyNXB4KTsgfSB9IH0gfSB9IH1cXG5cIixcIi8vR2xvYmFsIHZhcmlhYmxlcyB1c2VkIGhlcmVcXG4kcGFkZGluZzogMXJlbTtcXG5cXG4ud29yayB7XFxuICAgIC0tZ2FwOiAycmVtO1xcbiAgICAuY2FyZHMtY29udGFpbmVyIHtcXG4gICAgICAgIEBleHRlbmQgLm5vdC1jZW50ZXJlZDtcXG4gICAgICAgIC8vIHdpZHRoOiAkY29udGFpbmVyLXdpZHRoXFxuICAgICAgICAvLyBtYXJnaW46IDAgYXV0b1xcblxcbiAgICAgICAgQGluY2x1ZGUgZmxleChzdGFydCwgY2VudGVyLCByb3csIHZhcigtLWdhcCkpO1xcblxcbiAgICAgICAgb3ZlcmZsb3cteDogYXV0bztcXG5cXG4gICAgICAgIEBpbmNsdWRlIGFwcGx5LWNhcmRzLWVmZmVjdCgpO1xcblxcbiAgICAgICAgLy9UT0RPOiB0YWtlIGNhcmQgb2YgdGhvc2VcXG4gICAgICAgIC5nZW5lcmljLWNhcmQge1xcbiAgICAgICAgICAgIGJvcmRlci1yYWRpdXM6IDI1cHg7XFxuICAgICAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogIzE5MTkxOTtcXG4gICAgICAgICAgICBib3JkZXI6IDJweCBzb2xpZCAjM2QzZDNkO1xcbiAgICAgICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTsgfVxcbiAgICAgICAgLmNhcmQge1xcbiAgICAgICAgICAgIEBleHRlbmQgLmdlbmVyaWMtY2FyZDtcXG4gICAgICAgICAgICBAaW5jbHVkZSBzaXplKDM0MHB4LCAzODBweCk7XFxuICAgICAgICAgICAgQGluY2x1ZGUgZmxleChzcGFjZS1iZXR3ZWVuLCBzdGFydCwgY29sdW1uKTtcXG4gICAgICAgICAgICBvdmVyZmxvdzogaGlkZGVuO1xcbiAgICAgICAgICAgIHotaW5kZXg6IDI7XFxuICAgICAgICAgICAgLmNhcmQtYmcge1xcbiAgICAgICAgICAgICAgICBAaW5jbHVkZSBhYnNvbHV0ZS1jb3ZlcigpO1xcblxcbiAgICAgICAgICAgICAgICBib3JkZXItcmFkaXVzOiBpbmhlcml0O1xcbiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kLXJlcGVhdDogbm8tcmVwZWF0O1xcbiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kLXNpemU6IDcwJTtcXG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZC1wb3NpdGlvbjogYm90dG9tIC0zMCUgcmlnaHQgLTQwJTtcXG5cXG4gICAgICAgICAgICAgICAgb3BhY2l0eTogMC4yOyB9XFxuICAgICAgICAgICAgaGVhZGVyIHtcXG4gICAgICAgICAgICAgICAgd2lkdGg6IDEwMCU7XFxuICAgICAgICAgICAgICAgIHBhZGRpbmc6ICRwYWRkaW5nICRwYWRkaW5nIDA7XFxuICAgICAgICAgICAgICAgIEBpbmNsdWRlIGZsZXgoc3RhcnQsIHN0YXJ0LCBjb2x1bW4sIDAuNXJlbSk7XFxuICAgICAgICAgICAgICAgIC5jYXJkLXRpdGxlIHtcXG4gICAgICAgICAgICAgICAgICAgIEBpbmNsdWRlIGZsZXgoc3RhcnQsIGNlbnRlciwgcm93LCAwLjVyZW0pO1xcbiAgICAgICAgICAgICAgICAgICAgei1pbmRleDogMztcXG4gICAgICAgICAgICAgICAgICAgIC5jYXJkLW5hbWUge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvbnQtd2VpZ2h0OiA4MDA7XFxuICAgICAgICAgICAgICAgICAgICAgICAgbGluZS1oZWlnaHQ6IDEyMCU7XFxuICAgICAgICAgICAgICAgICAgICAgICAgQGluY2x1ZGUgZmlsbC1ncmQodmFyKC0tcHVycGxlLWdyZWVuLWdyZCkpOyB9XFxuICAgICAgICAgICAgICAgICAgICAuYXJyb3cge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zaXRpb246IHRyYW5zZm9ybSAuMnMgZWFzZTtcXG4gICAgICAgICAgICAgICAgICAgICAgICBqdXN0aWZ5LXNlbGY6IHN0YXJ0O1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsaWduLXNlbGY6IGNlbnRlcjtcXG4gICAgICAgICAgICAgICAgICAgICAgICBAaW5jbHVkZSBzaXplKDIycHgsIDIycHgpOyB9XFxuICAgICAgICAgICAgICAgICAgICAmOmhvdmVyIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBmaWx0ZXI6IGJyaWdodG5lc3MoMC44KTsgfSB9XFxuICAgICAgICAgICAgICAgIC53b3JrLWRvbmUge1xcbiAgICAgICAgICAgICAgICAgICAgZ3JpZC1yb3c6IDI7XFxuICAgICAgICAgICAgICAgICAgICBncmlkLWNvbHVtbjogMS8zO1xcbiAgICAgICAgICAgICAgICAgICAganVzdGlmeS1zZWxmOiBzdGFydDtcXG4gICAgICAgICAgICAgICAgICAgIEBpbmNsdWRlIGZsZXgoc3RhcnQsIHN0YXJ0LCByb3csIDAuNXJlbSk7XFxuICAgICAgICAgICAgICAgICAgICBmbGV4LWdyb3c6IDE7XFxuICAgICAgICAgICAgICAgICAgICBpbWcge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIEBpbmNsdWRlIHNpemUoMzBweCwgYXV0byk7IH0gfSB9XFxuXFxuICAgICAgICAgICAgZm9vdGVyIHtcXG4gICAgICAgICAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgICAgICAgICAgICAgICBkaXNwbGF5OiBncmlkO1xcbiAgICAgICAgICAgICAgICBncmlkLXRlbXBsYXRlLXJvd3M6IHJlcGVhdCgyLCBhdXRvKTtcXG4gICAgICAgICAgICAgICAgZ3JpZC10ZW1wbGF0ZS1jb2x1bW5zOiAxZnIgYXV0bztcXG4gICAgICAgICAgICAgICAgZ3JpZC1nYXA6IDAuNzVyZW0gMDtcXG4gICAgICAgICAgICAgICAgcGFkZGluZzogJHBhZGRpbmc7XFxuICAgICAgICAgICAgICAgIGJvcmRlci1yYWRpdXM6IGluaGVyaXQ7XFxuICAgICAgICAgICAgICAgIHotaW5kZXg6IGluaGVyaXQ7XFxuICAgICAgICAgICAgICAgIC5jYXJkLWRlc2NyaXB0aW9uIHtcXG4gICAgICAgICAgICAgICAgICAgIGdyaWQtY29sdW1uOiAxLzM7IH1cXG4gICAgICAgICAgICAgICAgLnllYXIge1xcbiAgICAgICAgICAgICAgICAgICAgZ3JpZC1yb3c6IDIvMztcXG4gICAgICAgICAgICAgICAgICAgIGdyaWQtY29sdW1uOiAyLzM7XFxuICAgICAgICAgICAgICAgICAgICBhbGlnbi1zZWxmOiBjZW50ZXI7XFxuICAgICAgICAgICAgICAgICAgICBAZXh0ZW5kIC50aW55LXNtYWxsO1xcbiAgICAgICAgICAgICAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tcHJpbWFyeS1ncmVlbik7XFxuICAgICAgICAgICAgICAgICAgICBjb2xvcjogcmdiYSgwLCAwLCAwLCAwLjcpO1xcbiAgICAgICAgICAgICAgICAgICAgcGFkZGluZzogMC4xcmVtIDAuMnJlbTtcXG4gICAgICAgICAgICAgICAgICAgIGJvcmRlci1yYWRpdXM6IDVweDsgfVxcbiAgICAgICAgICAgICAgICAucmVsYXRlZC1saW5rcyB7XFxuICAgICAgICAgICAgICAgICAgICBncmlkLXJvdzogMi8zO1xcbiAgICAgICAgICAgICAgICAgICAgZ3JpZC1jb2x1bW46IDEvMjtcXG4gICAgICAgICAgICAgICAgICAgIEBpbmNsdWRlIGZsZXgoc3RhcnQsIGNlbnRlciwgcm93LCAwLjNyZW0pO1xcbiAgICAgICAgICAgICAgICAgICAgYSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgQGluY2x1ZGUgZGFya2VuLW9uLWhvdmVyKDAuOCk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgQGluY2x1ZGUgc2l6ZSgyN3B4LDI3cHgpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGJhY2tncm91bmQtc2l6ZTogY292ZXI7XFxuICAgICAgICAgICAgICAgICAgICAgICAgaW1nIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgQGluY2x1ZGUgc2l6ZShpbmhlcml0LCBpbmhlcml0KTsgfVxcbiAgICAgICAgICAgICAgICAgICAgICAgICY6bnRoLWNoaWxkKDEpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmFja2dyb3VuZC1pbWFnZTogdXJsKC4uL2Fzc2V0cy9jYXJkLWRyaWJiYmxlLnN2Zyk7IH1cXG4gICAgICAgICAgICAgICAgICAgICAgICAmOm50aC1jaGlsZCgyKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJhY2tncm91bmQtaW1hZ2U6IHVybCguLi9hc3NldHMvY2FyZC1naXRodWIuc3ZnKTsgfSB9IH0gfVxcbiAgICAgICAgICAgIEBtZWRpYSBub3QgKGhvdmVyKSB7XFxuICAgICAgICAgICAgICAgIGhlYWRlciAud29yay1kb25lIGltZyB7XFxuICAgICAgICAgICAgICAgICAgICBmaWx0ZXI6IGJyaWdodG5lc3MoMCkgaW52ZXJ0KDEpOyB9XFxuICAgICAgICAgICAgICAgIGZvb3RlciB7XFxuICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVkoMzQlKTtcXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zaXRpb246IHRyYW5zZm9ybSAuMnMgZWFzZSAuMXM7IH1cXG4gICAgICAgICAgICAgICAgJjpob3ZlciB7XFxuICAgICAgICAgICAgICAgICAgICAud29yay1kb25lIGltZyB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgZmlsdGVyOiBicmlnaHRuZXNzKDEpIGludmVydCgwKTsgfVxcbiAgICAgICAgICAgICAgICAgICAgZm9vdGVyIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVkoMCk7IH0gfSB9IH1cXG4gICAgICAgICNwaWctZGljZSAuY2FyZC1iZyB7XFxuICAgICAgICAgICAgYmFja2dyb3VuZC1pbWFnZTogdXJsKC4uL2Fzc2V0cy9waWdkaWNlLnN2Zyk7IH1cXG4gICAgICAgICNtb25zdGVyLXNsYXllciB7XFxuICAgICAgICAgICAgLmNhcmQtYmcge1xcbiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kLWltYWdlOiB1cmwoLi4vYXNzZXRzL21vbnN0ZXItc2xheWVyLnN2Zyk7IH1cXG4gICAgICAgICAgICAuY2FyZC1uYW1lIHtcXG4gICAgICAgICAgICAgICAgd2lkdGg6IG1pbi1jb250ZW50OyB9IH1cXG4gICAgICAgICNvc2MtZ2Vla3MgLmNhcmQtYmcge1xcbiAgICAgICAgICAgIGJhY2tncm91bmQtaW1hZ2U6IHVybCguLi9hc3NldHMvb3NjLWdlZWtzLnN2Zyk7IH1cXG5cXG4gICAgICAgIC5kdW1teS1jYXJkIHtcXG4gICAgICAgICAgICBtYXJnaW46IDAgIWltcG9ydGFudDtcXG4gICAgICAgICAgICBmbGV4LWdyb3c6IDE7XFxuICAgICAgICAgICAgYm9yZGVyOiAycHggZGFzaGVkICMzZDNkM2Q7XFxuICAgICAgICAgICAgYm9yZGVyLXJhZGl1czogMjVweDtcXG4gICAgICAgICAgICBhbGlnbi1zZWxmOiBzdHJldGNoO1xcbiAgICAgICAgICAgIEBpbmNsdWRlIGdyaWQtY2VudGVyKCk7XFxuICAgICAgICAgICAgaW1nIHtcXG4gICAgICAgICAgICAgICAgQGluY2x1ZGUgc2l6ZSgxMDBweCwgYXV0byk7XFxuICAgICAgICAgICAgICAgIG9wYWNpdHk6IDAuNDsgfSB9IH1cXG4gICAgLnRhc2tzLWV4cGxhaW5lZCB7XFxuICAgICAgICBtYXJnaW4tdG9wOiAxcmVtO1xcbiAgICAgICAgQGluY2x1ZGUgZmxleChzdGFydCwgY2VudGVyLCByb3csIDE1cHgpO1xcbiAgICAgICAgZmxleC13cmFwOiB3cmFwO1xcbiAgICAgICAgLnRhc2sge1xcbiAgICAgICAgICAgIEBpbmNsdWRlIGZsZXgoY2VudGVyLCBjZW50ZXIsIHJvdywgNXB4KTtcXG4gICAgICAgICAgICBpbWcge1xcbiAgICAgICAgICAgICAgICBAaW5jbHVkZSBzaXplKDIwcHgsIDIwcHgpOyB9IH0gfSB9XFxuLy9iYXNlOiArc2l6ZSgzNDBweCwgMzgwcHgpXFxuQG1lZGlhIHNjcmVlbiBhbmQgKG1heC13aWR0aDogJGxhcHRvcCkgeyAvLzExMTZweFxcbiAgICAud29yayAuY2FyZHMtd3JhcHBlciAuY2FyZHMtY29udGFpbmVyIHtcXG4gICAgICAgIC5jYXJkIHtcXG4gICAgICAgICAgICBAaW5jbHVkZSBzaXplKDMxMHB4LCAzNTBweCk7IH1cXG4gICAgICAgIC5kdW1teS1jYXJkIHtcXG4gICAgICAgICAgICBkaXNwbGF5OiBub25lOyB9IH0gfVxcblxcbkBtZWRpYSBzY3JlZW4gYW5kIChtYXgtd2lkdGg6ICR0YWJsZXQxKSB7IC8vNzUwcHhcXG4gICAgLndvcmsgLmNhcmRzLXdyYXBwZXIgLmNhcmRzLWNvbnRhaW5lciB7XFxuICAgICAgICAtLW92ZXJsYXlpbmctbWFyZ2luOiAyMTBweDtcXG4gICAgICAgIC5jYXJkIHtcXG4gICAgICAgICAgICBAaW5jbHVkZSBzaXplKDMzMHB4LCAzNTBweCk7IH0gfSB9XFxuXFxuQG1lZGlhIHNjcmVlbiBhbmQgKG1heC13aWR0aDogJHRhYmxldDIpIHsgLy82NTBweFxcbiAgICAud29yayAuY2FyZHMtd3JhcHBlciB7XFxuICAgICAgICB3aWR0aDogMTAwJTtcXG4gICAgICAgIC5jYXJkcy1jb250YWluZXIge1xcbiAgICAgICAgICAgIHdpZHRoOiBpbmhlcml0O1xcbiAgICAgICAgICAgIGRpc3BsYXk6IGdyaWQ7XFxuICAgICAgICAgICAgZ3JpZC10ZW1wbGF0ZS1jb2x1bW5zOiByZXBlYXQoMywgYXV0byk7XFxuICAgICAgICAgICAgc2Nyb2xsLXNuYXAtdHlwZTogeCBtYW5kYXRvcnk7XFxuICAgICAgICAgICAgc2Nyb2xsLWJlaGF2aW9yOiBzbW9vdGg7XFxuICAgICAgICAgICAgLmNhcmQge1xcbiAgICAgICAgICAgICAgICBAaW5jbHVkZSBkaXNhYmxlLWNhcmRzLWVmZmVjdCgpO1xcbiAgICAgICAgICAgICAgICB3aWR0aDogNzB2dztcXG4gICAgICAgICAgICAgICAgbWFyZ2luOiAwO1xcbiAgICAgICAgICAgICAgICBzY3JvbGwtc25hcC1hbGlnbjogY2VudGVyO1xcbiAgICAgICAgICAgICAgICBzY3JvbGwtc25hcC1zdG9wOiBhbHdheXM7XFxuICAgICAgICAgICAgICAgIC53b3JrLWRvbmUge1xcbiAgICAgICAgICAgICAgICAgICAgaW1nIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBAaW5jbHVkZSBzaXplKDI1cHgsIDI1cHgpOyB9IH1cXG4gICAgICAgICAgICAgICAgJjpmaXJzdC1vZi10eXBlIHtcXG4gICAgICAgICAgICAgICAgICAgIG1hcmdpbi1sZWZ0OiB2YXIoLS1nYXApOyB9XFxuICAgICAgICAgICAgICAgICY6bGFzdC1vZi10eXBlIHtcXG4gICAgICAgICAgICAgICAgICAgIG1hcmdpbi1yaWdodDogdmFyKC0tZ2FwKTsgfSB9IH0gfSB9XFxuXFxuQG1lZGlhIHNjcmVlbiBhbmQgKG1heC13aWR0aDogJHBob25lMSkgeyAvLzQ1MHB4XFxuICAgIC53b3JrIHtcXG4gICAgICAgIC0tZ2FwOiAxcmVtO1xcbiAgICAgICAgLmNhcmRzLXdyYXBwZXIgLmNhcmRzLWNvbnRhaW5lciAuY2FyZCB7XFxuICAgICAgICAgICAgd2lkdGg6IDgwdnc7IH1cXG4gICAgICAgIC50YXNrcy1leHBsYWluZWQge1xcbiAgICAgICAgICAgIGp1c3RpZnktY29udGVudDogY2VudGVyOyB9IH0gfVxcblxcbkBtZWRpYSBzY3JlZW4gYW5kIChtYXgtd2lkdGg6ICRwaG9uZTIpIHsgLy8zNjBweFxcbiAgICAud29yayAuY2FyZHMtd3JhcHBlciAuY2FyZHMtY29udGFpbmVyIC5jYXJkIHtcXG4gICAgICAgIGhlaWdodDogMzAwcHg7IH0gfVxcblwiLFwiLmNvbnRhY3Qge1xcbiAgICBtaW4taGVpZ2h0OiBjbGFtcCg2NTBweCwgMTAwJSwgMTAwJSk7XFxuICAgIGRpc3BsYXk6IGdyaWQ7XFxuICAgIGdyaWQtdGVtcGxhdGUtcm93czogMi41ZnIgMWZyO1xcbiAgICBAZXh0ZW5kIC5ub3QtY2VudGVyZWQ7XFxuICAgIC5jb250YWN0LXRoZW1lIHtcXG4gICAgICAgIHdpZHRoOiAxMDAlO1xcbiAgICAgICAgaGVpZ2h0OiAxMDAlO1xcbiAgICAgICAgZGlzcGxheTogbm9uZTsgfVxcbiAgICAudXBwZXIge1xcbiAgICAgICAgZ3JpZC1yb3c6IDEvMjtcXG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6ICMwRjBGMEY7XFxuICAgICAgICBiYWNrZ3JvdW5kLWltYWdlOiB1cmwoJy4uL2Fzc2V0cy9jb250YWN0LXRoZW1lLTEud2VicCcpO1xcbiAgICAgICAgYmFja2dyb3VuZC1yZXBlYXQ6IG5vLXJlcGVhdDtcXG4gICAgICAgIGJhY2tncm91bmQtc2l6ZTogY2xhbXAoNjAwcHgsIDUwJSwgNTAlKSBhdXRvO1xcbiAgICAgICAgYmFja2dyb3VuZC1wb3NpdGlvbjogYm90dG9tIGxlZnQ7XFxuICAgICAgICB3aWR0aDogMTAwJTtcXG4gICAgICAgIG1hcmdpbjogMCBhdXRvO1xcbiAgICAgICAgbWF4LXdpZHRoOiAkbWF4LXdpZHRoO1xcbiAgICAgICAgLmNvbnRhaW5lciB7XFxuICAgICAgICAgICAgaGVpZ2h0OiAxMDAlO1xcbiAgICAgICAgICAgIEBpbmNsdWRlIGZsZXgoc3BhY2UtYmV0d2VlbiwgY2VudGVyLCByb3cpO1xcbiAgICAgICAgICAgIC50aXRsZSB7XFxuICAgICAgICAgICAgICAgIGFsaWduLXNlbGY6IGZsZXgtZW5kOyB9XFxuICAgICAgICAgICAgZm9ybSB7XFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gICAgICAgICAgICAgICAgQGluY2x1ZGUgZmxleChzdHJldGNoLCBzdHJldGNoLCBjb2x1bW4sICAwLjVyZW0pO1xcbiAgICAgICAgICAgICAgICBib3JkZXItcmFkaXVzOiAkYm9yZGVyLXJhZGl1cztcXG4gICAgICAgICAgICAgICAgcGFkZGluZzogMC43NXJlbTtcXG4gICAgICAgICAgICAgICAgQGluY2x1ZGUgc2l6ZSg0MCUsIDg1JSk7XFxuICAgICAgICAgICAgICAgIEBpbmNsdWRlIG1pbi1zaXplKDQ4MHB4LCBhdXRvKTtcXG4gICAgICAgICAgICAgICAgQGluY2x1ZGUgbWF4LXNpemUoYXV0bywgNDcwcHgpO1xcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICAgICAgICAgICAgICAgIC5pbnB1dC1jb250YWluZXIge1xcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheTogZ3JpZDtcXG4gICAgICAgICAgICAgICAgICAgIGdyaWQtdGVtcGxhdGUtcm93czogYXV0byAxZnI7XFxuICAgICAgICAgICAgICAgICAgICBncmlkLXRlbXBsYXRlLWNvbHVtbnM6IGF1dG8gMWZyO1xcbiAgICAgICAgICAgICAgICAgICAgZ3JpZC1yb3ctZ2FwOiA1cHg7XFxuICAgICAgICAgICAgICAgICAgICBsYWJlbCB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgZ3JpZC1yb3c6IDE7XFxuICAgICAgICAgICAgICAgICAgICAgICAgZ3JpZC1jb2x1bW46IDE7XFxuICAgICAgICAgICAgICAgICAgICAgICAganVzdGlmeS1zZWxmOiBsZWZ0O1xcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcmdpbjogMCAwIDAgNXB4OyB9XFxuICAgICAgICAgICAgICAgICAgICAuZXJyb3ItbXNnIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNwbGF5OiBub25lO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGdyaWQtcm93OiAxO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGdyaWQtY29sdW1uOiAyO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGp1c3RpZnktc2VsZjogcmlnaHQ7XFxuICAgICAgICAgICAgICAgICAgICAgICAgYWxpZ24tc2VsZjogZW5kOyB9XFxuICAgICAgICAgICAgICAgICAgICAudGV4dC1ib3gge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGdyaWQtcm93OiAyO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGdyaWQtY29sdW1uOiAxLzM7IH1cXG4gICAgICAgICAgICAgICAgICAgICY6bnRoLWNoaWxkKDMpIHsgLy8gTWVzc2FnZVxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZsZXgtZ3JvdzogMTsgfSB9XFxuICAgICAgICAgICAgICAgIC5pbnZhbGlkLWlucHV0IHtcXG4gICAgICAgICAgICAgICAgICAgIC5lcnJvci1tc2cge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BsYXk6IGlubGluZS1ibG9jazsgfVxcbiAgICAgICAgICAgICAgICAgICAgLnRleHQtYm94IHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBOb3QgY29udmllbmllbnQgdG8gbW92ZSB0byBfdGhlbWluZy5zYXNzXFxuICAgICAgICAgICAgICAgICAgICAgICAgYm9yZGVyLWNvbG9yOiB2YXIoLS1jb2xvci1lcnJvcik7IH0gfVxcbiAgICAgICAgICAgICAgICAudmFsaWQtaW5wdXQge1xcbiAgICAgICAgICAgICAgICAgICAgLmVycm9yLW1zZyB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGxheTogbm9uZTsgfVxcbiAgICAgICAgICAgICAgICAgICAgLnRleHQtYm94IHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBOb3QgY29udmllbmllbnQgdG8gbW92ZSB0byBfdGhlbWluZy5zYXNzXFxuICAgICAgICAgICAgICAgICAgICAgICAgYm9yZGVyLWNvbG9yOiB2YXIoLS1jb2xvci1zdWNjZXNzKTsgfSB9XFxuICAgICAgICAgICAgICAgIC5idG4ge1xcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICAgICAgICAgICAgICAgICAgYm9yZGVyLXJhZGl1czogOTk5cHg7XFxuICAgICAgICAgICAgICAgICAgICBwYWRkaW5nOiAwLjc1cmVtO1xcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IGZpdC1jb250ZW50O1xcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGUoLTUwJSwgLTUwJSk7XFxuICAgICAgICAgICAgICAgICAgICB0b3A6IDk2JTtcXG4gICAgICAgICAgICAgICAgICAgIGxlZnQ6IDk2JTtcXG4gICAgICAgICAgICAgICAgICAgIHotaW5kZXg6IDM7XFxuICAgICAgICAgICAgICAgICAgICAuYnRuLWljb24ge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIEBpbmNsdWRlIHNpemUoMzBweCwgMzBweCk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgYmFja2dyb3VuZC1pbWFnZTogdXJsKCcuLi9hc3NldHMvYXJyb3ctc2VuZC5zdmcnKTsgfSB9XFxuICAgICAgICAgICAgICAgIC5jb25mIHtcXG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgICAgICAgICAgICAgICAgIEBpbmNsdWRlIHNpemUoMTAwJSwgMTAwJSk7XFxuICAgICAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiBpbmhlcml0O1xcbiAgICAgICAgICAgICAgICAgICAgYm9yZGVyLXJhZGl1czogaW5oZXJpdDtcXG4gICAgICAgICAgICAgICAgICAgIHBhZGRpbmc6IDEuNXJlbTtcXG4gICAgICAgICAgICAgICAgICAgIHRvcDogMDtcXG4gICAgICAgICAgICAgICAgICAgIGxlZnQ6IDA7XFxuICAgICAgICAgICAgICAgICAgICBjb2xvcjogdmFyKC0tcHJpbWFyeS1ncmVlbik7XFxuICAgICAgICAgICAgICAgICAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxuICAgICAgICAgICAgICAgICAgICBAaW5jbHVkZSBmbGV4KGNlbnRlciwgc3RhcnQsIGNvbHVtbiwgMC41cmVtKTtcXG4gICAgICAgICAgICAgICAgICAgIGRpc3BsYXk6IG5vbmU7XFxuICAgICAgICAgICAgICAgICAgICBpbWcge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIEBpbmNsdWRlIHNpemUoNXJlbSwgNXJlbSk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgbWFyZ2luLWJvdHRvbTogMXJlbTsgfVxcbiAgICAgICAgICAgICAgICAgICAgc21hbGwge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wYWNpdHk6IDAuNzsgfSB9IH1cXG4gICAgICAgICAgICAuc2hvdy1jb25mIHtcXG4gICAgICAgICAgICAgICAgLmJ0biB7XFxuICAgICAgICAgICAgICAgICAgICBwb2ludGVyLWV2ZW50czogbm9uZTsgfVxcbiAgICAgICAgICAgICAgICAuY29uZiB7XFxuICAgICAgICAgICAgICAgICAgICBkaXNwbGF5OiBmbGV4OyB9IH0gfSB9XFxuICAgIC5sb3dlciB7XFxuICAgICAgICBncmlkLXJvdzogMi8zO1xcbiAgICAgICAgQGluY2x1ZGUgZ3JpZC1jZW50ZXIoKTtcXG4gICAgICAgIC5jb250YWluZXIge1xcbiAgICAgICAgICAgIEBpbmNsdWRlIGZsZXgoc3BhY2UtYmV0d2VlbiwgY2VudGVyKTtcXG4gICAgICAgICAgICAuY29udGFjdC1pbmZvIHtcXG4gICAgICAgICAgICAgICAgQGluY2x1ZGUgZmxleChzdGFydCwgc3RhcnQsIHJvdywgM3JlbSk7XFxuICAgICAgICAgICAgICAgIGxpIHtcXG4gICAgICAgICAgICAgICAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICAgICAgICAgICAgICAgICAgICBAaW5jbHVkZSBmbGV4KHN0YXJ0LCBzdGFydCwgY29sdW1uLCAwLjZyZW0pO1xcbiAgICAgICAgICAgICAgICAgICAgaW1nIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBAaW5jbHVkZSBzaXplKDQwcHgsIDQwcHgpOyB9XFxuICAgICAgICAgICAgICAgICAgICBzbWFsbCB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGxheTogYmxvY2s7IH0gfVxcbiAgICAgICAgICAgICAgICAjd29yay1waG9uZS1udW1iZXIsICN3b3JrLWVtYWlsIHtcXG4gICAgICAgICAgICAgICAgICAgIHRleHQtZGVjb3JhdGlvbjogdW5kZXJsaW5lOyB9IH1cXG4gICAgICAgICAgICAuc29jaWFsIHtcXG4gICAgICAgICAgICAgICAgQGluY2x1ZGUgZmxleChjZW50ZXIsIGNlbnRlciwgcm93LXJldmVyc2UsIDJyZW0pO1xcbiAgICAgICAgICAgICAgICBzbWFsbCB7XFxuICAgICAgICAgICAgICAgICAgICAmOjpiZWZvcmUge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6ICcnO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXG4gICAgICAgICAgICAgICAgICAgICAgICBAaW5jbHVkZSBzaXplKDIwcHgsIDRweCk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgYmFja2dyb3VuZDogI2ZmZjtcXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXJnaW46IDAgMC41cmVtIDNweCAwOyB9IH1cXG4gICAgICAgICAgICAgICAgLnBsYXRmb3JtcyB7XFxuICAgICAgICAgICAgICAgICAgICBAaW5jbHVkZSBmbGV4KHN0YXJ0LCBjZW50ZXIsIHJvdywgMC40cmVtKTtcXG4gICAgICAgICAgICAgICAgICAgIGxpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBAaW5jbHVkZSBzaXplKDMzcHgsIDMzcHgpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvcmRlci1yYWRpdXM6IDk5OXB4O1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zaXRpb246IHRyYW5zZm9ybSAwLjE1cyBlYXNlLW91dDtcXG4gICAgICAgICAgICAgICAgICAgICAgICAqIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgQGluY2x1ZGUgc2l6ZShpbmhlcml0LCBpbmhlcml0KTtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9yZGVyLXJhZGl1czogaW5oZXJpdDsgfVxcbiAgICAgICAgICAgICAgICAgICAgICAgICY6aG92ZXIge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm06IHNjYWxlKDEuMTUpIHRyYW5zbGF0ZVkoLTJweCk7IH0gfSB9IH0gfSB9IH1cXG5cXG5AbWVkaWEgc2NyZWVuIGFuZChtYXgtd2lkdGg6ICRsYXB0b3ApIHsgLy8xMTE2cHhcXG4gICAgLmNvbnRhY3Qge1xcbiAgICAgICAgLnVwcGVyIHtcXG4gICAgICAgICAgICBiYWNrZ3JvdW5kLWltYWdlOiB1cmwoJy4uL2Fzc2V0cy9jb250YWN0LXRoZW1lLTIud2VicCcpO1xcbiAgICAgICAgICAgIGJhY2tncm91bmQtc2l6ZTogYXV0byA5NSU7XFxuICAgICAgICAgICAgYmFja2dyb3VuZC1wb3NpdGlvbjogYm90dG9tIDYwJSBsZWZ0IC0xMCU7XFxuICAgICAgICAgICAgLmNvbnRhaW5lciB7XFxuICAgICAgICAgICAgICAgIC50aXRsZSB7XFxuICAgICAgICAgICAgICAgICAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xcbiAgICAgICAgICAgICAgICAgICAgYWxpZ24taXRlbXM6IGZsZXgtc3RhcnQ7IH1cXG4gICAgICAgICAgICAgICAgZm9ybSB7XFxuICAgICAgICAgICAgICAgICAgICBAaW5jbHVkZSBzaXplKDU1JSwgY2FsYygxMDAlLCAycmVtKSk7IH0gfSB9XFxuICAgICAgICAubG93ZXIgLmNvbnRhaW5lciB7XFxuICAgICAgICAgICAgYWxpZ24taXRlbXM6IGZsZXgtZW5kO1xcbiAgICAgICAgICAgIC5jb250YWN0LWluZm8ge1xcbiAgICAgICAgICAgICAgICBnYXA6IDAuNzVyZW07XFxuICAgICAgICAgICAgICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XFxuICAgICAgICAgICAgICAgIGxpIHtcXG4gICAgICAgICAgICAgICAgICAgIGZsZXgtZGlyZWN0aW9uOiByb3c7XFxuICAgICAgICAgICAgICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgICAgICAgICAgICAgICAgICAgaW1nIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBAaW5jbHVkZSBzaXplKDM1cHgsIDM1cHgpOyB9XFxuICAgICAgICAgICAgICAgICAgICBiciB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGxheTogbm9uZTsgfSB9IH1cXG5cXG4gICAgICAgICAgICAuc29jaWFsIHtcXG4gICAgICAgICAgICAgICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcXG4gICAgICAgICAgICAgICAgYWxpZ24taXRlbXM6IGZsZXgtZW5kO1xcbiAgICAgICAgICAgICAgICBnYXA6IDAuNnJlbTsgfSB9IH0gfVxcblxcbkBtZWRpYSBzY3JlZW4gYW5kICggbWF4LXdpZHRoOiAkdGFibGV0MCApIHsgLy85NTBweFxcbiAgICAuY29udGFjdCB7XFxuICAgICAgICAudXBwZXIgLmNvbnRhaW5lciB7XFxuICAgICAgICAgICAgcGFkZGluZy1ib3R0b206IDEuNXJlbTtcXG4gICAgICAgICAgICBhbGlnbi1pdGVtczogZmxleC1lbmQ7XFxuICAgICAgICAgICAgZm9ybSB7XFxuICAgICAgICAgICAgICAgIG1pbi13aWR0aDogMzgwcHg7IH1cXG4gICAgICAgICAgICAudGl0bGUge1xcbiAgICAgICAgICAgICAgICBtYXJnaW46IDA7IH0gfSB9IH1cXG5cXG5AbWVkaWEgc2NyZWVuIGFuZCAoIG1heC13aWR0aDogJHRhYmxldDIgKSB7IC8vNjUwcHhcXG4gICAgLmNvbnRhY3Qge1xcbiAgICAgICAgZ3JpZC10ZW1wbGF0ZS1yb3dzOiAyLjVmciAxZnI7XFxuICAgICAgICAvL05ld1xcbiAgICAgICAgZ3JpZC10ZW1wbGF0ZS1yb3dzOiAyZnIgMWZyO1xcbiAgICAgICAgLnVwcGVyIHtcXG4gICAgICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjMjcyNzI3O1xcbiAgICAgICAgICAgIC8vTmV3XFxuICAgICAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogIzI5MjkyOTtcXG4gICAgICAgICAgICBiYWNrZ3JvdW5kLWltYWdlOiBub25lO1xcbiAgICAgICAgICAgIC5jb250YWluZXIge1xcbiAgICAgICAgICAgICAgICBkaXNwbGF5OiBncmlkO1xcbiAgICAgICAgICAgICAgICAvLyBncmlkLWF1dG8tcm93czogMWZyIGF1dG8gMS41ZnJcXG4gICAgICAgICAgICAgICAgLy9OZXdcXG4gICAgICAgICAgICAgICAgZ3JpZC10ZW1wbGF0ZS1yb3dzOiBhdXRvIDFmcjtcXG4gICAgICAgICAgICAgICAgd2lkdGg6IDEwMHZ3O1xcbiAgICAgICAgICAgICAgICBwYWRkaW5nLWJvdHRvbTogMDtcXG4gICAgICAgICAgICAgICAgLmNvbnRhY3QtdGhlbWUge1xcbiAgICAgICAgICAgICAgICAgICAgLy9OZXdcXG4gICAgICAgICAgICAgICAgICAgIGRpc3BsYXk6IG5vbmU7XFxuICAgICAgICAgICAgICAgICAgICBncmlkLXJvdzogMS8yO1xcbiAgICAgICAgICAgICAgICAgICAgYmFja2dyb3VuZC1pbWFnZTogdXJsKCcuLi9hc3NldHMvY29udGFjdC10aGVtZS0zLndlYnAnKTtcXG4gICAgICAgICAgICAgICAgICAgIGJhY2tncm91bmQtcmVwZWF0OiBuby1yZXBlYXQ7XFxuICAgICAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kLXNpemU6IGF1dG8gMjMwJTtcXG4gICAgICAgICAgICAgICAgICAgIGJhY2tncm91bmQtcG9zaXRpb246IGNlbnRlciBjZW50ZXI7IH1cXG4gICAgICAgICAgICAgICAgLnRpdGxlIHtcXG4gICAgICAgICAgICAgICAgICAgIGdyaWQtcm93OiAyLzM7XFxuICAgICAgICAgICAgICAgICAgICAvL05ld1xcbiAgICAgICAgICAgICAgICAgICAgZ3JpZC1yb3c6IDEvMjtcXG4gICAgICAgICAgICAgICAgICAgIGZsZXgtZGlyZWN0aW9uOiByb3c7XFxuICAgICAgICAgICAgICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcXG4gICAgICAgICAgICAgICAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICAgICAgICAgICAgICAgICAgICBtYXJnaW46IDA7XFxuICAgICAgICAgICAgICAgICAgICB3aWR0aDogMTAwdnc7XFxuICAgICAgICAgICAgICAgICAgICAvL05ld1xcbiAgICAgICAgICAgICAgICAgICAgcGFkZGluZzogMS41cmVtIDAgMC41cmVtOyB9XFxuICAgICAgICAgICAgICAgIGZvcm0ge1xcbiAgICAgICAgICAgICAgICAgICAgZ3JpZC1yb3c6IDMvNDtcXG4gICAgICAgICAgICAgICAgICAgIC8vTmV3XFxuICAgICAgICAgICAgICAgICAgICBncmlkLXJvdzogMi8zO1xcbiAgICAgICAgICAgICAgICAgICAgbWluLXdpZHRoOiBhdXRvO1xcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IDEwMCU7XFxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IDEwMCU7XFxuICAgICAgICAgICAgICAgICAgICAjbWVzc2FnZSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgZ3JpZC1jb2x1bW46IDEvMzsgfVxcbiAgICAgICAgICAgICAgICAgICAgLmJ0biB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgdG9wOiA5OCU7XFxuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogNTAlOyB9XFxuICAgICAgICAgICAgICAgICAgICAuc2hvdy1jb25mIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjMjkyOTI5OyB9IH0gfSB9XFxuICAgICAgICAubG93ZXIge1xcbiAgICAgICAgICAgIC5jb250YWluZXIge1xcbiAgICAgICAgICAgICAgICBwYWRkaW5nOiAycmVtIDAgMXJlbSAwO1xcbiAgICAgICAgICAgICAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xcbiAgICAgICAgICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgICAgICAgICAgICAgICBnYXA6IDJyZW07XFxuICAgICAgICAgICAgICAgIC5zb2NpYWwge1xcbiAgICAgICAgICAgICAgICAgICAgc21hbGwge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BsYXk6IG5vbmU7IH0gfSB9IH0gfSB9XFxuXFxuLy8gQG1lZGlhIHNjcmVlbiBhbmQgKCBtYXgtd2lkdGg6ICRwaG9uZTEpIC8vNDc1cHhcXG4vLyAgICAgLmNvbnRhY3QgLnVwcGVyIC5jb250YWluZXJcXG4vLyAgICAgICAgIGdyaWQtYXV0by1yb3dzOiAwLjc1ZnIgYXV0byAxLjVmclxcbi8vICAgICAgICAgZm9ybVxcbi8vICAgICAgICAgICAgIGdyaWQtdGVtcGxhdGUtcm93czogYXV0byBhdXRvIDFmclxcbi8vICAgICAgICAgICAgIGdyaWQtdGVtcGxhdGUtY29sdW1uczogMWZyXFxuXCJdLFwic291cmNlUm9vdFwiOlwiXCJ9XSk7XG4vLyBFeHBvcnRzXG5leHBvcnQgZGVmYXVsdCBfX19DU1NfTE9BREVSX0VYUE9SVF9fXztcbiIsIlwidXNlIHN0cmljdFwiO1xuXG4vKlxuICBNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuICBBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXG4qL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoY3NzV2l0aE1hcHBpbmdUb1N0cmluZykge1xuICB2YXIgbGlzdCA9IFtdOyAvLyByZXR1cm4gdGhlIGxpc3Qgb2YgbW9kdWxlcyBhcyBjc3Mgc3RyaW5nXG5cbiAgbGlzdC50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgdmFyIGNvbnRlbnQgPSBcIlwiO1xuICAgICAgdmFyIG5lZWRMYXllciA9IHR5cGVvZiBpdGVtWzVdICE9PSBcInVuZGVmaW5lZFwiO1xuXG4gICAgICBpZiAoaXRlbVs0XSkge1xuICAgICAgICBjb250ZW50ICs9IFwiQHN1cHBvcnRzIChcIi5jb25jYXQoaXRlbVs0XSwgXCIpIHtcIik7XG4gICAgICB9XG5cbiAgICAgIGlmIChpdGVtWzJdKSB7XG4gICAgICAgIGNvbnRlbnQgKz0gXCJAbWVkaWEgXCIuY29uY2F0KGl0ZW1bMl0sIFwiIHtcIik7XG4gICAgICB9XG5cbiAgICAgIGlmIChuZWVkTGF5ZXIpIHtcbiAgICAgICAgY29udGVudCArPSBcIkBsYXllclwiLmNvbmNhdChpdGVtWzVdLmxlbmd0aCA+IDAgPyBcIiBcIi5jb25jYXQoaXRlbVs1XSkgOiBcIlwiLCBcIiB7XCIpO1xuICAgICAgfVxuXG4gICAgICBjb250ZW50ICs9IGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcoaXRlbSk7XG5cbiAgICAgIGlmIChuZWVkTGF5ZXIpIHtcbiAgICAgICAgY29udGVudCArPSBcIn1cIjtcbiAgICAgIH1cblxuICAgICAgaWYgKGl0ZW1bMl0pIHtcbiAgICAgICAgY29udGVudCArPSBcIn1cIjtcbiAgICAgIH1cblxuICAgICAgaWYgKGl0ZW1bNF0pIHtcbiAgICAgICAgY29udGVudCArPSBcIn1cIjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNvbnRlbnQ7XG4gICAgfSkuam9pbihcIlwiKTtcbiAgfTsgLy8gaW1wb3J0IGEgbGlzdCBvZiBtb2R1bGVzIGludG8gdGhlIGxpc3RcblxuXG4gIGxpc3QuaSA9IGZ1bmN0aW9uIGkobW9kdWxlcywgbWVkaWEsIGRlZHVwZSwgc3VwcG9ydHMsIGxheWVyKSB7XG4gICAgaWYgKHR5cGVvZiBtb2R1bGVzID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBtb2R1bGVzID0gW1tudWxsLCBtb2R1bGVzLCB1bmRlZmluZWRdXTtcbiAgICB9XG5cbiAgICB2YXIgYWxyZWFkeUltcG9ydGVkTW9kdWxlcyA9IHt9O1xuXG4gICAgaWYgKGRlZHVwZSkge1xuICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCB0aGlzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgIHZhciBpZCA9IHRoaXNba11bMF07XG5cbiAgICAgICAgaWYgKGlkICE9IG51bGwpIHtcbiAgICAgICAgICBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2lkXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKHZhciBfayA9IDA7IF9rIDwgbW9kdWxlcy5sZW5ndGg7IF9rKyspIHtcbiAgICAgIHZhciBpdGVtID0gW10uY29uY2F0KG1vZHVsZXNbX2tdKTtcblxuICAgICAgaWYgKGRlZHVwZSAmJiBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2l0ZW1bMF1dKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGxheWVyICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgaXRlbVs1XSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgIGl0ZW1bNV0gPSBsYXllcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpdGVtWzFdID0gXCJAbGF5ZXJcIi5jb25jYXQoaXRlbVs1XS5sZW5ndGggPiAwID8gXCIgXCIuY29uY2F0KGl0ZW1bNV0pIDogXCJcIiwgXCIge1wiKS5jb25jYXQoaXRlbVsxXSwgXCJ9XCIpO1xuICAgICAgICAgIGl0ZW1bNV0gPSBsYXllcjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAobWVkaWEpIHtcbiAgICAgICAgaWYgKCFpdGVtWzJdKSB7XG4gICAgICAgICAgaXRlbVsyXSA9IG1lZGlhO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGl0ZW1bMV0gPSBcIkBtZWRpYSBcIi5jb25jYXQoaXRlbVsyXSwgXCIge1wiKS5jb25jYXQoaXRlbVsxXSwgXCJ9XCIpO1xuICAgICAgICAgIGl0ZW1bMl0gPSBtZWRpYTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoc3VwcG9ydHMpIHtcbiAgICAgICAgaWYgKCFpdGVtWzRdKSB7XG4gICAgICAgICAgaXRlbVs0XSA9IFwiXCIuY29uY2F0KHN1cHBvcnRzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpdGVtWzFdID0gXCJAc3VwcG9ydHMgKFwiLmNvbmNhdChpdGVtWzRdLCBcIikge1wiKS5jb25jYXQoaXRlbVsxXSwgXCJ9XCIpO1xuICAgICAgICAgIGl0ZW1bNF0gPSBzdXBwb3J0cztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBsaXN0LnB1c2goaXRlbSk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBsaXN0O1xufTsiLCJcInVzZSBzdHJpY3RcIjtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodXJsLCBvcHRpb25zKSB7XG4gIGlmICghb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuXG4gIGlmICghdXJsKSB7XG4gICAgcmV0dXJuIHVybDtcbiAgfVxuXG4gIHVybCA9IFN0cmluZyh1cmwuX19lc01vZHVsZSA/IHVybC5kZWZhdWx0IDogdXJsKTsgLy8gSWYgdXJsIGlzIGFscmVhZHkgd3JhcHBlZCBpbiBxdW90ZXMsIHJlbW92ZSB0aGVtXG5cbiAgaWYgKC9eWydcIl0uKlsnXCJdJC8udGVzdCh1cmwpKSB7XG4gICAgdXJsID0gdXJsLnNsaWNlKDEsIC0xKTtcbiAgfVxuXG4gIGlmIChvcHRpb25zLmhhc2gpIHtcbiAgICB1cmwgKz0gb3B0aW9ucy5oYXNoO1xuICB9IC8vIFNob3VsZCB1cmwgYmUgd3JhcHBlZD9cbiAgLy8gU2VlIGh0dHBzOi8vZHJhZnRzLmNzc3dnLm9yZy9jc3MtdmFsdWVzLTMvI3VybHNcblxuXG4gIGlmICgvW1wiJygpIFxcdFxcbl18KCUyMCkvLnRlc3QodXJsKSB8fCBvcHRpb25zLm5lZWRRdW90ZXMpIHtcbiAgICByZXR1cm4gXCJcXFwiXCIuY29uY2F0KHVybC5yZXBsYWNlKC9cIi9nLCAnXFxcXFwiJykucmVwbGFjZSgvXFxuL2csIFwiXFxcXG5cIiksIFwiXFxcIlwiKTtcbiAgfVxuXG4gIHJldHVybiB1cmw7XG59OyIsIlwidXNlIHN0cmljdFwiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdGVtKSB7XG4gIHZhciBjb250ZW50ID0gaXRlbVsxXTtcbiAgdmFyIGNzc01hcHBpbmcgPSBpdGVtWzNdO1xuXG4gIGlmICghY3NzTWFwcGluZykge1xuICAgIHJldHVybiBjb250ZW50O1xuICB9XG5cbiAgaWYgKHR5cGVvZiBidG9hID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICB2YXIgYmFzZTY0ID0gYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoY3NzTWFwcGluZykpKSk7XG4gICAgdmFyIGRhdGEgPSBcInNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LFwiLmNvbmNhdChiYXNlNjQpO1xuICAgIHZhciBzb3VyY2VNYXBwaW5nID0gXCIvKiMgXCIuY29uY2F0KGRhdGEsIFwiICovXCIpO1xuICAgIHZhciBzb3VyY2VVUkxzID0gY3NzTWFwcGluZy5zb3VyY2VzLm1hcChmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgICByZXR1cm4gXCIvKiMgc291cmNlVVJMPVwiLmNvbmNhdChjc3NNYXBwaW5nLnNvdXJjZVJvb3QgfHwgXCJcIikuY29uY2F0KHNvdXJjZSwgXCIgKi9cIik7XG4gICAgfSk7XG4gICAgcmV0dXJuIFtjb250ZW50XS5jb25jYXQoc291cmNlVVJMcykuY29uY2F0KFtzb3VyY2VNYXBwaW5nXSkuam9pbihcIlxcblwiKTtcbiAgfVxuXG4gIHJldHVybiBbY29udGVudF0uam9pbihcIlxcblwiKTtcbn07IiwiaW1wb3J0IHsgcmVnaXN0ZXJWZXJzaW9uIH0gZnJvbSAnQGZpcmViYXNlL2FwcCc7XG5leHBvcnQgKiBmcm9tICdAZmlyZWJhc2UvYXBwJztcblxudmFyIG5hbWUgPSBcImZpcmViYXNlXCI7XG52YXIgdmVyc2lvbiA9IFwiOS42LjhcIjtcblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxucmVnaXN0ZXJWZXJzaW9uKG5hbWUsIHZlcnNpb24sICdhcHAnKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmVzbS5qcy5tYXBcbiIsImV4cG9ydCAqIGZyb20gJ0BmaXJlYmFzZS9kYXRhYmFzZSc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5lc20uanMubWFwXG4iLCIoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KGV4cG9ydHMpIDpcbiAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnZXhwb3J0cyddLCBmYWN0b3J5KSA6XG4gIChnbG9iYWwgPSBnbG9iYWwgfHwgc2VsZiwgZmFjdG9yeShnbG9iYWwuaWRiID0ge30pKTtcbn0odGhpcywgZnVuY3Rpb24gKGV4cG9ydHMpIHsgJ3VzZSBzdHJpY3QnO1xuXG4gIGZ1bmN0aW9uIHRvQXJyYXkoYXJyKSB7XG4gICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFycik7XG4gIH1cblxuICBmdW5jdGlvbiBwcm9taXNpZnlSZXF1ZXN0KHJlcXVlc3QpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICByZXF1ZXN0Lm9uc3VjY2VzcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXNvbHZlKHJlcXVlc3QucmVzdWx0KTtcbiAgICAgIH07XG5cbiAgICAgIHJlcXVlc3Qub25lcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZWplY3QocmVxdWVzdC5lcnJvcik7XG4gICAgICB9O1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gcHJvbWlzaWZ5UmVxdWVzdENhbGwob2JqLCBtZXRob2QsIGFyZ3MpIHtcbiAgICB2YXIgcmVxdWVzdDtcbiAgICB2YXIgcCA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgcmVxdWVzdCA9IG9ialttZXRob2RdLmFwcGx5KG9iaiwgYXJncyk7XG4gICAgICBwcm9taXNpZnlSZXF1ZXN0KHJlcXVlc3QpLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICB9KTtcblxuICAgIHAucmVxdWVzdCA9IHJlcXVlc3Q7XG4gICAgcmV0dXJuIHA7XG4gIH1cblxuICBmdW5jdGlvbiBwcm9taXNpZnlDdXJzb3JSZXF1ZXN0Q2FsbChvYmosIG1ldGhvZCwgYXJncykge1xuICAgIHZhciBwID0gcHJvbWlzaWZ5UmVxdWVzdENhbGwob2JqLCBtZXRob2QsIGFyZ3MpO1xuICAgIHJldHVybiBwLnRoZW4oZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIGlmICghdmFsdWUpIHJldHVybjtcbiAgICAgIHJldHVybiBuZXcgQ3Vyc29yKHZhbHVlLCBwLnJlcXVlc3QpO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gcHJveHlQcm9wZXJ0aWVzKFByb3h5Q2xhc3MsIHRhcmdldFByb3AsIHByb3BlcnRpZXMpIHtcbiAgICBwcm9wZXJ0aWVzLmZvckVhY2goZnVuY3Rpb24ocHJvcCkge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFByb3h5Q2xhc3MucHJvdG90eXBlLCBwcm9wLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXNbdGFyZ2V0UHJvcF1bcHJvcF07XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24odmFsKSB7XG4gICAgICAgICAgdGhpc1t0YXJnZXRQcm9wXVtwcm9wXSA9IHZhbDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBwcm94eVJlcXVlc3RNZXRob2RzKFByb3h5Q2xhc3MsIHRhcmdldFByb3AsIENvbnN0cnVjdG9yLCBwcm9wZXJ0aWVzKSB7XG4gICAgcHJvcGVydGllcy5mb3JFYWNoKGZ1bmN0aW9uKHByb3ApIHtcbiAgICAgIGlmICghKHByb3AgaW4gQ29uc3RydWN0b3IucHJvdG90eXBlKSkgcmV0dXJuO1xuICAgICAgUHJveHlDbGFzcy5wcm90b3R5cGVbcHJvcF0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHByb21pc2lmeVJlcXVlc3RDYWxsKHRoaXNbdGFyZ2V0UHJvcF0sIHByb3AsIGFyZ3VtZW50cyk7XG4gICAgICB9O1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gcHJveHlNZXRob2RzKFByb3h5Q2xhc3MsIHRhcmdldFByb3AsIENvbnN0cnVjdG9yLCBwcm9wZXJ0aWVzKSB7XG4gICAgcHJvcGVydGllcy5mb3JFYWNoKGZ1bmN0aW9uKHByb3ApIHtcbiAgICAgIGlmICghKHByb3AgaW4gQ29uc3RydWN0b3IucHJvdG90eXBlKSkgcmV0dXJuO1xuICAgICAgUHJveHlDbGFzcy5wcm90b3R5cGVbcHJvcF0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNbdGFyZ2V0UHJvcF1bcHJvcF0uYXBwbHkodGhpc1t0YXJnZXRQcm9wXSwgYXJndW1lbnRzKTtcbiAgICAgIH07XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBwcm94eUN1cnNvclJlcXVlc3RNZXRob2RzKFByb3h5Q2xhc3MsIHRhcmdldFByb3AsIENvbnN0cnVjdG9yLCBwcm9wZXJ0aWVzKSB7XG4gICAgcHJvcGVydGllcy5mb3JFYWNoKGZ1bmN0aW9uKHByb3ApIHtcbiAgICAgIGlmICghKHByb3AgaW4gQ29uc3RydWN0b3IucHJvdG90eXBlKSkgcmV0dXJuO1xuICAgICAgUHJveHlDbGFzcy5wcm90b3R5cGVbcHJvcF0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHByb21pc2lmeUN1cnNvclJlcXVlc3RDYWxsKHRoaXNbdGFyZ2V0UHJvcF0sIHByb3AsIGFyZ3VtZW50cyk7XG4gICAgICB9O1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gSW5kZXgoaW5kZXgpIHtcbiAgICB0aGlzLl9pbmRleCA9IGluZGV4O1xuICB9XG5cbiAgcHJveHlQcm9wZXJ0aWVzKEluZGV4LCAnX2luZGV4JywgW1xuICAgICduYW1lJyxcbiAgICAna2V5UGF0aCcsXG4gICAgJ211bHRpRW50cnknLFxuICAgICd1bmlxdWUnXG4gIF0pO1xuXG4gIHByb3h5UmVxdWVzdE1ldGhvZHMoSW5kZXgsICdfaW5kZXgnLCBJREJJbmRleCwgW1xuICAgICdnZXQnLFxuICAgICdnZXRLZXknLFxuICAgICdnZXRBbGwnLFxuICAgICdnZXRBbGxLZXlzJyxcbiAgICAnY291bnQnXG4gIF0pO1xuXG4gIHByb3h5Q3Vyc29yUmVxdWVzdE1ldGhvZHMoSW5kZXgsICdfaW5kZXgnLCBJREJJbmRleCwgW1xuICAgICdvcGVuQ3Vyc29yJyxcbiAgICAnb3BlbktleUN1cnNvcidcbiAgXSk7XG5cbiAgZnVuY3Rpb24gQ3Vyc29yKGN1cnNvciwgcmVxdWVzdCkge1xuICAgIHRoaXMuX2N1cnNvciA9IGN1cnNvcjtcbiAgICB0aGlzLl9yZXF1ZXN0ID0gcmVxdWVzdDtcbiAgfVxuXG4gIHByb3h5UHJvcGVydGllcyhDdXJzb3IsICdfY3Vyc29yJywgW1xuICAgICdkaXJlY3Rpb24nLFxuICAgICdrZXknLFxuICAgICdwcmltYXJ5S2V5JyxcbiAgICAndmFsdWUnXG4gIF0pO1xuXG4gIHByb3h5UmVxdWVzdE1ldGhvZHMoQ3Vyc29yLCAnX2N1cnNvcicsIElEQkN1cnNvciwgW1xuICAgICd1cGRhdGUnLFxuICAgICdkZWxldGUnXG4gIF0pO1xuXG4gIC8vIHByb3h5ICduZXh0JyBtZXRob2RzXG4gIFsnYWR2YW5jZScsICdjb250aW51ZScsICdjb250aW51ZVByaW1hcnlLZXknXS5mb3JFYWNoKGZ1bmN0aW9uKG1ldGhvZE5hbWUpIHtcbiAgICBpZiAoIShtZXRob2ROYW1lIGluIElEQkN1cnNvci5wcm90b3R5cGUpKSByZXR1cm47XG4gICAgQ3Vyc29yLnByb3RvdHlwZVttZXRob2ROYW1lXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGN1cnNvciA9IHRoaXM7XG4gICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICBjdXJzb3IuX2N1cnNvclttZXRob2ROYW1lXS5hcHBseShjdXJzb3IuX2N1cnNvciwgYXJncyk7XG4gICAgICAgIHJldHVybiBwcm9taXNpZnlSZXF1ZXN0KGN1cnNvci5fcmVxdWVzdCkudGhlbihmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgIGlmICghdmFsdWUpIHJldHVybjtcbiAgICAgICAgICByZXR1cm4gbmV3IEN1cnNvcih2YWx1ZSwgY3Vyc29yLl9yZXF1ZXN0KTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9O1xuICB9KTtcblxuICBmdW5jdGlvbiBPYmplY3RTdG9yZShzdG9yZSkge1xuICAgIHRoaXMuX3N0b3JlID0gc3RvcmU7XG4gIH1cblxuICBPYmplY3RTdG9yZS5wcm90b3R5cGUuY3JlYXRlSW5kZXggPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gbmV3IEluZGV4KHRoaXMuX3N0b3JlLmNyZWF0ZUluZGV4LmFwcGx5KHRoaXMuX3N0b3JlLCBhcmd1bWVudHMpKTtcbiAgfTtcblxuICBPYmplY3RTdG9yZS5wcm90b3R5cGUuaW5kZXggPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gbmV3IEluZGV4KHRoaXMuX3N0b3JlLmluZGV4LmFwcGx5KHRoaXMuX3N0b3JlLCBhcmd1bWVudHMpKTtcbiAgfTtcblxuICBwcm94eVByb3BlcnRpZXMoT2JqZWN0U3RvcmUsICdfc3RvcmUnLCBbXG4gICAgJ25hbWUnLFxuICAgICdrZXlQYXRoJyxcbiAgICAnaW5kZXhOYW1lcycsXG4gICAgJ2F1dG9JbmNyZW1lbnQnXG4gIF0pO1xuXG4gIHByb3h5UmVxdWVzdE1ldGhvZHMoT2JqZWN0U3RvcmUsICdfc3RvcmUnLCBJREJPYmplY3RTdG9yZSwgW1xuICAgICdwdXQnLFxuICAgICdhZGQnLFxuICAgICdkZWxldGUnLFxuICAgICdjbGVhcicsXG4gICAgJ2dldCcsXG4gICAgJ2dldEFsbCcsXG4gICAgJ2dldEtleScsXG4gICAgJ2dldEFsbEtleXMnLFxuICAgICdjb3VudCdcbiAgXSk7XG5cbiAgcHJveHlDdXJzb3JSZXF1ZXN0TWV0aG9kcyhPYmplY3RTdG9yZSwgJ19zdG9yZScsIElEQk9iamVjdFN0b3JlLCBbXG4gICAgJ29wZW5DdXJzb3InLFxuICAgICdvcGVuS2V5Q3Vyc29yJ1xuICBdKTtcblxuICBwcm94eU1ldGhvZHMoT2JqZWN0U3RvcmUsICdfc3RvcmUnLCBJREJPYmplY3RTdG9yZSwgW1xuICAgICdkZWxldGVJbmRleCdcbiAgXSk7XG5cbiAgZnVuY3Rpb24gVHJhbnNhY3Rpb24oaWRiVHJhbnNhY3Rpb24pIHtcbiAgICB0aGlzLl90eCA9IGlkYlRyYW5zYWN0aW9uO1xuICAgIHRoaXMuY29tcGxldGUgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIGlkYlRyYW5zYWN0aW9uLm9uY29tcGxldGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgfTtcbiAgICAgIGlkYlRyYW5zYWN0aW9uLm9uZXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmVqZWN0KGlkYlRyYW5zYWN0aW9uLmVycm9yKTtcbiAgICAgIH07XG4gICAgICBpZGJUcmFuc2FjdGlvbi5vbmFib3J0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJlamVjdChpZGJUcmFuc2FjdGlvbi5lcnJvcik7XG4gICAgICB9O1xuICAgIH0pO1xuICB9XG5cbiAgVHJhbnNhY3Rpb24ucHJvdG90eXBlLm9iamVjdFN0b3JlID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIG5ldyBPYmplY3RTdG9yZSh0aGlzLl90eC5vYmplY3RTdG9yZS5hcHBseSh0aGlzLl90eCwgYXJndW1lbnRzKSk7XG4gIH07XG5cbiAgcHJveHlQcm9wZXJ0aWVzKFRyYW5zYWN0aW9uLCAnX3R4JywgW1xuICAgICdvYmplY3RTdG9yZU5hbWVzJyxcbiAgICAnbW9kZSdcbiAgXSk7XG5cbiAgcHJveHlNZXRob2RzKFRyYW5zYWN0aW9uLCAnX3R4JywgSURCVHJhbnNhY3Rpb24sIFtcbiAgICAnYWJvcnQnXG4gIF0pO1xuXG4gIGZ1bmN0aW9uIFVwZ3JhZGVEQihkYiwgb2xkVmVyc2lvbiwgdHJhbnNhY3Rpb24pIHtcbiAgICB0aGlzLl9kYiA9IGRiO1xuICAgIHRoaXMub2xkVmVyc2lvbiA9IG9sZFZlcnNpb247XG4gICAgdGhpcy50cmFuc2FjdGlvbiA9IG5ldyBUcmFuc2FjdGlvbih0cmFuc2FjdGlvbik7XG4gIH1cblxuICBVcGdyYWRlREIucHJvdG90eXBlLmNyZWF0ZU9iamVjdFN0b3JlID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIG5ldyBPYmplY3RTdG9yZSh0aGlzLl9kYi5jcmVhdGVPYmplY3RTdG9yZS5hcHBseSh0aGlzLl9kYiwgYXJndW1lbnRzKSk7XG4gIH07XG5cbiAgcHJveHlQcm9wZXJ0aWVzKFVwZ3JhZGVEQiwgJ19kYicsIFtcbiAgICAnbmFtZScsXG4gICAgJ3ZlcnNpb24nLFxuICAgICdvYmplY3RTdG9yZU5hbWVzJ1xuICBdKTtcblxuICBwcm94eU1ldGhvZHMoVXBncmFkZURCLCAnX2RiJywgSURCRGF0YWJhc2UsIFtcbiAgICAnZGVsZXRlT2JqZWN0U3RvcmUnLFxuICAgICdjbG9zZSdcbiAgXSk7XG5cbiAgZnVuY3Rpb24gREIoZGIpIHtcbiAgICB0aGlzLl9kYiA9IGRiO1xuICB9XG5cbiAgREIucHJvdG90eXBlLnRyYW5zYWN0aW9uID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbih0aGlzLl9kYi50cmFuc2FjdGlvbi5hcHBseSh0aGlzLl9kYiwgYXJndW1lbnRzKSk7XG4gIH07XG5cbiAgcHJveHlQcm9wZXJ0aWVzKERCLCAnX2RiJywgW1xuICAgICduYW1lJyxcbiAgICAndmVyc2lvbicsXG4gICAgJ29iamVjdFN0b3JlTmFtZXMnXG4gIF0pO1xuXG4gIHByb3h5TWV0aG9kcyhEQiwgJ19kYicsIElEQkRhdGFiYXNlLCBbXG4gICAgJ2Nsb3NlJ1xuICBdKTtcblxuICAvLyBBZGQgY3Vyc29yIGl0ZXJhdG9yc1xuICAvLyBUT0RPOiByZW1vdmUgdGhpcyBvbmNlIGJyb3dzZXJzIGRvIHRoZSByaWdodCB0aGluZyB3aXRoIHByb21pc2VzXG4gIFsnb3BlbkN1cnNvcicsICdvcGVuS2V5Q3Vyc29yJ10uZm9yRWFjaChmdW5jdGlvbihmdW5jTmFtZSkge1xuICAgIFtPYmplY3RTdG9yZSwgSW5kZXhdLmZvckVhY2goZnVuY3Rpb24oQ29uc3RydWN0b3IpIHtcbiAgICAgIC8vIERvbid0IGNyZWF0ZSBpdGVyYXRlS2V5Q3Vyc29yIGlmIG9wZW5LZXlDdXJzb3IgZG9lc24ndCBleGlzdC5cbiAgICAgIGlmICghKGZ1bmNOYW1lIGluIENvbnN0cnVjdG9yLnByb3RvdHlwZSkpIHJldHVybjtcblxuICAgICAgQ29uc3RydWN0b3IucHJvdG90eXBlW2Z1bmNOYW1lLnJlcGxhY2UoJ29wZW4nLCAnaXRlcmF0ZScpXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYXJncyA9IHRvQXJyYXkoYXJndW1lbnRzKTtcbiAgICAgICAgdmFyIGNhbGxiYWNrID0gYXJnc1thcmdzLmxlbmd0aCAtIDFdO1xuICAgICAgICB2YXIgbmF0aXZlT2JqZWN0ID0gdGhpcy5fc3RvcmUgfHwgdGhpcy5faW5kZXg7XG4gICAgICAgIHZhciByZXF1ZXN0ID0gbmF0aXZlT2JqZWN0W2Z1bmNOYW1lXS5hcHBseShuYXRpdmVPYmplY3QsIGFyZ3Muc2xpY2UoMCwgLTEpKTtcbiAgICAgICAgcmVxdWVzdC5vbnN1Y2Nlc3MgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICBjYWxsYmFjayhyZXF1ZXN0LnJlc3VsdCk7XG4gICAgICAgIH07XG4gICAgICB9O1xuICAgIH0pO1xuICB9KTtcblxuICAvLyBwb2x5ZmlsbCBnZXRBbGxcbiAgW0luZGV4LCBPYmplY3RTdG9yZV0uZm9yRWFjaChmdW5jdGlvbihDb25zdHJ1Y3Rvcikge1xuICAgIGlmIChDb25zdHJ1Y3Rvci5wcm90b3R5cGUuZ2V0QWxsKSByZXR1cm47XG4gICAgQ29uc3RydWN0b3IucHJvdG90eXBlLmdldEFsbCA9IGZ1bmN0aW9uKHF1ZXJ5LCBjb3VudCkge1xuICAgICAgdmFyIGluc3RhbmNlID0gdGhpcztcbiAgICAgIHZhciBpdGVtcyA9IFtdO1xuXG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSkge1xuICAgICAgICBpbnN0YW5jZS5pdGVyYXRlQ3Vyc29yKHF1ZXJ5LCBmdW5jdGlvbihjdXJzb3IpIHtcbiAgICAgICAgICBpZiAoIWN1cnNvcikge1xuICAgICAgICAgICAgcmVzb2x2ZShpdGVtcyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGl0ZW1zLnB1c2goY3Vyc29yLnZhbHVlKTtcblxuICAgICAgICAgIGlmIChjb3VudCAhPT0gdW5kZWZpbmVkICYmIGl0ZW1zLmxlbmd0aCA9PSBjb3VudCkge1xuICAgICAgICAgICAgcmVzb2x2ZShpdGVtcyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGN1cnNvci5jb250aW51ZSgpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH07XG4gIH0pO1xuXG4gIGZ1bmN0aW9uIG9wZW5EYihuYW1lLCB2ZXJzaW9uLCB1cGdyYWRlQ2FsbGJhY2spIHtcbiAgICB2YXIgcCA9IHByb21pc2lmeVJlcXVlc3RDYWxsKGluZGV4ZWREQiwgJ29wZW4nLCBbbmFtZSwgdmVyc2lvbl0pO1xuICAgIHZhciByZXF1ZXN0ID0gcC5yZXF1ZXN0O1xuXG4gICAgaWYgKHJlcXVlc3QpIHtcbiAgICAgIHJlcXVlc3Qub251cGdyYWRlbmVlZGVkID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgaWYgKHVwZ3JhZGVDYWxsYmFjaykge1xuICAgICAgICAgIHVwZ3JhZGVDYWxsYmFjayhuZXcgVXBncmFkZURCKHJlcXVlc3QucmVzdWx0LCBldmVudC5vbGRWZXJzaW9uLCByZXF1ZXN0LnRyYW5zYWN0aW9uKSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIHAudGhlbihmdW5jdGlvbihkYikge1xuICAgICAgcmV0dXJuIG5ldyBEQihkYik7XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBkZWxldGVEYihuYW1lKSB7XG4gICAgcmV0dXJuIHByb21pc2lmeVJlcXVlc3RDYWxsKGluZGV4ZWREQiwgJ2RlbGV0ZURhdGFiYXNlJywgW25hbWVdKTtcbiAgfVxuXG4gIGV4cG9ydHMub3BlbkRiID0gb3BlbkRiO1xuICBleHBvcnRzLmRlbGV0ZURiID0gZGVsZXRlRGI7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxufSkpO1xuIiwiXG4gICAgICBpbXBvcnQgQVBJIGZyb20gXCIhLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvaW5qZWN0U3R5bGVzSW50b1N0eWxlVGFnLmpzXCI7XG4gICAgICBpbXBvcnQgZG9tQVBJIGZyb20gXCIhLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvc3R5bGVEb21BUEkuanNcIjtcbiAgICAgIGltcG9ydCBpbnNlcnRGbiBmcm9tIFwiIS4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luc2VydEJ5U2VsZWN0b3IuanNcIjtcbiAgICAgIGltcG9ydCBzZXRBdHRyaWJ1dGVzIGZyb20gXCIhLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvc2V0QXR0cmlidXRlc1dpdGhvdXRBdHRyaWJ1dGVzLmpzXCI7XG4gICAgICBpbXBvcnQgaW5zZXJ0U3R5bGVFbGVtZW50IGZyb20gXCIhLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvaW5zZXJ0U3R5bGVFbGVtZW50LmpzXCI7XG4gICAgICBpbXBvcnQgc3R5bGVUYWdUcmFuc2Zvcm1GbiBmcm9tIFwiIS4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL3N0eWxlVGFnVHJhbnNmb3JtLmpzXCI7XG4gICAgICBpbXBvcnQgY29udGVudCwgKiBhcyBuYW1lZEV4cG9ydCBmcm9tIFwiISEuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcyEuLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvZGlzdC9janMuanMhLi9pbmRleC5zYXNzXCI7XG4gICAgICBcbiAgICAgIFxuXG52YXIgb3B0aW9ucyA9IHt9O1xuXG5vcHRpb25zLnN0eWxlVGFnVHJhbnNmb3JtID0gc3R5bGVUYWdUcmFuc2Zvcm1Gbjtcbm9wdGlvbnMuc2V0QXR0cmlidXRlcyA9IHNldEF0dHJpYnV0ZXM7XG5cbiAgICAgIG9wdGlvbnMuaW5zZXJ0ID0gaW5zZXJ0Rm4uYmluZChudWxsLCBcImhlYWRcIik7XG4gICAgXG5vcHRpb25zLmRvbUFQSSA9IGRvbUFQSTtcbm9wdGlvbnMuaW5zZXJ0U3R5bGVFbGVtZW50ID0gaW5zZXJ0U3R5bGVFbGVtZW50O1xuXG52YXIgdXBkYXRlID0gQVBJKGNvbnRlbnQsIG9wdGlvbnMpO1xuXG5cblxuZXhwb3J0ICogZnJvbSBcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanMhLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vaW5kZXguc2Fzc1wiO1xuICAgICAgIGV4cG9ydCBkZWZhdWx0IGNvbnRlbnQgJiYgY29udGVudC5sb2NhbHMgPyBjb250ZW50LmxvY2FscyA6IHVuZGVmaW5lZDtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgc3R5bGVzSW5ET00gPSBbXTtcblxuZnVuY3Rpb24gZ2V0SW5kZXhCeUlkZW50aWZpZXIoaWRlbnRpZmllcikge1xuICB2YXIgcmVzdWx0ID0gLTE7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHlsZXNJbkRPTS5sZW5ndGg7IGkrKykge1xuICAgIGlmIChzdHlsZXNJbkRPTVtpXS5pZGVudGlmaWVyID09PSBpZGVudGlmaWVyKSB7XG4gICAgICByZXN1bHQgPSBpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gbW9kdWxlc1RvRG9tKGxpc3QsIG9wdGlvbnMpIHtcbiAgdmFyIGlkQ291bnRNYXAgPSB7fTtcbiAgdmFyIGlkZW50aWZpZXJzID0gW107XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGl0ZW0gPSBsaXN0W2ldO1xuICAgIHZhciBpZCA9IG9wdGlvbnMuYmFzZSA/IGl0ZW1bMF0gKyBvcHRpb25zLmJhc2UgOiBpdGVtWzBdO1xuICAgIHZhciBjb3VudCA9IGlkQ291bnRNYXBbaWRdIHx8IDA7XG4gICAgdmFyIGlkZW50aWZpZXIgPSBcIlwiLmNvbmNhdChpZCwgXCIgXCIpLmNvbmNhdChjb3VudCk7XG4gICAgaWRDb3VudE1hcFtpZF0gPSBjb3VudCArIDE7XG4gICAgdmFyIGluZGV4QnlJZGVudGlmaWVyID0gZ2V0SW5kZXhCeUlkZW50aWZpZXIoaWRlbnRpZmllcik7XG4gICAgdmFyIG9iaiA9IHtcbiAgICAgIGNzczogaXRlbVsxXSxcbiAgICAgIG1lZGlhOiBpdGVtWzJdLFxuICAgICAgc291cmNlTWFwOiBpdGVtWzNdLFxuICAgICAgc3VwcG9ydHM6IGl0ZW1bNF0sXG4gICAgICBsYXllcjogaXRlbVs1XVxuICAgIH07XG5cbiAgICBpZiAoaW5kZXhCeUlkZW50aWZpZXIgIT09IC0xKSB7XG4gICAgICBzdHlsZXNJbkRPTVtpbmRleEJ5SWRlbnRpZmllcl0ucmVmZXJlbmNlcysrO1xuICAgICAgc3R5bGVzSW5ET01baW5kZXhCeUlkZW50aWZpZXJdLnVwZGF0ZXIob2JqKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHVwZGF0ZXIgPSBhZGRFbGVtZW50U3R5bGUob2JqLCBvcHRpb25zKTtcbiAgICAgIG9wdGlvbnMuYnlJbmRleCA9IGk7XG4gICAgICBzdHlsZXNJbkRPTS5zcGxpY2UoaSwgMCwge1xuICAgICAgICBpZGVudGlmaWVyOiBpZGVudGlmaWVyLFxuICAgICAgICB1cGRhdGVyOiB1cGRhdGVyLFxuICAgICAgICByZWZlcmVuY2VzOiAxXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZGVudGlmaWVycy5wdXNoKGlkZW50aWZpZXIpO1xuICB9XG5cbiAgcmV0dXJuIGlkZW50aWZpZXJzO1xufVxuXG5mdW5jdGlvbiBhZGRFbGVtZW50U3R5bGUob2JqLCBvcHRpb25zKSB7XG4gIHZhciBhcGkgPSBvcHRpb25zLmRvbUFQSShvcHRpb25zKTtcbiAgYXBpLnVwZGF0ZShvYmopO1xuXG4gIHZhciB1cGRhdGVyID0gZnVuY3Rpb24gdXBkYXRlcihuZXdPYmopIHtcbiAgICBpZiAobmV3T2JqKSB7XG4gICAgICBpZiAobmV3T2JqLmNzcyA9PT0gb2JqLmNzcyAmJiBuZXdPYmoubWVkaWEgPT09IG9iai5tZWRpYSAmJiBuZXdPYmouc291cmNlTWFwID09PSBvYmouc291cmNlTWFwICYmIG5ld09iai5zdXBwb3J0cyA9PT0gb2JqLnN1cHBvcnRzICYmIG5ld09iai5sYXllciA9PT0gb2JqLmxheWVyKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgYXBpLnVwZGF0ZShvYmogPSBuZXdPYmopO1xuICAgIH0gZWxzZSB7XG4gICAgICBhcGkucmVtb3ZlKCk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiB1cGRhdGVyO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChsaXN0LCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBsaXN0ID0gbGlzdCB8fCBbXTtcbiAgdmFyIGxhc3RJZGVudGlmaWVycyA9IG1vZHVsZXNUb0RvbShsaXN0LCBvcHRpb25zKTtcbiAgcmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZShuZXdMaXN0KSB7XG4gICAgbmV3TGlzdCA9IG5ld0xpc3QgfHwgW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxhc3RJZGVudGlmaWVycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGlkZW50aWZpZXIgPSBsYXN0SWRlbnRpZmllcnNbaV07XG4gICAgICB2YXIgaW5kZXggPSBnZXRJbmRleEJ5SWRlbnRpZmllcihpZGVudGlmaWVyKTtcbiAgICAgIHN0eWxlc0luRE9NW2luZGV4XS5yZWZlcmVuY2VzLS07XG4gICAgfVxuXG4gICAgdmFyIG5ld0xhc3RJZGVudGlmaWVycyA9IG1vZHVsZXNUb0RvbShuZXdMaXN0LCBvcHRpb25zKTtcblxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBsYXN0SWRlbnRpZmllcnMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICB2YXIgX2lkZW50aWZpZXIgPSBsYXN0SWRlbnRpZmllcnNbX2ldO1xuXG4gICAgICB2YXIgX2luZGV4ID0gZ2V0SW5kZXhCeUlkZW50aWZpZXIoX2lkZW50aWZpZXIpO1xuXG4gICAgICBpZiAoc3R5bGVzSW5ET01bX2luZGV4XS5yZWZlcmVuY2VzID09PSAwKSB7XG4gICAgICAgIHN0eWxlc0luRE9NW19pbmRleF0udXBkYXRlcigpO1xuXG4gICAgICAgIHN0eWxlc0luRE9NLnNwbGljZShfaW5kZXgsIDEpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGxhc3RJZGVudGlmaWVycyA9IG5ld0xhc3RJZGVudGlmaWVycztcbiAgfTtcbn07IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBtZW1vID0ge307XG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAgKi9cblxuZnVuY3Rpb24gZ2V0VGFyZ2V0KHRhcmdldCkge1xuICBpZiAodHlwZW9mIG1lbW9bdGFyZ2V0XSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHZhciBzdHlsZVRhcmdldCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IodGFyZ2V0KTsgLy8gU3BlY2lhbCBjYXNlIHRvIHJldHVybiBoZWFkIG9mIGlmcmFtZSBpbnN0ZWFkIG9mIGlmcmFtZSBpdHNlbGZcblxuICAgIGlmICh3aW5kb3cuSFRNTElGcmFtZUVsZW1lbnQgJiYgc3R5bGVUYXJnZXQgaW5zdGFuY2VvZiB3aW5kb3cuSFRNTElGcmFtZUVsZW1lbnQpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIFRoaXMgd2lsbCB0aHJvdyBhbiBleGNlcHRpb24gaWYgYWNjZXNzIHRvIGlmcmFtZSBpcyBibG9ja2VkXG4gICAgICAgIC8vIGR1ZSB0byBjcm9zcy1vcmlnaW4gcmVzdHJpY3Rpb25zXG4gICAgICAgIHN0eWxlVGFyZ2V0ID0gc3R5bGVUYXJnZXQuY29udGVudERvY3VtZW50LmhlYWQ7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0XG4gICAgICAgIHN0eWxlVGFyZ2V0ID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBtZW1vW3RhcmdldF0gPSBzdHlsZVRhcmdldDtcbiAgfVxuXG4gIHJldHVybiBtZW1vW3RhcmdldF07XG59XG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAgKi9cblxuXG5mdW5jdGlvbiBpbnNlcnRCeVNlbGVjdG9yKGluc2VydCwgc3R5bGUpIHtcbiAgdmFyIHRhcmdldCA9IGdldFRhcmdldChpbnNlcnQpO1xuXG4gIGlmICghdGFyZ2V0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGRuJ3QgZmluZCBhIHN0eWxlIHRhcmdldC4gVGhpcyBwcm9iYWJseSBtZWFucyB0aGF0IHRoZSB2YWx1ZSBmb3IgdGhlICdpbnNlcnQnIHBhcmFtZXRlciBpcyBpbnZhbGlkLlwiKTtcbiAgfVxuXG4gIHRhcmdldC5hcHBlbmRDaGlsZChzdHlsZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaW5zZXJ0QnlTZWxlY3RvcjsiLCJcInVzZSBzdHJpY3RcIjtcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgICovXG5mdW5jdGlvbiBpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucykge1xuICB2YXIgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTtcbiAgb3B0aW9ucy5zZXRBdHRyaWJ1dGVzKGVsZW1lbnQsIG9wdGlvbnMuYXR0cmlidXRlcyk7XG4gIG9wdGlvbnMuaW5zZXJ0KGVsZW1lbnQsIG9wdGlvbnMub3B0aW9ucyk7XG4gIHJldHVybiBlbGVtZW50O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGluc2VydFN0eWxlRWxlbWVudDsiLCJcInVzZSBzdHJpY3RcIjtcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgICovXG5mdW5jdGlvbiBzZXRBdHRyaWJ1dGVzV2l0aG91dEF0dHJpYnV0ZXMoc3R5bGVFbGVtZW50KSB7XG4gIHZhciBub25jZSA9IHR5cGVvZiBfX3dlYnBhY2tfbm9uY2VfXyAhPT0gXCJ1bmRlZmluZWRcIiA/IF9fd2VicGFja19ub25jZV9fIDogbnVsbDtcblxuICBpZiAobm9uY2UpIHtcbiAgICBzdHlsZUVsZW1lbnQuc2V0QXR0cmlidXRlKFwibm9uY2VcIiwgbm9uY2UpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2V0QXR0cmlidXRlc1dpdGhvdXRBdHRyaWJ1dGVzOyIsIlwidXNlIHN0cmljdFwiO1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAgKi9cbmZ1bmN0aW9uIGFwcGx5KHN0eWxlRWxlbWVudCwgb3B0aW9ucywgb2JqKSB7XG4gIHZhciBjc3MgPSBcIlwiO1xuXG4gIGlmIChvYmouc3VwcG9ydHMpIHtcbiAgICBjc3MgKz0gXCJAc3VwcG9ydHMgKFwiLmNvbmNhdChvYmouc3VwcG9ydHMsIFwiKSB7XCIpO1xuICB9XG5cbiAgaWYgKG9iai5tZWRpYSkge1xuICAgIGNzcyArPSBcIkBtZWRpYSBcIi5jb25jYXQob2JqLm1lZGlhLCBcIiB7XCIpO1xuICB9XG5cbiAgdmFyIG5lZWRMYXllciA9IHR5cGVvZiBvYmoubGF5ZXIgIT09IFwidW5kZWZpbmVkXCI7XG5cbiAgaWYgKG5lZWRMYXllcikge1xuICAgIGNzcyArPSBcIkBsYXllclwiLmNvbmNhdChvYmoubGF5ZXIubGVuZ3RoID4gMCA/IFwiIFwiLmNvbmNhdChvYmoubGF5ZXIpIDogXCJcIiwgXCIge1wiKTtcbiAgfVxuXG4gIGNzcyArPSBvYmouY3NzO1xuXG4gIGlmIChuZWVkTGF5ZXIpIHtcbiAgICBjc3MgKz0gXCJ9XCI7XG4gIH1cblxuICBpZiAob2JqLm1lZGlhKSB7XG4gICAgY3NzICs9IFwifVwiO1xuICB9XG5cbiAgaWYgKG9iai5zdXBwb3J0cykge1xuICAgIGNzcyArPSBcIn1cIjtcbiAgfVxuXG4gIHZhciBzb3VyY2VNYXAgPSBvYmouc291cmNlTWFwO1xuXG4gIGlmIChzb3VyY2VNYXAgJiYgdHlwZW9mIGJ0b2EgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICBjc3MgKz0gXCJcXG4vKiMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LFwiLmNvbmNhdChidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpLCBcIiAqL1wiKTtcbiAgfSAvLyBGb3Igb2xkIElFXG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICAqL1xuXG5cbiAgb3B0aW9ucy5zdHlsZVRhZ1RyYW5zZm9ybShjc3MsIHN0eWxlRWxlbWVudCwgb3B0aW9ucy5vcHRpb25zKTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlRWxlbWVudCkge1xuICAvLyBpc3RhbmJ1bCBpZ25vcmUgaWZcbiAgaWYgKHN0eWxlRWxlbWVudC5wYXJlbnROb2RlID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgc3R5bGVFbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc3R5bGVFbGVtZW50KTtcbn1cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICAqL1xuXG5cbmZ1bmN0aW9uIGRvbUFQSShvcHRpb25zKSB7XG4gIHZhciBzdHlsZUVsZW1lbnQgPSBvcHRpb25zLmluc2VydFN0eWxlRWxlbWVudChvcHRpb25zKTtcbiAgcmV0dXJuIHtcbiAgICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZShvYmopIHtcbiAgICAgIGFwcGx5KHN0eWxlRWxlbWVudCwgb3B0aW9ucywgb2JqKTtcbiAgICB9LFxuICAgIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKCkge1xuICAgICAgcmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlRWxlbWVudCk7XG4gICAgfVxuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGRvbUFQSTsiLCJcInVzZSBzdHJpY3RcIjtcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgICovXG5mdW5jdGlvbiBzdHlsZVRhZ1RyYW5zZm9ybShjc3MsIHN0eWxlRWxlbWVudCkge1xuICBpZiAoc3R5bGVFbGVtZW50LnN0eWxlU2hlZXQpIHtcbiAgICBzdHlsZUVsZW1lbnQuc3R5bGVTaGVldC5jc3NUZXh0ID0gY3NzO1xuICB9IGVsc2Uge1xuICAgIHdoaWxlIChzdHlsZUVsZW1lbnQuZmlyc3RDaGlsZCkge1xuICAgICAgc3R5bGVFbGVtZW50LnJlbW92ZUNoaWxkKHN0eWxlRWxlbWVudC5maXJzdENoaWxkKTtcbiAgICB9XG5cbiAgICBzdHlsZUVsZW1lbnQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdHlsZVRhZ1RyYW5zZm9ybTsiLCIvKiFcbiAqIFxuICogICB0eXBlZC5qcyAtIEEgSmF2YVNjcmlwdCBUeXBpbmcgQW5pbWF0aW9uIExpYnJhcnlcbiAqICAgQXV0aG9yOiBNYXR0IEJvbGR0IDxtZUBtYXR0Ym9sZHQuY29tPlxuICogICBWZXJzaW9uOiB2Mi4wLjEyXG4gKiAgIFVybDogaHR0cHM6Ly9naXRodWIuY29tL21hdHRib2xkdC90eXBlZC5qc1xuICogICBMaWNlbnNlKHMpOiBNSVRcbiAqIFxuICovXG4oZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShbXSwgZmFjdG9yeSk7XG5cdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxuXHRcdGV4cG9ydHNbXCJUeXBlZFwiXSA9IGZhY3RvcnkoKTtcblx0ZWxzZVxuXHRcdHJvb3RbXCJUeXBlZFwiXSA9IGZhY3RvcnkoKTtcbn0pKHRoaXMsIGZ1bmN0aW9uKCkge1xucmV0dXJuIC8qKioqKiovIChmdW5jdGlvbihtb2R1bGVzKSB7IC8vIHdlYnBhY2tCb290c3RyYXBcbi8qKioqKiovIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbi8qKioqKiovIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbi8qKioqKiovIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSlcbi8qKioqKiovIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuLyoqKioqKi8gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbi8qKioqKiovIFx0XHRcdGV4cG9ydHM6IHt9LFxuLyoqKioqKi8gXHRcdFx0aWQ6IG1vZHVsZUlkLFxuLyoqKioqKi8gXHRcdFx0bG9hZGVkOiBmYWxzZVxuLyoqKioqKi8gXHRcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuLyoqKioqKi8gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4vKioqKioqLyBcdFx0bW9kdWxlLmxvYWRlZCA9IHRydWU7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4vKioqKioqLyBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHR9XG4vKioqKioqL1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4vKioqKioqLyBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuLyoqKioqKi8gfSlcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyAoW1xuLyogMCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdCd1c2Ugc3RyaWN0Jztcblx0XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHtcblx0ICB2YWx1ZTogdHJ1ZVxuXHR9KTtcblx0XG5cdHZhciBfY3JlYXRlQ2xhc3MgPSAoZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKCd2YWx1ZScgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0pKCk7XG5cdFxuXHRmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvbicpOyB9IH1cblx0XG5cdHZhciBfaW5pdGlhbGl6ZXJKcyA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cdFxuXHR2YXIgX2h0bWxQYXJzZXJKcyA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG5cdFxuXHQvKipcblx0ICogV2VsY29tZSB0byBUeXBlZC5qcyFcblx0ICogQHBhcmFtIHtzdHJpbmd9IGVsZW1lbnRJZCBIVE1MIGVsZW1lbnQgSUQgX09SXyBIVE1MIGVsZW1lbnRcblx0ICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgb3B0aW9ucyBvYmplY3Rcblx0ICogQHJldHVybnMge29iamVjdH0gYSBuZXcgVHlwZWQgb2JqZWN0XG5cdCAqL1xuXHRcblx0dmFyIFR5cGVkID0gKGZ1bmN0aW9uICgpIHtcblx0ICBmdW5jdGlvbiBUeXBlZChlbGVtZW50SWQsIG9wdGlvbnMpIHtcblx0ICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBUeXBlZCk7XG5cdFxuXHQgICAgLy8gSW5pdGlhbGl6ZSBpdCB1cFxuXHQgICAgX2luaXRpYWxpemVySnMuaW5pdGlhbGl6ZXIubG9hZCh0aGlzLCBvcHRpb25zLCBlbGVtZW50SWQpO1xuXHQgICAgLy8gQWxsIHN5c3RlbXMgZ28hXG5cdCAgICB0aGlzLmJlZ2luKCk7XG5cdCAgfVxuXHRcblx0ICAvKipcblx0ICAgKiBUb2dnbGUgc3RhcnQoKSBhbmQgc3RvcCgpIG9mIHRoZSBUeXBlZCBpbnN0YW5jZVxuXHQgICAqIEBwdWJsaWNcblx0ICAgKi9cblx0XG5cdCAgX2NyZWF0ZUNsYXNzKFR5cGVkLCBbe1xuXHQgICAga2V5OiAndG9nZ2xlJyxcblx0ICAgIHZhbHVlOiBmdW5jdGlvbiB0b2dnbGUoKSB7XG5cdCAgICAgIHRoaXMucGF1c2Uuc3RhdHVzID8gdGhpcy5zdGFydCgpIDogdGhpcy5zdG9wKCk7XG5cdCAgICB9XG5cdFxuXHQgICAgLyoqXG5cdCAgICAgKiBTdG9wIHR5cGluZyAvIGJhY2tzcGFjaW5nIGFuZCBlbmFibGUgY3Vyc29yIGJsaW5raW5nXG5cdCAgICAgKiBAcHVibGljXG5cdCAgICAgKi9cblx0ICB9LCB7XG5cdCAgICBrZXk6ICdzdG9wJyxcblx0ICAgIHZhbHVlOiBmdW5jdGlvbiBzdG9wKCkge1xuXHQgICAgICBpZiAodGhpcy50eXBpbmdDb21wbGV0ZSkgcmV0dXJuO1xuXHQgICAgICBpZiAodGhpcy5wYXVzZS5zdGF0dXMpIHJldHVybjtcblx0ICAgICAgdGhpcy50b2dnbGVCbGlua2luZyh0cnVlKTtcblx0ICAgICAgdGhpcy5wYXVzZS5zdGF0dXMgPSB0cnVlO1xuXHQgICAgICB0aGlzLm9wdGlvbnMub25TdG9wKHRoaXMuYXJyYXlQb3MsIHRoaXMpO1xuXHQgICAgfVxuXHRcblx0ICAgIC8qKlxuXHQgICAgICogU3RhcnQgdHlwaW5nIC8gYmFja3NwYWNpbmcgYWZ0ZXIgYmVpbmcgc3RvcHBlZFxuXHQgICAgICogQHB1YmxpY1xuXHQgICAgICovXG5cdCAgfSwge1xuXHQgICAga2V5OiAnc3RhcnQnLFxuXHQgICAgdmFsdWU6IGZ1bmN0aW9uIHN0YXJ0KCkge1xuXHQgICAgICBpZiAodGhpcy50eXBpbmdDb21wbGV0ZSkgcmV0dXJuO1xuXHQgICAgICBpZiAoIXRoaXMucGF1c2Uuc3RhdHVzKSByZXR1cm47XG5cdCAgICAgIHRoaXMucGF1c2Uuc3RhdHVzID0gZmFsc2U7XG5cdCAgICAgIGlmICh0aGlzLnBhdXNlLnR5cGV3cml0ZSkge1xuXHQgICAgICAgIHRoaXMudHlwZXdyaXRlKHRoaXMucGF1c2UuY3VyU3RyaW5nLCB0aGlzLnBhdXNlLmN1clN0clBvcyk7XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgdGhpcy5iYWNrc3BhY2UodGhpcy5wYXVzZS5jdXJTdHJpbmcsIHRoaXMucGF1c2UuY3VyU3RyUG9zKTtcblx0ICAgICAgfVxuXHQgICAgICB0aGlzLm9wdGlvbnMub25TdGFydCh0aGlzLmFycmF5UG9zLCB0aGlzKTtcblx0ICAgIH1cblx0XG5cdCAgICAvKipcblx0ICAgICAqIERlc3Ryb3kgdGhpcyBpbnN0YW5jZSBvZiBUeXBlZFxuXHQgICAgICogQHB1YmxpY1xuXHQgICAgICovXG5cdCAgfSwge1xuXHQgICAga2V5OiAnZGVzdHJveScsXG5cdCAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJveSgpIHtcblx0ICAgICAgdGhpcy5yZXNldChmYWxzZSk7XG5cdCAgICAgIHRoaXMub3B0aW9ucy5vbkRlc3Ryb3kodGhpcyk7XG5cdCAgICB9XG5cdFxuXHQgICAgLyoqXG5cdCAgICAgKiBSZXNldCBUeXBlZCBhbmQgb3B0aW9uYWxseSByZXN0YXJ0c1xuXHQgICAgICogQHBhcmFtIHtib29sZWFufSByZXN0YXJ0XG5cdCAgICAgKiBAcHVibGljXG5cdCAgICAgKi9cblx0ICB9LCB7XG5cdCAgICBrZXk6ICdyZXNldCcsXG5cdCAgICB2YWx1ZTogZnVuY3Rpb24gcmVzZXQoKSB7XG5cdCAgICAgIHZhciByZXN0YXJ0ID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwIHx8IGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IGFyZ3VtZW50c1swXTtcblx0XG5cdCAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy50aW1lb3V0KTtcblx0ICAgICAgdGhpcy5yZXBsYWNlVGV4dCgnJyk7XG5cdCAgICAgIGlmICh0aGlzLmN1cnNvciAmJiB0aGlzLmN1cnNvci5wYXJlbnROb2RlKSB7XG5cdCAgICAgICAgdGhpcy5jdXJzb3IucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmN1cnNvcik7XG5cdCAgICAgICAgdGhpcy5jdXJzb3IgPSBudWxsO1xuXHQgICAgICB9XG5cdCAgICAgIHRoaXMuc3RyUG9zID0gMDtcblx0ICAgICAgdGhpcy5hcnJheVBvcyA9IDA7XG5cdCAgICAgIHRoaXMuY3VyTG9vcCA9IDA7XG5cdCAgICAgIGlmIChyZXN0YXJ0KSB7XG5cdCAgICAgICAgdGhpcy5pbnNlcnRDdXJzb3IoKTtcblx0ICAgICAgICB0aGlzLm9wdGlvbnMub25SZXNldCh0aGlzKTtcblx0ICAgICAgICB0aGlzLmJlZ2luKCk7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0XG5cdCAgICAvKipcblx0ICAgICAqIEJlZ2lucyB0aGUgdHlwaW5nIGFuaW1hdGlvblxuXHQgICAgICogQHByaXZhdGVcblx0ICAgICAqL1xuXHQgIH0sIHtcblx0ICAgIGtleTogJ2JlZ2luJyxcblx0ICAgIHZhbHVlOiBmdW5jdGlvbiBiZWdpbigpIHtcblx0ICAgICAgdmFyIF90aGlzID0gdGhpcztcblx0XG5cdCAgICAgIHRoaXMub3B0aW9ucy5vbkJlZ2luKHRoaXMpO1xuXHQgICAgICB0aGlzLnR5cGluZ0NvbXBsZXRlID0gZmFsc2U7XG5cdCAgICAgIHRoaXMuc2h1ZmZsZVN0cmluZ3NJZk5lZWRlZCh0aGlzKTtcblx0ICAgICAgdGhpcy5pbnNlcnRDdXJzb3IoKTtcblx0ICAgICAgaWYgKHRoaXMuYmluZElucHV0Rm9jdXNFdmVudHMpIHRoaXMuYmluZEZvY3VzRXZlbnRzKCk7XG5cdCAgICAgIHRoaXMudGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIC8vIENoZWNrIGlmIHRoZXJlIGlzIHNvbWUgdGV4dCBpbiB0aGUgZWxlbWVudCwgaWYgeWVzIHN0YXJ0IGJ5IGJhY2tzcGFjaW5nIHRoZSBkZWZhdWx0IG1lc3NhZ2Vcblx0ICAgICAgICBpZiAoIV90aGlzLmN1cnJlbnRFbENvbnRlbnQgfHwgX3RoaXMuY3VycmVudEVsQ29udGVudC5sZW5ndGggPT09IDApIHtcblx0ICAgICAgICAgIF90aGlzLnR5cGV3cml0ZShfdGhpcy5zdHJpbmdzW190aGlzLnNlcXVlbmNlW190aGlzLmFycmF5UG9zXV0sIF90aGlzLnN0clBvcyk7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgIC8vIFN0YXJ0IHR5cGluZ1xuXHQgICAgICAgICAgX3RoaXMuYmFja3NwYWNlKF90aGlzLmN1cnJlbnRFbENvbnRlbnQsIF90aGlzLmN1cnJlbnRFbENvbnRlbnQubGVuZ3RoKTtcblx0ICAgICAgICB9XG5cdCAgICAgIH0sIHRoaXMuc3RhcnREZWxheSk7XG5cdCAgICB9XG5cdFxuXHQgICAgLyoqXG5cdCAgICAgKiBDYWxsZWQgZm9yIGVhY2ggY2hhcmFjdGVyIHR5cGVkXG5cdCAgICAgKiBAcGFyYW0ge3N0cmluZ30gY3VyU3RyaW5nIHRoZSBjdXJyZW50IHN0cmluZyBpbiB0aGUgc3RyaW5ncyBhcnJheVxuXHQgICAgICogQHBhcmFtIHtudW1iZXJ9IGN1clN0clBvcyB0aGUgY3VycmVudCBwb3NpdGlvbiBpbiB0aGUgY3VyU3RyaW5nXG5cdCAgICAgKiBAcHJpdmF0ZVxuXHQgICAgICovXG5cdCAgfSwge1xuXHQgICAga2V5OiAndHlwZXdyaXRlJyxcblx0ICAgIHZhbHVlOiBmdW5jdGlvbiB0eXBld3JpdGUoY3VyU3RyaW5nLCBjdXJTdHJQb3MpIHtcblx0ICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cdFxuXHQgICAgICBpZiAodGhpcy5mYWRlT3V0ICYmIHRoaXMuZWwuY2xhc3NMaXN0LmNvbnRhaW5zKHRoaXMuZmFkZU91dENsYXNzKSkge1xuXHQgICAgICAgIHRoaXMuZWwuY2xhc3NMaXN0LnJlbW92ZSh0aGlzLmZhZGVPdXRDbGFzcyk7XG5cdCAgICAgICAgaWYgKHRoaXMuY3Vyc29yKSB0aGlzLmN1cnNvci5jbGFzc0xpc3QucmVtb3ZlKHRoaXMuZmFkZU91dENsYXNzKTtcblx0ICAgICAgfVxuXHRcblx0ICAgICAgdmFyIGh1bWFuaXplID0gdGhpcy5odW1hbml6ZXIodGhpcy50eXBlU3BlZWQpO1xuXHQgICAgICB2YXIgbnVtQ2hhcnMgPSAxO1xuXHRcblx0ICAgICAgaWYgKHRoaXMucGF1c2Uuc3RhdHVzID09PSB0cnVlKSB7XG5cdCAgICAgICAgdGhpcy5zZXRQYXVzZVN0YXR1cyhjdXJTdHJpbmcsIGN1clN0clBvcywgdHJ1ZSk7XG5cdCAgICAgICAgcmV0dXJuO1xuXHQgICAgICB9XG5cdFxuXHQgICAgICAvLyBjb250YWluIHR5cGluZyBmdW5jdGlvbiBpbiBhIHRpbWVvdXQgaHVtYW5pemUnZCBkZWxheVxuXHQgICAgICB0aGlzLnRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAvLyBza2lwIG92ZXIgYW55IEhUTUwgY2hhcnNcblx0ICAgICAgICBjdXJTdHJQb3MgPSBfaHRtbFBhcnNlckpzLmh0bWxQYXJzZXIudHlwZUh0bWxDaGFycyhjdXJTdHJpbmcsIGN1clN0clBvcywgX3RoaXMyKTtcblx0XG5cdCAgICAgICAgdmFyIHBhdXNlVGltZSA9IDA7XG5cdCAgICAgICAgdmFyIHN1YnN0ciA9IGN1clN0cmluZy5zdWJzdHIoY3VyU3RyUG9zKTtcblx0ICAgICAgICAvLyBjaGVjayBmb3IgYW4gZXNjYXBlIGNoYXJhY3RlciBiZWZvcmUgYSBwYXVzZSB2YWx1ZVxuXHQgICAgICAgIC8vIGZvcm1hdDogXFxeXFxkKyAuLiBlZzogXjEwMDAgLi4gc2hvdWxkIGJlIGFibGUgdG8gcHJpbnQgdGhlIF4gdG9vIHVzaW5nIF5eXG5cdCAgICAgICAgLy8gc2luZ2xlIF4gYXJlIHJlbW92ZWQgZnJvbSBzdHJpbmdcblx0ICAgICAgICBpZiAoc3Vic3RyLmNoYXJBdCgwKSA9PT0gJ14nKSB7XG5cdCAgICAgICAgICBpZiAoL15cXF5cXGQrLy50ZXN0KHN1YnN0cikpIHtcblx0ICAgICAgICAgICAgdmFyIHNraXAgPSAxOyAvLyBza2lwIGF0IGxlYXN0IDFcblx0ICAgICAgICAgICAgc3Vic3RyID0gL1xcZCsvLmV4ZWMoc3Vic3RyKVswXTtcblx0ICAgICAgICAgICAgc2tpcCArPSBzdWJzdHIubGVuZ3RoO1xuXHQgICAgICAgICAgICBwYXVzZVRpbWUgPSBwYXJzZUludChzdWJzdHIpO1xuXHQgICAgICAgICAgICBfdGhpczIudGVtcG9yYXJ5UGF1c2UgPSB0cnVlO1xuXHQgICAgICAgICAgICBfdGhpczIub3B0aW9ucy5vblR5cGluZ1BhdXNlZChfdGhpczIuYXJyYXlQb3MsIF90aGlzMik7XG5cdCAgICAgICAgICAgIC8vIHN0cmlwIG91dCB0aGUgZXNjYXBlIGNoYXJhY3RlciBhbmQgcGF1c2UgdmFsdWUgc28gdGhleSdyZSBub3QgcHJpbnRlZFxuXHQgICAgICAgICAgICBjdXJTdHJpbmcgPSBjdXJTdHJpbmcuc3Vic3RyaW5nKDAsIGN1clN0clBvcykgKyBjdXJTdHJpbmcuc3Vic3RyaW5nKGN1clN0clBvcyArIHNraXApO1xuXHQgICAgICAgICAgICBfdGhpczIudG9nZ2xlQmxpbmtpbmcodHJ1ZSk7XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHRcblx0ICAgICAgICAvLyBjaGVjayBmb3Igc2tpcCBjaGFyYWN0ZXJzIGZvcm1hdHRlZCBhc1xuXHQgICAgICAgIC8vIFwidGhpcyBpcyBhIGBzdHJpbmcgdG8gcHJpbnQgTk9XYCAuLi5cIlxuXHQgICAgICAgIGlmIChzdWJzdHIuY2hhckF0KDApID09PSAnYCcpIHtcblx0ICAgICAgICAgIHdoaWxlIChjdXJTdHJpbmcuc3Vic3RyKGN1clN0clBvcyArIG51bUNoYXJzKS5jaGFyQXQoMCkgIT09ICdgJykge1xuXHQgICAgICAgICAgICBudW1DaGFycysrO1xuXHQgICAgICAgICAgICBpZiAoY3VyU3RyUG9zICsgbnVtQ2hhcnMgPiBjdXJTdHJpbmcubGVuZ3RoKSBicmVhaztcblx0ICAgICAgICAgIH1cblx0ICAgICAgICAgIC8vIHN0cmlwIG91dCB0aGUgZXNjYXBlIGNoYXJhY3RlcnMgYW5kIGFwcGVuZCBhbGwgdGhlIHN0cmluZyBpbiBiZXR3ZWVuXG5cdCAgICAgICAgICB2YXIgc3RyaW5nQmVmb3JlU2tpcCA9IGN1clN0cmluZy5zdWJzdHJpbmcoMCwgY3VyU3RyUG9zKTtcblx0ICAgICAgICAgIHZhciBzdHJpbmdTa2lwcGVkID0gY3VyU3RyaW5nLnN1YnN0cmluZyhzdHJpbmdCZWZvcmVTa2lwLmxlbmd0aCArIDEsIGN1clN0clBvcyArIG51bUNoYXJzKTtcblx0ICAgICAgICAgIHZhciBzdHJpbmdBZnRlclNraXAgPSBjdXJTdHJpbmcuc3Vic3RyaW5nKGN1clN0clBvcyArIG51bUNoYXJzICsgMSk7XG5cdCAgICAgICAgICBjdXJTdHJpbmcgPSBzdHJpbmdCZWZvcmVTa2lwICsgc3RyaW5nU2tpcHBlZCArIHN0cmluZ0FmdGVyU2tpcDtcblx0ICAgICAgICAgIG51bUNoYXJzLS07XG5cdCAgICAgICAgfVxuXHRcblx0ICAgICAgICAvLyB0aW1lb3V0IGZvciBhbnkgcGF1c2UgYWZ0ZXIgYSBjaGFyYWN0ZXJcblx0ICAgICAgICBfdGhpczIudGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgLy8gQWNjb3VudHMgZm9yIGJsaW5raW5nIHdoaWxlIHBhdXNlZFxuXHQgICAgICAgICAgX3RoaXMyLnRvZ2dsZUJsaW5raW5nKGZhbHNlKTtcblx0XG5cdCAgICAgICAgICAvLyBXZSdyZSBkb25lIHdpdGggdGhpcyBzZW50ZW5jZSFcblx0ICAgICAgICAgIGlmIChjdXJTdHJQb3MgPj0gY3VyU3RyaW5nLmxlbmd0aCkge1xuXHQgICAgICAgICAgICBfdGhpczIuZG9uZVR5cGluZyhjdXJTdHJpbmcsIGN1clN0clBvcyk7XG5cdCAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICBfdGhpczIua2VlcFR5cGluZyhjdXJTdHJpbmcsIGN1clN0clBvcywgbnVtQ2hhcnMpO1xuXHQgICAgICAgICAgfVxuXHQgICAgICAgICAgLy8gZW5kIG9mIGNoYXJhY3RlciBwYXVzZVxuXHQgICAgICAgICAgaWYgKF90aGlzMi50ZW1wb3JhcnlQYXVzZSkge1xuXHQgICAgICAgICAgICBfdGhpczIudGVtcG9yYXJ5UGF1c2UgPSBmYWxzZTtcblx0ICAgICAgICAgICAgX3RoaXMyLm9wdGlvbnMub25UeXBpbmdSZXN1bWVkKF90aGlzMi5hcnJheVBvcywgX3RoaXMyKTtcblx0ICAgICAgICAgIH1cblx0ICAgICAgICB9LCBwYXVzZVRpbWUpO1xuXHRcblx0ICAgICAgICAvLyBodW1hbml6ZWQgdmFsdWUgZm9yIHR5cGluZ1xuXHQgICAgICB9LCBodW1hbml6ZSk7XG5cdCAgICB9XG5cdFxuXHQgICAgLyoqXG5cdCAgICAgKiBDb250aW51ZSB0byB0aGUgbmV4dCBzdHJpbmcgJiBiZWdpbiB0eXBpbmdcblx0ICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjdXJTdHJpbmcgdGhlIGN1cnJlbnQgc3RyaW5nIGluIHRoZSBzdHJpbmdzIGFycmF5XG5cdCAgICAgKiBAcGFyYW0ge251bWJlcn0gY3VyU3RyUG9zIHRoZSBjdXJyZW50IHBvc2l0aW9uIGluIHRoZSBjdXJTdHJpbmdcblx0ICAgICAqIEBwcml2YXRlXG5cdCAgICAgKi9cblx0ICB9LCB7XG5cdCAgICBrZXk6ICdrZWVwVHlwaW5nJyxcblx0ICAgIHZhbHVlOiBmdW5jdGlvbiBrZWVwVHlwaW5nKGN1clN0cmluZywgY3VyU3RyUG9zLCBudW1DaGFycykge1xuXHQgICAgICAvLyBjYWxsIGJlZm9yZSBmdW5jdGlvbnMgaWYgYXBwbGljYWJsZVxuXHQgICAgICBpZiAoY3VyU3RyUG9zID09PSAwKSB7XG5cdCAgICAgICAgdGhpcy50b2dnbGVCbGlua2luZyhmYWxzZSk7XG5cdCAgICAgICAgdGhpcy5vcHRpb25zLnByZVN0cmluZ1R5cGVkKHRoaXMuYXJyYXlQb3MsIHRoaXMpO1xuXHQgICAgICB9XG5cdCAgICAgIC8vIHN0YXJ0IHR5cGluZyBlYWNoIG5ldyBjaGFyIGludG8gZXhpc3Rpbmcgc3RyaW5nXG5cdCAgICAgIC8vIGN1clN0cmluZzogYXJnLCB0aGlzLmVsLmh0bWw6IG9yaWdpbmFsIHRleHQgaW5zaWRlIGVsZW1lbnRcblx0ICAgICAgY3VyU3RyUG9zICs9IG51bUNoYXJzO1xuXHQgICAgICB2YXIgbmV4dFN0cmluZyA9IGN1clN0cmluZy5zdWJzdHIoMCwgY3VyU3RyUG9zKTtcblx0ICAgICAgdGhpcy5yZXBsYWNlVGV4dChuZXh0U3RyaW5nKTtcblx0ICAgICAgLy8gbG9vcCB0aGUgZnVuY3Rpb25cblx0ICAgICAgdGhpcy50eXBld3JpdGUoY3VyU3RyaW5nLCBjdXJTdHJQb3MpO1xuXHQgICAgfVxuXHRcblx0ICAgIC8qKlxuXHQgICAgICogV2UncmUgZG9uZSB0eXBpbmcgdGhlIGN1cnJlbnQgc3RyaW5nXG5cdCAgICAgKiBAcGFyYW0ge3N0cmluZ30gY3VyU3RyaW5nIHRoZSBjdXJyZW50IHN0cmluZyBpbiB0aGUgc3RyaW5ncyBhcnJheVxuXHQgICAgICogQHBhcmFtIHtudW1iZXJ9IGN1clN0clBvcyB0aGUgY3VycmVudCBwb3NpdGlvbiBpbiB0aGUgY3VyU3RyaW5nXG5cdCAgICAgKiBAcHJpdmF0ZVxuXHQgICAgICovXG5cdCAgfSwge1xuXHQgICAga2V5OiAnZG9uZVR5cGluZycsXG5cdCAgICB2YWx1ZTogZnVuY3Rpb24gZG9uZVR5cGluZyhjdXJTdHJpbmcsIGN1clN0clBvcykge1xuXHQgICAgICB2YXIgX3RoaXMzID0gdGhpcztcblx0XG5cdCAgICAgIC8vIGZpcmVzIGNhbGxiYWNrIGZ1bmN0aW9uXG5cdCAgICAgIHRoaXMub3B0aW9ucy5vblN0cmluZ1R5cGVkKHRoaXMuYXJyYXlQb3MsIHRoaXMpO1xuXHQgICAgICB0aGlzLnRvZ2dsZUJsaW5raW5nKHRydWUpO1xuXHQgICAgICAvLyBpcyB0aGlzIHRoZSBmaW5hbCBzdHJpbmdcblx0ICAgICAgaWYgKHRoaXMuYXJyYXlQb3MgPT09IHRoaXMuc3RyaW5ncy5sZW5ndGggLSAxKSB7XG5cdCAgICAgICAgLy8gY2FsbGJhY2sgdGhhdCBvY2N1cnMgb24gdGhlIGxhc3QgdHlwZWQgc3RyaW5nXG5cdCAgICAgICAgdGhpcy5jb21wbGV0ZSgpO1xuXHQgICAgICAgIC8vIHF1aXQgaWYgd2Ugd29udCBsb29wIGJhY2tcblx0ICAgICAgICBpZiAodGhpcy5sb29wID09PSBmYWxzZSB8fCB0aGlzLmN1ckxvb3AgPT09IHRoaXMubG9vcENvdW50KSB7XG5cdCAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICAgIHRoaXMudGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIF90aGlzMy5iYWNrc3BhY2UoY3VyU3RyaW5nLCBjdXJTdHJQb3MpO1xuXHQgICAgICB9LCB0aGlzLmJhY2tEZWxheSk7XG5cdCAgICB9XG5cdFxuXHQgICAgLyoqXG5cdCAgICAgKiBCYWNrc3BhY2VzIDEgY2hhcmFjdGVyIGF0IGEgdGltZVxuXHQgICAgICogQHBhcmFtIHtzdHJpbmd9IGN1clN0cmluZyB0aGUgY3VycmVudCBzdHJpbmcgaW4gdGhlIHN0cmluZ3MgYXJyYXlcblx0ICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjdXJTdHJQb3MgdGhlIGN1cnJlbnQgcG9zaXRpb24gaW4gdGhlIGN1clN0cmluZ1xuXHQgICAgICogQHByaXZhdGVcblx0ICAgICAqL1xuXHQgIH0sIHtcblx0ICAgIGtleTogJ2JhY2tzcGFjZScsXG5cdCAgICB2YWx1ZTogZnVuY3Rpb24gYmFja3NwYWNlKGN1clN0cmluZywgY3VyU3RyUG9zKSB7XG5cdCAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXHRcblx0ICAgICAgaWYgKHRoaXMucGF1c2Uuc3RhdHVzID09PSB0cnVlKSB7XG5cdCAgICAgICAgdGhpcy5zZXRQYXVzZVN0YXR1cyhjdXJTdHJpbmcsIGN1clN0clBvcywgZmFsc2UpO1xuXHQgICAgICAgIHJldHVybjtcblx0ICAgICAgfVxuXHQgICAgICBpZiAodGhpcy5mYWRlT3V0KSByZXR1cm4gdGhpcy5pbml0RmFkZU91dCgpO1xuXHRcblx0ICAgICAgdGhpcy50b2dnbGVCbGlua2luZyhmYWxzZSk7XG5cdCAgICAgIHZhciBodW1hbml6ZSA9IHRoaXMuaHVtYW5pemVyKHRoaXMuYmFja1NwZWVkKTtcblx0XG5cdCAgICAgIHRoaXMudGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIGN1clN0clBvcyA9IF9odG1sUGFyc2VySnMuaHRtbFBhcnNlci5iYWNrU3BhY2VIdG1sQ2hhcnMoY3VyU3RyaW5nLCBjdXJTdHJQb3MsIF90aGlzNCk7XG5cdCAgICAgICAgLy8gcmVwbGFjZSB0ZXh0IHdpdGggYmFzZSB0ZXh0ICsgdHlwZWQgY2hhcmFjdGVyc1xuXHQgICAgICAgIHZhciBjdXJTdHJpbmdBdFBvc2l0aW9uID0gY3VyU3RyaW5nLnN1YnN0cigwLCBjdXJTdHJQb3MpO1xuXHQgICAgICAgIF90aGlzNC5yZXBsYWNlVGV4dChjdXJTdHJpbmdBdFBvc2l0aW9uKTtcblx0XG5cdCAgICAgICAgLy8gaWYgc21hcnRCYWNrIGlzIGVuYWJsZWRcblx0ICAgICAgICBpZiAoX3RoaXM0LnNtYXJ0QmFja3NwYWNlKSB7XG5cdCAgICAgICAgICAvLyB0aGUgcmVtYWluaW5nIHBhcnQgb2YgdGhlIGN1cnJlbnQgc3RyaW5nIGlzIGVxdWFsIG9mIHRoZSBzYW1lIHBhcnQgb2YgdGhlIG5ldyBzdHJpbmdcblx0ICAgICAgICAgIHZhciBuZXh0U3RyaW5nID0gX3RoaXM0LnN0cmluZ3NbX3RoaXM0LmFycmF5UG9zICsgMV07XG5cdCAgICAgICAgICBpZiAobmV4dFN0cmluZyAmJiBjdXJTdHJpbmdBdFBvc2l0aW9uID09PSBuZXh0U3RyaW5nLnN1YnN0cigwLCBjdXJTdHJQb3MpKSB7XG5cdCAgICAgICAgICAgIF90aGlzNC5zdG9wTnVtID0gY3VyU3RyUG9zO1xuXHQgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgX3RoaXM0LnN0b3BOdW0gPSAwO1xuXHQgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0XG5cdCAgICAgICAgLy8gaWYgdGhlIG51bWJlciAoaWQgb2YgY2hhcmFjdGVyIGluIGN1cnJlbnQgc3RyaW5nKSBpc1xuXHQgICAgICAgIC8vIGxlc3MgdGhhbiB0aGUgc3RvcCBudW1iZXIsIGtlZXAgZ29pbmdcblx0ICAgICAgICBpZiAoY3VyU3RyUG9zID4gX3RoaXM0LnN0b3BOdW0pIHtcblx0ICAgICAgICAgIC8vIHN1YnRyYWN0IGNoYXJhY3RlcnMgb25lIGJ5IG9uZVxuXHQgICAgICAgICAgY3VyU3RyUG9zLS07XG5cdCAgICAgICAgICAvLyBsb29wIHRoZSBmdW5jdGlvblxuXHQgICAgICAgICAgX3RoaXM0LmJhY2tzcGFjZShjdXJTdHJpbmcsIGN1clN0clBvcyk7XG5cdCAgICAgICAgfSBlbHNlIGlmIChjdXJTdHJQb3MgPD0gX3RoaXM0LnN0b3BOdW0pIHtcblx0ICAgICAgICAgIC8vIGlmIHRoZSBzdG9wIG51bWJlciBoYXMgYmVlbiByZWFjaGVkLCBpbmNyZWFzZVxuXHQgICAgICAgICAgLy8gYXJyYXkgcG9zaXRpb24gdG8gbmV4dCBzdHJpbmdcblx0ICAgICAgICAgIF90aGlzNC5hcnJheVBvcysrO1xuXHQgICAgICAgICAgLy8gV2hlbiBsb29waW5nLCBiZWdpbiBhdCB0aGUgYmVnaW5uaW5nIGFmdGVyIGJhY2tzcGFjZSBjb21wbGV0ZVxuXHQgICAgICAgICAgaWYgKF90aGlzNC5hcnJheVBvcyA9PT0gX3RoaXM0LnN0cmluZ3MubGVuZ3RoKSB7XG5cdCAgICAgICAgICAgIF90aGlzNC5hcnJheVBvcyA9IDA7XG5cdCAgICAgICAgICAgIF90aGlzNC5vcHRpb25zLm9uTGFzdFN0cmluZ0JhY2tzcGFjZWQoKTtcblx0ICAgICAgICAgICAgX3RoaXM0LnNodWZmbGVTdHJpbmdzSWZOZWVkZWQoKTtcblx0ICAgICAgICAgICAgX3RoaXM0LmJlZ2luKCk7XG5cdCAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICBfdGhpczQudHlwZXdyaXRlKF90aGlzNC5zdHJpbmdzW190aGlzNC5zZXF1ZW5jZVtfdGhpczQuYXJyYXlQb3NdXSwgY3VyU3RyUG9zKTtcblx0ICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgLy8gaHVtYW5pemVkIHZhbHVlIGZvciB0eXBpbmdcblx0ICAgICAgfSwgaHVtYW5pemUpO1xuXHQgICAgfVxuXHRcblx0ICAgIC8qKlxuXHQgICAgICogRnVsbCBhbmltYXRpb24gaXMgY29tcGxldGVcblx0ICAgICAqIEBwcml2YXRlXG5cdCAgICAgKi9cblx0ICB9LCB7XG5cdCAgICBrZXk6ICdjb21wbGV0ZScsXG5cdCAgICB2YWx1ZTogZnVuY3Rpb24gY29tcGxldGUoKSB7XG5cdCAgICAgIHRoaXMub3B0aW9ucy5vbkNvbXBsZXRlKHRoaXMpO1xuXHQgICAgICBpZiAodGhpcy5sb29wKSB7XG5cdCAgICAgICAgdGhpcy5jdXJMb29wKys7XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgdGhpcy50eXBpbmdDb21wbGV0ZSA9IHRydWU7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0XG5cdCAgICAvKipcblx0ICAgICAqIEhhcyB0aGUgdHlwaW5nIGJlZW4gc3RvcHBlZFxuXHQgICAgICogQHBhcmFtIHtzdHJpbmd9IGN1clN0cmluZyB0aGUgY3VycmVudCBzdHJpbmcgaW4gdGhlIHN0cmluZ3MgYXJyYXlcblx0ICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjdXJTdHJQb3MgdGhlIGN1cnJlbnQgcG9zaXRpb24gaW4gdGhlIGN1clN0cmluZ1xuXHQgICAgICogQHBhcmFtIHtib29sZWFufSBpc1R5cGluZ1xuXHQgICAgICogQHByaXZhdGVcblx0ICAgICAqL1xuXHQgIH0sIHtcblx0ICAgIGtleTogJ3NldFBhdXNlU3RhdHVzJyxcblx0ICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRQYXVzZVN0YXR1cyhjdXJTdHJpbmcsIGN1clN0clBvcywgaXNUeXBpbmcpIHtcblx0ICAgICAgdGhpcy5wYXVzZS50eXBld3JpdGUgPSBpc1R5cGluZztcblx0ICAgICAgdGhpcy5wYXVzZS5jdXJTdHJpbmcgPSBjdXJTdHJpbmc7XG5cdCAgICAgIHRoaXMucGF1c2UuY3VyU3RyUG9zID0gY3VyU3RyUG9zO1xuXHQgICAgfVxuXHRcblx0ICAgIC8qKlxuXHQgICAgICogVG9nZ2xlIHRoZSBibGlua2luZyBjdXJzb3Jcblx0ICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNCbGlua2luZ1xuXHQgICAgICogQHByaXZhdGVcblx0ICAgICAqL1xuXHQgIH0sIHtcblx0ICAgIGtleTogJ3RvZ2dsZUJsaW5raW5nJyxcblx0ICAgIHZhbHVlOiBmdW5jdGlvbiB0b2dnbGVCbGlua2luZyhpc0JsaW5raW5nKSB7XG5cdCAgICAgIGlmICghdGhpcy5jdXJzb3IpIHJldHVybjtcblx0ICAgICAgLy8gaWYgaW4gcGF1c2VkIHN0YXRlLCBkb24ndCB0b2dnbGUgYmxpbmtpbmcgYSAybmQgdGltZVxuXHQgICAgICBpZiAodGhpcy5wYXVzZS5zdGF0dXMpIHJldHVybjtcblx0ICAgICAgaWYgKHRoaXMuY3Vyc29yQmxpbmtpbmcgPT09IGlzQmxpbmtpbmcpIHJldHVybjtcblx0ICAgICAgdGhpcy5jdXJzb3JCbGlua2luZyA9IGlzQmxpbmtpbmc7XG5cdCAgICAgIGlmIChpc0JsaW5raW5nKSB7XG5cdCAgICAgICAgdGhpcy5jdXJzb3IuY2xhc3NMaXN0LmFkZCgndHlwZWQtY3Vyc29yLS1ibGluaycpO1xuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIHRoaXMuY3Vyc29yLmNsYXNzTGlzdC5yZW1vdmUoJ3R5cGVkLWN1cnNvci0tYmxpbmsnKTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHRcblx0ICAgIC8qKlxuXHQgICAgICogU3BlZWQgaW4gTVMgdG8gdHlwZVxuXHQgICAgICogQHBhcmFtIHtudW1iZXJ9IHNwZWVkXG5cdCAgICAgKiBAcHJpdmF0ZVxuXHQgICAgICovXG5cdCAgfSwge1xuXHQgICAga2V5OiAnaHVtYW5pemVyJyxcblx0ICAgIHZhbHVlOiBmdW5jdGlvbiBodW1hbml6ZXIoc3BlZWQpIHtcblx0ICAgICAgcmV0dXJuIE1hdGgucm91bmQoTWF0aC5yYW5kb20oKSAqIHNwZWVkIC8gMikgKyBzcGVlZDtcblx0ICAgIH1cblx0XG5cdCAgICAvKipcblx0ICAgICAqIFNodWZmbGUgdGhlIHNlcXVlbmNlIG9mIHRoZSBzdHJpbmdzIGFycmF5XG5cdCAgICAgKiBAcHJpdmF0ZVxuXHQgICAgICovXG5cdCAgfSwge1xuXHQgICAga2V5OiAnc2h1ZmZsZVN0cmluZ3NJZk5lZWRlZCcsXG5cdCAgICB2YWx1ZTogZnVuY3Rpb24gc2h1ZmZsZVN0cmluZ3NJZk5lZWRlZCgpIHtcblx0ICAgICAgaWYgKCF0aGlzLnNodWZmbGUpIHJldHVybjtcblx0ICAgICAgdGhpcy5zZXF1ZW5jZSA9IHRoaXMuc2VxdWVuY2Uuc29ydChmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgcmV0dXJuIE1hdGgucmFuZG9tKCkgLSAwLjU7XG5cdCAgICAgIH0pO1xuXHQgICAgfVxuXHRcblx0ICAgIC8qKlxuXHQgICAgICogQWRkcyBhIENTUyBjbGFzcyB0byBmYWRlIG91dCBjdXJyZW50IHN0cmluZ1xuXHQgICAgICogQHByaXZhdGVcblx0ICAgICAqL1xuXHQgIH0sIHtcblx0ICAgIGtleTogJ2luaXRGYWRlT3V0Jyxcblx0ICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0RmFkZU91dCgpIHtcblx0ICAgICAgdmFyIF90aGlzNSA9IHRoaXM7XG5cdFxuXHQgICAgICB0aGlzLmVsLmNsYXNzTmFtZSArPSAnICcgKyB0aGlzLmZhZGVPdXRDbGFzcztcblx0ICAgICAgaWYgKHRoaXMuY3Vyc29yKSB0aGlzLmN1cnNvci5jbGFzc05hbWUgKz0gJyAnICsgdGhpcy5mYWRlT3V0Q2xhc3M7XG5cdCAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBfdGhpczUuYXJyYXlQb3MrKztcblx0ICAgICAgICBfdGhpczUucmVwbGFjZVRleHQoJycpO1xuXHRcblx0ICAgICAgICAvLyBSZXNldHMgY3VycmVudCBzdHJpbmcgaWYgZW5kIG9mIGxvb3AgcmVhY2hlZFxuXHQgICAgICAgIGlmIChfdGhpczUuc3RyaW5ncy5sZW5ndGggPiBfdGhpczUuYXJyYXlQb3MpIHtcblx0ICAgICAgICAgIF90aGlzNS50eXBld3JpdGUoX3RoaXM1LnN0cmluZ3NbX3RoaXM1LnNlcXVlbmNlW190aGlzNS5hcnJheVBvc11dLCAwKTtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgX3RoaXM1LnR5cGV3cml0ZShfdGhpczUuc3RyaW5nc1swXSwgMCk7XG5cdCAgICAgICAgICBfdGhpczUuYXJyYXlQb3MgPSAwO1xuXHQgICAgICAgIH1cblx0ICAgICAgfSwgdGhpcy5mYWRlT3V0RGVsYXkpO1xuXHQgICAgfVxuXHRcblx0ICAgIC8qKlxuXHQgICAgICogUmVwbGFjZXMgY3VycmVudCB0ZXh0IGluIHRoZSBIVE1MIGVsZW1lbnRcblx0ICAgICAqIGRlcGVuZGluZyBvbiBlbGVtZW50IHR5cGVcblx0ICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcblx0ICAgICAqIEBwcml2YXRlXG5cdCAgICAgKi9cblx0ICB9LCB7XG5cdCAgICBrZXk6ICdyZXBsYWNlVGV4dCcsXG5cdCAgICB2YWx1ZTogZnVuY3Rpb24gcmVwbGFjZVRleHQoc3RyKSB7XG5cdCAgICAgIGlmICh0aGlzLmF0dHIpIHtcblx0ICAgICAgICB0aGlzLmVsLnNldEF0dHJpYnV0ZSh0aGlzLmF0dHIsIHN0cik7XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgaWYgKHRoaXMuaXNJbnB1dCkge1xuXHQgICAgICAgICAgdGhpcy5lbC52YWx1ZSA9IHN0cjtcblx0ICAgICAgICB9IGVsc2UgaWYgKHRoaXMuY29udGVudFR5cGUgPT09ICdodG1sJykge1xuXHQgICAgICAgICAgdGhpcy5lbC5pbm5lckhUTUwgPSBzdHI7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgIHRoaXMuZWwudGV4dENvbnRlbnQgPSBzdHI7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICB9XG5cdFxuXHQgICAgLyoqXG5cdCAgICAgKiBJZiB1c2luZyBpbnB1dCBlbGVtZW50cywgYmluZCBmb2N1cyBpbiBvcmRlciB0b1xuXHQgICAgICogc3RhcnQgYW5kIHN0b3AgdGhlIGFuaW1hdGlvblxuXHQgICAgICogQHByaXZhdGVcblx0ICAgICAqL1xuXHQgIH0sIHtcblx0ICAgIGtleTogJ2JpbmRGb2N1c0V2ZW50cycsXG5cdCAgICB2YWx1ZTogZnVuY3Rpb24gYmluZEZvY3VzRXZlbnRzKCkge1xuXHQgICAgICB2YXIgX3RoaXM2ID0gdGhpcztcblx0XG5cdCAgICAgIGlmICghdGhpcy5pc0lucHV0KSByZXR1cm47XG5cdCAgICAgIHRoaXMuZWwuYWRkRXZlbnRMaXN0ZW5lcignZm9jdXMnLCBmdW5jdGlvbiAoZSkge1xuXHQgICAgICAgIF90aGlzNi5zdG9wKCk7XG5cdCAgICAgIH0pO1xuXHQgICAgICB0aGlzLmVsLmFkZEV2ZW50TGlzdGVuZXIoJ2JsdXInLCBmdW5jdGlvbiAoZSkge1xuXHQgICAgICAgIGlmIChfdGhpczYuZWwudmFsdWUgJiYgX3RoaXM2LmVsLnZhbHVlLmxlbmd0aCAhPT0gMCkge1xuXHQgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBfdGhpczYuc3RhcnQoKTtcblx0ICAgICAgfSk7XG5cdCAgICB9XG5cdFxuXHQgICAgLyoqXG5cdCAgICAgKiBPbiBpbml0LCBpbnNlcnQgdGhlIGN1cnNvciBlbGVtZW50XG5cdCAgICAgKiBAcHJpdmF0ZVxuXHQgICAgICovXG5cdCAgfSwge1xuXHQgICAga2V5OiAnaW5zZXJ0Q3Vyc29yJyxcblx0ICAgIHZhbHVlOiBmdW5jdGlvbiBpbnNlcnRDdXJzb3IoKSB7XG5cdCAgICAgIGlmICghdGhpcy5zaG93Q3Vyc29yKSByZXR1cm47XG5cdCAgICAgIGlmICh0aGlzLmN1cnNvcikgcmV0dXJuO1xuXHQgICAgICB0aGlzLmN1cnNvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcblx0ICAgICAgdGhpcy5jdXJzb3IuY2xhc3NOYW1lID0gJ3R5cGVkLWN1cnNvcic7XG5cdCAgICAgIHRoaXMuY3Vyc29yLnNldEF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nLCB0cnVlKTtcblx0ICAgICAgdGhpcy5jdXJzb3IuaW5uZXJIVE1MID0gdGhpcy5jdXJzb3JDaGFyO1xuXHQgICAgICB0aGlzLmVsLnBhcmVudE5vZGUgJiYgdGhpcy5lbC5wYXJlbnROb2RlLmluc2VydEJlZm9yZSh0aGlzLmN1cnNvciwgdGhpcy5lbC5uZXh0U2libGluZyk7XG5cdCAgICB9XG5cdCAgfV0pO1xuXHRcblx0ICByZXR1cm4gVHlwZWQ7XG5cdH0pKCk7XG5cdFxuXHRleHBvcnRzWydkZWZhdWx0J10gPSBUeXBlZDtcblx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cbi8qKiovIH0pLFxuLyogMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdCd1c2Ugc3RyaWN0Jztcblx0XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHtcblx0ICB2YWx1ZTogdHJ1ZVxuXHR9KTtcblx0XG5cdHZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cdFxuXHR2YXIgX2NyZWF0ZUNsYXNzID0gKGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmICgndmFsdWUnIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KSgpO1xuXHRcblx0ZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXHRcblx0ZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb24nKTsgfSB9XG5cdFxuXHR2YXIgX2RlZmF1bHRzSnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuXHRcblx0dmFyIF9kZWZhdWx0c0pzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2RlZmF1bHRzSnMpO1xuXHRcblx0LyoqXG5cdCAqIEluaXRpYWxpemUgdGhlIFR5cGVkIG9iamVjdFxuXHQgKi9cblx0XG5cdHZhciBJbml0aWFsaXplciA9IChmdW5jdGlvbiAoKSB7XG5cdCAgZnVuY3Rpb24gSW5pdGlhbGl6ZXIoKSB7XG5cdCAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgSW5pdGlhbGl6ZXIpO1xuXHQgIH1cblx0XG5cdCAgX2NyZWF0ZUNsYXNzKEluaXRpYWxpemVyLCBbe1xuXHQgICAga2V5OiAnbG9hZCcsXG5cdFxuXHQgICAgLyoqXG5cdCAgICAgKiBMb2FkIHVwIGRlZmF1bHRzICYgb3B0aW9ucyBvbiB0aGUgVHlwZWQgaW5zdGFuY2Vcblx0ICAgICAqIEBwYXJhbSB7VHlwZWR9IHNlbGYgaW5zdGFuY2Ugb2YgVHlwZWRcblx0ICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIG9wdGlvbnMgb2JqZWN0XG5cdCAgICAgKiBAcGFyYW0ge3N0cmluZ30gZWxlbWVudElkIEhUTUwgZWxlbWVudCBJRCBfT1JfIGluc3RhbmNlIG9mIEhUTUwgZWxlbWVudFxuXHQgICAgICogQHByaXZhdGVcblx0ICAgICAqL1xuXHRcblx0ICAgIHZhbHVlOiBmdW5jdGlvbiBsb2FkKHNlbGYsIG9wdGlvbnMsIGVsZW1lbnRJZCkge1xuXHQgICAgICAvLyBjaG9zZW4gZWxlbWVudCB0byBtYW5pcHVsYXRlIHRleHRcblx0ICAgICAgaWYgKHR5cGVvZiBlbGVtZW50SWQgPT09ICdzdHJpbmcnKSB7XG5cdCAgICAgICAgc2VsZi5lbCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoZWxlbWVudElkKTtcblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICBzZWxmLmVsID0gZWxlbWVudElkO1xuXHQgICAgICB9XG5cdFxuXHQgICAgICBzZWxmLm9wdGlvbnMgPSBfZXh0ZW5kcyh7fSwgX2RlZmF1bHRzSnMyWydkZWZhdWx0J10sIG9wdGlvbnMpO1xuXHRcblx0ICAgICAgLy8gYXR0cmlidXRlIHRvIHR5cGUgaW50b1xuXHQgICAgICBzZWxmLmlzSW5wdXQgPSBzZWxmLmVsLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2lucHV0Jztcblx0ICAgICAgc2VsZi5hdHRyID0gc2VsZi5vcHRpb25zLmF0dHI7XG5cdCAgICAgIHNlbGYuYmluZElucHV0Rm9jdXNFdmVudHMgPSBzZWxmLm9wdGlvbnMuYmluZElucHV0Rm9jdXNFdmVudHM7XG5cdFxuXHQgICAgICAvLyBzaG93IGN1cnNvclxuXHQgICAgICBzZWxmLnNob3dDdXJzb3IgPSBzZWxmLmlzSW5wdXQgPyBmYWxzZSA6IHNlbGYub3B0aW9ucy5zaG93Q3Vyc29yO1xuXHRcblx0ICAgICAgLy8gY3VzdG9tIGN1cnNvclxuXHQgICAgICBzZWxmLmN1cnNvckNoYXIgPSBzZWxmLm9wdGlvbnMuY3Vyc29yQ2hhcjtcblx0XG5cdCAgICAgIC8vIElzIHRoZSBjdXJzb3IgYmxpbmtpbmdcblx0ICAgICAgc2VsZi5jdXJzb3JCbGlua2luZyA9IHRydWU7XG5cdFxuXHQgICAgICAvLyB0ZXh0IGNvbnRlbnQgb2YgZWxlbWVudFxuXHQgICAgICBzZWxmLmVsQ29udGVudCA9IHNlbGYuYXR0ciA/IHNlbGYuZWwuZ2V0QXR0cmlidXRlKHNlbGYuYXR0cikgOiBzZWxmLmVsLnRleHRDb250ZW50O1xuXHRcblx0ICAgICAgLy8gaHRtbCBvciBwbGFpbiB0ZXh0XG5cdCAgICAgIHNlbGYuY29udGVudFR5cGUgPSBzZWxmLm9wdGlvbnMuY29udGVudFR5cGU7XG5cdFxuXHQgICAgICAvLyB0eXBpbmcgc3BlZWRcblx0ICAgICAgc2VsZi50eXBlU3BlZWQgPSBzZWxmLm9wdGlvbnMudHlwZVNwZWVkO1xuXHRcblx0ICAgICAgLy8gYWRkIGEgZGVsYXkgYmVmb3JlIHR5cGluZyBzdGFydHNcblx0ICAgICAgc2VsZi5zdGFydERlbGF5ID0gc2VsZi5vcHRpb25zLnN0YXJ0RGVsYXk7XG5cdFxuXHQgICAgICAvLyBiYWNrc3BhY2luZyBzcGVlZFxuXHQgICAgICBzZWxmLmJhY2tTcGVlZCA9IHNlbGYub3B0aW9ucy5iYWNrU3BlZWQ7XG5cdFxuXHQgICAgICAvLyBvbmx5IGJhY2tzcGFjZSB3aGF0IGRvZXNuJ3QgbWF0Y2ggdGhlIHByZXZpb3VzIHN0cmluZ1xuXHQgICAgICBzZWxmLnNtYXJ0QmFja3NwYWNlID0gc2VsZi5vcHRpb25zLnNtYXJ0QmFja3NwYWNlO1xuXHRcblx0ICAgICAgLy8gYW1vdW50IG9mIHRpbWUgdG8gd2FpdCBiZWZvcmUgYmFja3NwYWNpbmdcblx0ICAgICAgc2VsZi5iYWNrRGVsYXkgPSBzZWxmLm9wdGlvbnMuYmFja0RlbGF5O1xuXHRcblx0ICAgICAgLy8gRmFkZSBvdXQgaW5zdGVhZCBvZiBiYWNrc3BhY2Vcblx0ICAgICAgc2VsZi5mYWRlT3V0ID0gc2VsZi5vcHRpb25zLmZhZGVPdXQ7XG5cdCAgICAgIHNlbGYuZmFkZU91dENsYXNzID0gc2VsZi5vcHRpb25zLmZhZGVPdXRDbGFzcztcblx0ICAgICAgc2VsZi5mYWRlT3V0RGVsYXkgPSBzZWxmLm9wdGlvbnMuZmFkZU91dERlbGF5O1xuXHRcblx0ICAgICAgLy8gdmFyaWFibGUgdG8gY2hlY2sgd2hldGhlciB0eXBpbmcgaXMgY3VycmVudGx5IHBhdXNlZFxuXHQgICAgICBzZWxmLmlzUGF1c2VkID0gZmFsc2U7XG5cdFxuXHQgICAgICAvLyBpbnB1dCBzdHJpbmdzIG9mIHRleHRcblx0ICAgICAgc2VsZi5zdHJpbmdzID0gc2VsZi5vcHRpb25zLnN0cmluZ3MubWFwKGZ1bmN0aW9uIChzKSB7XG5cdCAgICAgICAgcmV0dXJuIHMudHJpbSgpO1xuXHQgICAgICB9KTtcblx0XG5cdCAgICAgIC8vIGRpdiBjb250YWluaW5nIHN0cmluZ3Ncblx0ICAgICAgaWYgKHR5cGVvZiBzZWxmLm9wdGlvbnMuc3RyaW5nc0VsZW1lbnQgPT09ICdzdHJpbmcnKSB7XG5cdCAgICAgICAgc2VsZi5zdHJpbmdzRWxlbWVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3Ioc2VsZi5vcHRpb25zLnN0cmluZ3NFbGVtZW50KTtcblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICBzZWxmLnN0cmluZ3NFbGVtZW50ID0gc2VsZi5vcHRpb25zLnN0cmluZ3NFbGVtZW50O1xuXHQgICAgICB9XG5cdFxuXHQgICAgICBpZiAoc2VsZi5zdHJpbmdzRWxlbWVudCkge1xuXHQgICAgICAgIHNlbGYuc3RyaW5ncyA9IFtdO1xuXHQgICAgICAgIHNlbGYuc3RyaW5nc0VsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICdub25lJztcblx0ICAgICAgICB2YXIgc3RyaW5ncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5hcHBseShzZWxmLnN0cmluZ3NFbGVtZW50LmNoaWxkcmVuKTtcblx0ICAgICAgICB2YXIgc3RyaW5nc0xlbmd0aCA9IHN0cmluZ3MubGVuZ3RoO1xuXHRcblx0ICAgICAgICBpZiAoc3RyaW5nc0xlbmd0aCkge1xuXHQgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHJpbmdzTGVuZ3RoOyBpICs9IDEpIHtcblx0ICAgICAgICAgICAgdmFyIHN0cmluZ0VsID0gc3RyaW5nc1tpXTtcblx0ICAgICAgICAgICAgc2VsZi5zdHJpbmdzLnB1c2goc3RyaW5nRWwuaW5uZXJIVE1MLnRyaW0oKSk7XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdFxuXHQgICAgICAvLyBjaGFyYWN0ZXIgbnVtYmVyIHBvc2l0aW9uIG9mIGN1cnJlbnQgc3RyaW5nXG5cdCAgICAgIHNlbGYuc3RyUG9zID0gMDtcblx0XG5cdCAgICAgIC8vIGN1cnJlbnQgYXJyYXkgcG9zaXRpb25cblx0ICAgICAgc2VsZi5hcnJheVBvcyA9IDA7XG5cdFxuXHQgICAgICAvLyBpbmRleCBvZiBzdHJpbmcgdG8gc3RvcCBiYWNrc3BhY2luZyBvblxuXHQgICAgICBzZWxmLnN0b3BOdW0gPSAwO1xuXHRcblx0ICAgICAgLy8gTG9vcGluZyBsb2dpY1xuXHQgICAgICBzZWxmLmxvb3AgPSBzZWxmLm9wdGlvbnMubG9vcDtcblx0ICAgICAgc2VsZi5sb29wQ291bnQgPSBzZWxmLm9wdGlvbnMubG9vcENvdW50O1xuXHQgICAgICBzZWxmLmN1ckxvb3AgPSAwO1xuXHRcblx0ICAgICAgLy8gc2h1ZmZsZSB0aGUgc3RyaW5nc1xuXHQgICAgICBzZWxmLnNodWZmbGUgPSBzZWxmLm9wdGlvbnMuc2h1ZmZsZTtcblx0ICAgICAgLy8gdGhlIG9yZGVyIG9mIHN0cmluZ3Ncblx0ICAgICAgc2VsZi5zZXF1ZW5jZSA9IFtdO1xuXHRcblx0ICAgICAgc2VsZi5wYXVzZSA9IHtcblx0ICAgICAgICBzdGF0dXM6IGZhbHNlLFxuXHQgICAgICAgIHR5cGV3cml0ZTogdHJ1ZSxcblx0ICAgICAgICBjdXJTdHJpbmc6ICcnLFxuXHQgICAgICAgIGN1clN0clBvczogMFxuXHQgICAgICB9O1xuXHRcblx0ICAgICAgLy8gV2hlbiB0aGUgdHlwaW5nIGlzIGNvbXBsZXRlICh3aGVuIG5vdCBsb29wZWQpXG5cdCAgICAgIHNlbGYudHlwaW5nQ29tcGxldGUgPSBmYWxzZTtcblx0XG5cdCAgICAgIC8vIFNldCB0aGUgb3JkZXIgaW4gd2hpY2ggdGhlIHN0cmluZ3MgYXJlIHR5cGVkXG5cdCAgICAgIGZvciAodmFyIGkgaW4gc2VsZi5zdHJpbmdzKSB7XG5cdCAgICAgICAgc2VsZi5zZXF1ZW5jZVtpXSA9IGk7XG5cdCAgICAgIH1cblx0XG5cdCAgICAgIC8vIElmIHRoZXJlIGlzIHNvbWUgdGV4dCBpbiB0aGUgZWxlbWVudFxuXHQgICAgICBzZWxmLmN1cnJlbnRFbENvbnRlbnQgPSB0aGlzLmdldEN1cnJlbnRFbENvbnRlbnQoc2VsZik7XG5cdFxuXHQgICAgICBzZWxmLmF1dG9JbnNlcnRDc3MgPSBzZWxmLm9wdGlvbnMuYXV0b0luc2VydENzcztcblx0XG5cdCAgICAgIHRoaXMuYXBwZW5kQW5pbWF0aW9uQ3NzKHNlbGYpO1xuXHQgICAgfVxuXHQgIH0sIHtcblx0ICAgIGtleTogJ2dldEN1cnJlbnRFbENvbnRlbnQnLFxuXHQgICAgdmFsdWU6IGZ1bmN0aW9uIGdldEN1cnJlbnRFbENvbnRlbnQoc2VsZikge1xuXHQgICAgICB2YXIgZWxDb250ZW50ID0gJyc7XG5cdCAgICAgIGlmIChzZWxmLmF0dHIpIHtcblx0ICAgICAgICBlbENvbnRlbnQgPSBzZWxmLmVsLmdldEF0dHJpYnV0ZShzZWxmLmF0dHIpO1xuXHQgICAgICB9IGVsc2UgaWYgKHNlbGYuaXNJbnB1dCkge1xuXHQgICAgICAgIGVsQ29udGVudCA9IHNlbGYuZWwudmFsdWU7XG5cdCAgICAgIH0gZWxzZSBpZiAoc2VsZi5jb250ZW50VHlwZSA9PT0gJ2h0bWwnKSB7XG5cdCAgICAgICAgZWxDb250ZW50ID0gc2VsZi5lbC5pbm5lckhUTUw7XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgZWxDb250ZW50ID0gc2VsZi5lbC50ZXh0Q29udGVudDtcblx0ICAgICAgfVxuXHQgICAgICByZXR1cm4gZWxDb250ZW50O1xuXHQgICAgfVxuXHQgIH0sIHtcblx0ICAgIGtleTogJ2FwcGVuZEFuaW1hdGlvbkNzcycsXG5cdCAgICB2YWx1ZTogZnVuY3Rpb24gYXBwZW5kQW5pbWF0aW9uQ3NzKHNlbGYpIHtcblx0ICAgICAgdmFyIGNzc0RhdGFOYW1lID0gJ2RhdGEtdHlwZWQtanMtY3NzJztcblx0ICAgICAgaWYgKCFzZWxmLmF1dG9JbnNlcnRDc3MpIHtcblx0ICAgICAgICByZXR1cm47XG5cdCAgICAgIH1cblx0ICAgICAgaWYgKCFzZWxmLnNob3dDdXJzb3IgJiYgIXNlbGYuZmFkZU91dCkge1xuXHQgICAgICAgIHJldHVybjtcblx0ICAgICAgfVxuXHQgICAgICBpZiAoZG9jdW1lbnQucXVlcnlTZWxlY3RvcignWycgKyBjc3NEYXRhTmFtZSArICddJykpIHtcblx0ICAgICAgICByZXR1cm47XG5cdCAgICAgIH1cblx0XG5cdCAgICAgIHZhciBjc3MgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuXHQgICAgICBjc3MudHlwZSA9ICd0ZXh0L2Nzcyc7XG5cdCAgICAgIGNzcy5zZXRBdHRyaWJ1dGUoY3NzRGF0YU5hbWUsIHRydWUpO1xuXHRcblx0ICAgICAgdmFyIGlubmVyQ3NzID0gJyc7XG5cdCAgICAgIGlmIChzZWxmLnNob3dDdXJzb3IpIHtcblx0ICAgICAgICBpbm5lckNzcyArPSAnXFxuICAgICAgICAudHlwZWQtY3Vyc29ye1xcbiAgICAgICAgICBvcGFjaXR5OiAxO1xcbiAgICAgICAgfVxcbiAgICAgICAgLnR5cGVkLWN1cnNvci50eXBlZC1jdXJzb3ItLWJsaW5re1xcbiAgICAgICAgICBhbmltYXRpb246IHR5cGVkanNCbGluayAwLjdzIGluZmluaXRlO1xcbiAgICAgICAgICAtd2Via2l0LWFuaW1hdGlvbjogdHlwZWRqc0JsaW5rIDAuN3MgaW5maW5pdGU7XFxuICAgICAgICAgICAgICAgICAgYW5pbWF0aW9uOiB0eXBlZGpzQmxpbmsgMC43cyBpbmZpbml0ZTtcXG4gICAgICAgIH1cXG4gICAgICAgIEBrZXlmcmFtZXMgdHlwZWRqc0JsaW5re1xcbiAgICAgICAgICA1MCUgeyBvcGFjaXR5OiAwLjA7IH1cXG4gICAgICAgIH1cXG4gICAgICAgIEAtd2Via2l0LWtleWZyYW1lcyB0eXBlZGpzQmxpbmt7XFxuICAgICAgICAgIDAlIHsgb3BhY2l0eTogMTsgfVxcbiAgICAgICAgICA1MCUgeyBvcGFjaXR5OiAwLjA7IH1cXG4gICAgICAgICAgMTAwJSB7IG9wYWNpdHk6IDE7IH1cXG4gICAgICAgIH1cXG4gICAgICAnO1xuXHQgICAgICB9XG5cdCAgICAgIGlmIChzZWxmLmZhZGVPdXQpIHtcblx0ICAgICAgICBpbm5lckNzcyArPSAnXFxuICAgICAgICAudHlwZWQtZmFkZS1vdXR7XFxuICAgICAgICAgIG9wYWNpdHk6IDA7XFxuICAgICAgICAgIHRyYW5zaXRpb246IG9wYWNpdHkgLjI1cztcXG4gICAgICAgIH1cXG4gICAgICAgIC50eXBlZC1jdXJzb3IudHlwZWQtY3Vyc29yLS1ibGluay50eXBlZC1mYWRlLW91dHtcXG4gICAgICAgICAgLXdlYmtpdC1hbmltYXRpb246IDA7XFxuICAgICAgICAgIGFuaW1hdGlvbjogMDtcXG4gICAgICAgIH1cXG4gICAgICAnO1xuXHQgICAgICB9XG5cdCAgICAgIGlmIChjc3MubGVuZ3RoID09PSAwKSB7XG5cdCAgICAgICAgcmV0dXJuO1xuXHQgICAgICB9XG5cdCAgICAgIGNzcy5pbm5lckhUTUwgPSBpbm5lckNzcztcblx0ICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChjc3MpO1xuXHQgICAgfVxuXHQgIH1dKTtcblx0XG5cdCAgcmV0dXJuIEluaXRpYWxpemVyO1xuXHR9KSgpO1xuXHRcblx0ZXhwb3J0c1snZGVmYXVsdCddID0gSW5pdGlhbGl6ZXI7XG5cdHZhciBpbml0aWFsaXplciA9IG5ldyBJbml0aWFsaXplcigpO1xuXHRleHBvcnRzLmluaXRpYWxpemVyID0gaW5pdGlhbGl6ZXI7XG5cbi8qKiovIH0pLFxuLyogMiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdC8qKlxuXHQgKiBEZWZhdWx0cyAmIG9wdGlvbnNcblx0ICogQHJldHVybnMge29iamVjdH0gVHlwZWQgZGVmYXVsdHMgJiBvcHRpb25zXG5cdCAqIEBwdWJsaWNcblx0ICovXG5cdFxuXHQndXNlIHN0cmljdCc7XG5cdFxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7XG5cdCAgdmFsdWU6IHRydWVcblx0fSk7XG5cdHZhciBkZWZhdWx0cyA9IHtcblx0ICAvKipcblx0ICAgKiBAcHJvcGVydHkge2FycmF5fSBzdHJpbmdzIHN0cmluZ3MgdG8gYmUgdHlwZWRcblx0ICAgKiBAcHJvcGVydHkge3N0cmluZ30gc3RyaW5nc0VsZW1lbnQgSUQgb2YgZWxlbWVudCBjb250YWluaW5nIHN0cmluZyBjaGlsZHJlblxuXHQgICAqL1xuXHQgIHN0cmluZ3M6IFsnVGhlc2UgYXJlIHRoZSBkZWZhdWx0IHZhbHVlcy4uLicsICdZb3Uga25vdyB3aGF0IHlvdSBzaG91bGQgZG8/JywgJ1VzZSB5b3VyIG93biEnLCAnSGF2ZSBhIGdyZWF0IGRheSEnXSxcblx0ICBzdHJpbmdzRWxlbWVudDogbnVsbCxcblx0XG5cdCAgLyoqXG5cdCAgICogQHByb3BlcnR5IHtudW1iZXJ9IHR5cGVTcGVlZCB0eXBlIHNwZWVkIGluIG1pbGxpc2Vjb25kc1xuXHQgICAqL1xuXHQgIHR5cGVTcGVlZDogMCxcblx0XG5cdCAgLyoqXG5cdCAgICogQHByb3BlcnR5IHtudW1iZXJ9IHN0YXJ0RGVsYXkgdGltZSBiZWZvcmUgdHlwaW5nIHN0YXJ0cyBpbiBtaWxsaXNlY29uZHNcblx0ICAgKi9cblx0ICBzdGFydERlbGF5OiAwLFxuXHRcblx0ICAvKipcblx0ICAgKiBAcHJvcGVydHkge251bWJlcn0gYmFja1NwZWVkIGJhY2tzcGFjaW5nIHNwZWVkIGluIG1pbGxpc2Vjb25kc1xuXHQgICAqL1xuXHQgIGJhY2tTcGVlZDogMCxcblx0XG5cdCAgLyoqXG5cdCAgICogQHByb3BlcnR5IHtib29sZWFufSBzbWFydEJhY2tzcGFjZSBvbmx5IGJhY2tzcGFjZSB3aGF0IGRvZXNuJ3QgbWF0Y2ggdGhlIHByZXZpb3VzIHN0cmluZ1xuXHQgICAqL1xuXHQgIHNtYXJ0QmFja3NwYWNlOiB0cnVlLFxuXHRcblx0ICAvKipcblx0ICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IHNodWZmbGUgc2h1ZmZsZSB0aGUgc3RyaW5nc1xuXHQgICAqL1xuXHQgIHNodWZmbGU6IGZhbHNlLFxuXHRcblx0ICAvKipcblx0ICAgKiBAcHJvcGVydHkge251bWJlcn0gYmFja0RlbGF5IHRpbWUgYmVmb3JlIGJhY2tzcGFjaW5nIGluIG1pbGxpc2Vjb25kc1xuXHQgICAqL1xuXHQgIGJhY2tEZWxheTogNzAwLFxuXHRcblx0ICAvKipcblx0ICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IGZhZGVPdXQgRmFkZSBvdXQgaW5zdGVhZCBvZiBiYWNrc3BhY2Vcblx0ICAgKiBAcHJvcGVydHkge3N0cmluZ30gZmFkZU91dENsYXNzIGNzcyBjbGFzcyBmb3IgZmFkZSBhbmltYXRpb25cblx0ICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IGZhZGVPdXREZWxheSBGYWRlIG91dCBkZWxheSBpbiBtaWxsaXNlY29uZHNcblx0ICAgKi9cblx0ICBmYWRlT3V0OiBmYWxzZSxcblx0ICBmYWRlT3V0Q2xhc3M6ICd0eXBlZC1mYWRlLW91dCcsXG5cdCAgZmFkZU91dERlbGF5OiA1MDAsXG5cdFxuXHQgIC8qKlxuXHQgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gbG9vcCBsb29wIHN0cmluZ3Ncblx0ICAgKiBAcHJvcGVydHkge251bWJlcn0gbG9vcENvdW50IGFtb3VudCBvZiBsb29wc1xuXHQgICAqL1xuXHQgIGxvb3A6IGZhbHNlLFxuXHQgIGxvb3BDb3VudDogSW5maW5pdHksXG5cdFxuXHQgIC8qKlxuXHQgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gc2hvd0N1cnNvciBzaG93IGN1cnNvclxuXHQgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBjdXJzb3JDaGFyIGNoYXJhY3RlciBmb3IgY3Vyc29yXG5cdCAgICogQHByb3BlcnR5IHtib29sZWFufSBhdXRvSW5zZXJ0Q3NzIGluc2VydCBDU1MgZm9yIGN1cnNvciBhbmQgZmFkZU91dCBpbnRvIEhUTUwgPGhlYWQ+XG5cdCAgICovXG5cdCAgc2hvd0N1cnNvcjogdHJ1ZSxcblx0ICBjdXJzb3JDaGFyOiAnfCcsXG5cdCAgYXV0b0luc2VydENzczogdHJ1ZSxcblx0XG5cdCAgLyoqXG5cdCAgICogQHByb3BlcnR5IHtzdHJpbmd9IGF0dHIgYXR0cmlidXRlIGZvciB0eXBpbmdcblx0ICAgKiBFeDogaW5wdXQgcGxhY2Vob2xkZXIsIHZhbHVlLCBvciBqdXN0IEhUTUwgdGV4dFxuXHQgICAqL1xuXHQgIGF0dHI6IG51bGwsXG5cdFxuXHQgIC8qKlxuXHQgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gYmluZElucHV0Rm9jdXNFdmVudHMgYmluZCB0byBmb2N1cyBhbmQgYmx1ciBpZiBlbCBpcyB0ZXh0IGlucHV0XG5cdCAgICovXG5cdCAgYmluZElucHV0Rm9jdXNFdmVudHM6IGZhbHNlLFxuXHRcblx0ICAvKipcblx0ICAgKiBAcHJvcGVydHkge3N0cmluZ30gY29udGVudFR5cGUgJ2h0bWwnIG9yICdudWxsJyBmb3IgcGxhaW50ZXh0XG5cdCAgICovXG5cdCAgY29udGVudFR5cGU6ICdodG1sJyxcblx0XG5cdCAgLyoqXG5cdCAgICogQmVmb3JlIGl0IGJlZ2lucyB0eXBpbmdcblx0ICAgKiBAcGFyYW0ge1R5cGVkfSBzZWxmXG5cdCAgICovXG5cdCAgb25CZWdpbjogZnVuY3Rpb24gb25CZWdpbihzZWxmKSB7fSxcblx0XG5cdCAgLyoqXG5cdCAgICogQWxsIHR5cGluZyBpcyBjb21wbGV0ZVxuXHQgICAqIEBwYXJhbSB7VHlwZWR9IHNlbGZcblx0ICAgKi9cblx0ICBvbkNvbXBsZXRlOiBmdW5jdGlvbiBvbkNvbXBsZXRlKHNlbGYpIHt9LFxuXHRcblx0ICAvKipcblx0ICAgKiBCZWZvcmUgZWFjaCBzdHJpbmcgaXMgdHlwZWRcblx0ICAgKiBAcGFyYW0ge251bWJlcn0gYXJyYXlQb3Ncblx0ICAgKiBAcGFyYW0ge1R5cGVkfSBzZWxmXG5cdCAgICovXG5cdCAgcHJlU3RyaW5nVHlwZWQ6IGZ1bmN0aW9uIHByZVN0cmluZ1R5cGVkKGFycmF5UG9zLCBzZWxmKSB7fSxcblx0XG5cdCAgLyoqXG5cdCAgICogQWZ0ZXIgZWFjaCBzdHJpbmcgaXMgdHlwZWRcblx0ICAgKiBAcGFyYW0ge251bWJlcn0gYXJyYXlQb3Ncblx0ICAgKiBAcGFyYW0ge1R5cGVkfSBzZWxmXG5cdCAgICovXG5cdCAgb25TdHJpbmdUeXBlZDogZnVuY3Rpb24gb25TdHJpbmdUeXBlZChhcnJheVBvcywgc2VsZikge30sXG5cdFxuXHQgIC8qKlxuXHQgICAqIER1cmluZyBsb29waW5nLCBhZnRlciBsYXN0IHN0cmluZyBpcyB0eXBlZFxuXHQgICAqIEBwYXJhbSB7VHlwZWR9IHNlbGZcblx0ICAgKi9cblx0ICBvbkxhc3RTdHJpbmdCYWNrc3BhY2VkOiBmdW5jdGlvbiBvbkxhc3RTdHJpbmdCYWNrc3BhY2VkKHNlbGYpIHt9LFxuXHRcblx0ICAvKipcblx0ICAgKiBUeXBpbmcgaGFzIGJlZW4gc3RvcHBlZFxuXHQgICAqIEBwYXJhbSB7bnVtYmVyfSBhcnJheVBvc1xuXHQgICAqIEBwYXJhbSB7VHlwZWR9IHNlbGZcblx0ICAgKi9cblx0ICBvblR5cGluZ1BhdXNlZDogZnVuY3Rpb24gb25UeXBpbmdQYXVzZWQoYXJyYXlQb3MsIHNlbGYpIHt9LFxuXHRcblx0ICAvKipcblx0ICAgKiBUeXBpbmcgaGFzIGJlZW4gc3RhcnRlZCBhZnRlciBiZWluZyBzdG9wcGVkXG5cdCAgICogQHBhcmFtIHtudW1iZXJ9IGFycmF5UG9zXG5cdCAgICogQHBhcmFtIHtUeXBlZH0gc2VsZlxuXHQgICAqL1xuXHQgIG9uVHlwaW5nUmVzdW1lZDogZnVuY3Rpb24gb25UeXBpbmdSZXN1bWVkKGFycmF5UG9zLCBzZWxmKSB7fSxcblx0XG5cdCAgLyoqXG5cdCAgICogQWZ0ZXIgcmVzZXRcblx0ICAgKiBAcGFyYW0ge1R5cGVkfSBzZWxmXG5cdCAgICovXG5cdCAgb25SZXNldDogZnVuY3Rpb24gb25SZXNldChzZWxmKSB7fSxcblx0XG5cdCAgLyoqXG5cdCAgICogQWZ0ZXIgc3RvcFxuXHQgICAqIEBwYXJhbSB7bnVtYmVyfSBhcnJheVBvc1xuXHQgICAqIEBwYXJhbSB7VHlwZWR9IHNlbGZcblx0ICAgKi9cblx0ICBvblN0b3A6IGZ1bmN0aW9uIG9uU3RvcChhcnJheVBvcywgc2VsZikge30sXG5cdFxuXHQgIC8qKlxuXHQgICAqIEFmdGVyIHN0YXJ0XG5cdCAgICogQHBhcmFtIHtudW1iZXJ9IGFycmF5UG9zXG5cdCAgICogQHBhcmFtIHtUeXBlZH0gc2VsZlxuXHQgICAqL1xuXHQgIG9uU3RhcnQ6IGZ1bmN0aW9uIG9uU3RhcnQoYXJyYXlQb3MsIHNlbGYpIHt9LFxuXHRcblx0ICAvKipcblx0ICAgKiBBZnRlciBkZXN0cm95XG5cdCAgICogQHBhcmFtIHtUeXBlZH0gc2VsZlxuXHQgICAqL1xuXHQgIG9uRGVzdHJveTogZnVuY3Rpb24gb25EZXN0cm95KHNlbGYpIHt9XG5cdH07XG5cdFxuXHRleHBvcnRzWydkZWZhdWx0J10gPSBkZWZhdWx0cztcblx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cbi8qKiovIH0pLFxuLyogMyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdC8qKlxuXHQgKiBUT0RPOiBUaGVzZSBtZXRob2RzIGNhbiBwcm9iYWJseSBiZSBjb21iaW5lZCBzb21laG93XG5cdCAqIFBhcnNlIEhUTUwgdGFncyAmIEhUTUwgQ2hhcmFjdGVyc1xuXHQgKi9cblx0XG5cdCd1c2Ugc3RyaWN0Jztcblx0XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHtcblx0ICB2YWx1ZTogdHJ1ZVxuXHR9KTtcblx0XG5cdHZhciBfY3JlYXRlQ2xhc3MgPSAoZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKCd2YWx1ZScgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0pKCk7XG5cdFxuXHRmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvbicpOyB9IH1cblx0XG5cdHZhciBIVE1MUGFyc2VyID0gKGZ1bmN0aW9uICgpIHtcblx0ICBmdW5jdGlvbiBIVE1MUGFyc2VyKCkge1xuXHQgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEhUTUxQYXJzZXIpO1xuXHQgIH1cblx0XG5cdCAgX2NyZWF0ZUNsYXNzKEhUTUxQYXJzZXIsIFt7XG5cdCAgICBrZXk6ICd0eXBlSHRtbENoYXJzJyxcblx0XG5cdCAgICAvKipcblx0ICAgICAqIFR5cGUgSFRNTCB0YWdzICYgSFRNTCBDaGFyYWN0ZXJzXG5cdCAgICAgKiBAcGFyYW0ge3N0cmluZ30gY3VyU3RyaW5nIEN1cnJlbnQgc3RyaW5nXG5cdCAgICAgKiBAcGFyYW0ge251bWJlcn0gY3VyU3RyUG9zIFBvc2l0aW9uIGluIGN1cnJlbnQgc3RyaW5nXG5cdCAgICAgKiBAcGFyYW0ge1R5cGVkfSBzZWxmIGluc3RhbmNlIG9mIFR5cGVkXG5cdCAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBhIG5ldyBzdHJpbmcgcG9zaXRpb25cblx0ICAgICAqIEBwcml2YXRlXG5cdCAgICAgKi9cblx0XG5cdCAgICB2YWx1ZTogZnVuY3Rpb24gdHlwZUh0bWxDaGFycyhjdXJTdHJpbmcsIGN1clN0clBvcywgc2VsZikge1xuXHQgICAgICBpZiAoc2VsZi5jb250ZW50VHlwZSAhPT0gJ2h0bWwnKSByZXR1cm4gY3VyU3RyUG9zO1xuXHQgICAgICB2YXIgY3VyQ2hhciA9IGN1clN0cmluZy5zdWJzdHIoY3VyU3RyUG9zKS5jaGFyQXQoMCk7XG5cdCAgICAgIGlmIChjdXJDaGFyID09PSAnPCcgfHwgY3VyQ2hhciA9PT0gJyYnKSB7XG5cdCAgICAgICAgdmFyIGVuZFRhZyA9ICcnO1xuXHQgICAgICAgIGlmIChjdXJDaGFyID09PSAnPCcpIHtcblx0ICAgICAgICAgIGVuZFRhZyA9ICc+Jztcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgZW5kVGFnID0gJzsnO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB3aGlsZSAoY3VyU3RyaW5nLnN1YnN0cihjdXJTdHJQb3MgKyAxKS5jaGFyQXQoMCkgIT09IGVuZFRhZykge1xuXHQgICAgICAgICAgY3VyU3RyUG9zKys7XG5cdCAgICAgICAgICBpZiAoY3VyU3RyUG9zICsgMSA+IGN1clN0cmluZy5sZW5ndGgpIHtcblx0ICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGN1clN0clBvcysrO1xuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiBjdXJTdHJQb3M7XG5cdCAgICB9XG5cdFxuXHQgICAgLyoqXG5cdCAgICAgKiBCYWNrc3BhY2UgSFRNTCB0YWdzIGFuZCBIVE1MIENoYXJhY3RlcnNcblx0ICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjdXJTdHJpbmcgQ3VycmVudCBzdHJpbmdcblx0ICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjdXJTdHJQb3MgUG9zaXRpb24gaW4gY3VycmVudCBzdHJpbmdcblx0ICAgICAqIEBwYXJhbSB7VHlwZWR9IHNlbGYgaW5zdGFuY2Ugb2YgVHlwZWRcblx0ICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IGEgbmV3IHN0cmluZyBwb3NpdGlvblxuXHQgICAgICogQHByaXZhdGVcblx0ICAgICAqL1xuXHQgIH0sIHtcblx0ICAgIGtleTogJ2JhY2tTcGFjZUh0bWxDaGFycycsXG5cdCAgICB2YWx1ZTogZnVuY3Rpb24gYmFja1NwYWNlSHRtbENoYXJzKGN1clN0cmluZywgY3VyU3RyUG9zLCBzZWxmKSB7XG5cdCAgICAgIGlmIChzZWxmLmNvbnRlbnRUeXBlICE9PSAnaHRtbCcpIHJldHVybiBjdXJTdHJQb3M7XG5cdCAgICAgIHZhciBjdXJDaGFyID0gY3VyU3RyaW5nLnN1YnN0cihjdXJTdHJQb3MpLmNoYXJBdCgwKTtcblx0ICAgICAgaWYgKGN1ckNoYXIgPT09ICc+JyB8fCBjdXJDaGFyID09PSAnOycpIHtcblx0ICAgICAgICB2YXIgZW5kVGFnID0gJyc7XG5cdCAgICAgICAgaWYgKGN1ckNoYXIgPT09ICc+Jykge1xuXHQgICAgICAgICAgZW5kVGFnID0gJzwnO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICBlbmRUYWcgPSAnJic7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHdoaWxlIChjdXJTdHJpbmcuc3Vic3RyKGN1clN0clBvcyAtIDEpLmNoYXJBdCgwKSAhPT0gZW5kVGFnKSB7XG5cdCAgICAgICAgICBjdXJTdHJQb3MtLTtcblx0ICAgICAgICAgIGlmIChjdXJTdHJQb3MgPCAwKSB7XG5cdCAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICBjdXJTdHJQb3MtLTtcblx0ICAgICAgfVxuXHQgICAgICByZXR1cm4gY3VyU3RyUG9zO1xuXHQgICAgfVxuXHQgIH1dKTtcblx0XG5cdCAgcmV0dXJuIEhUTUxQYXJzZXI7XG5cdH0pKCk7XG5cdFxuXHRleHBvcnRzWydkZWZhdWx0J10gPSBIVE1MUGFyc2VyO1xuXHR2YXIgaHRtbFBhcnNlciA9IG5ldyBIVE1MUGFyc2VyKCk7XG5cdGV4cG9ydHMuaHRtbFBhcnNlciA9IGh0bWxQYXJzZXI7XG5cbi8qKiovIH0pXG4vKioqKioqLyBdKVxufSk7XG47IiwiaW1wb3J0IHsgQ29tcG9uZW50LCBDb21wb25lbnRDb250YWluZXIgfSBmcm9tICdAZmlyZWJhc2UvY29tcG9uZW50JztcbmltcG9ydCB7IExvZ2dlciwgc2V0VXNlckxvZ0hhbmRsZXIsIHNldExvZ0xldmVsIGFzIHNldExvZ0xldmVsJDEgfSBmcm9tICdAZmlyZWJhc2UvbG9nZ2VyJztcbmltcG9ydCB7IEVycm9yRmFjdG9yeSwgZGVlcEVxdWFsLCBiYXNlNjRFbmNvZGUsIGlzSW5kZXhlZERCQXZhaWxhYmxlLCB2YWxpZGF0ZUluZGV4ZWREQk9wZW5hYmxlIH0gZnJvbSAnQGZpcmViYXNlL3V0aWwnO1xuZXhwb3J0IHsgRmlyZWJhc2VFcnJvciB9IGZyb20gJ0BmaXJlYmFzZS91dGlsJztcbmltcG9ydCB7IG9wZW5EYiB9IGZyb20gJ2lkYic7XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmNsYXNzIFBsYXRmb3JtTG9nZ2VyU2VydmljZUltcGwge1xyXG4gICAgY29uc3RydWN0b3IoY29udGFpbmVyKSB7XHJcbiAgICAgICAgdGhpcy5jb250YWluZXIgPSBjb250YWluZXI7XHJcbiAgICB9XHJcbiAgICAvLyBJbiBpbml0aWFsIGltcGxlbWVudGF0aW9uLCB0aGlzIHdpbGwgYmUgY2FsbGVkIGJ5IGluc3RhbGxhdGlvbnMgb25cclxuICAgIC8vIGF1dGggdG9rZW4gcmVmcmVzaCwgYW5kIGluc3RhbGxhdGlvbnMgd2lsbCBzZW5kIHRoaXMgc3RyaW5nLlxyXG4gICAgZ2V0UGxhdGZvcm1JbmZvU3RyaW5nKCkge1xyXG4gICAgICAgIGNvbnN0IHByb3ZpZGVycyA9IHRoaXMuY29udGFpbmVyLmdldFByb3ZpZGVycygpO1xyXG4gICAgICAgIC8vIExvb3AgdGhyb3VnaCBwcm92aWRlcnMgYW5kIGdldCBsaWJyYXJ5L3ZlcnNpb24gcGFpcnMgZnJvbSBhbnkgdGhhdCBhcmVcclxuICAgICAgICAvLyB2ZXJzaW9uIGNvbXBvbmVudHMuXHJcbiAgICAgICAgcmV0dXJuIHByb3ZpZGVyc1xyXG4gICAgICAgICAgICAubWFwKHByb3ZpZGVyID0+IHtcclxuICAgICAgICAgICAgaWYgKGlzVmVyc2lvblNlcnZpY2VQcm92aWRlcihwcm92aWRlcikpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHNlcnZpY2UgPSBwcm92aWRlci5nZXRJbW1lZGlhdGUoKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBgJHtzZXJ2aWNlLmxpYnJhcnl9LyR7c2VydmljZS52ZXJzaW9ufWA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5maWx0ZXIobG9nU3RyaW5nID0+IGxvZ1N0cmluZylcclxuICAgICAgICAgICAgLmpvaW4oJyAnKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICpcclxuICogQHBhcmFtIHByb3ZpZGVyIGNoZWNrIGlmIHRoaXMgcHJvdmlkZXIgcHJvdmlkZXMgYSBWZXJzaW9uU2VydmljZVxyXG4gKlxyXG4gKiBOT1RFOiBVc2luZyBQcm92aWRlcjwnYXBwLXZlcnNpb24nPiBpcyBhIGhhY2sgdG8gaW5kaWNhdGUgdGhhdCB0aGUgcHJvdmlkZXJcclxuICogcHJvdmlkZXMgVmVyc2lvblNlcnZpY2UuIFRoZSBwcm92aWRlciBpcyBub3QgbmVjZXNzYXJpbHkgYSAnYXBwLXZlcnNpb24nXHJcbiAqIHByb3ZpZGVyLlxyXG4gKi9cclxuZnVuY3Rpb24gaXNWZXJzaW9uU2VydmljZVByb3ZpZGVyKHByb3ZpZGVyKSB7XHJcbiAgICBjb25zdCBjb21wb25lbnQgPSBwcm92aWRlci5nZXRDb21wb25lbnQoKTtcclxuICAgIHJldHVybiAoY29tcG9uZW50ID09PSBudWxsIHx8IGNvbXBvbmVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29tcG9uZW50LnR5cGUpID09PSBcIlZFUlNJT05cIiAvKiBWRVJTSU9OICovO1xyXG59XG5cbmNvbnN0IG5hbWUkbyA9IFwiQGZpcmViYXNlL2FwcFwiO1xuY29uc3QgdmVyc2lvbiQxID0gXCIwLjcuMThcIjtcblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuY29uc3QgbG9nZ2VyID0gbmV3IExvZ2dlcignQGZpcmViYXNlL2FwcCcpO1xuXG5jb25zdCBuYW1lJG4gPSBcIkBmaXJlYmFzZS9hcHAtY29tcGF0XCI7XG5cbmNvbnN0IG5hbWUkbSA9IFwiQGZpcmViYXNlL2FuYWx5dGljcy1jb21wYXRcIjtcblxuY29uc3QgbmFtZSRsID0gXCJAZmlyZWJhc2UvYW5hbHl0aWNzXCI7XG5cbmNvbnN0IG5hbWUkayA9IFwiQGZpcmViYXNlL2FwcC1jaGVjay1jb21wYXRcIjtcblxuY29uc3QgbmFtZSRqID0gXCJAZmlyZWJhc2UvYXBwLWNoZWNrXCI7XG5cbmNvbnN0IG5hbWUkaSA9IFwiQGZpcmViYXNlL2F1dGhcIjtcblxuY29uc3QgbmFtZSRoID0gXCJAZmlyZWJhc2UvYXV0aC1jb21wYXRcIjtcblxuY29uc3QgbmFtZSRnID0gXCJAZmlyZWJhc2UvZGF0YWJhc2VcIjtcblxuY29uc3QgbmFtZSRmID0gXCJAZmlyZWJhc2UvZGF0YWJhc2UtY29tcGF0XCI7XG5cbmNvbnN0IG5hbWUkZSA9IFwiQGZpcmViYXNlL2Z1bmN0aW9uc1wiO1xuXG5jb25zdCBuYW1lJGQgPSBcIkBmaXJlYmFzZS9mdW5jdGlvbnMtY29tcGF0XCI7XG5cbmNvbnN0IG5hbWUkYyA9IFwiQGZpcmViYXNlL2luc3RhbGxhdGlvbnNcIjtcblxuY29uc3QgbmFtZSRiID0gXCJAZmlyZWJhc2UvaW5zdGFsbGF0aW9ucy1jb21wYXRcIjtcblxuY29uc3QgbmFtZSRhID0gXCJAZmlyZWJhc2UvbWVzc2FnaW5nXCI7XG5cbmNvbnN0IG5hbWUkOSA9IFwiQGZpcmViYXNlL21lc3NhZ2luZy1jb21wYXRcIjtcblxuY29uc3QgbmFtZSQ4ID0gXCJAZmlyZWJhc2UvcGVyZm9ybWFuY2VcIjtcblxuY29uc3QgbmFtZSQ3ID0gXCJAZmlyZWJhc2UvcGVyZm9ybWFuY2UtY29tcGF0XCI7XG5cbmNvbnN0IG5hbWUkNiA9IFwiQGZpcmViYXNlL3JlbW90ZS1jb25maWdcIjtcblxuY29uc3QgbmFtZSQ1ID0gXCJAZmlyZWJhc2UvcmVtb3RlLWNvbmZpZy1jb21wYXRcIjtcblxuY29uc3QgbmFtZSQ0ID0gXCJAZmlyZWJhc2Uvc3RvcmFnZVwiO1xuXG5jb25zdCBuYW1lJDMgPSBcIkBmaXJlYmFzZS9zdG9yYWdlLWNvbXBhdFwiO1xuXG5jb25zdCBuYW1lJDIgPSBcIkBmaXJlYmFzZS9maXJlc3RvcmVcIjtcblxuY29uc3QgbmFtZSQxID0gXCJAZmlyZWJhc2UvZmlyZXN0b3JlLWNvbXBhdFwiO1xuXG5jb25zdCBuYW1lID0gXCJmaXJlYmFzZVwiO1xuY29uc3QgdmVyc2lvbiA9IFwiOS42LjhcIjtcblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIFRoZSBkZWZhdWx0IGFwcCBuYW1lXHJcbiAqXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cclxuY29uc3QgREVGQVVMVF9FTlRSWV9OQU1FID0gJ1tERUZBVUxUXSc7XHJcbmNvbnN0IFBMQVRGT1JNX0xPR19TVFJJTkcgPSB7XHJcbiAgICBbbmFtZSRvXTogJ2ZpcmUtY29yZScsXHJcbiAgICBbbmFtZSRuXTogJ2ZpcmUtY29yZS1jb21wYXQnLFxyXG4gICAgW25hbWUkbF06ICdmaXJlLWFuYWx5dGljcycsXHJcbiAgICBbbmFtZSRtXTogJ2ZpcmUtYW5hbHl0aWNzLWNvbXBhdCcsXHJcbiAgICBbbmFtZSRqXTogJ2ZpcmUtYXBwLWNoZWNrJyxcclxuICAgIFtuYW1lJGtdOiAnZmlyZS1hcHAtY2hlY2stY29tcGF0JyxcclxuICAgIFtuYW1lJGldOiAnZmlyZS1hdXRoJyxcclxuICAgIFtuYW1lJGhdOiAnZmlyZS1hdXRoLWNvbXBhdCcsXHJcbiAgICBbbmFtZSRnXTogJ2ZpcmUtcnRkYicsXHJcbiAgICBbbmFtZSRmXTogJ2ZpcmUtcnRkYi1jb21wYXQnLFxyXG4gICAgW25hbWUkZV06ICdmaXJlLWZuJyxcclxuICAgIFtuYW1lJGRdOiAnZmlyZS1mbi1jb21wYXQnLFxyXG4gICAgW25hbWUkY106ICdmaXJlLWlpZCcsXHJcbiAgICBbbmFtZSRiXTogJ2ZpcmUtaWlkLWNvbXBhdCcsXHJcbiAgICBbbmFtZSRhXTogJ2ZpcmUtZmNtJyxcclxuICAgIFtuYW1lJDldOiAnZmlyZS1mY20tY29tcGF0JyxcclxuICAgIFtuYW1lJDhdOiAnZmlyZS1wZXJmJyxcclxuICAgIFtuYW1lJDddOiAnZmlyZS1wZXJmLWNvbXBhdCcsXHJcbiAgICBbbmFtZSQ2XTogJ2ZpcmUtcmMnLFxyXG4gICAgW25hbWUkNV06ICdmaXJlLXJjLWNvbXBhdCcsXHJcbiAgICBbbmFtZSQ0XTogJ2ZpcmUtZ2NzJyxcclxuICAgIFtuYW1lJDNdOiAnZmlyZS1nY3MtY29tcGF0JyxcclxuICAgIFtuYW1lJDJdOiAnZmlyZS1mc3QnLFxyXG4gICAgW25hbWUkMV06ICdmaXJlLWZzdC1jb21wYXQnLFxyXG4gICAgJ2ZpcmUtanMnOiAnZmlyZS1qcycsXHJcbiAgICBbbmFtZV06ICdmaXJlLWpzLWFsbCdcclxufTtcblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cclxuY29uc3QgX2FwcHMgPSBuZXcgTWFwKCk7XHJcbi8qKlxyXG4gKiBSZWdpc3RlcmVkIGNvbXBvbmVudHMuXHJcbiAqXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cclxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcclxuY29uc3QgX2NvbXBvbmVudHMgPSBuZXcgTWFwKCk7XHJcbi8qKlxyXG4gKiBAcGFyYW0gY29tcG9uZW50IC0gdGhlIGNvbXBvbmVudCBiZWluZyBhZGRlZCB0byB0aGlzIGFwcCdzIGNvbnRhaW5lclxyXG4gKlxyXG4gKiBAaW50ZXJuYWxcclxuICovXHJcbmZ1bmN0aW9uIF9hZGRDb21wb25lbnQoYXBwLCBjb21wb25lbnQpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgYXBwLmNvbnRhaW5lci5hZGRDb21wb25lbnQoY29tcG9uZW50KTtcclxuICAgIH1cclxuICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgbG9nZ2VyLmRlYnVnKGBDb21wb25lbnQgJHtjb21wb25lbnQubmFtZX0gZmFpbGVkIHRvIHJlZ2lzdGVyIHdpdGggRmlyZWJhc2VBcHAgJHthcHAubmFtZX1gLCBlKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICpcclxuICogQGludGVybmFsXHJcbiAqL1xyXG5mdW5jdGlvbiBfYWRkT3JPdmVyd3JpdGVDb21wb25lbnQoYXBwLCBjb21wb25lbnQpIHtcclxuICAgIGFwcC5jb250YWluZXIuYWRkT3JPdmVyd3JpdGVDb21wb25lbnQoY29tcG9uZW50KTtcclxufVxyXG4vKipcclxuICpcclxuICogQHBhcmFtIGNvbXBvbmVudCAtIHRoZSBjb21wb25lbnQgdG8gcmVnaXN0ZXJcclxuICogQHJldHVybnMgd2hldGhlciBvciBub3QgdGhlIGNvbXBvbmVudCBpcyByZWdpc3RlcmVkIHN1Y2Nlc3NmdWxseVxyXG4gKlxyXG4gKiBAaW50ZXJuYWxcclxuICovXHJcbmZ1bmN0aW9uIF9yZWdpc3RlckNvbXBvbmVudChjb21wb25lbnQpIHtcclxuICAgIGNvbnN0IGNvbXBvbmVudE5hbWUgPSBjb21wb25lbnQubmFtZTtcclxuICAgIGlmIChfY29tcG9uZW50cy5oYXMoY29tcG9uZW50TmFtZSkpIHtcclxuICAgICAgICBsb2dnZXIuZGVidWcoYFRoZXJlIHdlcmUgbXVsdGlwbGUgYXR0ZW1wdHMgdG8gcmVnaXN0ZXIgY29tcG9uZW50ICR7Y29tcG9uZW50TmFtZX0uYCk7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgX2NvbXBvbmVudHMuc2V0KGNvbXBvbmVudE5hbWUsIGNvbXBvbmVudCk7XHJcbiAgICAvLyBhZGQgdGhlIGNvbXBvbmVudCB0byBleGlzdGluZyBhcHAgaW5zdGFuY2VzXHJcbiAgICBmb3IgKGNvbnN0IGFwcCBvZiBfYXBwcy52YWx1ZXMoKSkge1xyXG4gICAgICAgIF9hZGRDb21wb25lbnQoYXBwLCBjb21wb25lbnQpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbn1cclxuLyoqXHJcbiAqXHJcbiAqIEBwYXJhbSBhcHAgLSBGaXJlYmFzZUFwcCBpbnN0YW5jZVxyXG4gKiBAcGFyYW0gbmFtZSAtIHNlcnZpY2UgbmFtZVxyXG4gKlxyXG4gKiBAcmV0dXJucyB0aGUgcHJvdmlkZXIgZm9yIHRoZSBzZXJ2aWNlIHdpdGggdGhlIG1hdGNoaW5nIG5hbWVcclxuICpcclxuICogQGludGVybmFsXHJcbiAqL1xyXG5mdW5jdGlvbiBfZ2V0UHJvdmlkZXIoYXBwLCBuYW1lKSB7XHJcbiAgICBjb25zdCBoZWFydGJlYXRDb250cm9sbGVyID0gYXBwLmNvbnRhaW5lclxyXG4gICAgICAgIC5nZXRQcm92aWRlcignaGVhcnRiZWF0JylcclxuICAgICAgICAuZ2V0SW1tZWRpYXRlKHsgb3B0aW9uYWw6IHRydWUgfSk7XHJcbiAgICBpZiAoaGVhcnRiZWF0Q29udHJvbGxlcikge1xyXG4gICAgICAgIHZvaWQgaGVhcnRiZWF0Q29udHJvbGxlci50cmlnZ2VySGVhcnRiZWF0KCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYXBwLmNvbnRhaW5lci5nZXRQcm92aWRlcihuYW1lKTtcclxufVxyXG4vKipcclxuICpcclxuICogQHBhcmFtIGFwcCAtIEZpcmViYXNlQXBwIGluc3RhbmNlXHJcbiAqIEBwYXJhbSBuYW1lIC0gc2VydmljZSBuYW1lXHJcbiAqIEBwYXJhbSBpbnN0YW5jZUlkZW50aWZpZXIgLSBzZXJ2aWNlIGluc3RhbmNlIGlkZW50aWZpZXIgaW4gY2FzZSB0aGUgc2VydmljZSBzdXBwb3J0cyBtdWx0aXBsZSBpbnN0YW5jZXNcclxuICpcclxuICogQGludGVybmFsXHJcbiAqL1xyXG5mdW5jdGlvbiBfcmVtb3ZlU2VydmljZUluc3RhbmNlKGFwcCwgbmFtZSwgaW5zdGFuY2VJZGVudGlmaWVyID0gREVGQVVMVF9FTlRSWV9OQU1FKSB7XHJcbiAgICBfZ2V0UHJvdmlkZXIoYXBwLCBuYW1lKS5jbGVhckluc3RhbmNlKGluc3RhbmNlSWRlbnRpZmllcik7XHJcbn1cclxuLyoqXHJcbiAqIFRlc3Qgb25seVxyXG4gKlxyXG4gKiBAaW50ZXJuYWxcclxuICovXHJcbmZ1bmN0aW9uIF9jbGVhckNvbXBvbmVudHMoKSB7XHJcbiAgICBfY29tcG9uZW50cy5jbGVhcigpO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmNvbnN0IEVSUk9SUyA9IHtcclxuICAgIFtcIm5vLWFwcFwiIC8qIE5PX0FQUCAqL106IFwiTm8gRmlyZWJhc2UgQXBwICd7JGFwcE5hbWV9JyBoYXMgYmVlbiBjcmVhdGVkIC0gXCIgK1xyXG4gICAgICAgICdjYWxsIEZpcmViYXNlIEFwcC5pbml0aWFsaXplQXBwKCknLFxyXG4gICAgW1wiYmFkLWFwcC1uYW1lXCIgLyogQkFEX0FQUF9OQU1FICovXTogXCJJbGxlZ2FsIEFwcCBuYW1lOiAneyRhcHBOYW1lfVwiLFxyXG4gICAgW1wiZHVwbGljYXRlLWFwcFwiIC8qIERVUExJQ0FURV9BUFAgKi9dOiBcIkZpcmViYXNlIEFwcCBuYW1lZCAneyRhcHBOYW1lfScgYWxyZWFkeSBleGlzdHMgd2l0aCBkaWZmZXJlbnQgb3B0aW9ucyBvciBjb25maWdcIixcclxuICAgIFtcImFwcC1kZWxldGVkXCIgLyogQVBQX0RFTEVURUQgKi9dOiBcIkZpcmViYXNlIEFwcCBuYW1lZCAneyRhcHBOYW1lfScgYWxyZWFkeSBkZWxldGVkXCIsXHJcbiAgICBbXCJpbnZhbGlkLWFwcC1hcmd1bWVudFwiIC8qIElOVkFMSURfQVBQX0FSR1VNRU5UICovXTogJ2ZpcmViYXNlLnskYXBwTmFtZX0oKSB0YWtlcyBlaXRoZXIgbm8gYXJndW1lbnQgb3IgYSAnICtcclxuICAgICAgICAnRmlyZWJhc2UgQXBwIGluc3RhbmNlLicsXHJcbiAgICBbXCJpbnZhbGlkLWxvZy1hcmd1bWVudFwiIC8qIElOVkFMSURfTE9HX0FSR1VNRU5UICovXTogJ0ZpcnN0IGFyZ3VtZW50IHRvIGBvbkxvZ2AgbXVzdCBiZSBudWxsIG9yIGEgZnVuY3Rpb24uJyxcclxuICAgIFtcInN0b3JhZ2Utb3BlblwiIC8qIFNUT1JBR0VfT1BFTiAqL106ICdFcnJvciB0aHJvd24gd2hlbiBvcGVuaW5nIHN0b3JhZ2UuIE9yaWdpbmFsIGVycm9yOiB7JG9yaWdpbmFsRXJyb3JNZXNzYWdlfS4nLFxyXG4gICAgW1wic3RvcmFnZS1nZXRcIiAvKiBTVE9SQUdFX0dFVCAqL106ICdFcnJvciB0aHJvd24gd2hlbiByZWFkaW5nIGZyb20gc3RvcmFnZS4gT3JpZ2luYWwgZXJyb3I6IHskb3JpZ2luYWxFcnJvck1lc3NhZ2V9LicsXHJcbiAgICBbXCJzdG9yYWdlLXNldFwiIC8qIFNUT1JBR0VfV1JJVEUgKi9dOiAnRXJyb3IgdGhyb3duIHdoZW4gd3JpdGluZyB0byBzdG9yYWdlLiBPcmlnaW5hbCBlcnJvcjogeyRvcmlnaW5hbEVycm9yTWVzc2FnZX0uJyxcclxuICAgIFtcInN0b3JhZ2UtZGVsZXRlXCIgLyogU1RPUkFHRV9ERUxFVEUgKi9dOiAnRXJyb3IgdGhyb3duIHdoZW4gZGVsZXRpbmcgZnJvbSBzdG9yYWdlLiBPcmlnaW5hbCBlcnJvcjogeyRvcmlnaW5hbEVycm9yTWVzc2FnZX0uJ1xyXG59O1xyXG5jb25zdCBFUlJPUl9GQUNUT1JZID0gbmV3IEVycm9yRmFjdG9yeSgnYXBwJywgJ0ZpcmViYXNlJywgRVJST1JTKTtcblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuY2xhc3MgRmlyZWJhc2VBcHBJbXBsIHtcclxuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMsIGNvbmZpZywgY29udGFpbmVyKSB7XHJcbiAgICAgICAgdGhpcy5faXNEZWxldGVkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5fb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMpO1xyXG4gICAgICAgIHRoaXMuX2NvbmZpZyA9IE9iamVjdC5hc3NpZ24oe30sIGNvbmZpZyk7XHJcbiAgICAgICAgdGhpcy5fbmFtZSA9IGNvbmZpZy5uYW1lO1xyXG4gICAgICAgIHRoaXMuX2F1dG9tYXRpY0RhdGFDb2xsZWN0aW9uRW5hYmxlZCA9XHJcbiAgICAgICAgICAgIGNvbmZpZy5hdXRvbWF0aWNEYXRhQ29sbGVjdGlvbkVuYWJsZWQ7XHJcbiAgICAgICAgdGhpcy5fY29udGFpbmVyID0gY29udGFpbmVyO1xyXG4gICAgICAgIHRoaXMuY29udGFpbmVyLmFkZENvbXBvbmVudChuZXcgQ29tcG9uZW50KCdhcHAnLCAoKSA9PiB0aGlzLCBcIlBVQkxJQ1wiIC8qIFBVQkxJQyAqLykpO1xyXG4gICAgfVxyXG4gICAgZ2V0IGF1dG9tYXRpY0RhdGFDb2xsZWN0aW9uRW5hYmxlZCgpIHtcclxuICAgICAgICB0aGlzLmNoZWNrRGVzdHJveWVkKCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2F1dG9tYXRpY0RhdGFDb2xsZWN0aW9uRW5hYmxlZDtcclxuICAgIH1cclxuICAgIHNldCBhdXRvbWF0aWNEYXRhQ29sbGVjdGlvbkVuYWJsZWQodmFsKSB7XHJcbiAgICAgICAgdGhpcy5jaGVja0Rlc3Ryb3llZCgpO1xyXG4gICAgICAgIHRoaXMuX2F1dG9tYXRpY0RhdGFDb2xsZWN0aW9uRW5hYmxlZCA9IHZhbDtcclxuICAgIH1cclxuICAgIGdldCBuYW1lKCkge1xyXG4gICAgICAgIHRoaXMuY2hlY2tEZXN0cm95ZWQoKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5fbmFtZTtcclxuICAgIH1cclxuICAgIGdldCBvcHRpb25zKCkge1xyXG4gICAgICAgIHRoaXMuY2hlY2tEZXN0cm95ZWQoKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5fb3B0aW9ucztcclxuICAgIH1cclxuICAgIGdldCBjb25maWcoKSB7XHJcbiAgICAgICAgdGhpcy5jaGVja0Rlc3Ryb3llZCgpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9jb25maWc7XHJcbiAgICB9XHJcbiAgICBnZXQgY29udGFpbmVyKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9jb250YWluZXI7XHJcbiAgICB9XHJcbiAgICBnZXQgaXNEZWxldGVkKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9pc0RlbGV0ZWQ7XHJcbiAgICB9XHJcbiAgICBzZXQgaXNEZWxldGVkKHZhbCkge1xyXG4gICAgICAgIHRoaXMuX2lzRGVsZXRlZCA9IHZhbDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBmdW5jdGlvbiB3aWxsIHRocm93IGFuIEVycm9yIGlmIHRoZSBBcHAgaGFzIGFscmVhZHkgYmVlbiBkZWxldGVkIC1cclxuICAgICAqIHVzZSBiZWZvcmUgcGVyZm9ybWluZyBBUEkgYWN0aW9ucyBvbiB0aGUgQXBwLlxyXG4gICAgICovXHJcbiAgICBjaGVja0Rlc3Ryb3llZCgpIHtcclxuICAgICAgICBpZiAodGhpcy5pc0RlbGV0ZWQpIHtcclxuICAgICAgICAgICAgdGhyb3cgRVJST1JfRkFDVE9SWS5jcmVhdGUoXCJhcHAtZGVsZXRlZFwiIC8qIEFQUF9ERUxFVEVEICovLCB7IGFwcE5hbWU6IHRoaXMuX25hbWUgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBUaGUgY3VycmVudCBTREsgdmVyc2lvbi5cclxuICpcclxuICogQHB1YmxpY1xyXG4gKi9cclxuY29uc3QgU0RLX1ZFUlNJT04gPSB2ZXJzaW9uO1xyXG5mdW5jdGlvbiBpbml0aWFsaXplQXBwKG9wdGlvbnMsIHJhd0NvbmZpZyA9IHt9KSB7XHJcbiAgICBpZiAodHlwZW9mIHJhd0NvbmZpZyAhPT0gJ29iamVjdCcpIHtcclxuICAgICAgICBjb25zdCBuYW1lID0gcmF3Q29uZmlnO1xyXG4gICAgICAgIHJhd0NvbmZpZyA9IHsgbmFtZSB9O1xyXG4gICAgfVxyXG4gICAgY29uc3QgY29uZmlnID0gT2JqZWN0LmFzc2lnbih7IG5hbWU6IERFRkFVTFRfRU5UUllfTkFNRSwgYXV0b21hdGljRGF0YUNvbGxlY3Rpb25FbmFibGVkOiBmYWxzZSB9LCByYXdDb25maWcpO1xyXG4gICAgY29uc3QgbmFtZSA9IGNvbmZpZy5uYW1lO1xyXG4gICAgaWYgKHR5cGVvZiBuYW1lICE9PSAnc3RyaW5nJyB8fCAhbmFtZSkge1xyXG4gICAgICAgIHRocm93IEVSUk9SX0ZBQ1RPUlkuY3JlYXRlKFwiYmFkLWFwcC1uYW1lXCIgLyogQkFEX0FQUF9OQU1FICovLCB7XHJcbiAgICAgICAgICAgIGFwcE5hbWU6IFN0cmluZyhuYW1lKVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgY29uc3QgZXhpc3RpbmdBcHAgPSBfYXBwcy5nZXQobmFtZSk7XHJcbiAgICBpZiAoZXhpc3RpbmdBcHApIHtcclxuICAgICAgICAvLyByZXR1cm4gdGhlIGV4aXN0aW5nIGFwcCBpZiBvcHRpb25zIGFuZCBjb25maWcgZGVlcCBlcXVhbCB0aGUgb25lcyBpbiB0aGUgZXhpc3RpbmcgYXBwLlxyXG4gICAgICAgIGlmIChkZWVwRXF1YWwob3B0aW9ucywgZXhpc3RpbmdBcHAub3B0aW9ucykgJiZcclxuICAgICAgICAgICAgZGVlcEVxdWFsKGNvbmZpZywgZXhpc3RpbmdBcHAuY29uZmlnKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZXhpc3RpbmdBcHA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aHJvdyBFUlJPUl9GQUNUT1JZLmNyZWF0ZShcImR1cGxpY2F0ZS1hcHBcIiAvKiBEVVBMSUNBVEVfQVBQICovLCB7IGFwcE5hbWU6IG5hbWUgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY29uc3QgY29udGFpbmVyID0gbmV3IENvbXBvbmVudENvbnRhaW5lcihuYW1lKTtcclxuICAgIGZvciAoY29uc3QgY29tcG9uZW50IG9mIF9jb21wb25lbnRzLnZhbHVlcygpKSB7XHJcbiAgICAgICAgY29udGFpbmVyLmFkZENvbXBvbmVudChjb21wb25lbnQpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgbmV3QXBwID0gbmV3IEZpcmViYXNlQXBwSW1wbChvcHRpb25zLCBjb25maWcsIGNvbnRhaW5lcik7XHJcbiAgICBfYXBwcy5zZXQobmFtZSwgbmV3QXBwKTtcclxuICAgIHJldHVybiBuZXdBcHA7XHJcbn1cclxuLyoqXHJcbiAqIFJldHJpZXZlcyBhIHtAbGluayBAZmlyZWJhc2UvYXBwI0ZpcmViYXNlQXBwfSBpbnN0YW5jZS5cclxuICpcclxuICogV2hlbiBjYWxsZWQgd2l0aCBubyBhcmd1bWVudHMsIHRoZSBkZWZhdWx0IGFwcCBpcyByZXR1cm5lZC4gV2hlbiBhbiBhcHAgbmFtZVxyXG4gKiBpcyBwcm92aWRlZCwgdGhlIGFwcCBjb3JyZXNwb25kaW5nIHRvIHRoYXQgbmFtZSBpcyByZXR1cm5lZC5cclxuICpcclxuICogQW4gZXhjZXB0aW9uIGlzIHRocm93biBpZiB0aGUgYXBwIGJlaW5nIHJldHJpZXZlZCBoYXMgbm90IHlldCBiZWVuXHJcbiAqIGluaXRpYWxpemVkLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKiBgYGBqYXZhc2NyaXB0XHJcbiAqIC8vIFJldHVybiB0aGUgZGVmYXVsdCBhcHBcclxuICogY29uc3QgYXBwID0gZ2V0QXBwKCk7XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKiBgYGBqYXZhc2NyaXB0XHJcbiAqIC8vIFJldHVybiBhIG5hbWVkIGFwcFxyXG4gKiBjb25zdCBvdGhlckFwcCA9IGdldEFwcChcIm90aGVyQXBwXCIpO1xyXG4gKiBgYGBcclxuICpcclxuICogQHBhcmFtIG5hbWUgLSBPcHRpb25hbCBuYW1lIG9mIHRoZSBhcHAgdG8gcmV0dXJuLiBJZiBubyBuYW1lIGlzXHJcbiAqICAgcHJvdmlkZWQsIHRoZSBkZWZhdWx0IGlzIGBcIltERUZBVUxUXVwiYC5cclxuICpcclxuICogQHJldHVybnMgVGhlIGFwcCBjb3JyZXNwb25kaW5nIHRvIHRoZSBwcm92aWRlZCBhcHAgbmFtZS5cclxuICogICBJZiBubyBhcHAgbmFtZSBpcyBwcm92aWRlZCwgdGhlIGRlZmF1bHQgYXBwIGlzIHJldHVybmVkLlxyXG4gKlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRBcHAobmFtZSA9IERFRkFVTFRfRU5UUllfTkFNRSkge1xyXG4gICAgY29uc3QgYXBwID0gX2FwcHMuZ2V0KG5hbWUpO1xyXG4gICAgaWYgKCFhcHApIHtcclxuICAgICAgICB0aHJvdyBFUlJPUl9GQUNUT1JZLmNyZWF0ZShcIm5vLWFwcFwiIC8qIE5PX0FQUCAqLywgeyBhcHBOYW1lOiBuYW1lIH0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGFwcDtcclxufVxyXG4vKipcclxuICogQSAocmVhZC1vbmx5KSBhcnJheSBvZiBhbGwgaW5pdGlhbGl6ZWQgYXBwcy5cclxuICogQHB1YmxpY1xyXG4gKi9cclxuZnVuY3Rpb24gZ2V0QXBwcygpIHtcclxuICAgIHJldHVybiBBcnJheS5mcm9tKF9hcHBzLnZhbHVlcygpKTtcclxufVxyXG4vKipcclxuICogUmVuZGVycyB0aGlzIGFwcCB1bnVzYWJsZSBhbmQgZnJlZXMgdGhlIHJlc291cmNlcyBvZiBhbGwgYXNzb2NpYXRlZFxyXG4gKiBzZXJ2aWNlcy5cclxuICpcclxuICogQGV4YW1wbGVcclxuICogYGBgamF2YXNjcmlwdFxyXG4gKiBkZWxldGVBcHAoYXBwKVxyXG4gKiAgIC50aGVuKGZ1bmN0aW9uKCkge1xyXG4gKiAgICAgY29uc29sZS5sb2coXCJBcHAgZGVsZXRlZCBzdWNjZXNzZnVsbHlcIik7XHJcbiAqICAgfSlcclxuICogICAuY2F0Y2goZnVuY3Rpb24oZXJyb3IpIHtcclxuICogICAgIGNvbnNvbGUubG9nKFwiRXJyb3IgZGVsZXRpbmcgYXBwOlwiLCBlcnJvcik7XHJcbiAqICAgfSk7XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5hc3luYyBmdW5jdGlvbiBkZWxldGVBcHAoYXBwKSB7XHJcbiAgICBjb25zdCBuYW1lID0gYXBwLm5hbWU7XHJcbiAgICBpZiAoX2FwcHMuaGFzKG5hbWUpKSB7XHJcbiAgICAgICAgX2FwcHMuZGVsZXRlKG5hbWUpO1xyXG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKGFwcC5jb250YWluZXJcclxuICAgICAgICAgICAgLmdldFByb3ZpZGVycygpXHJcbiAgICAgICAgICAgIC5tYXAocHJvdmlkZXIgPT4gcHJvdmlkZXIuZGVsZXRlKCkpKTtcclxuICAgICAgICBhcHAuaXNEZWxldGVkID0gdHJ1ZTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogUmVnaXN0ZXJzIGEgbGlicmFyeSdzIG5hbWUgYW5kIHZlcnNpb24gZm9yIHBsYXRmb3JtIGxvZ2dpbmcgcHVycG9zZXMuXHJcbiAqIEBwYXJhbSBsaWJyYXJ5IC0gTmFtZSBvZiAxcCBvciAzcCBsaWJyYXJ5IChlLmcuIGZpcmVzdG9yZSwgYW5ndWxhcmZpcmUpXHJcbiAqIEBwYXJhbSB2ZXJzaW9uIC0gQ3VycmVudCB2ZXJzaW9uIG9mIHRoYXQgbGlicmFyeS5cclxuICogQHBhcmFtIHZhcmlhbnQgLSBCdW5kbGUgdmFyaWFudCwgZS5nLiwgbm9kZSwgcm4sIGV0Yy5cclxuICpcclxuICogQHB1YmxpY1xyXG4gKi9cclxuZnVuY3Rpb24gcmVnaXN0ZXJWZXJzaW9uKGxpYnJhcnlLZXlPck5hbWUsIHZlcnNpb24sIHZhcmlhbnQpIHtcclxuICAgIHZhciBfYTtcclxuICAgIC8vIFRPRE86IFdlIGNhbiB1c2UgdGhpcyBjaGVjayB0byB3aGl0ZWxpc3Qgc3RyaW5ncyB3aGVuL2lmIHdlIHNldCB1cFxyXG4gICAgLy8gYSBnb29kIHdoaXRlbGlzdCBzeXN0ZW0uXHJcbiAgICBsZXQgbGlicmFyeSA9IChfYSA9IFBMQVRGT1JNX0xPR19TVFJJTkdbbGlicmFyeUtleU9yTmFtZV0pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGxpYnJhcnlLZXlPck5hbWU7XHJcbiAgICBpZiAodmFyaWFudCkge1xyXG4gICAgICAgIGxpYnJhcnkgKz0gYC0ke3ZhcmlhbnR9YDtcclxuICAgIH1cclxuICAgIGNvbnN0IGxpYnJhcnlNaXNtYXRjaCA9IGxpYnJhcnkubWF0Y2goL1xcc3xcXC8vKTtcclxuICAgIGNvbnN0IHZlcnNpb25NaXNtYXRjaCA9IHZlcnNpb24ubWF0Y2goL1xcc3xcXC8vKTtcclxuICAgIGlmIChsaWJyYXJ5TWlzbWF0Y2ggfHwgdmVyc2lvbk1pc21hdGNoKSB7XHJcbiAgICAgICAgY29uc3Qgd2FybmluZyA9IFtcclxuICAgICAgICAgICAgYFVuYWJsZSB0byByZWdpc3RlciBsaWJyYXJ5IFwiJHtsaWJyYXJ5fVwiIHdpdGggdmVyc2lvbiBcIiR7dmVyc2lvbn1cIjpgXHJcbiAgICAgICAgXTtcclxuICAgICAgICBpZiAobGlicmFyeU1pc21hdGNoKSB7XHJcbiAgICAgICAgICAgIHdhcm5pbmcucHVzaChgbGlicmFyeSBuYW1lIFwiJHtsaWJyYXJ5fVwiIGNvbnRhaW5zIGlsbGVnYWwgY2hhcmFjdGVycyAod2hpdGVzcGFjZSBvciBcIi9cIilgKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGxpYnJhcnlNaXNtYXRjaCAmJiB2ZXJzaW9uTWlzbWF0Y2gpIHtcclxuICAgICAgICAgICAgd2FybmluZy5wdXNoKCdhbmQnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHZlcnNpb25NaXNtYXRjaCkge1xyXG4gICAgICAgICAgICB3YXJuaW5nLnB1c2goYHZlcnNpb24gbmFtZSBcIiR7dmVyc2lvbn1cIiBjb250YWlucyBpbGxlZ2FsIGNoYXJhY3RlcnMgKHdoaXRlc3BhY2Ugb3IgXCIvXCIpYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxvZ2dlci53YXJuKHdhcm5pbmcuam9pbignICcpKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBfcmVnaXN0ZXJDb21wb25lbnQobmV3IENvbXBvbmVudChgJHtsaWJyYXJ5fS12ZXJzaW9uYCwgKCkgPT4gKHsgbGlicmFyeSwgdmVyc2lvbiB9KSwgXCJWRVJTSU9OXCIgLyogVkVSU0lPTiAqLykpO1xyXG59XHJcbi8qKlxyXG4gKiBTZXRzIGxvZyBoYW5kbGVyIGZvciBhbGwgRmlyZWJhc2UgU0RLcy5cclxuICogQHBhcmFtIGxvZ0NhbGxiYWNrIC0gQW4gb3B0aW9uYWwgY3VzdG9tIGxvZyBoYW5kbGVyIHRoYXQgZXhlY3V0ZXMgdXNlciBjb2RlIHdoZW5ldmVyXHJcbiAqIHRoZSBGaXJlYmFzZSBTREsgbWFrZXMgYSBsb2dnaW5nIGNhbGwuXHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmZ1bmN0aW9uIG9uTG9nKGxvZ0NhbGxiYWNrLCBvcHRpb25zKSB7XHJcbiAgICBpZiAobG9nQ2FsbGJhY2sgIT09IG51bGwgJiYgdHlwZW9mIGxvZ0NhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgdGhyb3cgRVJST1JfRkFDVE9SWS5jcmVhdGUoXCJpbnZhbGlkLWxvZy1hcmd1bWVudFwiIC8qIElOVkFMSURfTE9HX0FSR1VNRU5UICovKTtcclxuICAgIH1cclxuICAgIHNldFVzZXJMb2dIYW5kbGVyKGxvZ0NhbGxiYWNrLCBvcHRpb25zKTtcclxufVxyXG4vKipcclxuICogU2V0cyBsb2cgbGV2ZWwgZm9yIGFsbCBGaXJlYmFzZSBTREtzLlxyXG4gKlxyXG4gKiBBbGwgb2YgdGhlIGxvZyB0eXBlcyBhYm92ZSB0aGUgY3VycmVudCBsb2cgbGV2ZWwgYXJlIGNhcHR1cmVkIChpLmUuIGlmXHJcbiAqIHlvdSBzZXQgdGhlIGxvZyBsZXZlbCB0byBgaW5mb2AsIGVycm9ycyBhcmUgbG9nZ2VkLCBidXQgYGRlYnVnYCBhbmRcclxuICogYHZlcmJvc2VgIGxvZ3MgYXJlIG5vdCkuXHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmZ1bmN0aW9uIHNldExvZ0xldmVsKGxvZ0xldmVsKSB7XHJcbiAgICBzZXRMb2dMZXZlbCQxKGxvZ0xldmVsKTtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjEgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5jb25zdCBEQl9OQU1FID0gJ2ZpcmViYXNlLWhlYXJ0YmVhdC1kYXRhYmFzZSc7XHJcbmNvbnN0IERCX1ZFUlNJT04gPSAxO1xyXG5jb25zdCBTVE9SRV9OQU1FID0gJ2ZpcmViYXNlLWhlYXJ0YmVhdC1zdG9yZSc7XHJcbmxldCBkYlByb21pc2UgPSBudWxsO1xyXG5mdW5jdGlvbiBnZXREYlByb21pc2UoKSB7XHJcbiAgICBpZiAoIWRiUHJvbWlzZSkge1xyXG4gICAgICAgIGRiUHJvbWlzZSA9IG9wZW5EYihEQl9OQU1FLCBEQl9WRVJTSU9OLCB1cGdyYWRlREIgPT4ge1xyXG4gICAgICAgICAgICAvLyBXZSBkb24ndCB1c2UgJ2JyZWFrJyBpbiB0aGlzIHN3aXRjaCBzdGF0ZW1lbnQsIHRoZSBmYWxsLXRocm91Z2hcclxuICAgICAgICAgICAgLy8gYmVoYXZpb3IgaXMgd2hhdCB3ZSB3YW50LCBiZWNhdXNlIGlmIHRoZXJlIGFyZSBtdWx0aXBsZSB2ZXJzaW9ucyBiZXR3ZWVuXHJcbiAgICAgICAgICAgIC8vIHRoZSBvbGQgdmVyc2lvbiBhbmQgdGhlIGN1cnJlbnQgdmVyc2lvbiwgd2Ugd2FudCBBTEwgdGhlIG1pZ3JhdGlvbnNcclxuICAgICAgICAgICAgLy8gdGhhdCBjb3JyZXNwb25kIHRvIHRob3NlIHZlcnNpb25zIHRvIHJ1biwgbm90IG9ubHkgdGhlIGxhc3Qgb25lLlxyXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZGVmYXVsdC1jYXNlXHJcbiAgICAgICAgICAgIHN3aXRjaCAodXBncmFkZURCLm9sZFZlcnNpb24pIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICB1cGdyYWRlREIuY3JlYXRlT2JqZWN0U3RvcmUoU1RPUkVfTkFNRSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KS5jYXRjaChlID0+IHtcclxuICAgICAgICAgICAgdGhyb3cgRVJST1JfRkFDVE9SWS5jcmVhdGUoXCJzdG9yYWdlLW9wZW5cIiAvKiBTVE9SQUdFX09QRU4gKi8sIHtcclxuICAgICAgICAgICAgICAgIG9yaWdpbmFsRXJyb3JNZXNzYWdlOiBlLm1lc3NhZ2VcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZGJQcm9taXNlO1xyXG59XHJcbmFzeW5jIGZ1bmN0aW9uIHJlYWRIZWFydGJlYXRzRnJvbUluZGV4ZWREQihhcHApIHtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgY29uc3QgZGIgPSBhd2FpdCBnZXREYlByb21pc2UoKTtcclxuICAgICAgICByZXR1cm4gZGJcclxuICAgICAgICAgICAgLnRyYW5zYWN0aW9uKFNUT1JFX05BTUUpXHJcbiAgICAgICAgICAgIC5vYmplY3RTdG9yZShTVE9SRV9OQU1FKVxyXG4gICAgICAgICAgICAuZ2V0KGNvbXB1dGVLZXkoYXBwKSk7XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgIHRocm93IEVSUk9SX0ZBQ1RPUlkuY3JlYXRlKFwic3RvcmFnZS1nZXRcIiAvKiBTVE9SQUdFX0dFVCAqLywge1xyXG4gICAgICAgICAgICBvcmlnaW5hbEVycm9yTWVzc2FnZTogZS5tZXNzYWdlXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cclxuYXN5bmMgZnVuY3Rpb24gd3JpdGVIZWFydGJlYXRzVG9JbmRleGVkREIoYXBwLCBoZWFydGJlYXRPYmplY3QpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgY29uc3QgZGIgPSBhd2FpdCBnZXREYlByb21pc2UoKTtcclxuICAgICAgICBjb25zdCB0eCA9IGRiLnRyYW5zYWN0aW9uKFNUT1JFX05BTUUsICdyZWFkd3JpdGUnKTtcclxuICAgICAgICBjb25zdCBvYmplY3RTdG9yZSA9IHR4Lm9iamVjdFN0b3JlKFNUT1JFX05BTUUpO1xyXG4gICAgICAgIGF3YWl0IG9iamVjdFN0b3JlLnB1dChoZWFydGJlYXRPYmplY3QsIGNvbXB1dGVLZXkoYXBwKSk7XHJcbiAgICAgICAgcmV0dXJuIHR4LmNvbXBsZXRlO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICB0aHJvdyBFUlJPUl9GQUNUT1JZLmNyZWF0ZShcInN0b3JhZ2Utc2V0XCIgLyogU1RPUkFHRV9XUklURSAqLywge1xyXG4gICAgICAgICAgICBvcmlnaW5hbEVycm9yTWVzc2FnZTogZS5tZXNzYWdlXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cclxuYXN5bmMgZnVuY3Rpb24gZGVsZXRlSGVhcnRiZWF0c0Zyb21JbmRleGVkREIoYXBwKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIGNvbnN0IGRiID0gYXdhaXQgZ2V0RGJQcm9taXNlKCk7XHJcbiAgICAgICAgY29uc3QgdHggPSBkYi50cmFuc2FjdGlvbihTVE9SRV9OQU1FLCAncmVhZHdyaXRlJyk7XHJcbiAgICAgICAgYXdhaXQgdHgub2JqZWN0U3RvcmUoU1RPUkVfTkFNRSkuZGVsZXRlKGNvbXB1dGVLZXkoYXBwKSk7XHJcbiAgICAgICAgcmV0dXJuIHR4LmNvbXBsZXRlO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICB0aHJvdyBFUlJPUl9GQUNUT1JZLmNyZWF0ZShcInN0b3JhZ2UtZGVsZXRlXCIgLyogU1RPUkFHRV9ERUxFVEUgKi8sIHtcclxuICAgICAgICAgICAgb3JpZ2luYWxFcnJvck1lc3NhZ2U6IGUubWVzc2FnZVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGNvbXB1dGVLZXkoYXBwKSB7XHJcbiAgICByZXR1cm4gYCR7YXBwLm5hbWV9ISR7YXBwLm9wdGlvbnMuYXBwSWR9YDtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjEgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5jb25zdCBNQVhfSEVBREVSX0JZVEVTID0gMTAyNDtcclxuLy8gMzAgZGF5c1xyXG5jb25zdCBTVE9SRURfSEVBUlRCRUFUX1JFVEVOVElPTl9NQVhfTUlMTElTID0gMzAgKiAyNCAqIDYwICogNjAgKiAxMDAwO1xyXG5jbGFzcyBIZWFydGJlYXRTZXJ2aWNlSW1wbCB7XHJcbiAgICBjb25zdHJ1Y3Rvcihjb250YWluZXIpIHtcclxuICAgICAgICB0aGlzLmNvbnRhaW5lciA9IGNvbnRhaW5lcjtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBJbi1tZW1vcnkgY2FjaGUgZm9yIGhlYXJ0YmVhdHMsIHVzZWQgYnkgZ2V0SGVhcnRiZWF0c0hlYWRlcigpIHRvIGdlbmVyYXRlXHJcbiAgICAgICAgICogdGhlIGhlYWRlciBzdHJpbmcuXHJcbiAgICAgICAgICogU3RvcmVzIG9uZSByZWNvcmQgcGVyIGRhdGUuIFRoaXMgd2lsbCBiZSBjb25zb2xpZGF0ZWQgaW50byB0aGUgc3RhbmRhcmRcclxuICAgICAgICAgKiBmb3JtYXQgb2Ygb25lIHJlY29yZCBwZXIgdXNlciBhZ2VudCBzdHJpbmcgYmVmb3JlIGJlaW5nIHNlbnQgYXMgYSBoZWFkZXIuXHJcbiAgICAgICAgICogUG9wdWxhdGVkIGZyb20gaW5kZXhlZERCIHdoZW4gdGhlIGNvbnRyb2xsZXIgaXMgaW5zdGFudGlhdGVkIGFuZCBzaG91bGRcclxuICAgICAgICAgKiBiZSBrZXB0IGluIHN5bmMgd2l0aCBpbmRleGVkREIuXHJcbiAgICAgICAgICogTGVhdmUgcHVibGljIGZvciBlYXNpZXIgdGVzdGluZy5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLl9oZWFydGJlYXRzQ2FjaGUgPSBudWxsO1xyXG4gICAgICAgIGNvbnN0IGFwcCA9IHRoaXMuY29udGFpbmVyLmdldFByb3ZpZGVyKCdhcHAnKS5nZXRJbW1lZGlhdGUoKTtcclxuICAgICAgICB0aGlzLl9zdG9yYWdlID0gbmV3IEhlYXJ0YmVhdFN0b3JhZ2VJbXBsKGFwcCk7XHJcbiAgICAgICAgdGhpcy5faGVhcnRiZWF0c0NhY2hlUHJvbWlzZSA9IHRoaXMuX3N0b3JhZ2UucmVhZCgpLnRoZW4ocmVzdWx0ID0+IHtcclxuICAgICAgICAgICAgdGhpcy5faGVhcnRiZWF0c0NhY2hlID0gcmVzdWx0O1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxsZWQgdG8gcmVwb3J0IGEgaGVhcnRiZWF0LiBUaGUgZnVuY3Rpb24gd2lsbCBnZW5lcmF0ZVxyXG4gICAgICogYSBIZWFydGJlYXRzQnlVc2VyQWdlbnQgb2JqZWN0LCB1cGRhdGUgaGVhcnRiZWF0c0NhY2hlLCBhbmQgcGVyc2lzdCBpdFxyXG4gICAgICogdG8gSW5kZXhlZERCLlxyXG4gICAgICogTm90ZSB0aGF0IHdlIG9ubHkgc3RvcmUgb25lIGhlYXJ0YmVhdCBwZXIgZGF5LiBTbyBpZiBhIGhlYXJ0YmVhdCBmb3IgdG9kYXkgaXNcclxuICAgICAqIGFscmVhZHkgbG9nZ2VkLCBzdWJzZXF1ZW50IGNhbGxzIHRvIHRoaXMgZnVuY3Rpb24gaW4gdGhlIHNhbWUgZGF5IHdpbGwgYmUgaWdub3JlZC5cclxuICAgICAqL1xyXG4gICAgYXN5bmMgdHJpZ2dlckhlYXJ0YmVhdCgpIHtcclxuICAgICAgICBjb25zdCBwbGF0Zm9ybUxvZ2dlciA9IHRoaXMuY29udGFpbmVyXHJcbiAgICAgICAgICAgIC5nZXRQcm92aWRlcigncGxhdGZvcm0tbG9nZ2VyJylcclxuICAgICAgICAgICAgLmdldEltbWVkaWF0ZSgpO1xyXG4gICAgICAgIC8vIFRoaXMgaXMgdGhlIFwiRmlyZWJhc2UgdXNlciBhZ2VudFwiIHN0cmluZyBmcm9tIHRoZSBwbGF0Zm9ybSBsb2dnZXJcclxuICAgICAgICAvLyBzZXJ2aWNlLCBub3QgdGhlIGJyb3dzZXIgdXNlciBhZ2VudC5cclxuICAgICAgICBjb25zdCB1c2VyQWdlbnQgPSBwbGF0Zm9ybUxvZ2dlci5nZXRQbGF0Zm9ybUluZm9TdHJpbmcoKTtcclxuICAgICAgICBjb25zdCBkYXRlID0gZ2V0VVRDRGF0ZVN0cmluZygpO1xyXG4gICAgICAgIGlmICh0aGlzLl9oZWFydGJlYXRzQ2FjaGUgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgdGhpcy5faGVhcnRiZWF0c0NhY2hlID0gYXdhaXQgdGhpcy5faGVhcnRiZWF0c0NhY2hlUHJvbWlzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuX2hlYXJ0YmVhdHNDYWNoZS5zb21lKHNpbmdsZURhdGVIZWFydGJlYXQgPT4gc2luZ2xlRGF0ZUhlYXJ0YmVhdC5kYXRlID09PSBkYXRlKSkge1xyXG4gICAgICAgICAgICAvLyBEbyBub3Qgc3RvcmUgYSBoZWFydGJlYXQgaWYgb25lIGlzIGFscmVhZHkgc3RvcmVkIGZvciB0aGlzIGRheS5cclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gVGhlcmUgaXMgbm8gZW50cnkgZm9yIHRoaXMgZGF0ZS4gQ3JlYXRlIG9uZS5cclxuICAgICAgICAgICAgdGhpcy5faGVhcnRiZWF0c0NhY2hlLnB1c2goeyBkYXRlLCB1c2VyQWdlbnQgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFJlbW92ZSBlbnRyaWVzIG9sZGVyIHRoYW4gMzAgZGF5cy5cclxuICAgICAgICB0aGlzLl9oZWFydGJlYXRzQ2FjaGUgPSB0aGlzLl9oZWFydGJlYXRzQ2FjaGUuZmlsdGVyKHNpbmdsZURhdGVIZWFydGJlYXQgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBoYlRpbWVzdGFtcCA9IG5ldyBEYXRlKHNpbmdsZURhdGVIZWFydGJlYXQuZGF0ZSkudmFsdWVPZigpO1xyXG4gICAgICAgICAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xyXG4gICAgICAgICAgICByZXR1cm4gbm93IC0gaGJUaW1lc3RhbXAgPD0gU1RPUkVEX0hFQVJUQkVBVF9SRVRFTlRJT05fTUFYX01JTExJUztcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gdGhpcy5fc3RvcmFnZS5vdmVyd3JpdGUodGhpcy5faGVhcnRiZWF0c0NhY2hlKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIGJhc2U2NCBlbmNvZGVkIHN0cmluZyB3aGljaCBjYW4gYmUgYXR0YWNoZWQgdG8gdGhlIGhlYXJ0YmVhdC1zcGVjaWZpYyBoZWFkZXIgZGlyZWN0bHkuXHJcbiAgICAgKiBJdCBhbHNvIGNsZWFycyBhbGwgaGVhcnRiZWF0cyBmcm9tIG1lbW9yeSBhcyB3ZWxsIGFzIGluIEluZGV4ZWREQi5cclxuICAgICAqXHJcbiAgICAgKiBOT1RFOiBJdCB3aWxsIHJlYWQgaGVhcnRiZWF0cyBmcm9tIHRoZSBoZWFydGJlYXRzQ2FjaGUsIGluc3RlYWQgb2YgZnJvbSBpbmRleGVkREIgdG8gcmVkdWNlIGxhdGVuY3lcclxuICAgICAqL1xyXG4gICAgYXN5bmMgZ2V0SGVhcnRiZWF0c0hlYWRlcigpIHtcclxuICAgICAgICBpZiAodGhpcy5faGVhcnRiZWF0c0NhY2hlID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX2hlYXJ0YmVhdHNDYWNoZVByb21pc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIElmIGl0J3Mgc3RpbGwgbnVsbCwgaXQncyBiZWVuIGNsZWFyZWQgYW5kIGhhcyBub3QgYmVlbiByZXBvcHVsYXRlZC5cclxuICAgICAgICBpZiAodGhpcy5faGVhcnRiZWF0c0NhY2hlID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAnJztcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gRXh0cmFjdCBhcyBtYW55IGhlYXJ0YmVhdHMgZnJvbSB0aGUgY2FjaGUgYXMgd2lsbCBmaXQgdW5kZXIgdGhlIHNpemUgbGltaXQuXHJcbiAgICAgICAgY29uc3QgeyBoZWFydGJlYXRzVG9TZW5kLCB1bnNlbnRFbnRyaWVzIH0gPSBleHRyYWN0SGVhcnRiZWF0c0ZvckhlYWRlcih0aGlzLl9oZWFydGJlYXRzQ2FjaGUpO1xyXG4gICAgICAgIGNvbnN0IGhlYWRlclN0cmluZyA9IGJhc2U2NEVuY29kZShKU09OLnN0cmluZ2lmeSh7IHZlcnNpb246IDIsIGhlYXJ0YmVhdHM6IGhlYXJ0YmVhdHNUb1NlbmQgfSkpO1xyXG4gICAgICAgIGlmICh1bnNlbnRFbnRyaWVzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgLy8gU3RvcmUgYW55IHVuc2VudCBlbnRyaWVzIGlmIHRoZXkgZXhpc3QuXHJcbiAgICAgICAgICAgIHRoaXMuX2hlYXJ0YmVhdHNDYWNoZSA9IHVuc2VudEVudHJpZXM7XHJcbiAgICAgICAgICAgIC8vIFRoaXMgc2VlbXMgbW9yZSBsaWtlbHkgdGhhbiBkZWxldGVBbGwgKGJlbG93KSB0byBsZWFkIHRvIHNvbWUgb2RkIHN0YXRlXHJcbiAgICAgICAgICAgIC8vIHNpbmNlIHRoZSBjYWNoZSBpc24ndCBlbXB0eSBhbmQgdGhpcyB3aWxsIGJlIGNhbGxlZCBhZ2FpbiBvbiB0aGUgbmV4dCByZXF1ZXN0LFxyXG4gICAgICAgICAgICAvLyBhbmQgaXMgcHJvYmFibHkgc2FmZXN0IGlmIHdlIGF3YWl0IGl0LlxyXG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9zdG9yYWdlLm92ZXJ3cml0ZSh0aGlzLl9oZWFydGJlYXRzQ2FjaGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5faGVhcnRiZWF0c0NhY2hlID0gbnVsbDtcclxuICAgICAgICAgICAgLy8gRG8gbm90IHdhaXQgZm9yIHRoaXMsIHRvIHJlZHVjZSBsYXRlbmN5LlxyXG4gICAgICAgICAgICB2b2lkIHRoaXMuX3N0b3JhZ2UuZGVsZXRlQWxsKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBoZWFkZXJTdHJpbmc7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gZ2V0VVRDRGF0ZVN0cmluZygpIHtcclxuICAgIGNvbnN0IHRvZGF5ID0gbmV3IERhdGUoKTtcclxuICAgIC8vIFJldHVybnMgZGF0ZSBmb3JtYXQgJ1lZWVktTU0tREQnXHJcbiAgICByZXR1cm4gdG9kYXkudG9JU09TdHJpbmcoKS5zdWJzdHJpbmcoMCwgMTApO1xyXG59XHJcbmZ1bmN0aW9uIGV4dHJhY3RIZWFydGJlYXRzRm9ySGVhZGVyKGhlYXJ0YmVhdHNDYWNoZSwgbWF4U2l6ZSA9IE1BWF9IRUFERVJfQllURVMpIHtcclxuICAgIC8vIEhlYXJ0YmVhdHMgZ3JvdXBlZCBieSB1c2VyIGFnZW50IGluIHRoZSBzdGFuZGFyZCBmb3JtYXQgdG8gYmUgc2VudCBpblxyXG4gICAgLy8gdGhlIGhlYWRlci5cclxuICAgIGNvbnN0IGhlYXJ0YmVhdHNUb1NlbmQgPSBbXTtcclxuICAgIC8vIFNpbmdsZSBkYXRlIGZvcm1hdCBoZWFydGJlYXRzIHRoYXQgYXJlIG5vdCBzZW50LlxyXG4gICAgbGV0IHVuc2VudEVudHJpZXMgPSBoZWFydGJlYXRzQ2FjaGUuc2xpY2UoKTtcclxuICAgIGZvciAoY29uc3Qgc2luZ2xlRGF0ZUhlYXJ0YmVhdCBvZiBoZWFydGJlYXRzQ2FjaGUpIHtcclxuICAgICAgICAvLyBMb29rIGZvciBhbiBleGlzdGluZyBlbnRyeSB3aXRoIHRoZSBzYW1lIHVzZXIgYWdlbnQuXHJcbiAgICAgICAgY29uc3QgaGVhcnRiZWF0RW50cnkgPSBoZWFydGJlYXRzVG9TZW5kLmZpbmQoaGIgPT4gaGIudXNlckFnZW50ID09PSBzaW5nbGVEYXRlSGVhcnRiZWF0LnVzZXJBZ2VudCk7XHJcbiAgICAgICAgaWYgKCFoZWFydGJlYXRFbnRyeSkge1xyXG4gICAgICAgICAgICAvLyBJZiBubyBlbnRyeSBmb3IgdGhpcyB1c2VyIGFnZW50IGV4aXN0cywgY3JlYXRlIG9uZS5cclxuICAgICAgICAgICAgaGVhcnRiZWF0c1RvU2VuZC5wdXNoKHtcclxuICAgICAgICAgICAgICAgIHVzZXJBZ2VudDogc2luZ2xlRGF0ZUhlYXJ0YmVhdC51c2VyQWdlbnQsXHJcbiAgICAgICAgICAgICAgICBkYXRlczogW3NpbmdsZURhdGVIZWFydGJlYXQuZGF0ZV1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGlmIChjb3VudEJ5dGVzKGhlYXJ0YmVhdHNUb1NlbmQpID4gbWF4U2l6ZSkge1xyXG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIGhlYWRlciB3b3VsZCBleGNlZWQgbWF4IHNpemUsIHJlbW92ZSB0aGUgYWRkZWQgaGVhcnRiZWF0XHJcbiAgICAgICAgICAgICAgICAvLyBlbnRyeSBhbmQgc3RvcCBhZGRpbmcgdG8gdGhlIGhlYWRlci5cclxuICAgICAgICAgICAgICAgIGhlYXJ0YmVhdHNUb1NlbmQucG9wKCk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaGVhcnRiZWF0RW50cnkuZGF0ZXMucHVzaChzaW5nbGVEYXRlSGVhcnRiZWF0LmRhdGUpO1xyXG4gICAgICAgICAgICAvLyBJZiB0aGUgaGVhZGVyIHdvdWxkIGV4Y2VlZCBtYXggc2l6ZSwgcmVtb3ZlIHRoZSBhZGRlZCBkYXRlXHJcbiAgICAgICAgICAgIC8vIGFuZCBzdG9wIGFkZGluZyB0byB0aGUgaGVhZGVyLlxyXG4gICAgICAgICAgICBpZiAoY291bnRCeXRlcyhoZWFydGJlYXRzVG9TZW5kKSA+IG1heFNpemUpIHtcclxuICAgICAgICAgICAgICAgIGhlYXJ0YmVhdEVudHJ5LmRhdGVzLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gUG9wIHVuc2VudCBlbnRyeSBmcm9tIHF1ZXVlLiAoU2tpcHBlZCBpZiBhZGRpbmcgdGhlIGVudHJ5IGV4Y2VlZGVkXHJcbiAgICAgICAgLy8gcXVvdGEgYW5kIHRoZSBsb29wIGJyZWFrcyBlYXJseS4pXHJcbiAgICAgICAgdW5zZW50RW50cmllcyA9IHVuc2VudEVudHJpZXMuc2xpY2UoMSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGhlYXJ0YmVhdHNUb1NlbmQsXHJcbiAgICAgICAgdW5zZW50RW50cmllc1xyXG4gICAgfTtcclxufVxyXG5jbGFzcyBIZWFydGJlYXRTdG9yYWdlSW1wbCB7XHJcbiAgICBjb25zdHJ1Y3RvcihhcHApIHtcclxuICAgICAgICB0aGlzLmFwcCA9IGFwcDtcclxuICAgICAgICB0aGlzLl9jYW5Vc2VJbmRleGVkREJQcm9taXNlID0gdGhpcy5ydW5JbmRleGVkREJFbnZpcm9ubWVudENoZWNrKCk7XHJcbiAgICB9XHJcbiAgICBhc3luYyBydW5JbmRleGVkREJFbnZpcm9ubWVudENoZWNrKCkge1xyXG4gICAgICAgIGlmICghaXNJbmRleGVkREJBdmFpbGFibGUoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gdmFsaWRhdGVJbmRleGVkREJPcGVuYWJsZSgpXHJcbiAgICAgICAgICAgICAgICAudGhlbigoKSA9PiB0cnVlKVxyXG4gICAgICAgICAgICAgICAgLmNhdGNoKCgpID0+IGZhbHNlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlYWQgYWxsIGhlYXJ0YmVhdHMuXHJcbiAgICAgKi9cclxuICAgIGFzeW5jIHJlYWQoKSB7XHJcbiAgICAgICAgY29uc3QgY2FuVXNlSW5kZXhlZERCID0gYXdhaXQgdGhpcy5fY2FuVXNlSW5kZXhlZERCUHJvbWlzZTtcclxuICAgICAgICBpZiAoIWNhblVzZUluZGV4ZWREQikge1xyXG4gICAgICAgICAgICByZXR1cm4gW107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCBpZGJIZWFydGJlYXRPYmplY3QgPSBhd2FpdCByZWFkSGVhcnRiZWF0c0Zyb21JbmRleGVkREIodGhpcy5hcHApO1xyXG4gICAgICAgICAgICByZXR1cm4gKGlkYkhlYXJ0YmVhdE9iamVjdCA9PT0gbnVsbCB8fCBpZGJIZWFydGJlYXRPYmplY3QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGlkYkhlYXJ0YmVhdE9iamVjdC5oZWFydGJlYXRzKSB8fCBbXTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBvdmVyd3JpdGUgdGhlIHN0b3JhZ2Ugd2l0aCB0aGUgcHJvdmlkZWQgaGVhcnRiZWF0c1xyXG4gICAgYXN5bmMgb3ZlcndyaXRlKGhlYXJ0YmVhdHMpIHtcclxuICAgICAgICBjb25zdCBjYW5Vc2VJbmRleGVkREIgPSBhd2FpdCB0aGlzLl9jYW5Vc2VJbmRleGVkREJQcm9taXNlO1xyXG4gICAgICAgIGlmICghY2FuVXNlSW5kZXhlZERCKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB3cml0ZUhlYXJ0YmVhdHNUb0luZGV4ZWREQih0aGlzLmFwcCwgeyBoZWFydGJlYXRzIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIGFkZCBoZWFydGJlYXRzXHJcbiAgICBhc3luYyBhZGQoaGVhcnRiZWF0cykge1xyXG4gICAgICAgIGNvbnN0IGNhblVzZUluZGV4ZWREQiA9IGF3YWl0IHRoaXMuX2NhblVzZUluZGV4ZWREQlByb21pc2U7XHJcbiAgICAgICAgaWYgKCFjYW5Vc2VJbmRleGVkREIpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3QgZXhpc3RpbmdIZWFydGJlYXRzID0gYXdhaXQgdGhpcy5yZWFkKCk7XHJcbiAgICAgICAgICAgIHJldHVybiB3cml0ZUhlYXJ0YmVhdHNUb0luZGV4ZWREQih0aGlzLmFwcCwge1xyXG4gICAgICAgICAgICAgICAgaGVhcnRiZWF0czogWy4uLmV4aXN0aW5nSGVhcnRiZWF0cywgLi4uaGVhcnRiZWF0c11cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gZGVsZXRlIGhlYXJ0YmVhdHNcclxuICAgIGFzeW5jIGRlbGV0ZShoZWFydGJlYXRzKSB7XHJcbiAgICAgICAgY29uc3QgY2FuVXNlSW5kZXhlZERCID0gYXdhaXQgdGhpcy5fY2FuVXNlSW5kZXhlZERCUHJvbWlzZTtcclxuICAgICAgICBpZiAoIWNhblVzZUluZGV4ZWREQikge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCBleGlzdGluZ0hlYXJ0YmVhdHMgPSBhd2FpdCB0aGlzLnJlYWQoKTtcclxuICAgICAgICAgICAgcmV0dXJuIHdyaXRlSGVhcnRiZWF0c1RvSW5kZXhlZERCKHRoaXMuYXBwLCB7XHJcbiAgICAgICAgICAgICAgICBoZWFydGJlYXRzOiBleGlzdGluZ0hlYXJ0YmVhdHMuZmlsdGVyKGV4aXN0aW5nSGVhcnRiZWF0ID0+ICFoZWFydGJlYXRzLmluY2x1ZGVzKGV4aXN0aW5nSGVhcnRiZWF0KSlcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gZGVsZXRlIGFsbCBoZWFydGJlYXRzXHJcbiAgICBhc3luYyBkZWxldGVBbGwoKSB7XHJcbiAgICAgICAgY29uc3QgY2FuVXNlSW5kZXhlZERCID0gYXdhaXQgdGhpcy5fY2FuVXNlSW5kZXhlZERCUHJvbWlzZTtcclxuICAgICAgICBpZiAoIWNhblVzZUluZGV4ZWREQikge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gZGVsZXRlSGVhcnRiZWF0c0Zyb21JbmRleGVkREIodGhpcy5hcHApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4vKipcclxuICogQ2FsY3VsYXRlIGJ5dGVzIG9mIGEgSGVhcnRiZWF0c0J5VXNlckFnZW50IGFycmF5IGFmdGVyIGJlaW5nIHdyYXBwZWRcclxuICogaW4gYSBwbGF0Zm9ybSBsb2dnaW5nIGhlYWRlciBKU09OIG9iamVjdCwgc3RyaW5naWZpZWQsIGFuZCBjb252ZXJ0ZWRcclxuICogdG8gYmFzZSA2NC5cclxuICovXHJcbmZ1bmN0aW9uIGNvdW50Qnl0ZXMoaGVhcnRiZWF0c0NhY2hlKSB7XHJcbiAgICAvLyBiYXNlNjQgaGFzIGEgcmVzdHJpY3RlZCBzZXQgb2YgY2hhcmFjdGVycywgYWxsIG9mIHdoaWNoIHNob3VsZCBiZSAxIGJ5dGUuXHJcbiAgICByZXR1cm4gYmFzZTY0RW5jb2RlKFxyXG4gICAgLy8gaGVhcnRiZWF0c0NhY2hlIHdyYXBwZXIgcHJvcGVydGllc1xyXG4gICAgSlNPTi5zdHJpbmdpZnkoeyB2ZXJzaW9uOiAyLCBoZWFydGJlYXRzOiBoZWFydGJlYXRzQ2FjaGUgfSkpLmxlbmd0aDtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5mdW5jdGlvbiByZWdpc3RlckNvcmVDb21wb25lbnRzKHZhcmlhbnQpIHtcclxuICAgIF9yZWdpc3RlckNvbXBvbmVudChuZXcgQ29tcG9uZW50KCdwbGF0Zm9ybS1sb2dnZXInLCBjb250YWluZXIgPT4gbmV3IFBsYXRmb3JtTG9nZ2VyU2VydmljZUltcGwoY29udGFpbmVyKSwgXCJQUklWQVRFXCIgLyogUFJJVkFURSAqLykpO1xyXG4gICAgX3JlZ2lzdGVyQ29tcG9uZW50KG5ldyBDb21wb25lbnQoJ2hlYXJ0YmVhdCcsIGNvbnRhaW5lciA9PiBuZXcgSGVhcnRiZWF0U2VydmljZUltcGwoY29udGFpbmVyKSwgXCJQUklWQVRFXCIgLyogUFJJVkFURSAqLykpO1xyXG4gICAgLy8gUmVnaXN0ZXIgYGFwcGAgcGFja2FnZS5cclxuICAgIHJlZ2lzdGVyVmVyc2lvbihuYW1lJG8sIHZlcnNpb24kMSwgdmFyaWFudCk7XHJcbiAgICAvLyBCVUlMRF9UQVJHRVQgd2lsbCBiZSByZXBsYWNlZCBieSB2YWx1ZXMgbGlrZSBlc201LCBlc20yMDE3LCBjanM1LCBldGMgZHVyaW5nIHRoZSBjb21waWxhdGlvblxyXG4gICAgcmVnaXN0ZXJWZXJzaW9uKG5hbWUkbywgdmVyc2lvbiQxLCAnZXNtMjAxNycpO1xyXG4gICAgLy8gUmVnaXN0ZXIgcGxhdGZvcm0gU0RLIGlkZW50aWZpZXIgKG5vIHZlcnNpb24pLlxyXG4gICAgcmVnaXN0ZXJWZXJzaW9uKCdmaXJlLWpzJywgJycpO1xyXG59XG5cbi8qKlxyXG4gKiBGaXJlYmFzZSBBcHBcclxuICpcclxuICogQHJlbWFya3MgVGhpcyBwYWNrYWdlIGNvb3JkaW5hdGVzIHRoZSBjb21tdW5pY2F0aW9uIGJldHdlZW4gdGhlIGRpZmZlcmVudCBGaXJlYmFzZSBjb21wb25lbnRzXHJcbiAqIEBwYWNrYWdlRG9jdW1lbnRhdGlvblxyXG4gKi9cclxucmVnaXN0ZXJDb3JlQ29tcG9uZW50cygnJyk7XG5cbmV4cG9ydCB7IFNES19WRVJTSU9OLCBERUZBVUxUX0VOVFJZX05BTUUgYXMgX0RFRkFVTFRfRU5UUllfTkFNRSwgX2FkZENvbXBvbmVudCwgX2FkZE9yT3ZlcndyaXRlQ29tcG9uZW50LCBfYXBwcywgX2NsZWFyQ29tcG9uZW50cywgX2NvbXBvbmVudHMsIF9nZXRQcm92aWRlciwgX3JlZ2lzdGVyQ29tcG9uZW50LCBfcmVtb3ZlU2VydmljZUluc3RhbmNlLCBkZWxldGVBcHAsIGdldEFwcCwgZ2V0QXBwcywgaW5pdGlhbGl6ZUFwcCwgb25Mb2csIHJlZ2lzdGVyVmVyc2lvbiwgc2V0TG9nTGV2ZWwgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmVzbTIwMTcuanMubWFwXG4iLCJpbXBvcnQgeyBEZWZlcnJlZCB9IGZyb20gJ0BmaXJlYmFzZS91dGlsJztcblxuLyoqXHJcbiAqIENvbXBvbmVudCBmb3Igc2VydmljZSBuYW1lIFQsIGUuZy4gYGF1dGhgLCBgYXV0aC1pbnRlcm5hbGBcclxuICovXHJcbmNsYXNzIENvbXBvbmVudCB7XHJcbiAgICAvKipcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gbmFtZSBUaGUgcHVibGljIHNlcnZpY2UgbmFtZSwgZS5nLiBhcHAsIGF1dGgsIGZpcmVzdG9yZSwgZGF0YWJhc2VcclxuICAgICAqIEBwYXJhbSBpbnN0YW5jZUZhY3RvcnkgU2VydmljZSBmYWN0b3J5IHJlc3BvbnNpYmxlIGZvciBjcmVhdGluZyB0aGUgcHVibGljIGludGVyZmFjZVxyXG4gICAgICogQHBhcmFtIHR5cGUgd2hldGhlciB0aGUgc2VydmljZSBwcm92aWRlZCBieSB0aGUgY29tcG9uZW50IGlzIHB1YmxpYyBvciBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKG5hbWUsIGluc3RhbmNlRmFjdG9yeSwgdHlwZSkge1xyXG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XHJcbiAgICAgICAgdGhpcy5pbnN0YW5jZUZhY3RvcnkgPSBpbnN0YW5jZUZhY3Rvcnk7XHJcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcclxuICAgICAgICB0aGlzLm11bHRpcGxlSW5zdGFuY2VzID0gZmFsc2U7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUHJvcGVydGllcyB0byBiZSBhZGRlZCB0byB0aGUgc2VydmljZSBuYW1lc3BhY2VcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnNlcnZpY2VQcm9wcyA9IHt9O1xyXG4gICAgICAgIHRoaXMuaW5zdGFudGlhdGlvbk1vZGUgPSBcIkxBWllcIiAvKiBMQVpZICovO1xyXG4gICAgICAgIHRoaXMub25JbnN0YW5jZUNyZWF0ZWQgPSBudWxsO1xyXG4gICAgfVxyXG4gICAgc2V0SW5zdGFudGlhdGlvbk1vZGUobW9kZSkge1xyXG4gICAgICAgIHRoaXMuaW5zdGFudGlhdGlvbk1vZGUgPSBtb2RlO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgc2V0TXVsdGlwbGVJbnN0YW5jZXMobXVsdGlwbGVJbnN0YW5jZXMpIHtcclxuICAgICAgICB0aGlzLm11bHRpcGxlSW5zdGFuY2VzID0gbXVsdGlwbGVJbnN0YW5jZXM7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICBzZXRTZXJ2aWNlUHJvcHMocHJvcHMpIHtcclxuICAgICAgICB0aGlzLnNlcnZpY2VQcm9wcyA9IHByb3BzO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgc2V0SW5zdGFuY2VDcmVhdGVkQ2FsbGJhY2soY2FsbGJhY2spIHtcclxuICAgICAgICB0aGlzLm9uSW5zdGFuY2VDcmVhdGVkID0gY2FsbGJhY2s7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuY29uc3QgREVGQVVMVF9FTlRSWV9OQU1FID0gJ1tERUZBVUxUXSc7XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBQcm92aWRlciBmb3IgaW5zdGFuY2UgZm9yIHNlcnZpY2UgbmFtZSBULCBlLmcuICdhdXRoJywgJ2F1dGgtaW50ZXJuYWwnXHJcbiAqIE5hbWVTZXJ2aWNlTWFwcGluZ1tUXSBpcyBhbiBhbGlhcyBmb3IgdGhlIHR5cGUgb2YgdGhlIGluc3RhbmNlXHJcbiAqL1xyXG5jbGFzcyBQcm92aWRlciB7XHJcbiAgICBjb25zdHJ1Y3RvcihuYW1lLCBjb250YWluZXIpIHtcclxuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xyXG4gICAgICAgIHRoaXMuY29udGFpbmVyID0gY29udGFpbmVyO1xyXG4gICAgICAgIHRoaXMuY29tcG9uZW50ID0gbnVsbDtcclxuICAgICAgICB0aGlzLmluc3RhbmNlcyA9IG5ldyBNYXAoKTtcclxuICAgICAgICB0aGlzLmluc3RhbmNlc0RlZmVycmVkID0gbmV3IE1hcCgpO1xyXG4gICAgICAgIHRoaXMuaW5zdGFuY2VzT3B0aW9ucyA9IG5ldyBNYXAoKTtcclxuICAgICAgICB0aGlzLm9uSW5pdENhbGxiYWNrcyA9IG5ldyBNYXAoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIGlkZW50aWZpZXIgQSBwcm92aWRlciBjYW4gcHJvdmlkZSBtdWxpdHBsZSBpbnN0YW5jZXMgb2YgYSBzZXJ2aWNlXHJcbiAgICAgKiBpZiB0aGlzLmNvbXBvbmVudC5tdWx0aXBsZUluc3RhbmNlcyBpcyB0cnVlLlxyXG4gICAgICovXHJcbiAgICBnZXQoaWRlbnRpZmllcikge1xyXG4gICAgICAgIC8vIGlmIG11bHRpcGxlSW5zdGFuY2VzIGlzIG5vdCBzdXBwb3J0ZWQsIHVzZSB0aGUgZGVmYXVsdCBuYW1lXHJcbiAgICAgICAgY29uc3Qgbm9ybWFsaXplZElkZW50aWZpZXIgPSB0aGlzLm5vcm1hbGl6ZUluc3RhbmNlSWRlbnRpZmllcihpZGVudGlmaWVyKTtcclxuICAgICAgICBpZiAoIXRoaXMuaW5zdGFuY2VzRGVmZXJyZWQuaGFzKG5vcm1hbGl6ZWRJZGVudGlmaWVyKSkge1xyXG4gICAgICAgICAgICBjb25zdCBkZWZlcnJlZCA9IG5ldyBEZWZlcnJlZCgpO1xyXG4gICAgICAgICAgICB0aGlzLmluc3RhbmNlc0RlZmVycmVkLnNldChub3JtYWxpemVkSWRlbnRpZmllciwgZGVmZXJyZWQpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5pc0luaXRpYWxpemVkKG5vcm1hbGl6ZWRJZGVudGlmaWVyKSB8fFxyXG4gICAgICAgICAgICAgICAgdGhpcy5zaG91bGRBdXRvSW5pdGlhbGl6ZSgpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBpbml0aWFsaXplIHRoZSBzZXJ2aWNlIGlmIGl0IGNhbiBiZSBhdXRvLWluaXRpYWxpemVkXHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGluc3RhbmNlID0gdGhpcy5nZXRPckluaXRpYWxpemVTZXJ2aWNlKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2VJZGVudGlmaWVyOiBub3JtYWxpemVkSWRlbnRpZmllclxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnN0YW5jZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKGluc3RhbmNlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHdoZW4gdGhlIGluc3RhbmNlIGZhY3RvcnkgdGhyb3dzIGFuIGV4Y2VwdGlvbiBkdXJpbmcgZ2V0KCksIGl0IHNob3VsZCBub3QgY2F1c2VcclxuICAgICAgICAgICAgICAgICAgICAvLyBhIGZhdGFsIGVycm9yLiBXZSBqdXN0IHJldHVybiB0aGUgdW5yZXNvbHZlZCBwcm9taXNlIGluIHRoaXMgY2FzZS5cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5pbnN0YW5jZXNEZWZlcnJlZC5nZXQobm9ybWFsaXplZElkZW50aWZpZXIpLnByb21pc2U7XHJcbiAgICB9XHJcbiAgICBnZXRJbW1lZGlhdGUob3B0aW9ucykge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICAvLyBpZiBtdWx0aXBsZUluc3RhbmNlcyBpcyBub3Qgc3VwcG9ydGVkLCB1c2UgdGhlIGRlZmF1bHQgbmFtZVxyXG4gICAgICAgIGNvbnN0IG5vcm1hbGl6ZWRJZGVudGlmaWVyID0gdGhpcy5ub3JtYWxpemVJbnN0YW5jZUlkZW50aWZpZXIob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmlkZW50aWZpZXIpO1xyXG4gICAgICAgIGNvbnN0IG9wdGlvbmFsID0gKF9hID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLm9wdGlvbmFsKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBmYWxzZTtcclxuICAgICAgICBpZiAodGhpcy5pc0luaXRpYWxpemVkKG5vcm1hbGl6ZWRJZGVudGlmaWVyKSB8fFxyXG4gICAgICAgICAgICB0aGlzLnNob3VsZEF1dG9Jbml0aWFsaXplKCkpIHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldE9ySW5pdGlhbGl6ZVNlcnZpY2Uoe1xyXG4gICAgICAgICAgICAgICAgICAgIGluc3RhbmNlSWRlbnRpZmllcjogbm9ybWFsaXplZElkZW50aWZpZXJcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9uYWwpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IGU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIEluIGNhc2UgYSBjb21wb25lbnQgaXMgbm90IGluaXRpYWxpemVkIGFuZCBzaG91bGQvY2FuIG5vdCBiZSBhdXRvLWluaXRpYWxpemVkIGF0IHRoZSBtb21lbnQsIHJldHVybiBudWxsIGlmIHRoZSBvcHRpb25hbCBmbGFnIGlzIHNldCwgb3IgdGhyb3dcclxuICAgICAgICAgICAgaWYgKG9wdGlvbmFsKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKGBTZXJ2aWNlICR7dGhpcy5uYW1lfSBpcyBub3QgYXZhaWxhYmxlYCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBnZXRDb21wb25lbnQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcG9uZW50O1xyXG4gICAgfVxyXG4gICAgc2V0Q29tcG9uZW50KGNvbXBvbmVudCkge1xyXG4gICAgICAgIGlmIChjb21wb25lbnQubmFtZSAhPT0gdGhpcy5uYW1lKSB7XHJcbiAgICAgICAgICAgIHRocm93IEVycm9yKGBNaXNtYXRjaGluZyBDb21wb25lbnQgJHtjb21wb25lbnQubmFtZX0gZm9yIFByb3ZpZGVyICR7dGhpcy5uYW1lfS5gKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuY29tcG9uZW50KSB7XHJcbiAgICAgICAgICAgIHRocm93IEVycm9yKGBDb21wb25lbnQgZm9yICR7dGhpcy5uYW1lfSBoYXMgYWxyZWFkeSBiZWVuIHByb3ZpZGVkYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuY29tcG9uZW50ID0gY29tcG9uZW50O1xyXG4gICAgICAgIC8vIHJldHVybiBlYXJseSB3aXRob3V0IGF0dGVtcHRpbmcgdG8gaW5pdGlhbGl6ZSB0aGUgY29tcG9uZW50IGlmIHRoZSBjb21wb25lbnQgcmVxdWlyZXMgZXhwbGljaXQgaW5pdGlhbGl6YXRpb24gKGNhbGxpbmcgYFByb3ZpZGVyLmluaXRpYWxpemUoKWApXHJcbiAgICAgICAgaWYgKCF0aGlzLnNob3VsZEF1dG9Jbml0aWFsaXplKCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBpZiB0aGUgc2VydmljZSBpcyBlYWdlciwgaW5pdGlhbGl6ZSB0aGUgZGVmYXVsdCBpbnN0YW5jZVxyXG4gICAgICAgIGlmIChpc0NvbXBvbmVudEVhZ2VyKGNvbXBvbmVudCkpIHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZ2V0T3JJbml0aWFsaXplU2VydmljZSh7IGluc3RhbmNlSWRlbnRpZmllcjogREVGQVVMVF9FTlRSWV9OQU1FIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICAvLyB3aGVuIHRoZSBpbnN0YW5jZSBmYWN0b3J5IGZvciBhbiBlYWdlciBDb21wb25lbnQgdGhyb3dzIGFuIGV4Y2VwdGlvbiBkdXJpbmcgdGhlIGVhZ2VyXHJcbiAgICAgICAgICAgICAgICAvLyBpbml0aWFsaXphdGlvbiwgaXQgc2hvdWxkIG5vdCBjYXVzZSBhIGZhdGFsIGVycm9yLlxyXG4gICAgICAgICAgICAgICAgLy8gVE9ETzogSW52ZXN0aWdhdGUgaWYgd2UgbmVlZCB0byBtYWtlIGl0IGNvbmZpZ3VyYWJsZSwgYmVjYXVzZSBzb21lIGNvbXBvbmVudCBtYXkgd2FudCB0byBjYXVzZVxyXG4gICAgICAgICAgICAgICAgLy8gYSBmYXRhbCBlcnJvciBpbiB0aGlzIGNhc2U/XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gQ3JlYXRlIHNlcnZpY2UgaW5zdGFuY2VzIGZvciB0aGUgcGVuZGluZyBwcm9taXNlcyBhbmQgcmVzb2x2ZSB0aGVtXHJcbiAgICAgICAgLy8gTk9URTogaWYgdGhpcy5tdWx0aXBsZUluc3RhbmNlcyBpcyBmYWxzZSwgb25seSB0aGUgZGVmYXVsdCBpbnN0YW5jZSB3aWxsIGJlIGNyZWF0ZWRcclxuICAgICAgICAvLyBhbmQgYWxsIHByb21pc2VzIHdpdGggcmVzb2x2ZSB3aXRoIGl0IHJlZ2FyZGxlc3Mgb2YgdGhlIGlkZW50aWZpZXIuXHJcbiAgICAgICAgZm9yIChjb25zdCBbaW5zdGFuY2VJZGVudGlmaWVyLCBpbnN0YW5jZURlZmVycmVkXSBvZiB0aGlzLmluc3RhbmNlc0RlZmVycmVkLmVudHJpZXMoKSkge1xyXG4gICAgICAgICAgICBjb25zdCBub3JtYWxpemVkSWRlbnRpZmllciA9IHRoaXMubm9ybWFsaXplSW5zdGFuY2VJZGVudGlmaWVyKGluc3RhbmNlSWRlbnRpZmllcik7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAvLyBgZ2V0T3JJbml0aWFsaXplU2VydmljZSgpYCBzaG91bGQgYWx3YXlzIHJldHVybiBhIHZhbGlkIGluc3RhbmNlIHNpbmNlIGEgY29tcG9uZW50IGlzIGd1YXJhbnRlZWQuIHVzZSAhIHRvIG1ha2UgdHlwZXNjcmlwdCBoYXBweS5cclxuICAgICAgICAgICAgICAgIGNvbnN0IGluc3RhbmNlID0gdGhpcy5nZXRPckluaXRpYWxpemVTZXJ2aWNlKHtcclxuICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZUlkZW50aWZpZXI6IG5vcm1hbGl6ZWRJZGVudGlmaWVyXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIGluc3RhbmNlRGVmZXJyZWQucmVzb2x2ZShpbnN0YW5jZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgIC8vIHdoZW4gdGhlIGluc3RhbmNlIGZhY3RvcnkgdGhyb3dzIGFuIGV4Y2VwdGlvbiwgaXQgc2hvdWxkIG5vdCBjYXVzZVxyXG4gICAgICAgICAgICAgICAgLy8gYSBmYXRhbCBlcnJvci4gV2UganVzdCBsZWF2ZSB0aGUgcHJvbWlzZSB1bnJlc29sdmVkLlxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY2xlYXJJbnN0YW5jZShpZGVudGlmaWVyID0gREVGQVVMVF9FTlRSWV9OQU1FKSB7XHJcbiAgICAgICAgdGhpcy5pbnN0YW5jZXNEZWZlcnJlZC5kZWxldGUoaWRlbnRpZmllcik7XHJcbiAgICAgICAgdGhpcy5pbnN0YW5jZXNPcHRpb25zLmRlbGV0ZShpZGVudGlmaWVyKTtcclxuICAgICAgICB0aGlzLmluc3RhbmNlcy5kZWxldGUoaWRlbnRpZmllcik7XHJcbiAgICB9XHJcbiAgICAvLyBhcHAuZGVsZXRlKCkgd2lsbCBjYWxsIHRoaXMgbWV0aG9kIG9uIGV2ZXJ5IHByb3ZpZGVyIHRvIGRlbGV0ZSB0aGUgc2VydmljZXNcclxuICAgIC8vIFRPRE86IHNob3VsZCB3ZSBtYXJrIHRoZSBwcm92aWRlciBhcyBkZWxldGVkP1xyXG4gICAgYXN5bmMgZGVsZXRlKCkge1xyXG4gICAgICAgIGNvbnN0IHNlcnZpY2VzID0gQXJyYXkuZnJvbSh0aGlzLmluc3RhbmNlcy52YWx1ZXMoKSk7XHJcbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoW1xyXG4gICAgICAgICAgICAuLi5zZXJ2aWNlc1xyXG4gICAgICAgICAgICAgICAgLmZpbHRlcihzZXJ2aWNlID0+ICdJTlRFUk5BTCcgaW4gc2VydmljZSkgLy8gbGVnYWN5IHNlcnZpY2VzXHJcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxyXG4gICAgICAgICAgICAgICAgLm1hcChzZXJ2aWNlID0+IHNlcnZpY2UuSU5URVJOQUwuZGVsZXRlKCkpLFxyXG4gICAgICAgICAgICAuLi5zZXJ2aWNlc1xyXG4gICAgICAgICAgICAgICAgLmZpbHRlcihzZXJ2aWNlID0+ICdfZGVsZXRlJyBpbiBzZXJ2aWNlKSAvLyBtb2R1bGFyaXplZCBzZXJ2aWNlc1xyXG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcclxuICAgICAgICAgICAgICAgIC5tYXAoc2VydmljZSA9PiBzZXJ2aWNlLl9kZWxldGUoKSlcclxuICAgICAgICBdKTtcclxuICAgIH1cclxuICAgIGlzQ29tcG9uZW50U2V0KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBvbmVudCAhPSBudWxsO1xyXG4gICAgfVxyXG4gICAgaXNJbml0aWFsaXplZChpZGVudGlmaWVyID0gREVGQVVMVF9FTlRSWV9OQU1FKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5zdGFuY2VzLmhhcyhpZGVudGlmaWVyKTtcclxuICAgIH1cclxuICAgIGdldE9wdGlvbnMoaWRlbnRpZmllciA9IERFRkFVTFRfRU5UUllfTkFNRSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmluc3RhbmNlc09wdGlvbnMuZ2V0KGlkZW50aWZpZXIpIHx8IHt9O1xyXG4gICAgfVxyXG4gICAgaW5pdGlhbGl6ZShvcHRzID0ge30pIHtcclxuICAgICAgICBjb25zdCB7IG9wdGlvbnMgPSB7fSB9ID0gb3B0cztcclxuICAgICAgICBjb25zdCBub3JtYWxpemVkSWRlbnRpZmllciA9IHRoaXMubm9ybWFsaXplSW5zdGFuY2VJZGVudGlmaWVyKG9wdHMuaW5zdGFuY2VJZGVudGlmaWVyKTtcclxuICAgICAgICBpZiAodGhpcy5pc0luaXRpYWxpemVkKG5vcm1hbGl6ZWRJZGVudGlmaWVyKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBFcnJvcihgJHt0aGlzLm5hbWV9KCR7bm9ybWFsaXplZElkZW50aWZpZXJ9KSBoYXMgYWxyZWFkeSBiZWVuIGluaXRpYWxpemVkYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghdGhpcy5pc0NvbXBvbmVudFNldCgpKSB7XHJcbiAgICAgICAgICAgIHRocm93IEVycm9yKGBDb21wb25lbnQgJHt0aGlzLm5hbWV9IGhhcyBub3QgYmVlbiByZWdpc3RlcmVkIHlldGApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBpbnN0YW5jZSA9IHRoaXMuZ2V0T3JJbml0aWFsaXplU2VydmljZSh7XHJcbiAgICAgICAgICAgIGluc3RhbmNlSWRlbnRpZmllcjogbm9ybWFsaXplZElkZW50aWZpZXIsXHJcbiAgICAgICAgICAgIG9wdGlvbnNcclxuICAgICAgICB9KTtcclxuICAgICAgICAvLyByZXNvbHZlIGFueSBwZW5kaW5nIHByb21pc2Ugd2FpdGluZyBmb3IgdGhlIHNlcnZpY2UgaW5zdGFuY2VcclxuICAgICAgICBmb3IgKGNvbnN0IFtpbnN0YW5jZUlkZW50aWZpZXIsIGluc3RhbmNlRGVmZXJyZWRdIG9mIHRoaXMuaW5zdGFuY2VzRGVmZXJyZWQuZW50cmllcygpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG5vcm1hbGl6ZWREZWZlcnJlZElkZW50aWZpZXIgPSB0aGlzLm5vcm1hbGl6ZUluc3RhbmNlSWRlbnRpZmllcihpbnN0YW5jZUlkZW50aWZpZXIpO1xyXG4gICAgICAgICAgICBpZiAobm9ybWFsaXplZElkZW50aWZpZXIgPT09IG5vcm1hbGl6ZWREZWZlcnJlZElkZW50aWZpZXIpIHtcclxuICAgICAgICAgICAgICAgIGluc3RhbmNlRGVmZXJyZWQucmVzb2x2ZShpbnN0YW5jZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGluc3RhbmNlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGNhbGxiYWNrIC0gYSBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgaW52b2tlZCAgYWZ0ZXIgdGhlIHByb3ZpZGVyIGhhcyBiZWVuIGluaXRpYWxpemVkIGJ5IGNhbGxpbmcgcHJvdmlkZXIuaW5pdGlhbGl6ZSgpLlxyXG4gICAgICogVGhlIGZ1bmN0aW9uIGlzIGludm9rZWQgU1lOQ0hST05PVVNMWSwgc28gaXQgc2hvdWxkIG5vdCBleGVjdXRlIGFueSBsb25ncnVubmluZyB0YXNrcyBpbiBvcmRlciB0byBub3QgYmxvY2sgdGhlIHByb2dyYW0uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGlkZW50aWZpZXIgQW4gb3B0aW9uYWwgaW5zdGFuY2UgaWRlbnRpZmllclxyXG4gICAgICogQHJldHVybnMgYSBmdW5jdGlvbiB0byB1bnJlZ2lzdGVyIHRoZSBjYWxsYmFja1xyXG4gICAgICovXHJcbiAgICBvbkluaXQoY2FsbGJhY2ssIGlkZW50aWZpZXIpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgY29uc3Qgbm9ybWFsaXplZElkZW50aWZpZXIgPSB0aGlzLm5vcm1hbGl6ZUluc3RhbmNlSWRlbnRpZmllcihpZGVudGlmaWVyKTtcclxuICAgICAgICBjb25zdCBleGlzdGluZ0NhbGxiYWNrcyA9IChfYSA9IHRoaXMub25Jbml0Q2FsbGJhY2tzLmdldChub3JtYWxpemVkSWRlbnRpZmllcikpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IG5ldyBTZXQoKTtcclxuICAgICAgICBleGlzdGluZ0NhbGxiYWNrcy5hZGQoY2FsbGJhY2spO1xyXG4gICAgICAgIHRoaXMub25Jbml0Q2FsbGJhY2tzLnNldChub3JtYWxpemVkSWRlbnRpZmllciwgZXhpc3RpbmdDYWxsYmFja3MpO1xyXG4gICAgICAgIGNvbnN0IGV4aXN0aW5nSW5zdGFuY2UgPSB0aGlzLmluc3RhbmNlcy5nZXQobm9ybWFsaXplZElkZW50aWZpZXIpO1xyXG4gICAgICAgIGlmIChleGlzdGluZ0luc3RhbmNlKSB7XHJcbiAgICAgICAgICAgIGNhbGxiYWNrKGV4aXN0aW5nSW5zdGFuY2UsIG5vcm1hbGl6ZWRJZGVudGlmaWVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgICAgICAgZXhpc3RpbmdDYWxsYmFja3MuZGVsZXRlKGNhbGxiYWNrKTtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBJbnZva2Ugb25Jbml0IGNhbGxiYWNrcyBzeW5jaHJvbm91c2x5XHJcbiAgICAgKiBAcGFyYW0gaW5zdGFuY2UgdGhlIHNlcnZpY2UgaW5zdGFuY2VgXHJcbiAgICAgKi9cclxuICAgIGludm9rZU9uSW5pdENhbGxiYWNrcyhpbnN0YW5jZSwgaWRlbnRpZmllcikge1xyXG4gICAgICAgIGNvbnN0IGNhbGxiYWNrcyA9IHRoaXMub25Jbml0Q2FsbGJhY2tzLmdldChpZGVudGlmaWVyKTtcclxuICAgICAgICBpZiAoIWNhbGxiYWNrcykge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAoY29uc3QgY2FsbGJhY2sgb2YgY2FsbGJhY2tzKSB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhpbnN0YW5jZSwgaWRlbnRpZmllcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2ggKF9hKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBpZ25vcmUgZXJyb3JzIGluIHRoZSBvbkluaXQgY2FsbGJhY2tcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGdldE9ySW5pdGlhbGl6ZVNlcnZpY2UoeyBpbnN0YW5jZUlkZW50aWZpZXIsIG9wdGlvbnMgPSB7fSB9KSB7XHJcbiAgICAgICAgbGV0IGluc3RhbmNlID0gdGhpcy5pbnN0YW5jZXMuZ2V0KGluc3RhbmNlSWRlbnRpZmllcik7XHJcbiAgICAgICAgaWYgKCFpbnN0YW5jZSAmJiB0aGlzLmNvbXBvbmVudCkge1xyXG4gICAgICAgICAgICBpbnN0YW5jZSA9IHRoaXMuY29tcG9uZW50Lmluc3RhbmNlRmFjdG9yeSh0aGlzLmNvbnRhaW5lciwge1xyXG4gICAgICAgICAgICAgICAgaW5zdGFuY2VJZGVudGlmaWVyOiBub3JtYWxpemVJZGVudGlmaWVyRm9yRmFjdG9yeShpbnN0YW5jZUlkZW50aWZpZXIpLFxyXG4gICAgICAgICAgICAgICAgb3B0aW9uc1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgdGhpcy5pbnN0YW5jZXMuc2V0KGluc3RhbmNlSWRlbnRpZmllciwgaW5zdGFuY2UpO1xyXG4gICAgICAgICAgICB0aGlzLmluc3RhbmNlc09wdGlvbnMuc2V0KGluc3RhbmNlSWRlbnRpZmllciwgb3B0aW9ucyk7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBJbnZva2Ugb25Jbml0IGxpc3RlbmVycy5cclxuICAgICAgICAgICAgICogTm90ZSB0aGlzLmNvbXBvbmVudC5vbkluc3RhbmNlQ3JlYXRlZCBpcyBkaWZmZXJlbnQsIHdoaWNoIGlzIHVzZWQgYnkgdGhlIGNvbXBvbmVudCBjcmVhdG9yLFxyXG4gICAgICAgICAgICAgKiB3aGlsZSBvbkluaXQgbGlzdGVuZXJzIGFyZSByZWdpc3RlcmVkIGJ5IGNvbnN1bWVycyBvZiB0aGUgcHJvdmlkZXIuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLmludm9rZU9uSW5pdENhbGxiYWNrcyhpbnN0YW5jZSwgaW5zdGFuY2VJZGVudGlmaWVyKTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIE9yZGVyIGlzIGltcG9ydGFudFxyXG4gICAgICAgICAgICAgKiBvbkluc3RhbmNlQ3JlYXRlZCgpIHNob3VsZCBiZSBjYWxsZWQgYWZ0ZXIgdGhpcy5pbnN0YW5jZXMuc2V0KGluc3RhbmNlSWRlbnRpZmllciwgaW5zdGFuY2UpOyB3aGljaFxyXG4gICAgICAgICAgICAgKiBtYWtlcyBgaXNJbml0aWFsaXplZCgpYCByZXR1cm4gdHJ1ZS5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbXBvbmVudC5vbkluc3RhbmNlQ3JlYXRlZCkge1xyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbXBvbmVudC5vbkluc3RhbmNlQ3JlYXRlZCh0aGlzLmNvbnRhaW5lciwgaW5zdGFuY2VJZGVudGlmaWVyLCBpbnN0YW5jZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjYXRjaCAoX2EpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBpZ25vcmUgZXJyb3JzIGluIHRoZSBvbkluc3RhbmNlQ3JlYXRlZENhbGxiYWNrXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGluc3RhbmNlIHx8IG51bGw7XHJcbiAgICB9XHJcbiAgICBub3JtYWxpemVJbnN0YW5jZUlkZW50aWZpZXIoaWRlbnRpZmllciA9IERFRkFVTFRfRU5UUllfTkFNRSkge1xyXG4gICAgICAgIGlmICh0aGlzLmNvbXBvbmVudCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb21wb25lbnQubXVsdGlwbGVJbnN0YW5jZXMgPyBpZGVudGlmaWVyIDogREVGQVVMVF9FTlRSWV9OQU1FO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIGlkZW50aWZpZXI7IC8vIGFzc3VtZSBtdWx0aXBsZSBpbnN0YW5jZXMgYXJlIHN1cHBvcnRlZCBiZWZvcmUgdGhlIGNvbXBvbmVudCBpcyBwcm92aWRlZC5cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBzaG91bGRBdXRvSW5pdGlhbGl6ZSgpIHtcclxuICAgICAgICByZXR1cm4gKCEhdGhpcy5jb21wb25lbnQgJiZcclxuICAgICAgICAgICAgdGhpcy5jb21wb25lbnQuaW5zdGFudGlhdGlvbk1vZGUgIT09IFwiRVhQTElDSVRcIiAvKiBFWFBMSUNJVCAqLyk7XHJcbiAgICB9XHJcbn1cclxuLy8gdW5kZWZpbmVkIHNob3VsZCBiZSBwYXNzZWQgdG8gdGhlIHNlcnZpY2UgZmFjdG9yeSBmb3IgdGhlIGRlZmF1bHQgaW5zdGFuY2VcclxuZnVuY3Rpb24gbm9ybWFsaXplSWRlbnRpZmllckZvckZhY3RvcnkoaWRlbnRpZmllcikge1xyXG4gICAgcmV0dXJuIGlkZW50aWZpZXIgPT09IERFRkFVTFRfRU5UUllfTkFNRSA/IHVuZGVmaW5lZCA6IGlkZW50aWZpZXI7XHJcbn1cclxuZnVuY3Rpb24gaXNDb21wb25lbnRFYWdlcihjb21wb25lbnQpIHtcclxuICAgIHJldHVybiBjb21wb25lbnQuaW5zdGFudGlhdGlvbk1vZGUgPT09IFwiRUFHRVJcIiAvKiBFQUdFUiAqLztcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogQ29tcG9uZW50Q29udGFpbmVyIHRoYXQgcHJvdmlkZXMgUHJvdmlkZXJzIGZvciBzZXJ2aWNlIG5hbWUgVCwgZS5nLiBgYXV0aGAsIGBhdXRoLWludGVybmFsYFxyXG4gKi9cclxuY2xhc3MgQ29tcG9uZW50Q29udGFpbmVyIHtcclxuICAgIGNvbnN0cnVjdG9yKG5hbWUpIHtcclxuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xyXG4gICAgICAgIHRoaXMucHJvdmlkZXJzID0gbmV3IE1hcCgpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGNvbXBvbmVudCBDb21wb25lbnQgYmVpbmcgYWRkZWRcclxuICAgICAqIEBwYXJhbSBvdmVyd3JpdGUgV2hlbiBhIGNvbXBvbmVudCB3aXRoIHRoZSBzYW1lIG5hbWUgaGFzIGFscmVhZHkgYmVlbiByZWdpc3RlcmVkLFxyXG4gICAgICogaWYgb3ZlcndyaXRlIGlzIHRydWU6IG92ZXJ3cml0ZSB0aGUgZXhpc3RpbmcgY29tcG9uZW50IHdpdGggdGhlIG5ldyBjb21wb25lbnQgYW5kIGNyZWF0ZSBhIG5ld1xyXG4gICAgICogcHJvdmlkZXIgd2l0aCB0aGUgbmV3IGNvbXBvbmVudC4gSXQgY2FuIGJlIHVzZWZ1bCBpbiB0ZXN0cyB3aGVyZSB5b3Ugd2FudCB0byB1c2UgZGlmZmVyZW50IG1vY2tzXHJcbiAgICAgKiBmb3IgZGlmZmVyZW50IHRlc3RzLlxyXG4gICAgICogaWYgb3ZlcndyaXRlIGlzIGZhbHNlOiB0aHJvdyBhbiBleGNlcHRpb25cclxuICAgICAqL1xyXG4gICAgYWRkQ29tcG9uZW50KGNvbXBvbmVudCkge1xyXG4gICAgICAgIGNvbnN0IHByb3ZpZGVyID0gdGhpcy5nZXRQcm92aWRlcihjb21wb25lbnQubmFtZSk7XHJcbiAgICAgICAgaWYgKHByb3ZpZGVyLmlzQ29tcG9uZW50U2V0KCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb21wb25lbnQgJHtjb21wb25lbnQubmFtZX0gaGFzIGFscmVhZHkgYmVlbiByZWdpc3RlcmVkIHdpdGggJHt0aGlzLm5hbWV9YCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHByb3ZpZGVyLnNldENvbXBvbmVudChjb21wb25lbnQpO1xyXG4gICAgfVxyXG4gICAgYWRkT3JPdmVyd3JpdGVDb21wb25lbnQoY29tcG9uZW50KSB7XHJcbiAgICAgICAgY29uc3QgcHJvdmlkZXIgPSB0aGlzLmdldFByb3ZpZGVyKGNvbXBvbmVudC5uYW1lKTtcclxuICAgICAgICBpZiAocHJvdmlkZXIuaXNDb21wb25lbnRTZXQoKSkge1xyXG4gICAgICAgICAgICAvLyBkZWxldGUgdGhlIGV4aXN0aW5nIHByb3ZpZGVyIGZyb20gdGhlIGNvbnRhaW5lciwgc28gd2UgY2FuIHJlZ2lzdGVyIHRoZSBuZXcgY29tcG9uZW50XHJcbiAgICAgICAgICAgIHRoaXMucHJvdmlkZXJzLmRlbGV0ZShjb21wb25lbnQubmFtZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuYWRkQ29tcG9uZW50KGNvbXBvbmVudCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIGdldFByb3ZpZGVyIHByb3ZpZGVzIGEgdHlwZSBzYWZlIGludGVyZmFjZSB3aGVyZSBpdCBjYW4gb25seSBiZSBjYWxsZWQgd2l0aCBhIGZpZWxkIG5hbWVcclxuICAgICAqIHByZXNlbnQgaW4gTmFtZVNlcnZpY2VNYXBwaW5nIGludGVyZmFjZS5cclxuICAgICAqXHJcbiAgICAgKiBGaXJlYmFzZSBTREtzIHByb3ZpZGluZyBzZXJ2aWNlcyBzaG91bGQgZXh0ZW5kIE5hbWVTZXJ2aWNlTWFwcGluZyBpbnRlcmZhY2UgdG8gcmVnaXN0ZXJcclxuICAgICAqIHRoZW1zZWx2ZXMuXHJcbiAgICAgKi9cclxuICAgIGdldFByb3ZpZGVyKG5hbWUpIHtcclxuICAgICAgICBpZiAodGhpcy5wcm92aWRlcnMuaGFzKG5hbWUpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByb3ZpZGVycy5nZXQobmFtZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGNyZWF0ZSBhIFByb3ZpZGVyIGZvciBhIHNlcnZpY2UgdGhhdCBoYXNuJ3QgcmVnaXN0ZXJlZCB3aXRoIEZpcmViYXNlXHJcbiAgICAgICAgY29uc3QgcHJvdmlkZXIgPSBuZXcgUHJvdmlkZXIobmFtZSwgdGhpcyk7XHJcbiAgICAgICAgdGhpcy5wcm92aWRlcnMuc2V0KG5hbWUsIHByb3ZpZGVyKTtcclxuICAgICAgICByZXR1cm4gcHJvdmlkZXI7XHJcbiAgICB9XHJcbiAgICBnZXRQcm92aWRlcnMoKSB7XHJcbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5wcm92aWRlcnMudmFsdWVzKCkpO1xyXG4gICAgfVxyXG59XG5cbmV4cG9ydCB7IENvbXBvbmVudCwgQ29tcG9uZW50Q29udGFpbmVyLCBQcm92aWRlciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguZXNtMjAxNy5qcy5tYXBcbiIsIi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBBIGNvbnRhaW5lciBmb3IgYWxsIG9mIHRoZSBMb2dnZXIgaW5zdGFuY2VzXHJcbiAqL1xyXG5jb25zdCBpbnN0YW5jZXMgPSBbXTtcclxuLyoqXHJcbiAqIFRoZSBKUyBTREsgc3VwcG9ydHMgNSBsb2cgbGV2ZWxzIGFuZCBhbHNvIGFsbG93cyBhIHVzZXIgdGhlIGFiaWxpdHkgdG9cclxuICogc2lsZW5jZSB0aGUgbG9ncyBhbHRvZ2V0aGVyLlxyXG4gKlxyXG4gKiBUaGUgb3JkZXIgaXMgYSBmb2xsb3dzOlxyXG4gKiBERUJVRyA8IFZFUkJPU0UgPCBJTkZPIDwgV0FSTiA8IEVSUk9SXHJcbiAqXHJcbiAqIEFsbCBvZiB0aGUgbG9nIHR5cGVzIGFib3ZlIHRoZSBjdXJyZW50IGxvZyBsZXZlbCB3aWxsIGJlIGNhcHR1cmVkIChpLmUuIGlmXHJcbiAqIHlvdSBzZXQgdGhlIGxvZyBsZXZlbCB0byBgSU5GT2AsIGVycm9ycyB3aWxsIHN0aWxsIGJlIGxvZ2dlZCwgYnV0IGBERUJVR2AgYW5kXHJcbiAqIGBWRVJCT1NFYCBsb2dzIHdpbGwgbm90KVxyXG4gKi9cclxudmFyIExvZ0xldmVsO1xyXG4oZnVuY3Rpb24gKExvZ0xldmVsKSB7XHJcbiAgICBMb2dMZXZlbFtMb2dMZXZlbFtcIkRFQlVHXCJdID0gMF0gPSBcIkRFQlVHXCI7XHJcbiAgICBMb2dMZXZlbFtMb2dMZXZlbFtcIlZFUkJPU0VcIl0gPSAxXSA9IFwiVkVSQk9TRVwiO1xyXG4gICAgTG9nTGV2ZWxbTG9nTGV2ZWxbXCJJTkZPXCJdID0gMl0gPSBcIklORk9cIjtcclxuICAgIExvZ0xldmVsW0xvZ0xldmVsW1wiV0FSTlwiXSA9IDNdID0gXCJXQVJOXCI7XHJcbiAgICBMb2dMZXZlbFtMb2dMZXZlbFtcIkVSUk9SXCJdID0gNF0gPSBcIkVSUk9SXCI7XHJcbiAgICBMb2dMZXZlbFtMb2dMZXZlbFtcIlNJTEVOVFwiXSA9IDVdID0gXCJTSUxFTlRcIjtcclxufSkoTG9nTGV2ZWwgfHwgKExvZ0xldmVsID0ge30pKTtcclxuY29uc3QgbGV2ZWxTdHJpbmdUb0VudW0gPSB7XHJcbiAgICAnZGVidWcnOiBMb2dMZXZlbC5ERUJVRyxcclxuICAgICd2ZXJib3NlJzogTG9nTGV2ZWwuVkVSQk9TRSxcclxuICAgICdpbmZvJzogTG9nTGV2ZWwuSU5GTyxcclxuICAgICd3YXJuJzogTG9nTGV2ZWwuV0FSTixcclxuICAgICdlcnJvcic6IExvZ0xldmVsLkVSUk9SLFxyXG4gICAgJ3NpbGVudCc6IExvZ0xldmVsLlNJTEVOVFxyXG59O1xyXG4vKipcclxuICogVGhlIGRlZmF1bHQgbG9nIGxldmVsXHJcbiAqL1xyXG5jb25zdCBkZWZhdWx0TG9nTGV2ZWwgPSBMb2dMZXZlbC5JTkZPO1xyXG4vKipcclxuICogQnkgZGVmYXVsdCwgYGNvbnNvbGUuZGVidWdgIGlzIG5vdCBkaXNwbGF5ZWQgaW4gdGhlIGRldmVsb3BlciBjb25zb2xlIChpblxyXG4gKiBjaHJvbWUpLiBUbyBhdm9pZCBmb3JjaW5nIHVzZXJzIHRvIGhhdmUgdG8gb3B0LWluIHRvIHRoZXNlIGxvZ3MgdHdpY2VcclxuICogKGkuZS4gb25jZSBmb3IgZmlyZWJhc2UsIGFuZCBvbmNlIGluIHRoZSBjb25zb2xlKSwgd2UgYXJlIHNlbmRpbmcgYERFQlVHYFxyXG4gKiBsb2dzIHRvIHRoZSBgY29uc29sZS5sb2dgIGZ1bmN0aW9uLlxyXG4gKi9cclxuY29uc3QgQ29uc29sZU1ldGhvZCA9IHtcclxuICAgIFtMb2dMZXZlbC5ERUJVR106ICdsb2cnLFxyXG4gICAgW0xvZ0xldmVsLlZFUkJPU0VdOiAnbG9nJyxcclxuICAgIFtMb2dMZXZlbC5JTkZPXTogJ2luZm8nLFxyXG4gICAgW0xvZ0xldmVsLldBUk5dOiAnd2FybicsXHJcbiAgICBbTG9nTGV2ZWwuRVJST1JdOiAnZXJyb3InXHJcbn07XHJcbi8qKlxyXG4gKiBUaGUgZGVmYXVsdCBsb2cgaGFuZGxlciB3aWxsIGZvcndhcmQgREVCVUcsIFZFUkJPU0UsIElORk8sIFdBUk4sIGFuZCBFUlJPUlxyXG4gKiBtZXNzYWdlcyBvbiB0byB0aGVpciBjb3JyZXNwb25kaW5nIGNvbnNvbGUgY291bnRlcnBhcnRzIChpZiB0aGUgbG9nIG1ldGhvZFxyXG4gKiBpcyBzdXBwb3J0ZWQgYnkgdGhlIGN1cnJlbnQgbG9nIGxldmVsKVxyXG4gKi9cclxuY29uc3QgZGVmYXVsdExvZ0hhbmRsZXIgPSAoaW5zdGFuY2UsIGxvZ1R5cGUsIC4uLmFyZ3MpID0+IHtcclxuICAgIGlmIChsb2dUeXBlIDwgaW5zdGFuY2UubG9nTGV2ZWwpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCk7XHJcbiAgICBjb25zdCBtZXRob2QgPSBDb25zb2xlTWV0aG9kW2xvZ1R5cGVdO1xyXG4gICAgaWYgKG1ldGhvZCkge1xyXG4gICAgICAgIGNvbnNvbGVbbWV0aG9kXShgWyR7bm93fV0gICR7aW5zdGFuY2UubmFtZX06YCwgLi4uYXJncyk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEF0dGVtcHRlZCB0byBsb2cgYSBtZXNzYWdlIHdpdGggYW4gaW52YWxpZCBsb2dUeXBlICh2YWx1ZTogJHtsb2dUeXBlfSlgKTtcclxuICAgIH1cclxufTtcclxuY2xhc3MgTG9nZ2VyIHtcclxuICAgIC8qKlxyXG4gICAgICogR2l2ZXMgeW91IGFuIGluc3RhbmNlIG9mIGEgTG9nZ2VyIHRvIGNhcHR1cmUgbWVzc2FnZXMgYWNjb3JkaW5nIHRvXHJcbiAgICAgKiBGaXJlYmFzZSdzIGxvZ2dpbmcgc2NoZW1lLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBuYW1lIFRoZSBuYW1lIHRoYXQgdGhlIGxvZ3Mgd2lsbCBiZSBhc3NvY2lhdGVkIHdpdGhcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IobmFtZSkge1xyXG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIGxvZyBsZXZlbCBvZiB0aGUgZ2l2ZW4gTG9nZ2VyIGluc3RhbmNlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuX2xvZ0xldmVsID0gZGVmYXVsdExvZ0xldmVsO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBtYWluIChpbnRlcm5hbCkgbG9nIGhhbmRsZXIgZm9yIHRoZSBMb2dnZXIgaW5zdGFuY2UuXHJcbiAgICAgICAgICogQ2FuIGJlIHNldCB0byBhIG5ldyBmdW5jdGlvbiBpbiBpbnRlcm5hbCBwYWNrYWdlIGNvZGUgYnV0IG5vdCBieSB1c2VyLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuX2xvZ0hhbmRsZXIgPSBkZWZhdWx0TG9nSGFuZGxlcjtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgb3B0aW9uYWwsIGFkZGl0aW9uYWwsIHVzZXItZGVmaW5lZCBsb2cgaGFuZGxlciBmb3IgdGhlIExvZ2dlciBpbnN0YW5jZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLl91c2VyTG9nSGFuZGxlciA9IG51bGw7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ2FwdHVyZSB0aGUgY3VycmVudCBpbnN0YW5jZSBmb3IgbGF0ZXIgdXNlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgaW5zdGFuY2VzLnB1c2godGhpcyk7XHJcbiAgICB9XHJcbiAgICBnZXQgbG9nTGV2ZWwoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvZ0xldmVsO1xyXG4gICAgfVxyXG4gICAgc2V0IGxvZ0xldmVsKHZhbCkge1xyXG4gICAgICAgIGlmICghKHZhbCBpbiBMb2dMZXZlbCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgSW52YWxpZCB2YWx1ZSBcIiR7dmFsfVwiIGFzc2lnbmVkIHRvIFxcYGxvZ0xldmVsXFxgYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2xvZ0xldmVsID0gdmFsO1xyXG4gICAgfVxyXG4gICAgLy8gV29ya2Fyb3VuZCBmb3Igc2V0dGVyL2dldHRlciBoYXZpbmcgdG8gYmUgdGhlIHNhbWUgdHlwZS5cclxuICAgIHNldExvZ0xldmVsKHZhbCkge1xyXG4gICAgICAgIHRoaXMuX2xvZ0xldmVsID0gdHlwZW9mIHZhbCA9PT0gJ3N0cmluZycgPyBsZXZlbFN0cmluZ1RvRW51bVt2YWxdIDogdmFsO1xyXG4gICAgfVxyXG4gICAgZ2V0IGxvZ0hhbmRsZXIoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvZ0hhbmRsZXI7XHJcbiAgICB9XHJcbiAgICBzZXQgbG9nSGFuZGxlcih2YWwpIHtcclxuICAgICAgICBpZiAodHlwZW9mIHZhbCAhPT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdWYWx1ZSBhc3NpZ25lZCB0byBgbG9nSGFuZGxlcmAgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2xvZ0hhbmRsZXIgPSB2YWw7XHJcbiAgICB9XHJcbiAgICBnZXQgdXNlckxvZ0hhbmRsZXIoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3VzZXJMb2dIYW5kbGVyO1xyXG4gICAgfVxyXG4gICAgc2V0IHVzZXJMb2dIYW5kbGVyKHZhbCkge1xyXG4gICAgICAgIHRoaXMuX3VzZXJMb2dIYW5kbGVyID0gdmFsO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgZnVuY3Rpb25zIGJlbG93IGFyZSBhbGwgYmFzZWQgb24gdGhlIGBjb25zb2xlYCBpbnRlcmZhY2VcclxuICAgICAqL1xyXG4gICAgZGVidWcoLi4uYXJncykge1xyXG4gICAgICAgIHRoaXMuX3VzZXJMb2dIYW5kbGVyICYmIHRoaXMuX3VzZXJMb2dIYW5kbGVyKHRoaXMsIExvZ0xldmVsLkRFQlVHLCAuLi5hcmdzKTtcclxuICAgICAgICB0aGlzLl9sb2dIYW5kbGVyKHRoaXMsIExvZ0xldmVsLkRFQlVHLCAuLi5hcmdzKTtcclxuICAgIH1cclxuICAgIGxvZyguLi5hcmdzKSB7XHJcbiAgICAgICAgdGhpcy5fdXNlckxvZ0hhbmRsZXIgJiZcclxuICAgICAgICAgICAgdGhpcy5fdXNlckxvZ0hhbmRsZXIodGhpcywgTG9nTGV2ZWwuVkVSQk9TRSwgLi4uYXJncyk7XHJcbiAgICAgICAgdGhpcy5fbG9nSGFuZGxlcih0aGlzLCBMb2dMZXZlbC5WRVJCT1NFLCAuLi5hcmdzKTtcclxuICAgIH1cclxuICAgIGluZm8oLi4uYXJncykge1xyXG4gICAgICAgIHRoaXMuX3VzZXJMb2dIYW5kbGVyICYmIHRoaXMuX3VzZXJMb2dIYW5kbGVyKHRoaXMsIExvZ0xldmVsLklORk8sIC4uLmFyZ3MpO1xyXG4gICAgICAgIHRoaXMuX2xvZ0hhbmRsZXIodGhpcywgTG9nTGV2ZWwuSU5GTywgLi4uYXJncyk7XHJcbiAgICB9XHJcbiAgICB3YXJuKC4uLmFyZ3MpIHtcclxuICAgICAgICB0aGlzLl91c2VyTG9nSGFuZGxlciAmJiB0aGlzLl91c2VyTG9nSGFuZGxlcih0aGlzLCBMb2dMZXZlbC5XQVJOLCAuLi5hcmdzKTtcclxuICAgICAgICB0aGlzLl9sb2dIYW5kbGVyKHRoaXMsIExvZ0xldmVsLldBUk4sIC4uLmFyZ3MpO1xyXG4gICAgfVxyXG4gICAgZXJyb3IoLi4uYXJncykge1xyXG4gICAgICAgIHRoaXMuX3VzZXJMb2dIYW5kbGVyICYmIHRoaXMuX3VzZXJMb2dIYW5kbGVyKHRoaXMsIExvZ0xldmVsLkVSUk9SLCAuLi5hcmdzKTtcclxuICAgICAgICB0aGlzLl9sb2dIYW5kbGVyKHRoaXMsIExvZ0xldmVsLkVSUk9SLCAuLi5hcmdzKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBzZXRMb2dMZXZlbChsZXZlbCkge1xyXG4gICAgaW5zdGFuY2VzLmZvckVhY2goaW5zdCA9PiB7XHJcbiAgICAgICAgaW5zdC5zZXRMb2dMZXZlbChsZXZlbCk7XHJcbiAgICB9KTtcclxufVxyXG5mdW5jdGlvbiBzZXRVc2VyTG9nSGFuZGxlcihsb2dDYWxsYmFjaywgb3B0aW9ucykge1xyXG4gICAgZm9yIChjb25zdCBpbnN0YW5jZSBvZiBpbnN0YW5jZXMpIHtcclxuICAgICAgICBsZXQgY3VzdG9tTG9nTGV2ZWwgPSBudWxsO1xyXG4gICAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMubGV2ZWwpIHtcclxuICAgICAgICAgICAgY3VzdG9tTG9nTGV2ZWwgPSBsZXZlbFN0cmluZ1RvRW51bVtvcHRpb25zLmxldmVsXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGxvZ0NhbGxiYWNrID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGluc3RhbmNlLnVzZXJMb2dIYW5kbGVyID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGluc3RhbmNlLnVzZXJMb2dIYW5kbGVyID0gKGluc3RhbmNlLCBsZXZlbCwgLi4uYXJncykgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9IGFyZ3NcclxuICAgICAgICAgICAgICAgICAgICAubWFwKGFyZyA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFyZyA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgYXJnID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXJnO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgYXJnID09PSAnbnVtYmVyJyB8fCB0eXBlb2YgYXJnID09PSAnYm9vbGVhbicpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFyZy50b1N0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChhcmcgaW5zdGFuY2VvZiBFcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXJnLm1lc3NhZ2U7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGFyZyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGlnbm9yZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKGFyZyA9PiBhcmcpXHJcbiAgICAgICAgICAgICAgICAgICAgLmpvaW4oJyAnKTtcclxuICAgICAgICAgICAgICAgIGlmIChsZXZlbCA+PSAoY3VzdG9tTG9nTGV2ZWwgIT09IG51bGwgJiYgY3VzdG9tTG9nTGV2ZWwgIT09IHZvaWQgMCA/IGN1c3RvbUxvZ0xldmVsIDogaW5zdGFuY2UubG9nTGV2ZWwpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbG9nQ2FsbGJhY2soe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXZlbDogTG9nTGV2ZWxbbGV2ZWxdLnRvTG93ZXJDYXNlKCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3MsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IGluc3RhbmNlLm5hbWVcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cblxuZXhwb3J0IHsgTG9nTGV2ZWwsIExvZ2dlciwgc2V0TG9nTGV2ZWwsIHNldFVzZXJMb2dIYW5kbGVyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5lc20yMDE3LmpzLm1hcFxuIiwiLy8gVGhlIG1vZHVsZSBjYWNoZVxudmFyIF9fd2VicGFja19tb2R1bGVfY2FjaGVfXyA9IHt9O1xuXG4vLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcblx0dmFyIGNhY2hlZE1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF07XG5cdGlmIChjYWNoZWRNb2R1bGUgIT09IHVuZGVmaW5lZCkge1xuXHRcdHJldHVybiBjYWNoZWRNb2R1bGUuZXhwb3J0cztcblx0fVxuXHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuXHR2YXIgbW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXSA9IHtcblx0XHRpZDogbW9kdWxlSWQsXG5cdFx0Ly8gbm8gbW9kdWxlLmxvYWRlZCBuZWVkZWRcblx0XHRleHBvcnRzOiB7fVxuXHR9O1xuXG5cdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuXHRfX3dlYnBhY2tfbW9kdWxlc19fW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuXHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuXHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG59XG5cbi8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG5fX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBfX3dlYnBhY2tfbW9kdWxlc19fO1xuXG4iLCIvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuX193ZWJwYWNrX3JlcXVpcmVfXy5uID0gKG1vZHVsZSkgPT4ge1xuXHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cblx0XHQoKSA9PiAobW9kdWxlWydkZWZhdWx0J10pIDpcblx0XHQoKSA9PiAobW9kdWxlKTtcblx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgeyBhOiBnZXR0ZXIgfSk7XG5cdHJldHVybiBnZXR0ZXI7XG59OyIsIi8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb25zIGZvciBoYXJtb255IGV4cG9ydHNcbl9fd2VicGFja19yZXF1aXJlX18uZCA9IChleHBvcnRzLCBkZWZpbml0aW9uKSA9PiB7XG5cdGZvcih2YXIga2V5IGluIGRlZmluaXRpb24pIHtcblx0XHRpZihfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZGVmaW5pdGlvbiwga2V5KSAmJiAhX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIGtleSkpIHtcblx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBkZWZpbml0aW9uW2tleV0gfSk7XG5cdFx0fVxuXHR9XG59OyIsIl9fd2VicGFja19yZXF1aXJlX18uZyA9IChmdW5jdGlvbigpIHtcblx0aWYgKHR5cGVvZiBnbG9iYWxUaGlzID09PSAnb2JqZWN0JykgcmV0dXJuIGdsb2JhbFRoaXM7XG5cdHRyeSB7XG5cdFx0cmV0dXJuIHRoaXMgfHwgbmV3IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHRpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ29iamVjdCcpIHJldHVybiB3aW5kb3c7XG5cdH1cbn0pKCk7IiwiX193ZWJwYWNrX3JlcXVpcmVfXy5vID0gKG9iaiwgcHJvcCkgPT4gKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApKSIsIi8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbl9fd2VicGFja19yZXF1aXJlX18uciA9IChleHBvcnRzKSA9PiB7XG5cdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuXHR9XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG59OyIsInZhciBzY3JpcHRVcmw7XG5pZiAoX193ZWJwYWNrX3JlcXVpcmVfXy5nLmltcG9ydFNjcmlwdHMpIHNjcmlwdFVybCA9IF9fd2VicGFja19yZXF1aXJlX18uZy5sb2NhdGlvbiArIFwiXCI7XG52YXIgZG9jdW1lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fLmcuZG9jdW1lbnQ7XG5pZiAoIXNjcmlwdFVybCAmJiBkb2N1bWVudCkge1xuXHRpZiAoZG9jdW1lbnQuY3VycmVudFNjcmlwdClcblx0XHRzY3JpcHRVcmwgPSBkb2N1bWVudC5jdXJyZW50U2NyaXB0LnNyY1xuXHRpZiAoIXNjcmlwdFVybCkge1xuXHRcdHZhciBzY3JpcHRzID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJzY3JpcHRcIik7XG5cdFx0aWYoc2NyaXB0cy5sZW5ndGgpIHNjcmlwdFVybCA9IHNjcmlwdHNbc2NyaXB0cy5sZW5ndGggLSAxXS5zcmNcblx0fVxufVxuLy8gV2hlbiBzdXBwb3J0aW5nIGJyb3dzZXJzIHdoZXJlIGFuIGF1dG9tYXRpYyBwdWJsaWNQYXRoIGlzIG5vdCBzdXBwb3J0ZWQgeW91IG11c3Qgc3BlY2lmeSBhbiBvdXRwdXQucHVibGljUGF0aCBtYW51YWxseSB2aWEgY29uZmlndXJhdGlvblxuLy8gb3IgcGFzcyBhbiBlbXB0eSBzdHJpbmcgKFwiXCIpIGFuZCBzZXQgdGhlIF9fd2VicGFja19wdWJsaWNfcGF0aF9fIHZhcmlhYmxlIGZyb20geW91ciBjb2RlIHRvIHVzZSB5b3VyIG93biBsb2dpYy5cbmlmICghc2NyaXB0VXJsKSB0aHJvdyBuZXcgRXJyb3IoXCJBdXRvbWF0aWMgcHVibGljUGF0aCBpcyBub3Qgc3VwcG9ydGVkIGluIHRoaXMgYnJvd3NlclwiKTtcbnNjcmlwdFVybCA9IHNjcmlwdFVybC5yZXBsYWNlKC8jLiokLywgXCJcIikucmVwbGFjZSgvXFw/LiokLywgXCJcIikucmVwbGFjZSgvXFwvW15cXC9dKyQvLCBcIi9cIik7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBzY3JpcHRVcmw7IiwiX193ZWJwYWNrX3JlcXVpcmVfXy5iID0gZG9jdW1lbnQuYmFzZVVSSSB8fCBzZWxmLmxvY2F0aW9uLmhyZWY7XG5cbi8vIG9iamVjdCB0byBzdG9yZSBsb2FkZWQgYW5kIGxvYWRpbmcgY2h1bmtzXG4vLyB1bmRlZmluZWQgPSBjaHVuayBub3QgbG9hZGVkLCBudWxsID0gY2h1bmsgcHJlbG9hZGVkL3ByZWZldGNoZWRcbi8vIFtyZXNvbHZlLCByZWplY3QsIFByb21pc2VdID0gY2h1bmsgbG9hZGluZywgMCA9IGNodW5rIGxvYWRlZFxudmFyIGluc3RhbGxlZENodW5rcyA9IHtcblx0XCJpbmRleFwiOiAwXG59O1xuXG4vLyBubyBjaHVuayBvbiBkZW1hbmQgbG9hZGluZ1xuXG4vLyBubyBwcmVmZXRjaGluZ1xuXG4vLyBubyBwcmVsb2FkZWRcblxuLy8gbm8gSE1SXG5cbi8vIG5vIEhNUiBtYW5pZmVzdFxuXG4vLyBubyBvbiBjaHVua3MgbG9hZGVkXG5cbi8vIG5vIGpzb25wIGZ1bmN0aW9uIiwiLy8gTWFpbiBzYXNzIGZpbGUgaW1wb3J0aW5nIGFsbCBvdGhlciBzdWJmaWxlcyAoY2hlY2sgLi9zYXNzKVxuaW1wb3J0IFwiLi9zYXNzL2luZGV4LnNhc3NcIjtcblxuXG4vLyNyZWdpb24gZ2VuZXJhbFxuXG5cbmZ1bmN0aW9uIGdldFdpZHRoKCkge1xuICByZXR1cm4gTWF0aC5tYXgoXG4gICAgZG9jdW1lbnQuYm9keS5zY3JvbGxXaWR0aCxcbiAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsV2lkdGgsXG4gICAgZG9jdW1lbnQuYm9keS5vZmZzZXRXaWR0aCxcbiAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQub2Zmc2V0V2lkdGgsXG4gICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoXG4gICk7XG59XG5cbi8vI2VuZHJlZ2lvblxuXG5cbi8vI3JlZ2lvbiBMb2FkaW5nIHF1YWxpdGllc1xuaW1wb3J0IFR5cGVkIGZyb20gJ3R5cGVkLmpzJztcblxuY29uc3QgcXVhbGl0aWVzID0gW1wiQ3V0dGluZyBFZGdlXCIsIFwiVXBzY2FsZVwiICwgXCJBcnRpc3RpY1wiLCBcIkV4dHJhb3JkaW5hcnlcIl07XG5cbnZhciBvcHRpb25zID0ge1xuICBzdHJpbmdzOiBxdWFsaXRpZXMsXG4gIHR5cGVTcGVlZDogMTUwLFxuICBiYWNrU3BlZWQ6IDUwLFxuICBzaHVmZmxlOiBmYWxzZSxcbiAgYmFja0RlbGF5OiAxMDAwLFxuICBmYWRlT3V0OiBmYWxzZSxcblxuICAvL2N1cnNvclxuICBzaG93Q3Vyc29yOiB0cnVlLFxuICBjdXJzb3JDaGFyOiAnXycsXG59O1xuXG52YXIgdHlwZWQgPSBuZXcgVHlwZWQoJyNxdWFsaXRpZXMgc3Ryb25nJywgb3B0aW9ucyk7XG5cbi8vI2VuZHJlZ2lvblxuXG4vLyNyZWdpb24gaG9iYnkgaGFuZGxpbmdcbmNvbnN0IGhvYmJpZXMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcuaG9iYnkgYScpO1xuY29uc3QgaG9iYmllc0NvbnRhaW5lciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdob2JiaWVzLWNvbnRhaW5lcicpO1xuaG9iYmllcy5mb3JFYWNoKGhvYmJ5ID0+IHtcbiAgICBob2JieS5hZGRFdmVudExpc3RlbmVyKCdmb2N1cycsICgpID0+IHNldEp1c3RpZnlDb250ZW50KGhvYmJ5LCA2NTApKTtcbiAgICBob2JieS5hZGRFdmVudExpc3RlbmVyKCdmb2N1c291dCcsICgpID0+IGhvYmJpZXNDb250YWluZXIuc3R5bGUuanVzdGlmeUNvbnRlbnQgPSBcInNwYWNlLWFyb3VuZFwiKTtcbn0pXG5cbmZ1bmN0aW9uIHdpZHRoU21hbGxlclRoYW4od2lkdGgpe1xuICAgIGNvbnN0IGNsaWVudFdpZHRoID0gZ2V0V2lkdGgoKTsgIFxuICAgIGlmKGNsaWVudFdpZHRoID4gd2lkdGgpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbn1cblxuLy9UT0RPOiByZWZhY3RvclxuZnVuY3Rpb24gc2V0SnVzdGlmeUNvbnRlbnQoaG9iYnksIHByZWZlcmVkQ2xpZW50V2lkdGgpeyAvLzY1MHB4XG4gICAgY29uc3QgY2xpZW50V2lkdGggPSBnZXRXaWR0aCgpOyAgXG4gICAgaWYoY2xpZW50V2lkdGggPiBwcmVmZXJlZENsaWVudFdpZHRoKVxuICAgICAgICByZXR1cm47XG5cbiAgICBjb25zdCBpZCA9IGhvYmJ5LnBhcmVudE5vZGUuaWRcblxuICAgIGlmKGlkID09ICBcImRldmVsb3BlclwiKSAvL2p1c3RpZnktY29udGVudDogc3RhcnQ7XG4gICAgICAgIGhvYmJpZXNDb250YWluZXIuc3R5bGUuanVzdGlmeUNvbnRlbnQgPSBcImZsZXgtc3RhcnRcIjtcbiAgICBlbHNlIGlmKGlkID09IFwiZGVzaWduZXJcIikgLy9qdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgICAgICAgaG9iYmllc0NvbnRhaW5lci5zdHlsZS5qdXN0aWZ5Q29udGVudCA9IFwiY2VudGVyXCI7XG4gICAgZWxzZSBpZihpZCA9PSBcImNvbGxlY3RvclwiKSAvL2p1c3RpZnktY29udGVudDogZW5kO1xuICAgICAgICBob2JiaWVzQ29udGFpbmVyLnN0eWxlLmp1c3RpZnlDb250ZW50ID0gXCJmbGV4LWVuZFwiO1xufVxuXG4vLyNlbmRyZWdpb25cblxuXG4vLyNyZWdpb24gc3RpY2t5IGhlYWRlclxud2luZG93Lm9uc2Nyb2xsID0gZnVuY3Rpb24oKSB7c3RpY2tIZWFkZXIoKX07XG5cbnZhciBoZWFkZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImhlYWRlclwiKTtcbnZhciBsYW5kaW5nQ29udGFpbmVyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJoZXJvLWNvbnRhaW5lclwiKTtcblxuXG5mdW5jdGlvbiBzdGlja0hlYWRlcigpIHtcbiAgICB2YXIgb2Zmc2V0ID0gaGVhZGVyLm9mZnNldFRvcDtcbiAgICBpZiAod2luZG93LnBhZ2VZT2Zmc2V0ID4gb2Zmc2V0KSB7XG4gICAgICAgIGhlYWRlci5jbGFzc0xpc3QuYWRkKFwic3RpY2t5XCIpO1xuICAgICAgICBsYW5kaW5nQ29udGFpbmVyLnN0eWxlLnBhZGRpbmdUb3AgPSBoZWFkZXIuY2xpZW50SGVpZ2h0ICsgXCJweFwiOyBcbiAgICB9IGVsc2Uge1xuICAgICAgICBoZWFkZXIuY2xhc3NMaXN0LnJlbW92ZShcInN0aWNreVwiKTtcbiAgICAgICAgbGFuZGluZ0NvbnRhaW5lci5zdHlsZS5wYWRkaW5nVG9wID0gXCIwcHhcIjsgXG4gICAgfVxufVxuLy8jZW5kcmVnaW9uXG5cblxuLy8jcmVnaW9uIGR1dGllcyBoYW5kbGluZ1xuY29uc3QgZHV0eU5hbWVzID0gW1wiRXhjZXB0aW9uYWxseSBQZXJmb3JtYW50XCIsXG4gICAgICAgICAgICBcIkZ1bGx5IFJlc3BvbnNpdmVcIixcbiAgICAgICAgICAgIFwiSGlnaGx5IEludHVpdGl2ZVwiLFxuICAgICAgICAgICAgXCJTRU8gRGV2ZWxvcGVyIFJlYWR5XCJdO1xuXG5jb25zdCBkdXR5RGVzY3JpcHRpb25zID0gW1wiTXkgZHV0eSBpcyB0byBlbnN1cmUgZmFzdCBsb2FkIHRpbWVzIGFuZCBubyBhbnkgaXNzdWVzIHdpdGggcmVuZGVyaW5nIGFuZFwiXG4gICAgICAgICAgICAgICAgICAgICAgICArIFwiIGludHJhY3Rpb25zLiBJ4oCZbSBnb2luZyB0byBnaXZlIHlvdSB0aGUgZmFzdGVzdCB2ZXJzaW9uIG9mIHlvdXIgd2Vic2l0ZS5cIixcblxuICAgICAgICAgICAgICAgICAgICBcIkZyb20gNEsgc2NyZWVuIGFsbCB0aGUgd2F5IHRvIGZvbGRhYmxlIGRldmljZXMsIG15IGxheW91dCB3aWxsIGJlIGZsdWVudCBhbmQgZXllXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICsgXCIgYXBwZWFsaW5nIG5vIG1hdHRlciB0aGUgdXNlcidzIGRldmljZSBmb3JtIGZhY3RvciBvciBicmFuZC5cIixcblxuICAgICAgICAgICAgICAgICAgICBcIktub3duIGFib3V0IG1lLCAgSSBoYXZlIGEgc3Ryb25nIHByZWZlcmVuY2UgZm9yIHN0cm9uZyBhbmQgcG93ZXJmdWwgeWV0LFwiXG4gICAgICAgICAgICAgICAgICAgICAgICArIFwiIGVhc3kgdG8gdXNlIFVJLlwiLFxuXG4gICAgICAgICAgICAgICAgICAgIFwiRW5zdXJpbmcgYWxsIHBhZ2VzIGFyZSBvcHRpbWl6ZWQgZm9yIHNlYXJjaCBlbmdpbmUgcmVzdWx0cyByYW5raW5nXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICsgXCIgYnkgZm9sbG93aW5nIFNFTyBiZXN0IHByYWN0aWNlcyBhbmQgYnVpbGRpbmcgc2VtYW50aWMgbWFya3VwLlwiXTtcblxuY29uc3QgZHV0eUljb25zICA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5kdXR5LWljb24nKTtcbmNvbnN0IGFjdGl2ZUR1dHlDbGFzcyA9IFwiYWN0aXZlLWR1dHlcIjtcbmR1dHlJY29ucy5mb3JFYWNoKGR1dHlJY29uID0+IHtcbiAgICBkdXR5SWNvbi5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWVudGVyJywgKCkgPT4gaG9iYnlJY29uSG92ZXJDb250cm9sKGR1dHlJY29uKSk7XG4gICAgZHV0eUljb24uYWRkRXZlbnRMaXN0ZW5lcignbW91c2VsZWF2ZScsICgpID0+IGR1dHlJY29uLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IFwidHJhbnNwYXJlbnRcIik7XG4gICAgZHV0eUljb24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiBhY3RpdmF0ZUR1dHkoZHV0eUljb24pKTtcbn0pXG5cbmZ1bmN0aW9uIGhvYmJ5SWNvbkhvdmVyQ29udHJvbChkdXR5SWNvbil7XG4gICAgaWYoZHV0eUljb24ucGFyZW50Tm9kZS5jbGFzc0xpc3QuY29udGFpbnMoYWN0aXZlRHV0eUNsYXNzKSl7XG4gICAgICAgIGR1dHlJY29uLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IFwidHJhbnNwYXJlbnRcIjtcbiAgICAgICAgY29uc29sZS5sb2coXCJhY3RpdmUgaG92ZXJcIik7XG5cbiAgICB9XG4gICAgZWxzZXtcbiAgICAgICAgZHV0eUljb24uc3R5bGUuYmFja2dyb3VuZENvbG9yID0gXCJyZ2JhKDI1MCwgMjUwLCAyNTAsIDAuMDc1KVwiO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gYWN0aXZhdGVEdXR5KGR1dHlJY29uKXtcblxuICAgIGR1dHlJY29ucy5mb3JFYWNoKGFsbER1dGllcyA9PiBhbGxEdXRpZXMucGFyZW50Tm9kZS5jbGFzc0xpc3QucmVtb3ZlKGFjdGl2ZUR1dHlDbGFzcykpO1xuICAgIGR1dHlJY29uLnBhcmVudE5vZGUuY2xhc3NMaXN0LmFkZChhY3RpdmVEdXR5Q2xhc3MpO1xuXG5cbiAgICB2YXIgZHV0aWVzU2xpY2VkID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdkdXRpZXMnKS5jaGlsZHJlbiApO1xuICAgIGNvbnN0IGR1dHlJbmRleCA9IGR1dGllc1NsaWNlZC5pbmRleE9mKGR1dHlJY29uLnBhcmVudE5vZGUpO1xuXG4gICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJkdXR5LWRlc2NyaXB0aW9uXCIpLmlubmVySFRNTCA9IGR1dHlEZXNjcmlwdGlvbnNbZHV0eUluZGV4XTtcbiAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImR1dHktbmFtZVwiKS5pbm5lckhUTUwgPSBkdXR5TmFtZXNbZHV0eUluZGV4XTtcbn1cbi8vI2VuZHJlZ2lvblxuXG5cbndpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiY29udGV4dG1lbnVcIiwgZSA9PiBlLnByZXZlbnREZWZhdWx0KCkpO1xuXG5cbi8vIEZvcm0gaW5wdXQgdmFsaWRhdGlvbiBcblxuZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLnRleHQtYm94JykuZm9yRWFjaCh0ZXh0Qm94ID0+IHtcbiAgICB0ZXh0Qm94LmFkZEV2ZW50TGlzdGVuZXIoJ2tleXVwJywgdmFsaWRhdGUpO1xufSk7XG5cbmNvbnN0IGlzSW5wdXRFbXB0eSA9ICh0ZXh0Qm94KSA9PiB7XG4gICAgcmV0dXJuIHRleHRCb3gudmFsdWUgPT0gXCJcIiB8fCB0ZXh0Qm94LnZhbHVlID09IG51bGw7ICAgIFxufVxuXG5jb25zdCB2YWxpZGF0ZUVtYWlsID0gKGVtYWlsKSA9PiB7XG4gIHJldHVybiBlbWFpbC5tYXRjaChcbiAgICAvXigoW148PigpW1xcXVxcXFwuLDs6XFxzQFxcXCJdKyhcXC5bXjw+KClbXFxdXFxcXC4sOzpcXHNAXFxcIl0rKSopfChcXFwiLitcXFwiKSlAKChcXFtbMC05XXsxLDN9XFwuWzAtOV17MSwzfVxcLlswLTldezEsM31cXC5bMC05XXsxLDN9XFxdKXwoKFthLXpBLVpcXC0wLTldK1xcLikrW2EtekEtWl17Mix9KSkkL1xuICApO1xufTtcblxuY29uc3QgY2FwaXRhbGl6ZUZpcnN0ID0gKHN0cikgPT4ge1xuICAgIHJldHVybiBzdHJbMF0udG9VcHBlckNhc2UoKSArIHN0ci5zbGljZSgxKTsgXG59XG5cbi8vIG9iaiBtYXkgYmUgdGhlIGV2ZW50IGFyZ3Mgb3IgdGhlIDxpbnB1dC8+IGl0ZXNlbGYgZGVwZW5kaW5nIG9uIHRoZSBjYWxsZXJcbi8vIHdlJ2xsIGNoZWNrIGZvciB0aGF0XG5mdW5jdGlvbiB2YWxpZGF0ZShvYmope1xuICAgIGxldCB0ZXh0Qm94O1xuICAgIHRyeSB7XG4gICAgICAgIHRleHRCb3ggPSBvYmoucGF0aFswXTsgICAgXG4gICAgfSBjYXRjaCB7XG4gICAgICAgIHRleHRCb3ggPSBvYmo7XG4gICAgfVxuICAgICBcbiAgICBjb25zdCBib3hJZCA9IHRleHRCb3guaWQ7XG4gICAgY29uc3QgZXJyb3JMYWJlbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGJveElkICsgXCItZXJyb3ItbGFiZWxcIik7IFxuICAgIGNvbnN0IHBhcmVudCA9IHRleHRCb3gucGFyZW50RWxlbWVudDtcblxuICAgIC8vIGdlbmVyYWwgY2FzZTogbm8gZW1wdHkgdGV4dEJveFxuICAgIGlmKGlzSW5wdXRFbXB0eSh0ZXh0Qm94KSl7XG5cbiAgICAgICAgY29uc29sZS5sb2coXCJlbXB0eVwiKTtcblxuICAgICAgICBlcnJvckxhYmVsLmlubmVyVGV4dCA9IGNhcGl0YWxpemVGaXJzdChib3hJZCkgKyBcIiBjYW4ndCBiZSBlbXB0eS5cIjtcbiAgICAgICAgcGFyZW50LmNsYXNzTGlzdC5hZGQoXCJpbnZhbGlkLWlucHV0XCIpO1xuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBlbWFpbCBtdXN0IGJlIGZvcm1hcnRlZCBjb3JyZWN0bHkgYW5kIGNhbm5vdCBiZSBtaW5lIDpcIlxuICAgIGlmKGJveElkID09IFwiZW1haWxcIil7XG4gICAgICAgIGlmKCF2YWxpZGF0ZUVtYWlsKHRleHRCb3gudmFsdWUpKXtcbiAgICAgICAgICAgIGVycm9yTGFiZWwuaW5uZXJUZXh0ID0gXCJJbnZhbGlkIGVtYWlsXCI7XG4gICAgICAgICAgICBwYXJlbnQuY2xhc3NMaXN0LmFkZChcImludmFsaWQtaW5wdXRcIik7XG5cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmKHRleHRCb3gudmFsdWUgPT0gXCJhZGhhbWFsaV80NTAwQG91dGxvb2suY29tXCIpe1xuICAgICAgICAgICAgZXJyb3JMYWJlbC5pbm5lclRleHQgPSBcIkVtYWlsIGNhbid0IGJlIG1pbmVcIjtcbiAgICAgICAgICAgIHBhcmVudC5jbGFzc0xpc3QuYWRkKFwiaW52YWxpZC1pbnB1dFwiKTtcbiAgICAgICAgXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjbGVhckVycm9yU3RhdGUodGV4dEJveCk7XG4gICAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGNsZWFyRXJyb3JTdGF0ZSh0ZXh0Qm94KXsgXG4gICAgLy8gY29uc3QgcGFyZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZS50YXJnZXQuaWQpLnBhcmVudEVsZW1lbnQ7XG4gICAgY29uc3QgcGFyZW50ID0gdGV4dEJveC5wYXJlbnRFbGVtZW50O1xuICAgIHBhcmVudC5jbGFzc0xpc3QucmVtb3ZlKFwiaW52YWxpZC1pbnB1dFwiKTtcbn1cblxuaW1wb3J0IHsgaW5pdGlhbGl6ZUFwcCB9IGZyb20gJ2ZpcmViYXNlL2FwcCc7XG5pbXBvcnQgeyBnZXREYXRhYmFzZSwgcmVmLCBzZXQgfSBmcm9tIFwiZmlyZWJhc2UvZGF0YWJhc2VcIjtcblxuXG5jb25zdCBmaXJlYmFzZUNvbmZpZyA9IHtcbiAgYXBpS2V5OiBcIkFJemFTeUQyYm1Zalh1VkVxQktoeF9JQ0lRa1ZoendCZnl1YnEza1wiLFxuICBhdXRoRG9tYWluOiBcIm15LXBvcnRmb2xpby01Yzk4ZC5maXJlYmFzZWFwcC5jb21cIixcbiAgZGF0YWJhc2VVUkw6IFwiaHR0cHM6Ly9teS1wb3J0Zm9saW8tNWM5OGQtZGVmYXVsdC1ydGRiLmV1cm9wZS13ZXN0MS5maXJlYmFzZWRhdGFiYXNlLmFwcFwiLFxuICBwcm9qZWN0SWQ6IFwibXktcG9ydGZvbGlvLTVjOThkXCIsXG4gIHN0b3JhZ2VCdWNrZXQ6IFwibXktcG9ydGZvbGlvLTVjOThkLmFwcHNwb3QuY29tXCIsXG4gIG1lc3NhZ2luZ1NlbmRlcklkOiBcIjk5ODYyMDAyMDA2MlwiLFxuICBhcHBJZDogXCIxOjk5ODYyMDAyMDA2Mjp3ZWI6NTVkOGM0Yzg0NTQ3ZTUyZTA2MjNjZlwiLFxuICBtZWFzdXJlbWVudElkOiBcIkctTTRCUFZZME05MlwiXG59O1xuXG5jb25zdCBhcHAgPSBpbml0aWFsaXplQXBwKGZpcmViYXNlQ29uZmlnKTtcbmNvbnN0IGRhdGFiYXNlID0gZ2V0RGF0YWJhc2UoYXBwKTtcblxuZnVuY3Rpb24gc3RvcmVDbGllbnRNZXNzYWdlKG5hbWUsIGVtYWlsLCBtZXNzYWdlKSB7XG4gICAgY29uc3QgZGIgPSBnZXREYXRhYmFzZSgpO1xuICAgIHNldChyZWYoZGIsIG5hbWUrJy8nKSwge1xuICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICBlbWFpbDogZW1haWwsXG4gICAgICAgIG1lc3NhZ2UgOiBtZXNzYWdlXG4gICAgfSk7XG59XG5cblxuY29uc3QgZm9ybSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiZm9ybVwiKTsgXG5mb3JtLmFkZEV2ZW50TGlzdGVuZXIoXCJzdWJtaXRcIiwgKGUpID0+IHtcbiAgICBcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgXG4gICAgY29uc3QgdGV4dEJveGVzID0gW2RvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwibmFtZVwiKSwgXG4gICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJlbWFpbFwiKSxcbiAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcIm1lc3NhZ2VcIildXG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRleHRCb3hlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZighdmFsaWRhdGUodGV4dEJveGVzW2ldKSkge1xuICAgICAgICAgICAgdGV4dEJveGVzW2ldLmZvY3VzKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzdG9yZUNsaWVudE1lc3NhZ2UodGV4dEJveGVzWzBdLnZhbHVlLCB0ZXh0Qm94ZXNbMV0udmFsdWUsIHRleHRCb3hlc1syXS52YWx1ZSk7XG5cbiAgICBmb3JtLnJlc2V0KCk7XG4gICAgZm9ybS5jbGFzc0xpc3QuYWRkKFwic2hvdy1jb25mXCIpO1xuICAgIHNldFRpbWVvdXQoKCk9PmZvcm0uY2xhc3NMaXN0LnJlbW92ZShcInNob3ctY29uZlwiKSwgMjAwMCk7XG59KSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==